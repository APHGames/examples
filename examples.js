let t,e,i;var r,n,s,o,a,h,l,u,c,d,p,f,m,g,y,_,v,x,b,E,T,w,S,M,A,R,C,P,I,O,L,N,D,F,B,U,G,/**
 * Controls:
 * Q: will reverse the direction of all entities
 * W: will stop/resume the scene
 * E: will emit a new object (square/circle)
 * click on an item will make all other items of the same type take a color of the clicked one
 */k,H,z,j,V,X,W,Y,q,K,J,Z,$,Q,tt,te,ti,tr,tn,ts,to,ta,th,tl,tu,tc,td,tp,tf,tm,tg,ty,t_,tv,tx,tb,tE,tT,tw,tS,tM,tA="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function tR(t,e){return Object.keys(e).forEach(function(i){"default"===i||"__esModule"===i||t.hasOwnProperty(i)||Object.defineProperty(t,i,{enumerable:!0,get:function(){return e[i]}})}),t}function tC(t,e,i,r){Object.defineProperty(t,e,{get:i,set:r,enumerable:!0,configurable:!0})}function tP(t){return t&&t.__esModule?t.default:t}var tI={},tO={},tL=tA.parcelRequireb777;null==tL&&((tL=function(t){if(t in tI)return tI[t].exports;if(t in tO){var e=tO[t];delete tO[t];var i={id:t,exports:{}};return tI[t]=i,e.call(i.exports,i,i.exports),i.exports}var r=Error("Cannot find module '"+t+"'");throw r.code="MODULE_NOT_FOUND",r}).register=function(t,e){tO[t]=e},tA.parcelRequireb777=tL),tL.register("5tGEO",function(t,e){!function(i){/** Detect free variables */var r=e&&!e.nodeType&&e,n=t&&!t.nodeType&&t,s="object"==typeof tA&&tA;(s.global===s||s.window===s||s.self===s)&&(i=s);/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */var o,/** Temporary variable */a,/** Regular expressions */h=/^xn--/,l=/[^\x20-\x7E]/,u=/[\x2E\u3002\uFF0E\uFF61]/g,/** Error messages */c={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},d=Math.floor,p=String.fromCharCode;/*--------------------------------------------------------------------------*//**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function f(t){throw RangeError(c[t])}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function m(t,e){for(var i=t.length,r=[];i--;)r[i]=e(t[i]);return r}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function g(t,e){var i=t.split("@"),r="";return i.length>1&&(// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
r=i[0]+"@",t=i[1]),r+m(// Avoid `split(regex)` for IE8 compatibility. See #17.
(t=t.replace(u,".")).split("."),e).join(".")}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function y(t){for(var e,i,r=[],n=0,s=t.length;n<s;)(e=t.charCodeAt(n++))>=55296&&e<=56319&&n<s?(64512&// high surrogate, and there is a next character
(i=t.charCodeAt(n++)))==56320?r.push(((1023&e)<<10)+(1023&i)+65536):(// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
r.push(e),n--):r.push(e);return r}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function _(t){return m(t,function(t){var e="";return t>65535&&(t-=65536,e+=p(t>>>10&1023|55296),t=56320|1023&t),e+=p(t)}).join("")}/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */function v(t,e){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return t+22+75*(t<26)-((0!=e)<<5)}/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */function x(t,e,i){var r=0;for(t=i?d(t/700):t>>1,t+=d(t/e);t>455;r+=36)t=d(t/35);return d(r+36*t/(t+38))}/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */function b(t){// Don't use UCS-2
var e,i,r,n,s,o,a,h,l,u,/** Cached calculation results */c,p=[],m=t.length,g=0,y=128,v=72;for(// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
(r=t.lastIndexOf("-"))<0&&(r=0),n=0;n<r;++n)t.charCodeAt(n)>=128&&f("not-basic"),p.push(t.charCodeAt(n));// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(s=r>0?r+1:0;s<m;){// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(o=g,a=1,h=36;s>=m&&f("invalid-input"),((l=(e=t.charCodeAt(s++))-48<10?e-22:e-65<26?e-65:e-97<26?e-97:36)>=36||l>d((2147483647-g)/a))&&f("overflow"),g+=l*a,!(l<(u=h<=v?1:h>=v+26?26:h-v));h+=36)a>d(2147483647/(c=36-u))&&f("overflow"),a*=c;v=x(g-o,i=p.length+1,0==o),d(g/i)>2147483647-y&&f("overflow"),y+=d(g/i),g%=i,// Insert `n` at position `i` of the output
p.splice(g++,0,y)}return _(p)}/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */function E(t){var e,i,r,n,s,o,a,h,l,u,c,/** `inputLength` will hold the number of code points in `input`. */m,/** Cached calculation results */g,_,b,E=[];// Handle the basic code points
for(o=0,// Cache the length
m=// Convert the input in UCS-2 to Unicode
(t=y(t)).length,// Initialize the state
e=128,i=0,s=72;o<m;++o)(c=t[o])<128&&E.push(p(c));// Main encoding loop:
for(r=n=E.length,n&&E.push("-");r<m;){// All non-basic code points < n have been handled already. Find the next
// larger one:
for(a=2147483647,o=0;o<m;++o)(c=t[o])>=e&&c<a&&(a=c);for(a-e>d((2147483647-i)/// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
(g=r+1))&&f("overflow"),i+=(a-e)*g,e=a,o=0;o<m;++o)if((c=t[o])<e&&++i>2147483647&&f("overflow"),c==e){// Represent delta as a generalized variable-length integer
for(h=i,l=36;!(h<(u=l<=s?1:l>=s+26?26:l-s));l+=36)b=h-u,_=36-u,E.push(p(v(u+b%_,0))),h=d(b/_);E.push(p(v(h,0))),s=x(i,g,r==n),i=0,++r}++i,++e}return E.join("")}/** Expose `punycode` */// Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(/*--------------------------------------------------------------------------*//** Define the public API */o={/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */version:"1.3.2",/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */ucs2:{decode:y,encode:_},decode:b,encode:E,toASCII:/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */function(t){return g(t,function(t){return l.test(t)?"xn--"+E(t):t})},toUnicode:/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */function(t){return g(t,function(t){return h.test(t)?b(t.slice(4).toLowerCase()):t})}},"function"==typeof define&&"object"==typeof define.amd&&define.amd)define("punycode",function(){return o});else if(r&&n){if(t.exports==r)n.exports=o;else for(a in o)o.hasOwnProperty(a)&&(r[a]=o[a])}else i.punycode=o}(this)}),tL.register("bu5IZ",function(t,e){t.exports=function(t,e,r,n){e=e||"&",r=r||"=";var s={};if("string"!=typeof t||0===t.length)return s;var o=/\+/g;t=t.split(e);var a=1e3;n&&"number"==typeof n.maxKeys&&(a=n.maxKeys);var h=t.length;a>0&&h>a&&(h=a);for(var l=0;l<h;++l){var u,c,d,p,f=t[l].replace(o,"%20"),m=f.indexOf(r);(m>=0?(u=f.substr(0,m),c=f.substr(m+1)):(u=f,c=""),d=decodeURIComponent(u),p=decodeURIComponent(c),Object.prototype.hasOwnProperty.call(s,d))?i(s[d])?s[d].push(p):s[d]=[s[d],p]:s[d]=p}return s};var i=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)}}),tL.register("4gCs1",function(t,e){var i=function(t){switch(typeof t){case"string":return t;case"boolean":return t?"true":"false";case"number":return isFinite(t)?t:"";default:return""}};t.exports=function(t,e,o,a){return(e=e||"&",o=o||"=",null===t&&(t=void 0),"object"==typeof t)?n(s(t),function(s){var a=encodeURIComponent(i(s))+o;return r(t[s])?n(t[s],function(t){return a+encodeURIComponent(i(t))}).join(e):a+encodeURIComponent(i(t[s]))}).join(e):a?encodeURIComponent(i(a))+o+encodeURIComponent(i(t)):""};var r=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)};function n(t,e){if(t.map)return t.map(e);for(var i=[],r=0;r<t.length;r++)i.push(e(t[r],r));return i}var s=Object.keys||function(t){var e=[];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.push(i);return e}});var tN={};/**
 * @constructor
 */function tD(t,e){this.name="AggregateError",this.errors=t,this.message=e||""}tC(tN,"VERSION",()=>a7),tC(tN,"filters",()=>a9),tC(tN,"utils",()=>t1),tD.prototype=Error.prototype;// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var tF=setTimeout;function tB(t){return!!(t&&void 0!==t.length)}function tU(){}/**
 * @constructor
 * @param {Function} fn
 */function tG(t){if(!(this instanceof tG))throw TypeError("Promises must be constructed via new");if("function"!=typeof t)throw TypeError("not a function");/** @type {!number} */this._state=0,/** @type {!boolean} */this._handled=!1,/** @type {Promise|undefined} */this._value=void 0,/** @type {!Array<!Function>} */this._deferreds=[],tX(t,this)}function tk(t,e){for(;3===t._state;)t=t._value;if(0===t._state){t._deferreds.push(e);return}t._handled=!0,tG._immediateFn(function(){var i,r=1===t._state?e.onFulfilled:e.onRejected;if(null===r){(1===t._state?tH:tz)(e.promise,t._value);return}try{i=r(t._value)}catch(t){tz(e.promise,t);return}tH(e.promise,i)})}function tH(t,e){try{// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
if(e===t)throw TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var i=e.then;if(e instanceof tG){t._state=3,t._value=e,tj(t);return}if("function"==typeof i){tX(function(){i.apply(e,arguments)},t);return}}t._state=1,t._value=e,tj(t)}catch(e){tz(t,e)}}function tz(t,e){t._state=2,t._value=e,tj(t)}function tj(t){2===t._state&&0===t._deferreds.length&&tG._immediateFn(function(){t._handled||tG._unhandledRejectionFn(t._value)});for(var e=0,i=t._deferreds.length;e<i;e++)tk(t,t._deferreds[e]);t._deferreds=null}/**
 * @constructor
 */function tV(t,e,i){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=i}/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */function tX(t,e){var i=!1;try{t(function(t){i||(i=!0,tH(e,t))},function(t){i||(i=!0,tz(e,t))})}catch(t){if(i)return;i=!0,tz(e,t)}}tG.prototype.catch=function(t){return this.then(null,t)},tG.prototype.then=function(t,e){// @ts-ignore
var i=new this.constructor(tU);return tk(this,new tV(t,e,i)),i},tG.prototype.finally=/*!
 * pixi.js - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*!
 * @pixi/polyfill - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * @this {Promise}
 */function(t){var e=this.constructor;return this.then(function(i){// @ts-ignore
return e.resolve(t()).then(function(){return i})},function(i){// @ts-ignore
return e.resolve(t()).then(function(){// @ts-ignore
return e.reject(i)})})},tG.all=function(t){return new tG(function(e,i){if(!tB(t))return i(TypeError("Promise.all accepts an array"));var r=Array.prototype.slice.call(t);if(0===r.length)return e([]);for(var n=r.length,s=0;s<r.length;s++)!function t(s,o){try{if(o&&("object"==typeof o||"function"==typeof o)){var a=o.then;if("function"==typeof a){a.call(o,function(e){t(s,e)},i);return}}r[s]=o,0==--n&&e(r)}catch(t){i(t)}}(s,r[s])})},tG.any=function(t){var e=this;return new e(function(i,r){if(!(t&&void 0!==t.length))return r(TypeError("Promise.any accepts an array"));var n=Array.prototype.slice.call(t);if(0===n.length)return r();for(var s=[],o=0;o<n.length;o++)try{e.resolve(n[o]).then(i).catch(function(t){s.push(t),s.length===n.length&&r(new tD(s,"All promises were rejected"))})}catch(t){r(t)}})},tG.allSettled=function(t){return new this(function(e,i){if(!(t&&void 0!==t.length))return i(TypeError(typeof t+" "+t+" is not iterable(cannot read property Symbol(Symbol.iterator))"));var r=Array.prototype.slice.call(t);if(0===r.length)return e([]);for(var n=r.length,s=0;s<r.length;s++)!function t(i,s){if(s&&("object"==typeof s||"function"==typeof s)){var o=s.then;if("function"==typeof o){o.call(s,function(e){t(i,e)},function(t){r[i]={status:"rejected",reason:t},0==--n&&e(r)});return}}r[i]={status:"fulfilled",value:s},0==--n&&e(r)}(s,r[s])})},tG.resolve=function(t){return t&&"object"==typeof t&&t.constructor===tG?t:new tG(function(e){e(t)})},tG.reject=function(t){return new tG(function(e,i){i(t)})},tG.race=function(t){return new tG(function(e,i){if(!tB(t))return i(TypeError("Promise.race accepts an array"));for(var r=0,n=t.length;r<n;r++)tG.resolve(t[r]).then(e,i)})},// Use polyfill for setImmediate for performance gains
tG._immediateFn="function"==typeof setImmediate&&function(t){// @ts-ignore
setImmediate(t)}||function(t){tF(t,0)},tG._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t);// eslint-disable-line no-console
};var tW={},tY=Object.getOwnPropertySymbols,tq=Object.prototype.hasOwnProperty,tK=Object.prototype.propertyIsEnumerable;// performance.now
if(tW=!function(){try{if(!Object.assign)return!1;// Detect buggy property enumeration order in older V8 versions.
// https://bugs.chromium.org/p/v8/issues/detail?id=4118
var t=new String("abc");// eslint-disable-line no-new-wrappers
if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},i=0;i<10;i++)e["_"+String.fromCharCode(i)]=i;// https://bugs.chromium.org/p/v8/issues/detail?id=3056
var r=Object.getOwnPropertyNames(e).map(function(t){return e[t]});if("0123456789"!==r.join(""))return!1;// https://bugs.chromium.org/p/v8/issues/detail?id=3056
var n={};if("abcdefghijklmnopqrst".split("").forEach(function(t){n[t]=t}),"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},n)).join(""))return!1;return!0}catch(t){// We don't expect any of the above to throw, but better to be safe.
return!1}}()?function(t,e){for(var i,r,n=function(t){if(null==t)throw TypeError("Object.assign cannot be called with null or undefined");return Object(t)}(t),s=1;s<arguments.length;s++){for(var o in i=Object(arguments[s]))tq.call(i,o)&&(n[o]=i[o]);if(tY){r=tY(i);for(var a=0;a<r.length;a++)tK.call(i,r[a])&&(n[r[a]]=i[r[a]])}}return n}:Object.assign,self.Promise||(self.Promise=tG),Object.assign||(Object.assign=/*@__PURE__*/tP(tW)),Date.now&&Date.prototype.getTime||(Date.now=function(){return new Date().getTime()}),!(self.performance&&self.performance.now)){var tJ=Date.now();self.performance||(self.performance={}),self.performance.now=function(){return Date.now()-tJ}}for(var tZ=Date.now(),t$=["ms","moz","webkit","o"],tQ=0;tQ<t$.length&&!self.requestAnimationFrame;++tQ){var t0=t$[tQ];self.requestAnimationFrame=self[t0+"RequestAnimationFrame"],self.cancelAnimationFrame=self[t0+"CancelAnimationFrame"]||self[t0+"CancelRequestAnimationFrame"]}self.requestAnimationFrame||(self.requestAnimationFrame=function(t){if("function"!=typeof t)throw TypeError(t+"is not a function");var e=Date.now(),i=16+tZ-e;return i<0&&(i=0),tZ=e,self.setTimeout(function(){tZ=Date.now(),t(performance.now())},i)}),self.cancelAnimationFrame||(self.cancelAnimationFrame=function(t){return clearTimeout(t)}),Math.sign||(Math.sign=function(t){return 0===(t=Number(t))||isNaN(t)?t:t>0?1:-1}),Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t}),self.ArrayBuffer||(self.ArrayBuffer=Array),self.Float32Array||(self.Float32Array=Array),self.Uint32Array||(self.Uint32Array=Array),self.Uint16Array||(self.Uint16Array=Array),self.Uint8Array||(self.Uint8Array=Array),self.Int32Array||(self.Int32Array=Array);var t1={};tC(t1,"url",()=>e0),tC(t1,"skipHello",()=>e3),tC(t1,"sayHello",()=>e5),tC(t1,"isWebGLSupported",()=>e4),tC(t1,"hex2rgb",()=>e8),tC(t1,"hex2string",()=>e7),tC(t1,"string2hex",()=>e9),tC(t1,"rgb2hex",()=>it),tC(t1,"premultiplyBlendMode",()=>ie),tC(t1,"correctBlendMode",()=>ii),tC(t1,"premultiplyRgba",()=>ir),tC(t1,"premultiplyTint",()=>is),tC(t1,"premultiplyTintToRgba",()=>io),tC(t1,"createIndicesForQuads",()=>ia),tC(t1,"getBufferType",()=>ih),tC(t1,"interleaveTypedArrays",()=>iu),tC(t1,"nextPow2",()=>ic),tC(t1,"isPow2",()=>id),tC(t1,"log2",()=>ip),tC(t1,"removeItems",()=>im),tC(t1,"sign",()=>ig),tC(t1,"uid",()=>i_),tC(t1,"deprecation",()=>ix),tC(t1,"ProgramCache",()=>ib),tC(t1,"TextureCache",()=>iE),tC(t1,"BaseTextureCache",()=>iT),tC(t1,"destroyTextureCache",()=>iw),tC(t1,"clearTextureCache",()=>iS),tC(t1,"CanvasRenderTarget",()=>iM),tC(t1,"trimCanvas",()=>iA),tC(t1,"DATA_URI",()=>iR),tC(t1,"decomposeDataUri",()=>iC),tC(t1,"determineCrossOrigin",()=>iP),tC(t1,"getResolutionOfUrl",()=>iI),tC(t1,"isMobile",()=>eu),tC(t1,"EventEmitter",()=>/*@__PURE__*/tP(ed)),tC(t1,"earcut",()=>/*@__PURE__*/tP(ex));/*!
 * @pixi/utils - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var t2={};tC(t2,"isMobile",()=>eu),tC(t2,"settings",()=>ec);/*!
 * @pixi/settings - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var t3=/iPhone/i,t5=/iPod/i,t4=/iPad/i,t6=/\biOS-universal(?:.+)Mac\b/i,t8=/\bAndroid(?:.+)Mobile\b/i,t7=/Android/i,t9=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,et=/Silk/i,ee=/Windows Phone/i,ei=/\bWindows(?:.+)ARM\b/i,er=/BlackBerry/i,en=/BB10/i,es=/Opera Mini/i,eo=/\b(CriOS|Chrome)(?:.+)Mobile/i,ea=/Mobile(?:.+)Firefox\b/i,eh=function(t){return void 0!==t&&"MacIntel"===t.platform&&"number"==typeof t.maxTouchPoints&&t.maxTouchPoints>1&&"undefined"==typeof MSStream};function el(t){var e,i={userAgent:"",platform:"",maxTouchPoints:0};t||"undefined"==typeof navigator?"string"==typeof t?i.userAgent=t:t&&t.userAgent&&(i={userAgent:t.userAgent,platform:t.platform,maxTouchPoints:t.maxTouchPoints||0}):i={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0};var r=i.userAgent,n=r.split("[FBAN");void 0!==n[1]&&(r=n[0]),void 0!==(n=r.split("Twitter"))[1]&&(r=n[0]);var s=(e=r,function(t){return t.test(e)}),o={apple:{phone:s(t3)&&!s(ee),ipod:s(t5),tablet:!s(t3)&&(s(t4)||eh(i))&&!s(ee),universal:s(t6),device:(s(t3)||s(t5)||s(t4)||s(t6)||eh(i))&&!s(ee)},amazon:{phone:s(t9),tablet:!s(t9)&&s(et),device:s(t9)||s(et)},android:{phone:!s(ee)&&s(t9)||!s(ee)&&s(t8),tablet:!s(ee)&&!s(t9)&&!s(t8)&&(s(et)||s(t7)),device:!s(ee)&&(s(t9)||s(et)||s(t8)||s(t7))||s(/\bokhttp\b/i)},windows:{phone:s(ee),tablet:s(ei),device:s(ee)||s(ei)},other:{blackberry:s(er),blackberry10:s(en),opera:s(es),firefox:s(ea),chrome:s(eo),device:s(er)||s(en)||s(es)||s(ea)||s(eo)},any:!1,phone:!1,tablet:!1};return o.any=o.apple.device||o.android.device||o.windows.device||o.other.device,o.phone=o.apple.phone||o.android.phone||o.windows.phone,o.tablet=o.apple.tablet||o.android.tablet||o.windows.tablet,o}// The ESM/CJS versions of ismobilejs only
var eu=el(self.navigator);(_L=xS||(xS={}))[_L.WEBGL_LEGACY=0]="WEBGL_LEGACY",_L[_L.WEBGL=1]="WEBGL",_L[_L.WEBGL2=2]="WEBGL2",(_N=xM||(xM={}))[_N.UNKNOWN=0]="UNKNOWN",_N[_N.WEBGL=1]="WEBGL",_N[_N.CANVAS=2]="CANVAS",(_D=xA||(xA={}))[_D.COLOR=16384]="COLOR",_D[_D.DEPTH=256]="DEPTH",_D[_D.STENCIL=1024]="STENCIL",(_F=xR||(xR={}))[_F.NORMAL=0]="NORMAL",_F[_F.ADD=1]="ADD",_F[_F.MULTIPLY=2]="MULTIPLY",_F[_F.SCREEN=3]="SCREEN",_F[_F.OVERLAY=4]="OVERLAY",_F[_F.DARKEN=5]="DARKEN",_F[_F.LIGHTEN=6]="LIGHTEN",_F[_F.COLOR_DODGE=7]="COLOR_DODGE",_F[_F.COLOR_BURN=8]="COLOR_BURN",_F[_F.HARD_LIGHT=9]="HARD_LIGHT",_F[_F.SOFT_LIGHT=10]="SOFT_LIGHT",_F[_F.DIFFERENCE=11]="DIFFERENCE",_F[_F.EXCLUSION=12]="EXCLUSION",_F[_F.HUE=13]="HUE",_F[_F.SATURATION=14]="SATURATION",_F[_F.COLOR=15]="COLOR",_F[_F.LUMINOSITY=16]="LUMINOSITY",_F[_F.NORMAL_NPM=17]="NORMAL_NPM",_F[_F.ADD_NPM=18]="ADD_NPM",_F[_F.SCREEN_NPM=19]="SCREEN_NPM",_F[_F.NONE=20]="NONE",_F[_F.SRC_OVER=0]="SRC_OVER",_F[_F.SRC_IN=21]="SRC_IN",_F[_F.SRC_OUT=22]="SRC_OUT",_F[_F.SRC_ATOP=23]="SRC_ATOP",_F[_F.DST_OVER=24]="DST_OVER",_F[_F.DST_IN=25]="DST_IN",_F[_F.DST_OUT=26]="DST_OUT",_F[_F.DST_ATOP=27]="DST_ATOP",_F[_F.ERASE=26]="ERASE",_F[_F.SUBTRACT=28]="SUBTRACT",_F[_F.XOR=29]="XOR",(_B=xC||(xC={}))[_B.POINTS=0]="POINTS",_B[_B.LINES=1]="LINES",_B[_B.LINE_LOOP=2]="LINE_LOOP",_B[_B.LINE_STRIP=3]="LINE_STRIP",_B[_B.TRIANGLES=4]="TRIANGLES",_B[_B.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",_B[_B.TRIANGLE_FAN=6]="TRIANGLE_FAN",(_U=xP||(xP={}))[_U.RGBA=6408]="RGBA",_U[_U.RGB=6407]="RGB",_U[_U.RG=33319]="RG",_U[_U.RED=6403]="RED",_U[_U.RGBA_INTEGER=36249]="RGBA_INTEGER",_U[_U.RGB_INTEGER=36248]="RGB_INTEGER",_U[_U.RG_INTEGER=33320]="RG_INTEGER",_U[_U.RED_INTEGER=36244]="RED_INTEGER",_U[_U.ALPHA=6406]="ALPHA",_U[_U.LUMINANCE=6409]="LUMINANCE",_U[_U.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",_U[_U.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",_U[_U.DEPTH_STENCIL=34041]="DEPTH_STENCIL",(_G=xI||(xI={}))[_G.TEXTURE_2D=3553]="TEXTURE_2D",_G[_G.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",_G[_G.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",_G[_G.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",_G[_G.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",_G[_G.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",_G[_G.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",_G[_G.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",_G[_G.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",(_k=xO||(xO={}))[_k.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",_k[_k.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",_k[_k.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",_k[_k.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",_k[_k.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",_k[_k.UNSIGNED_INT=5125]="UNSIGNED_INT",_k[_k.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",_k[_k.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",_k[_k.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",_k[_k.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",_k[_k.BYTE=5120]="BYTE",_k[_k.SHORT=5122]="SHORT",_k[_k.INT=5124]="INT",_k[_k.FLOAT=5126]="FLOAT",_k[_k.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",_k[_k.HALF_FLOAT=36193]="HALF_FLOAT",(_H=xL||(xL={}))[_H.FLOAT=0]="FLOAT",_H[_H.INT=1]="INT",_H[_H.UINT=2]="UINT",(_z=xN||(xN={}))[_z.NEAREST=0]="NEAREST",_z[_z.LINEAR=1]="LINEAR",(_j=xD||(xD={}))[_j.CLAMP=33071]="CLAMP",_j[_j.REPEAT=10497]="REPEAT",_j[_j.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",(_V=xF||(xF={}))[_V.OFF=0]="OFF",_V[_V.POW2=1]="POW2",_V[_V.ON=2]="ON",_V[_V.ON_MANUAL=3]="ON_MANUAL",(_X=xB||(xB={}))[_X.NPM=0]="NPM",_X[_X.UNPACK=1]="UNPACK",_X[_X.PMA=2]="PMA",_X[_X.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",_X[_X.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",_X[_X.PREMULTIPLY_ALPHA=2]="PREMULTIPLY_ALPHA",(_W=xU||(xU={}))[_W.NO=0]="NO",_W[_W.YES=1]="YES",_W[_W.AUTO=2]="AUTO",_W[_W.BLEND=0]="BLEND",_W[_W.CLEAR=1]="CLEAR",_W[_W.BLIT=2]="BLIT",(_Y=xG||(xG={}))[_Y.AUTO=0]="AUTO",_Y[_Y.MANUAL=1]="MANUAL",(_q=xk||(xk={})).LOW="lowp",_q.MEDIUM="mediump",_q.HIGH="highp",(_K=xH||(xH={}))[_K.NONE=0]="NONE",_K[_K.SCISSOR=1]="SCISSOR",_K[_K.STENCIL=2]="STENCIL",_K[_K.SPRITE=3]="SPRITE",(_J=xz||(xz={}))[_J.NONE=0]="NONE",_J[_J.LOW=2]="LOW",_J[_J.MEDIUM=4]="MEDIUM",_J[_J.HIGH=8]="HIGH",(_Z=xj||(xj={}))[_Z.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",_Z[_Z.ARRAY_BUFFER=34962]="ARRAY_BUFFER",// NOT YET SUPPORTED
_Z[_Z.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER";/**
 * User's customizable globals for overriding the default PIXI settings, such
 * as a renderer's default resolution, framerate, float precision, etc.
 * @example
 * // Use the native window resolution as the default resolution
 * // will support high-density displays when rendering
 * PIXI.settings.RESOLUTION = window.devicePixelRatio;
 *
 * // Disable interpolation when scaling, will make texture be pixelated
 * PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
 * @namespace PIXI.settings
 */var ec={/**
     * If set to true WebGL will attempt make textures mimpaped by default.
     * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
     *
     * @static
     * @name MIPMAP_TEXTURES
     * @memberof PIXI.settings
     * @type {PIXI.MIPMAP_MODES}
     * @default PIXI.MIPMAP_MODES.POW2
     */MIPMAP_TEXTURES:xF.POW2,/**
     * Default anisotropic filtering level of textures.
     * Usually from 0 to 16
     *
     * @static
     * @name ANISOTROPIC_LEVEL
     * @memberof PIXI.settings
     * @type {number}
     * @default 0
     */ANISOTROPIC_LEVEL:0,/**
     * Default resolution / device pixel ratio of the renderer.
     *
     * @static
     * @name RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */RESOLUTION:1,/**
     * Default filter resolution.
     *
     * @static
     * @name FILTER_RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */FILTER_RESOLUTION:1,/**
     * Default filter samples.
     *
     * @static
     * @name FILTER_MULTISAMPLE
     * @memberof PIXI.settings
     * @type {PIXI.MSAA_QUALITY}
     * @default PIXI.MSAA_QUALITY.NONE
     */FILTER_MULTISAMPLE:xz.NONE,/**
     * The maximum textures that this device supports.
     *
     * @static
     * @name SPRITE_MAX_TEXTURES
     * @memberof PIXI.settings
     * @type {number}
     * @default 32
     */SPRITE_MAX_TEXTURES:/**
 * The maximum recommended texture units to use.
 * In theory the bigger the better, and for desktop we'll use as many as we can.
 * But some mobile devices slow down if there is to many branches in the shader.
 * So in practice there seems to be a sweet spot size that varies depending on the device.
 *
 * In v4, all mobile devices were limited to 4 texture units because for this.
 * In v5, we allow all texture units to be used on modern Apple or Android devices.
 *
 * @private
 * @param {number} max
 * @returns {number}
 */function(t){var e=!0;if(eu.tablet||eu.phone){if(eu.apple.device){var i=navigator.userAgent.match(/OS (\d+)_(\d+)?/);if(i){var r=parseInt(i[1],10);// Limit texture units on devices below iOS 11, which will be older hardware
r<11&&(e=!1)}}if(eu.android.device){var i=navigator.userAgent.match(/Android\s([0-9.]*)/);if(i){var r=parseInt(i[1],10);// Limit texture units on devices below Android 7 (Nougat), which will be older hardware
r<7&&(e=!1)}}}return e?32:4}(0),// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
     * The default sprite batch size.
     *
     * The default aims to balance desktop and mobile devices.
     *
     * @static
     * @name SPRITE_BATCH_SIZE
     * @memberof PIXI.settings
     * @type {number}
     * @default 4096
     */SPRITE_BATCH_SIZE:4096,/**
     * The default render options if none are supplied to {@link PIXI.Renderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @name RENDER_OPTIONS
     * @memberof PIXI.settings
     * @type {object}
     * @property {HTMLCanvasElement} view=null
     * @property {boolean} antialias=false
     * @property {boolean} autoDensity=false
     * @property {boolean} useContextAlpha=true
     * @property {number} backgroundColor=0x000000
     * @property {number} backgroundAlpha=1
     * @property {boolean} clearBeforeRender=true
     * @property {boolean} preserveDrawingBuffer=false
     * @property {number} width=800
     * @property {number} height=600
     * @property {boolean} legacy=false
     */RENDER_OPTIONS:{view:null,antialias:!1,autoDensity:!1,backgroundColor:0,backgroundAlpha:1,useContextAlpha:!0,clearBeforeRender:!0,preserveDrawingBuffer:!1,width:800,height:600,legacy:!1},/**
     * Default Garbage Collection mode.
     *
     * @static
     * @name GC_MODE
     * @memberof PIXI.settings
     * @type {PIXI.GC_MODES}
     * @default PIXI.GC_MODES.AUTO
     */GC_MODE:xG.AUTO,/**
     * Default Garbage Collection max idle.
     *
     * @static
     * @name GC_MAX_IDLE
     * @memberof PIXI.settings
     * @type {number}
     * @default 3600
     */GC_MAX_IDLE:3600,/**
     * Default Garbage Collection maximum check count.
     *
     * @static
     * @name GC_MAX_CHECK_COUNT
     * @memberof PIXI.settings
     * @type {number}
     * @default 600
     */GC_MAX_CHECK_COUNT:600,/**
     * Default wrap modes that are supported by pixi.
     *
     * @static
     * @name WRAP_MODE
     * @memberof PIXI.settings
     * @type {PIXI.WRAP_MODES}
     * @default PIXI.WRAP_MODES.CLAMP
     */WRAP_MODE:xD.CLAMP,/**
     * Default scale mode for textures.
     *
     * @static
     * @name SCALE_MODE
     * @memberof PIXI.settings
     * @type {PIXI.SCALE_MODES}
     * @default PIXI.SCALE_MODES.LINEAR
     */SCALE_MODE:xN.LINEAR,/**
     * Default specify float precision in vertex shader.
     *
     * @static
     * @name PRECISION_VERTEX
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.HIGH
     */PRECISION_VERTEX:xk.HIGH,/**
     * Default specify float precision in fragment shader.
     * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
     *
     * @static
     * @name PRECISION_FRAGMENT
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.MEDIUM
     */PRECISION_FRAGMENT:eu.apple.device?xk.HIGH:xk.MEDIUM,/**
     * Can we upload the same buffer in a single frame?
     *
     * @static
     * @name CAN_UPLOAD_SAME_BUFFER
     * @memberof PIXI.settings
     * @type {boolean}
     */CAN_UPLOAD_SAME_BUFFER:!eu.apple.device,/**
     * Enables bitmap creation before image load. This feature is experimental.
     *
     * @static
     * @name CREATE_IMAGE_BITMAP
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */CREATE_IMAGE_BITMAP:!1,/**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     *
     * @static
     * @constant
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */ROUND_PIXELS:!1},ed={},ep=Object.prototype.hasOwnProperty,ef="~";/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */function em(){}/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */function eg(t,e,i){this.fn=t,this.context=e,this.once=i||!1}/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */function ey(t,e,i,r,n){if("function"!=typeof i)throw TypeError("The listener must be a function");var s=new eg(i,r||t,n),o=ef?ef+e:e;return t._events[o]?t._events[o].fn?t._events[o]=[t._events[o],s]:t._events[o].push(s):(t._events[o]=s,t._eventsCount++),t}/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */function e_(t,e){0==--t._eventsCount?t._events=new em:delete t._events[e]}/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */function ev(){this._events=new em,this._eventsCount=0}Object.create&&(em.prototype=Object.create(null),new em().__proto__||(ef=!1)),/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ev.prototype.eventNames=function(){var t,e,i=[];if(0===this._eventsCount)return i;for(e in t=this._events)ep.call(t,e)&&i.push(ef?e.slice(1):e);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ev.prototype.listeners=function(t){var e=ef?ef+t:t,i=this._events[e];if(!i)return[];if(i.fn)return[i.fn];for(var r=0,n=i.length,s=Array(n);r<n;r++)s[r]=i[r].fn;return s},/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ev.prototype.listenerCount=function(t){var e=ef?ef+t:t,i=this._events[e];return i?i.fn?1:i.length:0},/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ev.prototype.emit=function(t,e,i,r,n,s){var o=ef?ef+t:t;if(!this._events[o])return!1;var a,h,l=this._events[o],u=arguments.length;if(l.fn){switch(l.once&&this.removeListener(t,l.fn,void 0,!0),u){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,e),!0;case 3:return l.fn.call(l.context,e,i),!0;case 4:return l.fn.call(l.context,e,i,r),!0;case 5:return l.fn.call(l.context,e,i,r,n),!0;case 6:return l.fn.call(l.context,e,i,r,n,s),!0}for(h=1,a=Array(u-1);h<u;h++)a[h-1]=arguments[h];l.fn.apply(l.context,a)}else{var c,d=l.length;for(h=0;h<d;h++)switch(l[h].once&&this.removeListener(t,l[h].fn,void 0,!0),u){case 1:l[h].fn.call(l[h].context);break;case 2:l[h].fn.call(l[h].context,e);break;case 3:l[h].fn.call(l[h].context,e,i);break;case 4:l[h].fn.call(l[h].context,e,i,r);break;default:if(!a)for(c=1,a=Array(u-1);c<u;c++)a[c-1]=arguments[c];l[h].fn.apply(l[h].context,a)}}return!0},/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ev.prototype.on=function(t,e,i){return ey(this,t,e,i,!1)},/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ev.prototype.once=function(t,e,i){return ey(this,t,e,i,!0)},/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ev.prototype.removeListener=function(t,e,i,r){var n=ef?ef+t:t;if(!this._events[n])return this;if(!e)return e_(this,n),this;var s=this._events[n];if(s.fn)s.fn!==e||r&&!s.once||i&&s.context!==i||e_(this,n);else{for(var o=0,a=[],h=s.length;o<h;o++)(s[o].fn!==e||r&&!s[o].once||i&&s[o].context!==i)&&a.push(s[o]);//
// Reset the array, or remove it completely if we have no more listeners.
//
a.length?this._events[n]=1===a.length?a[0]:a:e_(this,n)}return this},/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ev.prototype.removeAllListeners=function(t){var e;return t?(e=ef?ef+t:t,this._events[e]&&e_(this,e)):(this._events=new em,this._eventsCount=0),this},//
// Alias methods names because people roll like that.
//
ev.prototype.off=ev.prototype.removeListener,ev.prototype.addListener=ev.prototype.on,//
// Expose the prefix.
//
ev.prefixed=ef,//
// Allow `EventEmitter` to be imported as module namespace.
//
ev.EventEmitter=ev,ed=ev;var ex={};function eb(t,e,i){i=i||2;var r,n,s,o,a,h,l,u=e&&e.length,c=u?e[0]*i:t.length,d=eE(t,0,c,i,!0),p=[];if(!d||d.next===d.prev)return p;// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(u&&(d=// link every hole into the outer loop, producing a single-ring polygon without holes
function(t,e,i,r){var n,s,o,a,h,l=[];for(n=0,s=e.length;n<s;n++)o=e[n]*r,a=n<s-1?e[n+1]*r:t.length,(h=eE(t,o,a,r,!1))===h.next&&(h.steiner=!0),l.push(// find the leftmost node of a polygon ring
function(t){var e=t,i=t;do(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next;while(e!==t)return i}(h));// process holes from left to right
for(l.sort(ew),n=0;n<l.length;n++)i=// find a bridge between vertices that connects hole with an outer ring and and link it
function(t,e){var i=// David Eberly's algorithm for finding a bridge between hole and outer polygon
function(t,e){var i,r,n,s=e,o=t.x,a=t.y,h=-1/0;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(a<=s.y&&a>=s.next.y&&s.next.y!==s.y){var l=s.x+(a-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(l<=o&&l>h&&(h=l,n=s.x<s.next.x?s:s.next,l===o))return n;// hole touches outer segment; pick leftmost endpoint
}s=s.next}while(s!==e)if(!n)return null;// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var u,c=n,d=n.x,p=n.y,f=1/0;s=n;do o>=s.x&&s.x>=d&&o!==s.x&&eM(a<p?o:h,a,d,p,a<p?h:o,a,s.x,s.y)&&(u=Math.abs(a-s.y)/(o-s.x),eO(s,t)&&(u<f||u===f&&(s.x>n.x||s.x===n.x&&(i=n,r=s,0>eA(i.prev,i,r.prev)&&0>eA(r.next,i,i.next))))&&(n=s,f=u)),s=s.next;while(s!==c)return n}(t,e);if(!i)return e;var r=eL(i,t);return(// filter collinear points around the cuts
eT(r,r.next),eT(i,i.next))}(l[n],i);return i}(t,e,d,i)),t.length>80*i){r=s=t[0],n=o=t[1];for(var f=i;f<c;f+=i)a=t[f],h=t[f+1],a<r&&(r=a),h<n&&(n=h),a>s&&(s=a),h>o&&(o=h);l=0!==// minX, minY and invSize are later used to transform coords into integers for z-order calculation
(l=Math.max(s-r,o-n))?32767/l:0}return(// main ear slicing loop which triangulates a polygon (given as a linked list)
function t(e,i,r,n,s,o,a){if(e){// interlink polygon nodes in z-order
!a&&o&&// interlink polygon nodes in z-order
function(t,e,i,r){var n=t;do 0===n.z&&(n.z=eS(n.x,n.y,e,i,r)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==t)n.prevZ.nextZ=null,n.prevZ=null,// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function(t){var e,i,r,n,s,o,a,h,l=1;do{for(i=t,t=null,s=null,o=0;i;){for(o++,r=i,a=0,e=0;e<l&&(a++,r=r.nextZ);e++);for(h=l;a>0||h>0&&r;)0!==a&&(0===h||!r||i.z<=r.z)?(n=i,i=i.nextZ,a--):(n=r,r=r.nextZ,h--),s?s.nextZ=n:t=n,n.prevZ=s,s=n;i=r}s.nextZ=null,l*=2}while(o>1)}(n)}(e,n,s,o);// iterate through ears, slicing them one by one
for(var h,l,u=e;e.prev!==e.next;){if(h=e.prev,l=e.next,o?function(t,e,i,r){var n=t.prev,s=t.next;if(eA(n,t,s)>=0)return!1;// reflex, can't be an ear
// look for points inside the triangle in both directions
for(var o=n.x,a=t.x,h=s.x,l=n.y,u=t.y,c=s.y,d=o<a?o<h?o:h:a<h?a:h,p=l<u?l<c?l:c:u<c?u:c,f=o>a?o>h?o:h:a>h?a:h,m=l>u?l>c?l:c:u>c?u:c,g=eS(d,p,e,i,r),y=eS(f,m,e,i,r),_=t.prevZ,v=t.nextZ;_&&_.z>=g&&v&&v.z<=y;){if(_.x>=d&&_.x<=f&&_.y>=p&&_.y<=m&&_!==n&&_!==s&&eM(o,l,a,u,h,c,_.x,_.y)&&eA(_.prev,_,_.next)>=0||(_=_.prevZ,v.x>=d&&v.x<=f&&v.y>=p&&v.y<=m&&v!==n&&v!==s&&eM(o,l,a,u,h,c,v.x,v.y)&&eA(v.prev,v,v.next)>=0))return!1;v=v.nextZ}// look for remaining points in decreasing z-order
for(;_&&_.z>=g;){if(_.x>=d&&_.x<=f&&_.y>=p&&_.y<=m&&_!==n&&_!==s&&eM(o,l,a,u,h,c,_.x,_.y)&&eA(_.prev,_,_.next)>=0)return!1;_=_.prevZ}// look for remaining points in increasing z-order
for(;v&&v.z<=y;){if(v.x>=d&&v.x<=f&&v.y>=p&&v.y<=m&&v!==n&&v!==s&&eM(o,l,a,u,h,c,v.x,v.y)&&eA(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}(e,n,s,o):// check whether a polygon node forms a valid ear with adjacent nodes
function(t){var e=t.prev,i=t.next;if(eA(e,t,i)>=0)return!1;// reflex, can't be an ear
for(// now make sure we don't have other points inside the potential ear
var r=e.x,n=t.x,s=i.x,o=e.y,a=t.y,h=i.y,l=r<n?r<s?r:s:n<s?n:s,u=o<a?o<h?o:h:a<h?a:h,c=r>n?r>s?r:s:n>s?n:s,d=o>a?o>h?o:h:a>h?a:h,p=i.next;p!==e;){if(p.x>=l&&p.x<=c&&p.y>=u&&p.y<=d&&eM(r,o,n,a,s,h,p.x,p.y)&&eA(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}(e)){// cut off the triangle
i.push(h.i/r|0),i.push(e.i/r|0),i.push(l.i/r|0),eD(e),// skipping the next vertex leads to less sliver triangles
e=l.next,u=l.next;continue}// if we looped through the whole remaining polygon and can't find any more ears
if((e=l)===u){// try filtering points and slicing again
a?1===a?t(e=// go through all polygon nodes and cure small local self-intersections
function(t,e,i){var r=t;do{var n=r.prev,s=r.next.next;!eR(n,s)&&eC(n,r,r.next,s)&&eO(n,s)&&eO(s,n)&&(e.push(n.i/i|0),e.push(r.i/i|0),e.push(s.i/i|0),// remove two nodes involved
eD(r),eD(r.next),r=t=s),r=r.next}while(r!==t)return eT(r)}(eT(e),i,r),i,r,n,s,o,2):2===a&&// try splitting polygon into two and triangulate them independently
function(e,i,r,n,s,o){// look for a valid diagonal that divides the polygon into two
var a=e;do{for(var h,l,u=a.next.next;u!==a.prev;){if(a.i!==u.i&&(h=a,l=u,h.next.i!==l.i&&h.prev.i!==l.i&&!// check if a polygon diagonal intersects any polygon segments
function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&eC(i,i.next,t,e))return!0;i=i.next}while(i!==t)return!1}(h,l)&&// dones't intersect other edges
(eO(h,l)&&eO(l,h)&&// check if the middle point of a polygon diagonal is inside the polygon
function(t,e){var i=t,r=!1,n=(t.x+e.x)/2,s=(t.y+e.y)/2;do i.y>s!=i.next.y>s&&i.next.y!==i.y&&n<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==t)return r}(h,l)&&// locally visible
(eA(h.prev,h,l.prev)||eA(h,l.prev,l))||// does not create opposite-facing sectors
eR(h,l)&&eA(h.prev,h,h.next)>0&&eA(l.prev,l,l.next)>0))){// split the polygon in two by the diagonal
var c=eL(a,u);// filter colinear points around the cuts
a=eT(a,a.next),c=eT(c,c.next),// run earcut on each half
t(a,i,r,n,s,o,0),t(c,i,r,n,s,o,0);return}u=u.next}a=a.next}while(a!==e)}(e,i,r,n,s,o):t(eT(e),i,r,n,s,o,1);break}}}}(d,p,i,r,n,l,0),p)}// create a circular doubly linked list from polygon points in the specified winding order
function eE(t,e,i,r,n){var s,o;if(n===eB(t,e,i,r)>0)for(s=e;s<i;s+=r)o=eN(s,t[s],t[s+1],o);else for(s=i-r;s>=e;s-=r)o=eN(s,t[s],t[s+1],o);return o&&eR(o,o.next)&&(eD(o),o=o.next),o}// eliminate colinear or duplicate points
function eT(t,e){if(!t)return t;e||(e=t);var i,r=t;do if(i=!1,!r.steiner&&(eR(r,r.next)||0===eA(r.prev,r,r.next))){if(eD(r),(r=e=r.prev)===r.next)break;i=!0}else r=r.next;while(i||r!==e)return e}function ew(t,e){return t.x-e.x}// z-order of a point given coords and inverse of the longer side of data bbox
function eS(t,e,i,r,n){return(t=((t=((t=((t=(// coords are transformed into non-negative 15-bit integer range
(t=(t-i)*n|0)|t<<8)&16711935)|t<<4)&252645135)|t<<2)&858993459)|t<<1)&1431655765)|(e=((e=((e=((e=((e=(e-r)*n|0)|e<<8)&16711935)|e<<4)&252645135)|e<<2)&858993459)|e<<1)&1431655765)<<1}// check if a point lies within a convex triangle
function eM(t,e,i,r,n,s,o,a){return(n-o)*(e-a)>=(t-o)*(s-a)&&(t-o)*(r-a)>=(i-o)*(e-a)&&(i-o)*(s-a)>=(n-o)*(r-a)}// signed area of a triangle
function eA(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}// check if two points are equal
function eR(t,e){return t.x===e.x&&t.y===e.y}// check if two segments intersect
function eC(t,e,i,r){var n=eI(eA(t,e,i)),s=eI(eA(t,e,r)),o=eI(eA(i,r,t)),a=eI(eA(i,r,e));return!!(n!==s&&o!==a||0===n&&eP(t,i,e)||0===s&&eP(t,r,e)||0===o&&eP(i,t,r)||0===a&&eP(i,e,r))}// for collinear points p, q, r, check if point q lies on segment pr
function eP(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function eI(t){return t>0?1:t<0?-1:0}// check if a polygon diagonal is locally inside the polygon
function eO(t,e){return 0>eA(t.prev,t,t.next)?eA(t,e,t.next)>=0&&eA(t,t.prev,e)>=0:0>eA(t,e,t.prev)||0>eA(t,t.next,e)}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function eL(t,e){var i=new eF(t.i,t.x,t.y),r=new eF(e.i,e.x,e.y),n=t.next,s=e.prev;return t.next=e,e.prev=t,i.next=n,n.prev=i,r.next=i,i.prev=r,s.next=r,r.prev=s,r}// create a node and optionally link it with previous one (in a circular doubly linked list)
function eN(t,e,i,r){var n=new eF(t,e,i);return r?(n.next=r.next,n.prev=r,r.next.prev=n,r.next=n):(n.prev=n,n.next=n),n}function eD(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function eF(t,e,i){// vertex index in coordinates array
this.i=t,// vertex coordinates
this.x=e,this.y=i,// previous and next vertex nodes in a polygon ring
this.prev=null,this.next=null,// z-order curve value
this.z=0,// previous and next nodes in z-order
this.prevZ=null,this.nextZ=null,// indicates whether this is a steiner point
this.steiner=!1}function eB(t,e,i,r){for(var n=0,s=e,o=i-r;s<i;s+=r)n+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return n}(ex=eb).default=eb,// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
eb.deviation=function(t,e,i,r){var n=e&&e.length,s=n?e[0]*i:t.length,o=Math.abs(eB(t,0,s,i));if(n)for(var a=0,h=e.length;a<h;a++){var l=e[a]*i,u=a<h-1?e[a+1]*i:t.length;o-=Math.abs(eB(t,l,u,i))}var c=0;for(a=0;a<r.length;a+=3){var d=r[a]*i,p=r[a+1]*i,f=r[a+2]*i;c+=Math.abs((t[d]-t[f])*(t[p+1]-t[d+1])-(t[d]-t[p])*(t[f+1]-t[d+1]))}return 0===o&&0===c?0:Math.abs((c-o)/o)},// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
eb.flatten=function(t){for(var e=t[0][0].length,i={vertices:[],holes:[],dimensions:e},r=0,n=0;n<t.length;n++){for(var s=0;s<t[n].length;s++)for(var o=0;o<e;o++)i.vertices.push(t[n][s][o]);n>0&&(r+=t[n-1].length,i.holes.push(r))}return i};var eU=tL("5tGEO"),eG={};function ek(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}eG={isString:function(t){return"string"==typeof t},isObject:function(t){return"object"==typeof t&&null!==t},isNull:function(t){return null===t},isNullOrUndefined:function(t){return null==t}},xV=e$;// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var eH=/^([a-z0-9.+-]+:)/i,ez=/:[0-9]*$/,ej=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,eV=["'"].concat(["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","	"])),// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
eX=["%","/","?",";","#"].concat(eV),eW=["/","?","#"],eY=/^[+a-z0-9A-Z_-]{0,63}$/,eq=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,eK={javascript:!0,"javascript:":!0},eJ={javascript:!0,"javascript:":!0},eZ={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};function e$(t,e,i){if(t&&eG.isObject(t)&&t instanceof ek)return t;var r=new ek;return r.parse(t,e,i),r}xX=tL("bu5IZ"),xW=tL("4gCs1"),ek.prototype.parse=function(t,e,i){if(!eG.isString(t))throw TypeError("Parameter 'url' must be a string, not "+typeof t);// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var r=t.indexOf("?"),n=-1!==r&&r<t.indexOf("#")?"?":"#",s=t.split(n);s[0]=s[0].replace(/\\/g,"/");var o=t=s.join(n);if(// trim before proceeding.
// This is to support parse stuff like "  http://foo.com  \n"
o=o.trim(),!i&&1===t.split("#").length){// Try fast path regexp
var a=ej.exec(o);if(a)return this.path=o,this.href=o,this.pathname=a[1],a[2]?(this.search=a[2],e?this.query=xX(this.search.substr(1)):this.query=this.search.substr(1)):e&&(this.search="",this.query={}),this}var h=eH.exec(o);if(h){var l=(h=h[0]).toLowerCase();this.protocol=l,o=o.substr(h.length)}// figure out if it's got a host
// user@server is *always* interpreted as a hostname, and url
// resolution will treat //foo/bar as host=foo,path=bar because that's
// how the browser resolves relative URLs.
if(i||h||o.match(/^\/\/[^@\/]+@[^@\/]+/)){var u="//"===o.substr(0,2);u&&!(h&&eJ[h])&&(o=o.substr(2),this.slashes=!0)}if(!eJ[h]&&(u||h&&!eZ[h])){for(var c,d,p=-1,f=0;f<eW.length;f++){var m=o.indexOf(eW[f]);-1!==m&&(-1===p||m<p)&&(p=m)}-1!==(d=-1===p?o.lastIndexOf("@"):o.lastIndexOf("@",p))&&(c=o.slice(0,d),o=o.slice(d+1),this.auth=decodeURIComponent(c)),// the host is the remaining to the left of the first non-host char
p=-1;for(var f=0;f<eX.length;f++){var m=o.indexOf(eX[f]);-1!==m&&(-1===p||m<p)&&(p=m)}-1===p&&(p=o.length),this.host=o.slice(0,p),o=o.slice(p),// pull out port.
this.parseHost(),// we've indicated that there is a hostname,
// so even if it's empty, it has to be present.
this.hostname=this.hostname||"";// if hostname begins with [ and ends with ]
// assume that it's an IPv6 address.
var g="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];// validate a little.
if(!g)for(var y=this.hostname.split(/\./),f=0,_=y.length;f<_;f++){var v=y[f];if(v&&!v.match(eY)){for(var x="",b=0,E=v.length;b<E;b++)v.charCodeAt(b)>127?// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
x+="x":x+=v[b];// we test again with ASCII char only
if(!x.match(eY)){var T=y.slice(0,f),w=y.slice(f+1),S=v.match(eq);S&&(T.push(S[1]),w.unshift(S[2])),w.length&&(o="/"+w.join(".")+o),this.hostname=T.join(".");break}}}this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),g||// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn't matter if
// you call it with a domain that already is ASCII-only.
(this.hostname=eU.toASCII(this.hostname));var M=this.port?":"+this.port:"",A=this.hostname||"";this.host=A+M,this.href+=this.host,g&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==o[0]&&(o="/"+o))}// now rest is set to the post-host stuff.
// chop off any delim chars.
if(!eK[l])// escaped, even if encodeURIComponent doesn't think they
// need to be.
for(var f=0,_=eV.length;f<_;f++){var R=eV[f];if(-1!==o.indexOf(R)){var C=encodeURIComponent(R);C===R&&(C=escape(R)),o=o.split(R).join(C)}}// chop off from the tail first.
var P=o.indexOf("#");-1!==P&&(// got a fragment string.
this.hash=o.substr(P),o=o.slice(0,P));var I=o.indexOf("?");//to support http.request
if(-1!==I?(this.search=o.substr(I),this.query=o.substr(I+1),e&&(this.query=xX(this.query)),o=o.slice(0,I)):e&&(// no query string, but parseQueryString still requested
this.search="",this.query={}),o&&(this.pathname=o),eZ[l]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var M=this.pathname||"",O=this.search||"";this.path=M+O}return(// finally, reconstruct the href based on what has been validated.
this.href=this.format(),this)},ek.prototype.format=function(){var t=this.auth||"";t&&(t=(t=encodeURIComponent(t)).replace(/%3A/i,":")+"@");var e=this.protocol||"",i=this.pathname||"",r=this.hash||"",n=!1,s="";this.host?n=t+this.host:this.hostname&&(n=t+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(n+=":"+this.port)),this.query&&eG.isObject(this.query)&&Object.keys(this.query).length&&(s=xW(this.query));var o=this.search||s&&"?"+s||"";return e&&":"!==e.substr(-1)&&(e+=":"),this.slashes||(!e||eZ[e])&&!1!==n?(n="//"+(n||""),i&&"/"!==i.charAt(0)&&(i="/"+i)):n||(n=""),r&&"#"!==r.charAt(0)&&(r="#"+r),o&&"?"!==o.charAt(0)&&(o="?"+o),e+n+(i=i.replace(/[?#]/g,function(t){return encodeURIComponent(t)}))+(o=o.replace("#","%23"))+r},ek.prototype.resolve=function(t){return this.resolveObject(e$(t,!1,!0)).format()},ek.prototype.resolveObject=function(t){if(eG.isString(t)){var e=new ek;e.parse(t,!1,!0),t=e}for(var i=new ek,r=Object.keys(this),n=0;n<r.length;n++){var s=r[n];i[s]=this[s]}// if the relative url is empty, then there's nothing left to do here.
if(// hash is always overridden, no matter what.
// even href="" will remove it.
i.hash=t.hash,""===t.href)return i.href=i.format(),i;// hrefs like //foo/bar always cut to the protocol.
if(t.slashes&&!t.protocol){for(var o=Object.keys(t),a=0;a<o.length;a++){var h=o[a];"protocol"!==h&&(i[h]=t[h])}return eZ[i.protocol]&&i.hostname&&!i.pathname&&(i.path=i.pathname="/"),i.href=i.format(),i}if(t.protocol&&t.protocol!==i.protocol){// if it's a known url protocol, then changing
// the protocol does weird things
// first, if it's not file:, then we MUST have a host,
// and if there was a path
// to begin with, then we MUST have a path.
// if it is file:, then the host is dropped,
// because that's known to be hostless.
// anything else is assumed to be absolute.
if(!eZ[t.protocol]){for(var l=Object.keys(t),u=0;u<l.length;u++){var c=l[u];i[c]=t[c]}return i.href=i.format(),i}if(i.protocol=t.protocol,t.host||eJ[t.protocol])i.pathname=t.pathname;else{for(var d=(t.pathname||"").split("/");d.length&&!(t.host=d.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==d[0]&&d.unshift(""),d.length<2&&d.unshift(""),i.pathname=d.join("/")}// to support http.request
if(i.search=t.search,i.query=t.query,i.host=t.host||"",i.auth=t.auth,i.hostname=t.hostname||t.host,i.port=t.port,i.pathname||i.search){var p=i.pathname||"",f=i.search||"";i.path=p+f}return i.slashes=i.slashes||t.slashes,i.href=i.format(),i}var m=i.pathname&&"/"===i.pathname.charAt(0),g=t.host||t.pathname&&"/"===t.pathname.charAt(0),y=g||m||i.host&&t.pathname,_=y,v=i.pathname&&i.pathname.split("/")||[],d=t.pathname&&t.pathname.split("/")||[],x=i.protocol&&!eZ[i.protocol];if(x&&(i.hostname="",i.port=null,i.host&&(""===v[0]?v[0]=i.host:v.unshift(i.host)),i.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===d[0]?d[0]=t.host:d.unshift(t.host)),t.host=null),y=y&&(""===d[0]||""===v[0])),g)// it's absolute.
i.host=t.host||""===t.host?t.host:i.host,i.hostname=t.hostname||""===t.hostname?t.hostname:i.hostname,i.search=t.search,i.query=t.query,v=d;else if(d.length)v||(v=[]),v.pop(),v=v.concat(d),i.search=t.search,i.query=t.query;else if(!eG.isNullOrUndefined(t.search)){// just pull out the search.
// like href='?foo'.
// Put this after the other two cases because it simplifies the booleans
if(x){i.hostname=i.host=v.shift();//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var b=!!(i.host&&i.host.indexOf("@")>0)&&i.host.split("@");b&&(i.auth=b.shift(),i.host=i.hostname=b.shift())}return i.search=t.search,i.query=t.query,eG.isNull(i.pathname)&&eG.isNull(i.search)||(i.path=(i.pathname?i.pathname:"")+(i.search?i.search:"")),i.href=i.format(),i}if(!v.length)return(// no path at all.  easy.
// we've already handled the other stuff above.
i.pathname=null,i.search?i.path="/"+i.search:i.path=null,i.href=i.format(),i);for(var E=v.slice(-1)[0],T=(i.host||t.host||v.length>1)&&("."===E||".."===E)||""===E,w=0,S=v.length;S>=0;S--)"."===(E=v[S])?v.splice(S,1):".."===E?(v.splice(S,1),w++):w&&(v.splice(S,1),w--);// if the path is allowed to go above the root, restore leading ..s
if(!y&&!_)for(;w--;w)v.unshift("..");y&&""!==v[0]&&(!v[0]||"/"!==v[0].charAt(0))&&v.unshift(""),T&&"/"!==v.join("/").substr(-1)&&v.push("");var M=""===v[0]||v[0]&&"/"===v[0].charAt(0);// put the host back
if(x){i.hostname=i.host=M?"":v.length?v.shift():"";//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var b=!!(i.host&&i.host.indexOf("@")>0)&&i.host.split("@");b&&(i.auth=b.shift(),i.host=i.hostname=b.shift())}return(y=y||i.host&&v.length)&&!M&&v.unshift(""),v.length?i.pathname=v.join("/"):(i.pathname=null,i.path=null),eG.isNull(i.pathname)&&eG.isNull(i.search)||(i.path=(i.pathname?i.pathname:"")+(i.search?i.search:"")),i.auth=t.auth||i.auth,i.slashes=i.slashes||t.slashes,i.href=i.format(),i},ek.prototype.parseHost=function(){var t=this.host,e=ez.exec(t);e&&(":"!==(e=e[0])&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t)};var eQ={};tC(eQ,"ENV",()=>xY),tC(eQ,"RENDERER_TYPE",()=>xq),tC(eQ,"BUFFER_BITS",()=>xK),tC(eQ,"BLEND_MODES",()=>xJ),tC(eQ,"DRAW_MODES",()=>xZ),tC(eQ,"FORMATS",()=>x$),tC(eQ,"TARGETS",()=>xQ),tC(eQ,"TYPES",()=>x0),tC(eQ,"SAMPLER_TYPES",()=>x1),tC(eQ,"SCALE_MODES",()=>x2),tC(eQ,"WRAP_MODES",()=>x3),tC(eQ,"MIPMAP_MODES",()=>x5),tC(eQ,"ALPHA_MODES",()=>x4),tC(eQ,"CLEAR_MODES",()=>x6),tC(eQ,"GC_MODES",()=>x8),tC(eQ,"PRECISION",()=>x7),tC(eQ,"MASK_TYPES",()=>x9),tC(eQ,"MSAA_QUALITY",()=>bt),tC(eQ,"BUFFER_TYPE",()=>be),(_$=xY||(xY={}))[_$.WEBGL_LEGACY=0]="WEBGL_LEGACY",_$[_$.WEBGL=1]="WEBGL",_$[_$.WEBGL2=2]="WEBGL2",(_Q=xq||(xq={}))[_Q.UNKNOWN=0]="UNKNOWN",_Q[_Q.WEBGL=1]="WEBGL",_Q[_Q.CANVAS=2]="CANVAS",(_0=xK||(xK={}))[_0.COLOR=16384]="COLOR",_0[_0.DEPTH=256]="DEPTH",_0[_0.STENCIL=1024]="STENCIL",(_1=xJ||(xJ={}))[_1.NORMAL=0]="NORMAL",_1[_1.ADD=1]="ADD",_1[_1.MULTIPLY=2]="MULTIPLY",_1[_1.SCREEN=3]="SCREEN",_1[_1.OVERLAY=4]="OVERLAY",_1[_1.DARKEN=5]="DARKEN",_1[_1.LIGHTEN=6]="LIGHTEN",_1[_1.COLOR_DODGE=7]="COLOR_DODGE",_1[_1.COLOR_BURN=8]="COLOR_BURN",_1[_1.HARD_LIGHT=9]="HARD_LIGHT",_1[_1.SOFT_LIGHT=10]="SOFT_LIGHT",_1[_1.DIFFERENCE=11]="DIFFERENCE",_1[_1.EXCLUSION=12]="EXCLUSION",_1[_1.HUE=13]="HUE",_1[_1.SATURATION=14]="SATURATION",_1[_1.COLOR=15]="COLOR",_1[_1.LUMINOSITY=16]="LUMINOSITY",_1[_1.NORMAL_NPM=17]="NORMAL_NPM",_1[_1.ADD_NPM=18]="ADD_NPM",_1[_1.SCREEN_NPM=19]="SCREEN_NPM",_1[_1.NONE=20]="NONE",_1[_1.SRC_OVER=0]="SRC_OVER",_1[_1.SRC_IN=21]="SRC_IN",_1[_1.SRC_OUT=22]="SRC_OUT",_1[_1.SRC_ATOP=23]="SRC_ATOP",_1[_1.DST_OVER=24]="DST_OVER",_1[_1.DST_IN=25]="DST_IN",_1[_1.DST_OUT=26]="DST_OUT",_1[_1.DST_ATOP=27]="DST_ATOP",_1[_1.ERASE=26]="ERASE",_1[_1.SUBTRACT=28]="SUBTRACT",_1[_1.XOR=29]="XOR",(_2=xZ||(xZ={}))[_2.POINTS=0]="POINTS",_2[_2.LINES=1]="LINES",_2[_2.LINE_LOOP=2]="LINE_LOOP",_2[_2.LINE_STRIP=3]="LINE_STRIP",_2[_2.TRIANGLES=4]="TRIANGLES",_2[_2.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",_2[_2.TRIANGLE_FAN=6]="TRIANGLE_FAN",(_3=x$||(x$={}))[_3.RGBA=6408]="RGBA",_3[_3.RGB=6407]="RGB",_3[_3.RG=33319]="RG",_3[_3.RED=6403]="RED",_3[_3.RGBA_INTEGER=36249]="RGBA_INTEGER",_3[_3.RGB_INTEGER=36248]="RGB_INTEGER",_3[_3.RG_INTEGER=33320]="RG_INTEGER",_3[_3.RED_INTEGER=36244]="RED_INTEGER",_3[_3.ALPHA=6406]="ALPHA",_3[_3.LUMINANCE=6409]="LUMINANCE",_3[_3.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",_3[_3.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",_3[_3.DEPTH_STENCIL=34041]="DEPTH_STENCIL",(_5=xQ||(xQ={}))[_5.TEXTURE_2D=3553]="TEXTURE_2D",_5[_5.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",_5[_5.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",_5[_5.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",_5[_5.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",_5[_5.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",_5[_5.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",_5[_5.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",_5[_5.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",(_4=x0||(x0={}))[_4.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",_4[_4.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",_4[_4.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",_4[_4.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",_4[_4.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",_4[_4.UNSIGNED_INT=5125]="UNSIGNED_INT",_4[_4.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",_4[_4.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",_4[_4.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",_4[_4.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",_4[_4.BYTE=5120]="BYTE",_4[_4.SHORT=5122]="SHORT",_4[_4.INT=5124]="INT",_4[_4.FLOAT=5126]="FLOAT",_4[_4.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",_4[_4.HALF_FLOAT=36193]="HALF_FLOAT",(_6=x1||(x1={}))[_6.FLOAT=0]="FLOAT",_6[_6.INT=1]="INT",_6[_6.UINT=2]="UINT",(_8=x2||(x2={}))[_8.NEAREST=0]="NEAREST",_8[_8.LINEAR=1]="LINEAR",(_7=x3||(x3={}))[_7.CLAMP=33071]="CLAMP",_7[_7.REPEAT=10497]="REPEAT",_7[_7.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",(_9=x5||(x5={}))[_9.OFF=0]="OFF",_9[_9.POW2=1]="POW2",_9[_9.ON=2]="ON",_9[_9.ON_MANUAL=3]="ON_MANUAL",(vt=x4||(x4={}))[vt.NPM=0]="NPM",vt[vt.UNPACK=1]="UNPACK",vt[vt.PMA=2]="PMA",vt[vt.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",vt[vt.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",vt[vt.PREMULTIPLY_ALPHA=2]="PREMULTIPLY_ALPHA",(ve=x6||(x6={}))[ve.NO=0]="NO",ve[ve.YES=1]="YES",ve[ve.AUTO=2]="AUTO",ve[ve.BLEND=0]="BLEND",ve[ve.CLEAR=1]="CLEAR",ve[ve.BLIT=2]="BLIT",(vi=x8||(x8={}))[vi.AUTO=0]="AUTO",vi[vi.MANUAL=1]="MANUAL",(vr=x7||(x7={})).LOW="lowp",vr.MEDIUM="mediump",vr.HIGH="highp",(vn=x9||(x9={}))[vn.NONE=0]="NONE",vn[vn.SCISSOR=1]="SCISSOR",vn[vn.STENCIL=2]="STENCIL",vn[vn.SPRITE=3]="SPRITE",(vs=bt||(bt={}))[vs.NONE=0]="NONE",vs[vs.LOW=2]="LOW",vs[vs.MEDIUM=4]="MEDIUM",vs[vs.HIGH=8]="HIGH",(vo=be||(be={}))[vo.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",vo[vo.ARRAY_BUFFER=34962]="ARRAY_BUFFER",// NOT YET SUPPORTED
vo[vo.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER";/**
 * This file contains redeclared types for Node `url` and `querystring` modules. These modules
 * don't provide their own typings but instead are a part of the full Node typings. The purpose of
 * this file is to redeclare the required types to avoid having the whole Node types as a
 * dependency.
 */var e0={parse:xV,format:// format a parsed object into a url string
function(t){return(eG.isString(t)&&(t=e$(t)),t instanceof ek)?t.format():ek.prototype.format.call(t)},resolve:function(t,e){return e$(t,!1,!0).resolve(e)}};ec.RETINA_PREFIX=/@([0-9\.]+)x/,ec.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT=!1;var e1=!1,e2="6.1.2";/**
 * Skips the hello message of renderers that are created after this is run.
 *
 * @function skipHello
 * @memberof PIXI.utils
 */function e3(){e1=!0}/**
 * Logs out the version and renderer information for this running instance of PIXI.
 * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
 * creating your renderer. Keep in mind that doing that will forever make you a jerk face.
 *
 * @static
 * @function sayHello
 * @memberof PIXI.utils
 * @param {string} type - The string renderer type to log.
 */function e5(t){var e;if(!e1){if(navigator.userAgent.toLowerCase().indexOf("chrome")>-1){var i=["\n %c %c %c PixiJS "+e2+" -  "+t+"   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n","background: #ff66a5; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff66a5; background: #030307; padding:5px 0;","background: #ff66a5; padding:5px 0;","background: #ffc3dc; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;"];(e=self.console).log.apply(e,i)}else self.console&&self.console.log("PixiJS "+e2+" - "+t+" - http://www.pixijs.com/");e1=!0}}/**
 * Helper for checking for WebGL support.
 *
 * @memberof PIXI.utils
 * @function isWebGLSupported
 * @return {boolean} Is WebGL supported.
 */function e4(){return void 0===bi&&(bi=function(){var t={stencil:!0,failIfMajorPerformanceCaveat:ec.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT};try{if(!self.WebGLRenderingContext)return!1;var e=document.createElement("canvas"),i=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),r=!!(i&&i.getContextAttributes().stencil);if(i){var n=i.getExtension("WEBGL_lose_context");n&&n.loseContext()}return i=null,r}catch(t){return!1}}()),bi}var e6={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",goldenrod:"#daa520",gold:"#ffd700",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavenderblush:"#fff0f5",lavender:"#e6e6fa",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};/**
 * Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
 *
 * @example
 * PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]
 * @memberof PIXI.utils
 * @function hex2rgb
 * @param {number} hex - The hexadecimal number to convert
 * @param  {number[]} [out=[]] - If supplied, this array will be used rather than returning a new one
 * @return {number[]} An array representing the [R, G, B] of the color where all values are floats.
 */function e8(t,e){return void 0===e&&(e=[]),e[0]=(t>>16&255)/255,e[1]=(t>>8&255)/255,e[2]=(255&t)/255,e}/**
 * Converts a hexadecimal color number to a string.
 *
 * @example
 * PIXI.utils.hex2string(0xffffff); // returns "#ffffff"
 * @memberof PIXI.utils
 * @function hex2string
 * @param {number} hex - Number in hex (e.g., `0xffffff`)
 * @return {string} The string color (e.g., `"#ffffff"`).
 */function e7(t){var e=t.toString(16);return"#"+(e="000000".substr(0,6-e.length)+e)}/**
 * Converts a string to a hexadecimal color number.
 * It can handle:
 *  hex strings starting with #: "#ffffff"
 *  hex strings starting with 0x: "0xffffff"
 *  hex strings without prefix: "ffffff"
 *  css colors: "black"
 *
 * @example
 * PIXI.utils.string2hex("#ffffff"); // returns 0xffffff
 * @memberof PIXI.utils
 * @function string2hex
 * @param {string} string - The string color (e.g., `"#ffffff"`)
 * @return {number} Number in hexadecimal.
 */function e9(t){return"string"==typeof t&&"#"===(t=e6[t.toLowerCase()]||t)[0]&&(t=t.substr(1)),parseInt(t,16)}/**
 * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
 *
 * @example
 * PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff
 * @memberof PIXI.utils
 * @function rgb2hex
 * @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
 * @return {number} Number in hexadecimal.
 */function it(t){return(255*t[0]<<16)+(255*t[1]<<8)+(255*t[2]|0)}/**
 * maps premultiply flag and blendMode to adjusted blendMode
 * @memberof PIXI.utils
 * @const premultiplyBlendMode
 * @type {Array<number[]>}
 */var ie=/**
 * Corrects PixiJS blend, takes premultiplied alpha into account
 *
 * @memberof PIXI.utils
 * @function mapPremultipliedBlendModes
 * @private
 * @return {Array<number[]>} Mapped modes.
 */function(){for(var t=[],e=[],i=0;i<32;i++)t[i]=i,e[i]=i;t[xJ.NORMAL_NPM]=xJ.NORMAL,t[xJ.ADD_NPM]=xJ.ADD,t[xJ.SCREEN_NPM]=xJ.SCREEN,e[xJ.NORMAL]=xJ.NORMAL_NPM,e[xJ.ADD]=xJ.ADD_NPM,e[xJ.SCREEN]=xJ.SCREEN_NPM;var r=[];return r.push(e),r.push(t),r}();/**
 * changes blendMode according to texture format
 *
 * @memberof PIXI.utils
 * @function correctBlendMode
 * @param {number} blendMode - supposed blend mode
 * @param {boolean} premultiplied - whether source is premultiplied
 * @returns {number} true blend mode for this texture
 */function ii(t,e){return ie[e?1:0][t]}/**
 * combines rgb and alpha to out array
 *
 * @memberof PIXI.utils
 * @function premultiplyRgba
 * @param {Float32Array|number[]} rgb - input rgb
 * @param {number} alpha - alpha param
 * @param {Float32Array} [out] - output
 * @param {boolean} [premultiply=true] - do premultiply it
 * @returns {Float32Array} vec4 rgba
 */function ir(t,e,i,r){return i=i||new Float32Array(4),r||void 0===r?(i[0]=t[0]*e,i[1]=t[1]*e,i[2]=t[2]*e):(i[0]=t[0],i[1]=t[1],i[2]=t[2]),i[3]=e,i}/**
 * premultiplies tint
 *
 * @memberof PIXI.utils
 * @function premultiplyTint
 * @param {number} tint - integer RGB
 * @param {number} alpha - floating point alpha (0.0-1.0)
 * @returns {number} tint multiplied by alpha
 */function is(t,e){if(1===e)return(255*e<<24)+t;if(0===e)return 0;var i=t>>16&255,r=t>>8&255,n=255&t;return i=i*e+.5|0,r=r*e+.5|0,n=n*e+.5|0,(255*e<<24)+(i<<16)+(r<<8)+n}/**
 * converts integer tint and float alpha to vec4 form, premultiplies by default
 *
 * @memberof PIXI.utils
 * @function premultiplyTintToRgba
 * @param {number} tint - input tint
 * @param {number} alpha - alpha param
 * @param {Float32Array} [out] - output
 * @param {boolean} [premultiply=true] - do premultiply it
 * @returns {Float32Array} vec4 rgba
 */function io(t,e,i,r){return(i=i||new Float32Array(4))[0]=(t>>16&255)/255,i[1]=(t>>8&255)/255,i[2]=(255&t)/255,(r||void 0===r)&&(i[0]*=e,i[1]*=e,i[2]*=e),i[3]=e,i}/**
 * Generic Mask Stack data structure
 *
 * @memberof PIXI.utils
 * @function createIndicesForQuads
 * @param {number} size - Number of quads
 * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`
 * @return {Uint16Array|Uint32Array} - Resulting index buffer
 */function ia(t,e){void 0===e&&(e=null);// the total number of indices in our array, there are 6 points per quad.
var i=6*t;if((e=e||new Uint16Array(i)).length!==i)throw Error("Out buffer length is incorrect, got "+e.length+" and expected "+i);// fill the indices with the quads to draw
for(var r=0,n=0;r<i;r+=6,n+=4)e[r+0]=n+0,e[r+1]=n+1,e[r+2]=n+2,e[r+3]=n+0,e[r+4]=n+2,e[r+5]=n+3;return e}function ih(t){if(4===t.BYTES_PER_ELEMENT)return t instanceof Float32Array?"Float32Array":t instanceof Uint32Array?"Uint32Array":"Int32Array";if(2===t.BYTES_PER_ELEMENT){if(t instanceof Uint16Array)return"Uint16Array"}else if(1===t.BYTES_PER_ELEMENT&&t instanceof Uint8Array)return"Uint8Array";// TODO map out the rest of the array elements!
return null}/* eslint-disable object-shorthand */var il={Float32Array:Float32Array,Uint32Array:Uint32Array,Int32Array:Int32Array,Uint8Array:Uint8Array};function iu(t,e){for(var i=0,r=0,n={},s=0;s<t.length;s++)r+=e[s],i+=t[s].length;for(var o=new ArrayBuffer(4*i),a=null,h=0,s=0;s<t.length;s++){var l=e[s],u=t[s],c=ih(u);n[c]||(n[c]=new il[c](o)),a=n[c];for(var d=0;d<u.length;d++)a[(d/l|0)*r+h+d%l]=u[d];h+=l}return new Float32Array(o)}// Taken from the bit-twiddle package
/**
 * Rounds to next power of two.
 *
 * @function nextPow2
 * @memberof PIXI.utils
 * @param {number} v - input value
 * @return {number}
 */function ic(t){return t+=0===t?1:0,--t,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,(t|=t>>>16)+1}/**
 * Checks if a number is a power of two.
 *
 * @function isPow2
 * @memberof PIXI.utils
 * @param {number} v - input value
 * @return {boolean} `true` if value is power of two
 */function id(t){return!(t&t-1)&&!!t}/**
 * Computes ceil of log base 2
 *
 * @function log2
 * @memberof PIXI.utils
 * @param {number} v - input value
 * @return {number} logarithm base 2
 */function ip(t){var e=(t>65535?1:0)<<4,i=((t>>>=e)>255?1:0)<<3;return t>>>=i,e|=i,i=(t>15?1:0)<<2,t>>>=i,e|=i,i=(t>3?1:0)<<1,t>>>=i,(e|=i)|t>>1}/**
 * Remove items from a javascript array without generating garbage
 *
 * @function removeItems
 * @memberof PIXI.utils
 * @param {Array<any>} arr - Array to remove elements from
 * @param {number} startIdx - starting index
 * @param {number} removeCount - how many to remove
 */function im(t,e,i){var r,n=t.length;if(!(e>=n)&&0!==i){i=e+i>n?n-e:i;var s=n-i;for(r=e;r<s;++r)t[r]=t[r+i];t.length=s}}/**
 * Returns sign of number
 *
 * @memberof PIXI.utils
 * @function sign
 * @param {number} n - the number to check the sign of
 * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
 */function ig(t){return 0===t?0:t<0?-1:1}var iy=0;/**
 * Gets the next unique identifier
 *
 * @memberof PIXI.utils
 * @function uid
 * @return {number} The next unique identifier to use.
 */function i_(){return++iy}// A map of warning messages already fired
var iv={};/**
 * Helper for warning developers about deprecated features & settings.
 * A stack track for warnings is given; useful for tracking-down where
 * deprecated methods/properties/classes are being used within the code.
 *
 * @memberof PIXI.utils
 * @function deprecation
 * @param {string} version - The version where the feature became deprecated
 * @param {string} message - Message should include what is deprecated, where, and the new solution
 * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack
 *        this is mostly to ignore internal deprecation calls.
 */function ix(t,e,i){// Ignore duplicat
if(void 0===i&&(i=3),!iv[e]){/* eslint-disable no-console */var r=Error().stack;void 0===r?console.warn("PixiJS Deprecation Warning: ",e+"\nDeprecated since v"+t):(// chop off the stack trace which includes PixiJS internal calls
r=r.split("\n").splice(i).join("\n"),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",e+"\nDeprecated since v"+t),console.warn(r),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",e+"\nDeprecated since v"+t),console.warn(r))),/* eslint-enable no-console */iv[e]=!0}}/**
 * @todo Describe property usage
 *
 * @static
 * @name ProgramCache
 * @memberof PIXI.utils
 * @type {Object}
 */var ib={},iE=Object.create(null),iT=Object.create(null);/**
 * Destroys all texture in the cache
 *
 * @memberof PIXI.utils
 * @function destroyTextureCache
 */function iw(){var t;for(t in iE)iE[t].destroy();for(t in iT)iT[t].destroy()}/**
 * Removes all textures from cache, but does not destroy them
 *
 * @memberof PIXI.utils
 * @function clearTextureCache
 */function iS(){var t;for(t in iE)delete iE[t];for(t in iT)delete iT[t]}/**
 * Creates a Canvas element of the given size to be used as a target for rendering to.
 *
 * @class
 * @memberof PIXI.utils
 */var iM=/** @class */function(){/**
     * @param width - the width for the newly created canvas
     * @param height - the height for the newly created canvas
     * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas
     */function t(t,e,i){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.resolution=i||ec.RESOLUTION,this.resize(t,e)}return(/**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */t.prototype.clear=function(){this.context.setTransform(1,0,0,1,0,0),this.context.clearRect(0,0,this.canvas.width,this.canvas.height)},/**
     * Resizes the canvas to the specified width and height.
     *
     * @param desiredWidth - the desired width of the canvas
     * @param desiredHeight - the desired height of the canvas
     */t.prototype.resize=function(t,e){this.canvas.width=Math.round(t*this.resolution),this.canvas.height=Math.round(e*this.resolution)},/** Destroys this canvas. */t.prototype.destroy=function(){this.context=null,this.canvas=null},Object.defineProperty(t.prototype,"width",{/**
         * The width of the canvas buffer in pixels.
         *
         * @member {number}
         */get:function(){return this.canvas.width},set:function(t){this.canvas.width=Math.round(t)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{/**
         * The height of the canvas buffer in pixels.
         *
         * @member {number}
         */get:function(){return this.canvas.height},set:function(t){this.canvas.height=Math.round(t)},enumerable:!1,configurable:!0}),t)}();/**
 * Trim transparent borders from a canvas
 *
 * @memberof PIXI.utils
 * @function trimCanvas
 * @param {HTMLCanvasElement} canvas - the canvas to trim
 * @returns {object} Trim data
 */function iA(t){// https://gist.github.com/remy/784508
var e,i,r,n=t.width,s=t.height,o=t.getContext("2d"),a=o.getImageData(0,0,n,s).data,h=a.length,l={top:null,left:null,right:null,bottom:null},u=null;for(e=0;e<h;e+=4)0!==a[e+3]&&(i=e/4%n,r=~~(e/4/n),null===l.top&&(l.top=r),null===l.left?l.left=i:i<l.left&&(l.left=i),null===l.right?l.right=i+1:l.right<i&&(l.right=i+1),null===l.bottom?l.bottom=r:l.bottom<r&&(l.bottom=r));return null!==l.top&&(n=l.right-l.left,s=l.bottom-l.top+1,u=o.getImageData(l.left,l.top,n,s)),{height:s,width:n,data:u}}/**
 * Regexp for data URI.
 * Based on: {@link https://github.com/ragingwind/data-uri-regex}
 *
 * @static
 * @constant {RegExp|string} DATA_URI
 * @memberof PIXI
 * @example data:image/png;base64
 */var iR=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;/**
 * @memberof PIXI.utils
 * @interface DecomposedDataUri
 *//**
 * type, eg. `image`
 * @memberof PIXI.utils.DecomposedDataUri#
 * @member {string} mediaType
 *//**
 * Sub type, eg. `png`
 * @memberof PIXI.utils.DecomposedDataUri#
 * @member {string} subType
 *//**
 * @memberof PIXI.utils.DecomposedDataUri#
 * @member {string} charset
 *//**
 * Data encoding, eg. `base64`
 * @memberof PIXI.utils.DecomposedDataUri#
 * @member {string} encoding
 *//**
 * The actual data
 * @memberof PIXI.utils.DecomposedDataUri#
 * @member {string} data
 *//**
 * Split a data URI into components. Returns undefined if
 * parameter `dataUri` is not a valid data URI.
 *
 * @memberof PIXI.utils
 * @function decomposeDataUri
 * @param {string} dataUri - the data URI to check
 * @return {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined
 */function iC(t){var e=iR.exec(t);if(e)return{mediaType:e[1]?e[1].toLowerCase():void 0,subType:e[2]?e[2].toLowerCase():void 0,charset:e[3]?e[3].toLowerCase():void 0,encoding:e[4]?e[4].toLowerCase():void 0,data:e[5]}}/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 * Nipped from the resource loader!
 *
 * @ignore
 * @param {string} url - The url to test.
 * @param {object} [loc=window.location] - The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */function iP(t,e){// data: and javascript: urls are considered same-origin
if(void 0===e&&(e=self.location),0===t.indexOf("data:"))return"";// default is window.location
e=e||self.location,br||(br=document.createElement("a")),// let the browser determine the full href for the url of this resource and then
// parse with the node url lib, we can't use the properties of the anchor element
// because they don't work in IE9 :(
br.href=t;var i=e0.parse(br.href),r=!i.port&&""===e.port||i.port===e.port;return(// if cross origin
i.hostname===e.hostname&&r&&i.protocol===e.protocol?"":"anonymous")}/**
 * get the resolution / device pixel ratio of an asset by looking for the prefix
 * used by spritesheets and image urls
 *
 * @memberof PIXI.utils
 * @function getResolutionOfUrl
 * @param {string} url - the image path
 * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
 * @return {number} resolution / device pixel ratio of an asset
 */function iI(t,e){var i=ec.RETINA_PREFIX.exec(t);return i?parseFloat(i[1]):void 0!==e?e:1}var iO={};tC(iO,"accessibleTarget",()=>i7),tC(iO,"AccessibilityManager",()=>i9);/*!
 * @pixi/accessibility - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var iL={};tC(iL,"Bounds",()=>i1),tC(iL,"DisplayObject",()=>i5),tC(iL,"TemporaryDisplayObject",()=>i4),tC(iL,"Container",()=>i8);/*!
 * @pixi/display - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var iN={};tC(iN,"PI_2",()=>iD),tC(iN,"RAD_TO_DEG",()=>iF),tC(iN,"DEG_TO_RAD",()=>iB),tC(iN,"SHAPES",()=>bn),tC(iN,"Rectangle",()=>iU),tC(iN,"Circle",()=>iG),tC(iN,"Ellipse",()=>ik),tC(iN,"Polygon",()=>iH),tC(iN,"RoundedRectangle",()=>iz),tC(iN,"Point",()=>ij),tC(iN,"ObservablePoint",()=>iV),tC(iN,"Matrix",()=>iX),tC(iN,"groupD8",()=>iQ),tC(iN,"Transform",()=>i0);/*!
 * @pixi/math - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * Two Pi.
 *
 * @static
 * @member {number}
 * @memberof PIXI
 */var iD=2*Math.PI,iF=180/Math.PI,iB=Math.PI/180;(va=bn||(bn={}))[va.POLY=0]="POLY",va[va.RECT=1]="RECT",va[va.CIRC=2]="CIRC",va[va.ELIP=3]="ELIP",va[va.RREC=4]="RREC";/**
 * Size object, contains width and height
 *
 * @memberof PIXI
 * @typedef {object} ISize
 * @property {number} width - Width component
 * @property {number} height - Height component
 *//**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */var iU=/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
     * @param {number} [width=0] - The overall width of this rectangle
     * @param {number} [height=0] - The overall height of this rectangle
     */function t(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),/**
         * @member {number}
         * @default 0
         */this.x=Number(t),/**
         * @member {number}
         * @default 0
         */this.y=Number(e),/**
         * @member {number}
         * @default 0
         */this.width=Number(i),/**
         * @member {number}
         * @default 0
         */this.height=Number(r),/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */this.type=bn.RECT}return Object.defineProperty(t.prototype,"left",{/**
         * returns the left edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.x},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"right",{/**
         * returns the right edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.x+this.width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"top",{/**
         * returns the top edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.y},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"bottom",{/**
         * returns the bottom edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.y+this.height},enumerable:!1,configurable:!0}),Object.defineProperty(t,"EMPTY",{/**
         * A constant empty rectangle.
         *
         * @static
         * @constant
         * @member {PIXI.Rectangle}
         * @return {PIXI.Rectangle} An empty rectangle
         */get:function(){return new t(0,0,0,0)},enumerable:!1,configurable:!0}),/**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},/**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this},/**
     * Copies this rectangle to another one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
     * @return {PIXI.Rectangle} Returns given parameter.
     */t.prototype.copyTo=function(t){return t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t},/**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */t.prototype.contains=function(t,e){return!(this.width<=0)&&!(this.height<=0)&&t>=this.x&&t<this.x+this.width&&e>=this.y&&e<this.y+this.height},/**
     * Pads the rectangle making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     *
     * @param {number} [paddingX=0] - The horizontal padding amount.
     * @param {number} [paddingY=0] - The vertical padding amount.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.pad=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.x-=t,this.y-=e,this.width+=2*t,this.height+=2*e,this},/**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.fit=function(t){var e=Math.max(this.x,t.x),i=Math.min(this.x+this.width,t.x+t.width),r=Math.max(this.y,t.y),n=Math.min(this.y+this.height,t.y+t.height);return this.x=e,this.width=Math.max(i-e,0),this.y=r,this.height=Math.max(n-r,0),this},/**
     * Enlarges rectangle that way its corners lie on grid
     *
     * @param {number} [resolution=1] - resolution
     * @param {number} [eps=0.001] - precision
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.ceil=function(t,e){void 0===t&&(t=1),void 0===e&&(e=.001);var i=Math.ceil((this.x+this.width-e)*t)/t,r=Math.ceil((this.y+this.height-e)*t)/t;return this.x=Math.floor((this.x+e)*t)/t,this.y=Math.floor((this.y+e)*t)/t,this.width=i-this.x,this.height=r-this.y,this},/**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.enlarge=function(t){var e=Math.min(this.x,t.x),i=Math.max(this.x+this.width,t.x+t.width),r=Math.min(this.y,t.y),n=Math.max(this.y+this.height,t.y+t.height);return this.x=e,this.width=i-e,this.y=r,this.height=n-r,this},t.prototype.toString=function(){return"[@pixi/math:Rectangle x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+"]"},t}(),iG=/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the center of this circle
     * @param {number} [y=0] - The Y coordinate of the center of this circle
     * @param {number} [radius=0] - The radius of the circle
     */function t(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.radius=i,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */this.type=bn.CIRC}return(/**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.radius)},/**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */t.prototype.contains=function(t,e){if(this.radius<=0)return!1;var i=this.radius*this.radius,r=this.x-t,n=this.y-e;return r*=r,n*=n,r+n<=i},/**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */t.prototype.getBounds=function(){return new iU(this.x-this.radius,this.y-this.radius,2*this.radius,2*this.radius)},t.prototype.toString=function(){return"[@pixi/math:Circle x="+this.x+" y="+this.y+" radius="+this.radius+"]"},t)}(),ik=/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the center of this ellipse
     * @param {number} [y=0] - The Y coordinate of the center of this ellipse
     * @param {number} [halfWidth=0] - The half width of this ellipse
     * @param {number} [halfHeight=0] - The half height of this ellipse
     */function t(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.width=i,/**
         * @member {number}
         * @default 0
         */this.height=r,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */this.type=bn.ELIP}return(/**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},/**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;// normalize the coords to an ellipse with center 0,0
var i=(t-this.x)/this.width,r=(e-this.y)/this.height;return i*=i,r*=r,i+r<=1},/**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */t.prototype.getBounds=function(){return new iU(this.x-this.width,this.y-this.height,this.width,this.height)},t.prototype.toString=function(){return"[@pixi/math:Ellipse x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+"]"},t)}(),iH=/** @class */function(){/**
     * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */function t(){for(var t=arguments,e=[],i=0;i<arguments.length;i++)e[i]=t[i];var r=Array.isArray(e[0])?e[0]:e;// if this is an array of points, convert it to a flat array of numbers
if("number"!=typeof r[0]){for(var n=[],s=0,o=r.length;s<o;s++)n.push(r[s].x,r[s].y);r=n}/**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */this.points=r,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */this.type=bn.POLY,/**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */this.closeStroke=!0}return(/**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */t.prototype.clone=function(){var e=this.points.slice(),i=new t(e);return i.closeStroke=this.closeStroke,i},/**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */t.prototype.contains=function(t,e){for(var i=!1,r=this.points.length/2,n=0,s=r-1;n<r;s=n++){var o=this.points[2*n],a=this.points[2*n+1],h=this.points[2*s],l=this.points[2*s+1];a>e!=l>e&&t<(h-o)*((e-a)/(l-a))+o&&(i=!i)}return i},t.prototype.toString=function(){return"[@pixi/math:PolygoncloseStroke="+this.closeStroke+"points="+this.points.reduce(function(t,e){return t+", "+e},"")+"]"},t)}(),iz=/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [width=0] - The overall width of this rounded rectangle
     * @param {number} [height=0] - The overall height of this rounded rectangle
     * @param {number} [radius=20] - Controls the radius of the rounded corners
     */function t(t,e,i,r,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),void 0===n&&(n=20),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.width=i,/**
         * @member {number}
         * @default 0
         */this.height=r,/**
         * @member {number}
         * @default 20
         */this.radius=n,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */this.type=bn.RREC}return(/**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height,this.radius)},/**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){if(e>=this.y+this.radius&&e<=this.y+this.height-this.radius||t>=this.x+this.radius&&t<=this.x+this.width-this.radius)return!0;var i=t-(this.x+this.radius),r=e-(this.y+this.radius),n=this.radius*this.radius;if(i*i+r*r<=n||(i=t-(this.x+this.width-this.radius))*i+r*r<=n||i*i+(r=e-(this.y+this.height-this.radius))*r<=n||(i=t-(this.x+this.radius))*i+r*r<=n)return!0}return!1},t.prototype.toString=function(){return"[@pixi/math:RoundedRectangle x="+this.x+" y="+this.y+("width="+this.width+" height="+this.height)+" radius="+this.radius+"]"},t)}(),ij=/** @class */function(){/** Creates a new `Point`
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */function t(t,e){void 0===t&&(t=0),void 0===e&&(e=0),/** Position of the point on the x axis */this.x=0,/** Position of the point on the y axis */this.y=0,this.x=t,this.y=e}return(/** Creates a clone of this point
     * @returns A clone of this point
     */t.prototype.clone=function(){return new t(this.x,this.y)},/**
     * Copies `x` and `y` from the given point into this point
     *
     * @param p - The point to copy from
     * @returns The point instance itself
     */t.prototype.copyFrom=function(t){return this.set(t.x,t.y),this},/**
     * Copies this point's x and y into the given point (`p`).
     *
     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
     * @returns The point (`p`) with values updated
     */t.prototype.copyTo=function(t){return t.set(this.x,this.y),t},/**
     * Accepts another point (`p`) and returns `true` if the given point is equal to this point
     *
     * @param p - The point to check
     * @returns Returns `true` if both `x` and `y` are equal
     */t.prototype.equals=function(t){return t.x===this.x&&t.y===this.y},/**
     * Sets the point to a new `x` and `y` position.
     * If `y` is omitted, both `x` and `y` will be set to `x`.
     *
     * @param {number} [x=0] - position of the point on the `x` axis
     * @param {number} [y=x] - position of the point on the `y` axis
     * @returns The point instance itself
     */t.prototype.set=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.x=t,this.y=e,this},t.prototype.toString=function(){return"[@pixi/math:Point x="+this.x+" y="+this.y+"]"},t)}(),iV=/** @class */function(){/**
     * Creates a new `ObservablePoint`
     *
     * @param cb - callback function triggered when `x` and/or `y` are changed
     * @param scope - owner of callback
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
    */function t(t,e,i,r){void 0===i&&(i=0),void 0===r&&(r=0),this._x=i,this._y=r,this.cb=t,this.scope=e}return(/**
     * Creates a clone of this point.
     * The callback and scope params can be overridden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param cb - The callback function triggered when `x` and/or `y` are changed
     * @param scope - The owner of the callback
     * @return a copy of this observable point
     */t.prototype.clone=function(e,i){return void 0===e&&(e=this.cb),void 0===i&&(i=this.scope),new t(e,i,this._x,this._y)},/**
     * Sets the point to a new `x` and `y` position.
     * If `y` is omitted, both `x` and `y` will be set to `x`.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns The observable point instance itself
     */t.prototype.set=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),(this._x!==t||this._y!==e)&&(this._x=t,this._y=e,this.cb.call(this.scope)),this},/**
     * Copies x and y from the given point (`p`)
     *
     * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
     * @returns The observable point instance itself
     */t.prototype.copyFrom=function(t){return(this._x!==t.x||this._y!==t.y)&&(this._x=t.x,this._y=t.y,this.cb.call(this.scope)),this},/**
     * Copies this point's x and y into that of the given point (`p`)
     *
     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
     * @returns The point (`p`) with values updated
     */t.prototype.copyTo=function(t){return t.set(this._x,this._y),t},/**
     * Accepts another point (`p`) and returns `true` if the given point is equal to this point
     *
     * @param p - The point to check
     * @returns Returns `true` if both `x` and `y` are equal
     */t.prototype.equals=function(t){return t.x===this._x&&t.y===this._y},t.prototype.toString=function(){return"[@pixi/math:ObservablePoint x=0 y=0 scope="+this.scope+"]"},Object.defineProperty(t.prototype,"x",{/** Position of the observable point on the x axis
         * @type {number}
         */get:function(){return this._x},set:function(t){this._x!==t&&(this._x=t,this.cb.call(this.scope))},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"y",{/** Position of the observable point on the y axis
         * @type {number}
         */get:function(){return this._y},set:function(t){this._y!==t&&(this._y=t,this.cb.call(this.scope))},enumerable:!1,configurable:!0}),t)}(),iX=/** @class */function(){/**
     * @param {number} [a=1] - x scale
     * @param {number} [b=0] - y skew
     * @param {number} [c=0] - x skew
     * @param {number} [d=1] - y scale
     * @param {number} [tx=0] - x translation
     * @param {number} [ty=0] - y translation
     */function t(t,e,i,r,n,s){void 0===t&&(t=1),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=1),void 0===n&&(n=0),void 0===s&&(s=0),this.array=null,/**
         * @member {number}
         * @default 1
         */this.a=t,/**
         * @member {number}
         * @default 0
         */this.b=e,/**
         * @member {number}
         * @default 0
         */this.c=i,/**
         * @member {number}
         * @default 1
         */this.d=r,/**
         * @member {number}
         * @default 0
         */this.tx=n,/**
         * @member {number}
         * @default 0
         */this.ty=s}return(/**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */t.prototype.fromArray=function(t){this.a=t[0],this.b=t[1],this.c=t[3],this.d=t[4],this.tx=t[2],this.ty=t[5]},/**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.set=function(t,e,i,r,n,s){return this.a=t,this.b=e,this.c=i,this.d=r,this.tx=n,this.ty=s,this},/**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */t.prototype.toArray=function(t,e){this.array||(this.array=new Float32Array(9));var i=e||this.array;return t?(i[0]=this.a,i[1]=this.b,i[2]=0,i[3]=this.c,i[4]=this.d,i[5]=0,i[6]=this.tx,i[7]=this.ty):(i[0]=this.a,i[1]=this.c,i[2]=this.tx,i[3]=this.b,i[4]=this.d,i[5]=this.ty,i[6]=0,i[7]=0),i[8]=1,i},/**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.IPointData} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */t.prototype.apply=function(t,e){e=e||new ij;var i=t.x,r=t.y;return e.x=this.a*i+this.c*r+this.tx,e.y=this.b*i+this.d*r+this.ty,e},/**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.IPointData} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */t.prototype.applyInverse=function(t,e){e=e||new ij;var i=1/(this.a*this.d+-(this.c*this.b)),r=t.x,n=t.y;return e.x=this.d*i*r+-this.c*i*n+(this.ty*this.c-this.tx*this.d)*i,e.y=this.a*i*n+-this.b*i*r+(-this.ty*this.a+this.tx*this.b)*i,e},/**
     * Translates the matrix on the x and y.
     *
     * @param {number} x - How much to translate x by
     * @param {number} y - How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.translate=function(t,e){return this.tx+=t,this.ty+=e,this},/**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x - The amount to scale horizontally
     * @param {number} y - The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.scale=function(t,e){return this.a*=t,this.d*=e,this.c*=t,this.b*=e,this.tx*=t,this.ty*=e,this},/**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.rotate=function(t){var e=Math.cos(t),i=Math.sin(t),r=this.a,n=this.c,s=this.tx;return this.a=r*e-this.b*i,this.b=r*i+this.b*e,this.c=n*e-this.d*i,this.d=n*i+this.d*e,this.tx=s*e-this.ty*i,this.ty=s*i+this.ty*e,this},/**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.append=function(t){var e=this.a,i=this.b,r=this.c,n=this.d;return this.a=t.a*e+t.b*r,this.b=t.a*i+t.b*n,this.c=t.c*e+t.d*r,this.d=t.c*i+t.d*n,this.tx=t.tx*e+t.ty*r+this.tx,this.ty=t.tx*i+t.ty*n+this.ty,this},/**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.setTransform=function(t,e,i,r,n,s,o,a,h){return this.a=Math.cos(o+h)*n,this.b=Math.sin(o+h)*n,this.c=-Math.sin(o-a)*s,this.d=Math.cos(o-a)*s,this.tx=t-(i*this.a+r*this.c),this.ty=e-(i*this.b+r*this.d),this},/**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.prepend=function(t){var e=this.tx;if(1!==t.a||0!==t.b||0!==t.c||1!==t.d){var i=this.a,r=this.c;this.a=i*t.a+this.b*t.c,this.b=i*t.b+this.b*t.d,this.c=r*t.a+this.d*t.c,this.d=r*t.b+this.d*t.d}return this.tx=e*t.a+this.ty*t.c+t.tx,this.ty=e*t.b+this.ty*t.d+t.ty,this},/**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */t.prototype.decompose=function(t){// sort out rotation / skew..
var e=this.a,i=this.b,r=this.c,n=this.d,s=t.pivot,o=-Math.atan2(-r,n),a=Math.atan2(i,e),h=Math.abs(o+a);return h<1e-5||1e-5>Math.abs(iD-h)?(t.rotation=a,t.skew.x=t.skew.y=0):(t.rotation=0,t.skew.x=o,t.skew.y=a),// next set scale
t.scale.x=Math.sqrt(e*e+i*i),t.scale.y=Math.sqrt(r*r+n*n),// next set position
t.position.x=this.tx+(s.x*e+s.y*r),t.position.y=this.ty+(s.x*i+s.y*n),t},/**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.invert=function(){var t=this.a,e=this.b,i=this.c,r=this.d,n=this.tx,s=t*r-e*i;return this.a=r/s,this.b=-e/s,this.c=-i/s,this.d=t/s,this.tx=(i*this.ty-r*n)/s,this.ty=-(t*this.ty-e*n)/s,this},/**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.identity=function(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this},/**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */t.prototype.clone=function(){var e=new t;return e.a=this.a,e.b=this.b,e.c=this.c,e.d=this.d,e.tx=this.tx,e.ty=this.ty,e},/**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */t.prototype.copyTo=function(t){return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t},/**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */t.prototype.copyFrom=function(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this},t.prototype.toString=function(){return"[@pixi/math:Matrix a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+"]"},Object.defineProperty(t,"IDENTITY",{/**
         * A default (identity) matrix
         *
         * @static
         * @const
         * @member {PIXI.Matrix}
         */get:function(){return new t},enumerable:!1,configurable:!0}),Object.defineProperty(t,"TEMP_MATRIX",{/**
         * A temp matrix
         *
         * @static
         * @const
         * @member {PIXI.Matrix}
         */get:function(){return new t},enumerable:!1,configurable:!0}),t)}(),iW=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],iY=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],iq=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],iK=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],iJ=[],iZ=[],i$=Math.sign;!/*
 * Initializes `rotationCayley` and `rotationMatrices`. It is called
 * only once below.
 */function(){for(var t=0;t<16;t++){var e=[];iJ.push(e);for(var i=0;i<16;i++)/* Finds rotation matrix matching the product and pushes it. */for(var r=i$(iW[t]*iW[i]+iq[t]*iY[i]),n=i$(iY[t]*iW[i]+iK[t]*iY[i]),s=i$(iW[t]*iq[i]+iq[t]*iK[i]),o=i$(iY[t]*iq[i]+iK[t]*iK[i]),a=0;a<16;a++)if(iW[a]===r&&iY[a]===n&&iq[a]===s&&iK[a]===o){e.push(a);break}}for(var t=0;t<16;t++){var h=new iX;h.set(iW[t],iY[t],iq[t],iK[t],0,0),iZ.push(h)}}();/**
 * @memberof PIXI
 * @typedef {number} GD8Symmetry
 * @see PIXI.groupD8
 *//**
 * Implements the dihedral group D8, which is similar to
 * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};
 * D8 is the same but with diagonals, and it is used for texture
 * rotations.
 *
 * The directions the U- and V- axes after rotation
 * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`
 * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.
 *
 * **Origin:**<br>
 *  This is the small part of gameofbombs.com portal system. It works.
 *
 * @see PIXI.groupD8.E
 * @see PIXI.groupD8.SE
 * @see PIXI.groupD8.S
 * @see PIXI.groupD8.SW
 * @see PIXI.groupD8.W
 * @see PIXI.groupD8.NW
 * @see PIXI.groupD8.N
 * @see PIXI.groupD8.NE
 * @author Ivan @ivanpopelyshev
 * @namespace PIXI.groupD8
 * @memberof PIXI
 */var iQ={/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0       | East      |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */E:0,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45     | Southeast |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */SE:1,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90     | South     |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */S:2,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135    | Southwest |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */SW:3,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180     | West      |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */W:4,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135/225 | Northwest    |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */NW:5,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90/270  | North        |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */N:6,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45/315  | Northeast    |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */NE:7,/**
     * Reflection about Y-axis.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MIRROR_VERTICAL:8,/**
     * Reflection about the main diagonal.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MAIN_DIAGONAL:10,/**
     * Reflection about X-axis.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MIRROR_HORIZONTAL:12,/**
     * Reflection about reverse diagonal.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */REVERSE_DIAGONAL:14,/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */uX:function(t){return iW[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */uY:function(t){return iY[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */vX:function(t){return iq[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */vY:function(t){return iK[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
     */inv:function(t){return 8&t?15&t:7&-t// or rotation % 16
},/**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @return {PIXI.GD8Symmetry} Composed operation
     */add:function(t,e){return iJ[t][e]},/**
     * Reverse of `add`.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation
     * @return {PIXI.GD8Symmetry} Result
     */sub:function(t,e){return iJ[t][iQ.inv(e)]},/**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     *
     * @memberof PIXI.groupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */rotate180:function(t){return 4^t},/**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */isVertical:function(t){return(3&t)==2},/**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `groupD8`.
     *
     * @memberof PIXI.groupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @return {PIXI.GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */byDirection:function(t,e){return 2*Math.abs(t)<=Math.abs(e)?e>=0?iQ.S:iQ.N:2*Math.abs(e)<=Math.abs(t)?t>0?iQ.E:iQ.W:e>0?t>0?iQ.SE:iQ.SW:t>0?iQ.NE:iQ.NW},/**
     * Helps sprite to compensate texture packer rotation.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */matrixAppendRotationInv:function(t,e,i,r){void 0===i&&(i=0),void 0===r&&(r=0);// Packer used "rotation", we use "inv(rotation)"
var n=iZ[iQ.inv(e)];n.tx=i,n.ty=r,t.append(n)}},i0=/** @class */function(){function t(){/**
         * The world transformation matrix.
         *
         * @member {PIXI.Matrix}
         */this.worldTransform=new iX,/**
         * The local transformation matrix.
         *
         * @member {PIXI.Matrix}
         */this.localTransform=new iX,/**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @member {PIXI.ObservablePoint}
         */this.position=new iV(this.onChange,this,0,0),/**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */this.scale=new iV(this.onChange,this,1,1),/**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */this.pivot=new iV(this.onChange,this,0,0),/**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */this.skew=new iV(this.updateSkew,this,0,0),/**
         * The rotation amount.
         *
         * @protected
         * @member {number}
         */this._rotation=0,/**
         * The X-coordinate value of the normalized local X axis,
         * the first column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._cx=1,/**
         * The Y-coordinate value of the normalized local X axis,
         * the first column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._sx=0,/**
         * The X-coordinate value of the normalized local Y axis,
         * the second column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._cy=0,/**
         * The Y-coordinate value of the normalized local Y axis,
         * the second column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._sy=1,/**
         * The locally unique ID of the local transform.
         *
         * @protected
         * @member {number}
         */this._localID=0,/**
         * The locally unique ID of the local transform
         * used to calculate the current local transformation matrix.
         *
         * @protected
         * @member {number}
         */this._currentLocalID=0,/**
         * The locally unique ID of the world transform.
         *
         * @protected
         * @member {number}
         */this._worldID=0,/**
         * The locally unique ID of the parent's world transform
         * used to calculate the current world transformation matrix.
         *
         * @protected
         * @member {number}
         */this._parentID=0}return(/**
     * Called when a value changes.
     *
     * @protected
     */t.prototype.onChange=function(){this._localID++},/**
     * Called when the skew or the rotation changes.
     *
     * @protected
     */t.prototype.updateSkew=function(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this._localID++},t.prototype.toString=function(){return"[@pixi/math:Transform position=("+this.position.x+", "+this.position.y+") rotation="+this.rotation+" "+("scale=("+this.scale.x)+", "+this.scale.y+") "+("skew=("+this.skew.x)+", "+this.skew.y+") ]"},/**
     * Updates the local transformation matrix.
     */t.prototype.updateLocalTransform=function(){var t=this.localTransform;this._localID!==this._currentLocalID&&(// get the matrix values of the displayobject based on its transform properties..
t.a=this._cx*this.scale.x,t.b=this._sx*this.scale.x,t.c=this._cy*this.scale.y,t.d=this._sy*this.scale.y,t.tx=this.position.x-(this.pivot.x*t.a+this.pivot.y*t.c),t.ty=this.position.y-(this.pivot.x*t.b+this.pivot.y*t.d),this._currentLocalID=this._localID,// force an update..
this._parentID=-1)},/**
     * Updates the local and the world transformation matrices.
     *
     * @param {PIXI.Transform} parentTransform - The parent transform
     */t.prototype.updateTransform=function(t){var e=this.localTransform;if(this._localID!==this._currentLocalID&&(// get the matrix values of the displayobject based on its transform properties..
e.a=this._cx*this.scale.x,e.b=this._sx*this.scale.x,e.c=this._cy*this.scale.y,e.d=this._sy*this.scale.y,e.tx=this.position.x-(this.pivot.x*e.a+this.pivot.y*e.c),e.ty=this.position.y-(this.pivot.x*e.b+this.pivot.y*e.d),this._currentLocalID=this._localID,// force an update..
this._parentID=-1),this._parentID!==t._worldID){// concat the parent matrix with the objects transform.
var i=t.worldTransform,r=this.worldTransform;r.a=e.a*i.a+e.b*i.c,r.b=e.a*i.b+e.b*i.d,r.c=e.c*i.a+e.d*i.c,r.d=e.c*i.b+e.d*i.d,r.tx=e.tx*i.a+e.ty*i.c+i.tx,r.ty=e.tx*i.b+e.ty*i.d+i.ty,this._parentID=t._worldID,// update the id of the transform..
this._worldID++}},/**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */t.prototype.setFromMatrix=function(t){t.decompose(this),this._localID++},Object.defineProperty(t.prototype,"rotation",{/**
         * The rotation of the object in radians.
         *
         * @member {number}
         */get:function(){return this._rotation},set:function(t){this._rotation!==t&&(this._rotation=t,this.updateSkew())},enumerable:!1,configurable:!0}),/**
     * A default (identity) transform
     *
     * @static
     * @constant
     * @member {PIXI.Transform}
     */t.IDENTITY=new t,t)}();ec.SORTABLE_CHILDREN=!1;/**
 * 'Builder' pattern for bounds rectangles.
 *
 * This could be called an Axis-Aligned Bounding Box.
 * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.
 *
 * @class
 * @memberof PIXI
 */var i1=/** @class */function(){function t(){/**
         * @member {number}
         * @default 0
         */this.minX=1/0,/**
         * @member {number}
         * @default 0
         */this.minY=1/0,/**
         * @member {number}
         * @default 0
         */this.maxX=-1/0,/**
         * @member {number}
         * @default 0
         */this.maxY=-1/0,this.rect=null,/**
         * It is updated to _boundsID of corresponding object to keep bounds in sync with content.
         * Updated from outside, thus public modifier.
         *
         * @member {number}
         * @public
         */this.updateID=-1}return(/**
     * Checks if bounds are empty.
     *
     * @return {boolean} True if empty.
     */t.prototype.isEmpty=function(){return this.minX>this.maxX||this.minY>this.maxY},/**
     * Clears the bounds and resets.
     *
     */t.prototype.clear=function(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0},/**
     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
     * It is not guaranteed that it will return tempRect
     *
     * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
     * @returns {PIXI.Rectangle} A rectangle of the bounds
     */t.prototype.getRectangle=function(t){return this.minX>this.maxX||this.minY>this.maxY?iU.EMPTY:((t=t||new iU(0,0,1,1)).x=this.minX,t.y=this.minY,t.width=this.maxX-this.minX,t.height=this.maxY-this.minY,t)},/**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.IPointData} point - The point to add.
     */t.prototype.addPoint=function(t){this.minX=Math.min(this.minX,t.x),this.maxX=Math.max(this.maxX,t.x),this.minY=Math.min(this.minY,t.y),this.maxY=Math.max(this.maxY,t.y)},/**
     * Adds a point, after transformed. This should be inlined when its possible.
     *
     * @param matrix
     * @param point
     */t.prototype.addPointMatrix=function(t,e){var i=t.a,r=t.b,n=t.c,s=t.d,o=t.tx,a=t.ty,h=i*e.x+n*e.y+o,l=r*e.x+s*e.y+a;this.minX=Math.min(this.minX,h),this.maxX=Math.max(this.maxX,h),this.minY=Math.min(this.minY,l),this.maxY=Math.max(this.maxY,l)},/**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */t.prototype.addQuad=function(t){var e=this.minX,i=this.minY,r=this.maxX,n=this.maxY,s=t[0],o=t[1];e=s<e?s:e,i=o<i?o:i,r=s>r?s:r,n=o>n?o:n,s=t[2],o=t[3],e=s<e?s:e,i=o<i?o:i,r=s>r?s:r,n=o>n?o:n,s=t[4],o=t[5],e=s<e?s:e,i=o<i?o:i,r=s>r?s:r,n=o>n?o:n,s=t[6],o=t[7],e=s<e?s:e,i=o<i?o:i,r=s>r?s:r,n=o>n?o:n,this.minX=e,this.minY=i,this.maxX=r,this.maxY=n},/**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.Transform} transform - transform to apply
     * @param {number} x0 - left X of frame
     * @param {number} y0 - top Y of frame
     * @param {number} x1 - right X of frame
     * @param {number} y1 - bottom Y of frame
     */t.prototype.addFrame=function(t,e,i,r,n){this.addFrameMatrix(t.worldTransform,e,i,r,n)},/**
     * Adds sprite frame, multiplied by matrix
     *
     * @param {PIXI.Matrix} matrix - matrix to apply
     * @param {number} x0 - left X of frame
     * @param {number} y0 - top Y of frame
     * @param {number} x1 - right X of frame
     * @param {number} y1 - bottom Y of frame
     */t.prototype.addFrameMatrix=function(t,e,i,r,n){var s=t.a,o=t.b,a=t.c,h=t.d,l=t.tx,u=t.ty,c=this.minX,d=this.minY,p=this.maxX,f=this.maxY,m=s*e+a*i+l,g=o*e+h*i+u;c=m<c?m:c,d=g<d?g:d,p=m>p?m:p,f=g>f?g:f,m=s*r+a*i+l,g=o*r+h*i+u,c=m<c?m:c,d=g<d?g:d,p=m>p?m:p,f=g>f?g:f,m=s*e+a*n+l,g=o*e+h*n+u,c=m<c?m:c,d=g<d?g:d,p=m>p?m:p,f=g>f?g:f,m=s*r+a*n+l,g=o*r+h*n+u,c=m<c?m:c,d=g<d?g:d,p=m>p?m:p,f=g>f?g:f,this.minX=c,this.minY=d,this.maxX=p,this.maxY=f},/**
     * Adds screen vertices from array
     *
     * @param {Float32Array} vertexData - calculated vertices
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */t.prototype.addVertexData=function(t,e,i){for(var r=this.minX,n=this.minY,s=this.maxX,o=this.maxY,a=e;a<i;a+=2){var h=t[a],l=t[a+1];r=h<r?h:r,n=l<n?l:n,s=h>s?h:s,o=l>o?l:o}this.minX=r,this.minY=n,this.maxX=s,this.maxY=o},/**
     * Add an array of mesh vertices
     *
     * @param {PIXI.Transform} transform - mesh transform
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */t.prototype.addVertices=function(t,e,i,r){this.addVerticesMatrix(t.worldTransform,e,i,r)},/**
     * Add an array of mesh vertices.
     *
     * @param {PIXI.Matrix} matrix - mesh matrix
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     * @param {number} [padX=0] - x padding
     * @param {number} [padY=0] - y padding
     */t.prototype.addVerticesMatrix=function(t,e,i,r,n,s){void 0===n&&(n=0),void 0===s&&(s=n);for(var o=t.a,a=t.b,h=t.c,l=t.d,u=t.tx,c=t.ty,d=this.minX,p=this.minY,f=this.maxX,m=this.maxY,g=i;g<r;g+=2){var y=e[g],_=e[g+1],v=o*y+h*_+u,x=l*_+a*y+c;d=Math.min(d,v-n),f=Math.max(f,v+n),p=Math.min(p,x-s),m=Math.max(m,x+s)}this.minX=d,this.minY=p,this.maxX=f,this.maxY=m},/**
     * Adds other Bounds.
     *
     * @param {PIXI.Bounds} bounds - The Bounds to be added
     */t.prototype.addBounds=function(t){var e=this.minX,i=this.minY,r=this.maxX,n=this.maxY;this.minX=t.minX<e?t.minX:e,this.minY=t.minY<i?t.minY:i,this.maxX=t.maxX>r?t.maxX:r,this.maxY=t.maxY>n?t.maxY:n},/**
     * Adds other Bounds, masked with Bounds.
     *
     * @param {PIXI.Bounds} bounds - The Bounds to be added.
     * @param {PIXI.Bounds} mask - TODO
     */t.prototype.addBoundsMask=function(t,e){var i=t.minX>e.minX?t.minX:e.minX,r=t.minY>e.minY?t.minY:e.minY,n=t.maxX<e.maxX?t.maxX:e.maxX,s=t.maxY<e.maxY?t.maxY:e.maxY;if(i<=n&&r<=s){var o=this.minX,a=this.minY,h=this.maxX,l=this.maxY;this.minX=i<o?i:o,this.minY=r<a?r:a,this.maxX=n>h?n:h,this.maxY=s>l?s:l}},/**
     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.
     *
     * @param {PIXI.Bounds} bounds - other bounds
     * @param {PIXI.Matrix} matrix - multiplicator
     */t.prototype.addBoundsMatrix=function(t,e){this.addFrameMatrix(e,t.minX,t.minY,t.maxX,t.maxY)},/**
     * Adds other Bounds, masked with Rectangle.
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */t.prototype.addBoundsArea=function(t,e){var i=t.minX>e.x?t.minX:e.x,r=t.minY>e.y?t.minY:e.y,n=t.maxX<e.x+e.width?t.maxX:e.x+e.width,s=t.maxY<e.y+e.height?t.maxY:e.y+e.height;if(i<=n&&r<=s){var o=this.minX,a=this.minY,h=this.maxX,l=this.maxY;this.minX=i<o?i:o,this.minY=r<a?r:a,this.maxX=n>h?n:h,this.maxY=s>l?s:l}},/**
     * Pads bounds object, making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     *
     * @param {number} [paddingX=0] - The horizontal padding amount.
     * @param {number} [paddingY=0] - The vertical padding amount.
     */t.prototype.pad=function(t,e){void 0===t&&(t=0),void 0===e&&(e=t),this.isEmpty()||(this.minX-=t,this.maxX+=t,this.minY-=e,this.maxY+=e)},/**
     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)
     *
     * @param {number} x0 - left X of frame
     * @param {number} y0 - top Y of frame
     * @param {number} x1 - right X of frame
     * @param {number} y1 - bottom Y of frame
     * @param {number} padX - padding X
     * @param {number} padY - padding Y
     */t.prototype.addFramePad=function(t,e,i,r,n,s){t-=n,e-=s,i+=n,r+=s,this.minX=this.minX<t?this.minX:t,this.maxX=this.maxX>i?this.maxX:i,this.minY=this.minY<e?this.minY:e,this.maxY=this.maxY>r?this.maxY:r},t)}(),i2=function(t,e){return(i2=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function i3(t,e){function i(){this.constructor=t}i2(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * The base class for all objects that are rendered on the screen.
 *
 * This is an abstract class and can not be used on its own; rather it should be extended.
 *
 * ## Display objects implemented in PixiJS
 *
 * | Display Object                  | Description                                                           |
 * | ------------------------------- | --------------------------------------------------------------------- |
 * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |
 * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |
 * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |
 * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |
 * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |
 * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |
 * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |
 * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |
 * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |
 * | {@link PIXI.SimpleMesh}         | v4-compatibile mesh                                                   |
 * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |
 * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |
 *
 * ## Transforms
 *
 * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its
 * local coordinate space to its parent's local coordinate space. The following properties are derived
 * from the transform:
 *
 * <table>
 *   <thead>
 *     <tr>
 *       <th>Property</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>
 *       <td>
 *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot
 *         is equal to position, regardless of the other three transformations. In other words, It is the center of
 *         rotation, scaling, and skewing.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>[position]{@link PIXI.DisplayObject#position}</td>
 *       <td>
 *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local
 *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object
 *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>
 *       <td>
 *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the
 *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center
 *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>
 *       <td>
 *          Rotation. This will rotate the display object's projection by this angle (in radians).
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>
 *       <td>
 *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>
 *         <p>
 *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be
 *         thought of the net rotation applied to the coordinate axes (separately). For example, if "skew.x" is
 *          and "skew.y" is , then the line x = 0 will be rotated by  (y = -x*cot) and the line y = 0 will be
 *         rotated by  (y = x*tan). A line y = x*tan (i.e. a line at angle  to the x-axis in local-space) will
 *         be rotated by an angle between  and .
 *         </p>
 *         <p>
 *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying
 *         a rotation. Indeed, if "skew.x" = - and "skew.y" = , it will produce an equivalent of "rotation" = .
 *         </p>
 *         <p>
 *         Another quite interesting observation is that "skew.x", "skew.y", rotation are communtative operations. Indeed,
 *         because rotation is essentially a careful combination of the two.
 *         </p>
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>angle</td>
 *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>
 *     </tr>
 *     <tr>
 *       <td>x</td>
 *       <td>Translation. This is an alias for position.x!</td>
 *     </tr>
 *     <tr>
 *       <td>y</td>
 *       <td>Translation. This is an alias for position.y!</td>
 *     </tr>
 *     <tr>
 *       <td>width</td>
 *       <td>
 *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing
 *         the "requested" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there
 *         is no concept of user-defined width.
 *       </td>
 *     </tr>
 *     <tr>
 *       <td>height</td>
 *       <td>
 *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing
 *         the "requested" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there
 *         is no concept of user-defined height.
 *       </td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * ## Bounds
 *
 * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit
 * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the
 * `worldTransform` to calculate in world space).
 *
 * There are a few additional types of bounding boxes:
 *
 * | Bounds                | Description                                                                              |
 * | --------------------- | ---------------------------------------------------------------------------------------- |
 * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |
 * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |
 * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |
 * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |
 * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |
 * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|
 * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |
 *
 * ### calculateBounds
 *
 * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.
 *
 * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and
 * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.
 *
 * Generally, the following technique works for most simple cases: take the list of points
 * forming the "hull" of the object (i.e. outline of the object's shape), and then add them
 * using {@link PIXI.Bounds#addPointMatrix}.
 *
 * ```js
 * calculateBounds(): void
 * {
 *     const points = [...];
 *
 *     for (let i = 0, j = points.length; i < j; i++)
 *     {
 *         this._bounds.addPointMatrix(this.worldTransform, points[i]);
 *     }
 * }
 * ```
 *
 * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them
 * in one array together.
 *
 * ## Alpha
 *
 * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display
 * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not
 * applied on any ancestor further up the chain).
 *
 * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.
 *
 * ## Renderable vs Visible
 *
 * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the
 * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display
 * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not
 * be calculated.
 *
 * It is recommended that applications use the `renderable` property for culling. See
 * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or
 * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.
 *
 * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This
 * one is also better in terms of performance.
 *
 * @class
 * @extends PIXI.utils.EventEmitter
 * @memberof PIXI
 */var i5=/** @class */function(t){function e(){var e=t.call(this)||this;return e.tempDisplayObjectParent=null,// TODO: need to create Transform from factory
/**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */e.transform=new i0,/**
         * The opacity of the object.
         *
         * @member {number}
         */e.alpha=1,/**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */e.visible=!0,/**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */e.renderable=!0,/**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         */e.parent=null,/**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */e.worldAlpha=1,/**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */e._lastSortedIndex=0,/**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */e._zIndex=0,/**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */e.filterArea=null,/**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */e.filters=null,/**
         * Currently enabled filters
         * @member {PIXI.Filter[]}
         * @protected
         */e._enabledFilters=null,/**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         */e._bounds=new i1,/**
         * Local bounds object, swapped with `_bounds` when using `getLocalBounds()`.
         *
         * @member {PIXI.Bounds}
         */e._localBounds=null,/**
         * Flags the cached bounds as dirty.
         *
         * @member {number}
         * @protected
         */e._boundsID=0,/**
         * Cache of this display-object's bounds-rectangle.
         *
         * @member {PIXI.Bounds}
         * @protected
         */e._boundsRect=null,/**
         * Cache of this display-object's local-bounds rectangle.
         *
         * @member {PIXI.Bounds}
         * @protected
         */e._localBoundsRect=null,/**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Container|PIXI.MaskData|null}
         * @protected
         */e._mask=null,/**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */e._destroyed=!1,/**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */e.isSprite=!1,/**
         * Does any other displayObject use this object as a mask?
         * @member {boolean}
         */e.isMask=!1,e}return i3(e,t),/**
     * Mixes all enumerable properties and methods from a source object to DisplayObject.
     *
     * @param {object} source - The source of properties and methods to mix in.
     */e.mixin=function(t){// loop through properties
for(var i=Object.keys(t),r=0;r<i.length;++r){var n=i[r];// Set the property using the property descriptor - this works for accessors and normal value properties
Object.defineProperty(e.prototype,n,Object.getOwnPropertyDescriptor(t,n))}},Object.defineProperty(e.prototype,"destroyed",{/**
         * Fired when this DisplayObject is added to a Container.
         *
         * @instance
         * @event added
         * @param {PIXI.Container} container - The container added to.
         *//**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @instance
         * @event removed
         * @param {PIXI.Container} container - The container removed from.
         *//**
         * Fired when this DisplayObject is destroyed.
         *
         * @instance
         * @event destroyed
         *//**
         * Readonly flag for destroyed display objects.
         */get:function(){return this._destroyed},enumerable:!1,configurable:!0}),/**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */e.prototype._recursivePostUpdateTransform=function(){this.parent?(this.parent._recursivePostUpdateTransform(),this.transform.updateTransform(this.parent.transform)):this.transform.updateTransform(this._tempDisplayObjectParent.transform)},/**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */e.prototype.updateTransform=function(){this._boundsID++,this.transform.updateTransform(this.parent.transform),// multiply the alphas..
this.worldAlpha=this.alpha*this.parent.worldAlpha},/**
     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.
     *
     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds
     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to
     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update
     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using
     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,
     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as
     * its height increases.
     *
     * * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.
     * * The world bounds of all display objects in a container's **subtree** will also be recalculated.
     *
     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds
     * calculation if needed.
     *
     * ```js
     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);
     * ```
     *
     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This
     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more
     * details.
     *
     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms
     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain
     * cases.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The minimum axis-aligned rectangle in world space that fits around this object.
     */e.prototype.getBounds=function(t,e){return t||(this.parent?(this._recursivePostUpdateTransform(),this.updateTransform()):(this.parent=this._tempDisplayObjectParent,this.updateTransform(),this.parent=null)),this._bounds.updateID!==this._boundsID&&(this.calculateBounds(),this._bounds.updateID=this._boundsID),e||(this._boundsRect||(this._boundsRect=new iU),e=this._boundsRect),this._bounds.getRectangle(e)},/**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */e.prototype.getLocalBounds=function(t){t||(this._localBoundsRect||(this._localBoundsRect=new iU),t=this._localBoundsRect),this._localBounds||(this._localBounds=new i1);var e=this.transform,i=this.parent;this.parent=null,this.transform=this._tempDisplayObjectParent.transform;var r=this._bounds,n=this._boundsID;this._bounds=this._localBounds;var s=this.getBounds(!1,t);return this.parent=i,this.transform=e,this._bounds=r,this._bounds.updateID+=this._boundsID-n,s},/**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPointData} position - The world origin to calculate from.
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.Point} A point object representing the position of this object.
     */e.prototype.toGlobal=function(t,e,i){// don't need to update the lot
return void 0===i&&(i=!1),i||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.apply(t,e)},/**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPointData} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.Point} A point object representing the position of this object
     */e.prototype.toLocal=function(t,e,i,r){// simply apply the matrix..
return e&&(t=e.toGlobal(t,i,r)),r||(this._recursivePostUpdateTransform(),this.parent?this.displayObjectUpdateTransform():(this.parent=this._tempDisplayObjectParent,this.displayObjectUpdateTransform(),this.parent=null)),this.worldTransform.applyInverse(t,i)},/**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */e.prototype.setParent=function(t){if(!t||!t.addChild)throw Error("setParent: Argument must be a Container");return t.addChild(this),t},/**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */e.prototype.setTransform=function(t,e,i,r,n,s,o,a,h){return void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=1),void 0===r&&(r=1),void 0===n&&(n=0),void 0===s&&(s=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===h&&(h=0),this.position.x=t,this.position.y=e,this.scale.x=i||1,this.scale.y=r||1,this.rotation=n,this.skew.x=s,this.skew.y=o,this.pivot.x=a,this.pivot.y=h,this},/**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */e.prototype.destroy=function(t){this.parent&&this.parent.removeChild(this),this.emit("destroyed"),this.removeAllListeners(),this.transform=null,this.parent=null,this._bounds=null,this._mask=null,this.filters=null,this.filterArea=null,this.hitArea=null,this.interactive=!1,this.interactiveChildren=!1,this._destroyed=!0},Object.defineProperty(e.prototype,"_tempDisplayObjectParent",{/**
         * @protected
         * @member {PIXI.Container}
         */get:function(){return null===this.tempDisplayObjectParent&&(this.tempDisplayObjectParent=new i4),this.tempDisplayObjectParent},enumerable:!1,configurable:!0}),/**
     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root
     *
     * ```
     * const cacheParent = elem.enableTempParent();
     * elem.updateTransform();
     * elem.disableTempParent(cacheParent);
     * ```
     *
     * @returns {PIXI.Container} current parent
     */e.prototype.enableTempParent=function(){var t=this.parent;return this.parent=this._tempDisplayObjectParent,t},/**
     * Pair method for `enableTempParent`
     *
     * @param {PIXI.Container} cacheParent - Actual parent of element
     */e.prototype.disableTempParent=function(t){this.parent=t},Object.defineProperty(e.prototype,"x",{/**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         *
         * @member {number}
         */get:function(){return this.position.x},set:function(t){this.transform.position.x=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"y",{/**
         * The position of the displayObject on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         *
         * @member {number}
         */get:function(){return this.position.y},set:function(t){this.transform.position.y=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"worldTransform",{/**
         * Current transform of the object based on world (parent) factors.
         *
         * @member {PIXI.Matrix}
         * @readonly
         */get:function(){return this.transform.worldTransform},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"localTransform",{/**
         * Current transform of the object based on local factors: position, scale, other stuff.
         *
         * @member {PIXI.Matrix}
         * @readonly
         */get:function(){return this.transform.localTransform},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"position",{/**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @since PixiJS 4
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.transform.position},set:function(t){this.transform.position.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"scale",{/**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         *
         * @since PixiJS 4
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.transform.scale},set:function(t){this.transform.scale.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"pivot",{/**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         *
         * @since PixiJS 4
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.transform.pivot},set:function(t){this.transform.pivot.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"skew",{/**
         * The skew factor for the object in radians.
         *
         * @since PixiJS 4
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.transform.skew},set:function(t){this.transform.skew.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"rotation",{/**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         *
         * @member {number}
         */get:function(){return this.transform.rotation},set:function(t){this.transform.rotation=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"angle",{/**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         *
         * @member {number}
         */get:function(){return this.transform.rotation*iF},set:function(t){this.transform.rotation=t*iB},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"zIndex",{/**
         * The zIndex of the displayObject.
         *
         * If a container has the sortableChildren property set to true, children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         *
         * @member {number}
         * @see PIXI.Container#sortableChildren
         */get:function(){return this._zIndex},set:function(t){this._zIndex=t,this.parent&&(this.parent.sortDirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"worldVisible",{/**
         * Indicates if the object is globally visible.
         *
         * @member {boolean}
         * @readonly
         */get:function(){var t=this;do{if(!t.visible)return!1;t=t.parent}while(t)return!0},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"mask",{/**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         *
         * @example
         * const graphics = new PIXI.Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new PIXI.Sprite(texture);
         * sprite.mask = graphics;
         *
         * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
         * @member {PIXI.Container|PIXI.MaskData|null}
         */get:function(){return this._mask},set:function(t){if(this._mask){var e=this._mask.maskObject||this._mask;e.renderable=!0,e.isMask=!1}if(this._mask=t,this._mask){var e=this._mask.maskObject||this._mask;e.renderable=!1,e.isMask=!0}},enumerable:!1,configurable:!0}),e}(/*@__PURE__*/tP(ed)),i4=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.sortDirty=null,e}return i3(e,t),e}(i5);function i6(t,e){return t.zIndex===e.zIndex?t._lastSortedIndex-e._lastSortedIndex:t.zIndex-e.zIndex}/**
 * DisplayObject default updateTransform, does not update children of container.
 * Will crash if there's no parent element.
 *
 * @memberof PIXI.DisplayObject#
 * @method displayObjectUpdateTransform
 */i5.prototype.displayObjectUpdateTransform=i5.prototype.updateTransform;/**
 * Container is a general-purpose display object that holds children. It also adds built-in support for advanced
 * rendering features like masking and filtering.
 *
 * It is the base class of all display objects that act as a container for other objects, including Graphics
 * and Sprite.
 *
 * ```js
 * import { BlurFilter } from '@pixi/filter-blur';
 * import { Container } from '@pixi/display';
 * import { Graphics } from '@pixi/graphics';
 * import { Sprite } from '@pixi/sprite';
 *
 * let container = new Container();
 * let sprite = Sprite.from("https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png");
 *
 * sprite.width = 512;
 * sprite.height = 512;
 *
 * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container
 * // is rendered.
 * container.addChild(sprite);
 *
 * // Blurs whatever is rendered by the container
 * container.filters = [new BlurFilter()];
 *
 * // Only the contents within a circle at the center should be rendered onto the screen.
 * container.mask = new Graphics()
 *  .beginFill(0xffffff)
 *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)
 *  .endFill();
 * ```
 *
 * @class
 * @extends PIXI.DisplayObject
 * @memberof PIXI
 */var i8=/** @class */function(t){function e(){var e=t.call(this)||this;return(/**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */e.children=[],/**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */e.sortableChildren=ec.SORTABLE_CHILDREN,/**
         * Should children be sorted by zIndex at the next updateTransform call.
         *
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */e.sortDirty=!1,e);/**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         *//**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */}return i3(e,t),/**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */e.prototype.onChildrenChange=function(t){/* empty */},/**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */e.prototype.addChild=function(){for(var t=arguments,e=[],i=0;i<arguments.length;i++)e[i]=t[i];// if there is only one argument we can bypass looping through the them
if(e.length>1)for(var r=0;r<e.length;r++)this.addChild(e[r]);else{var n=e[0];n.parent&&n.parent.removeChild(n),n.parent=this,this.sortDirty=!0,// ensure child transform will be recalculated
n.transform._parentID=-1,this.children.push(n),// ensure bounds will be recalculated
this._boundsID++,// TODO - lets either do all callbacks or all events.. not both!
this.onChildrenChange(this.children.length-1),this.emit("childAdded",n,this,this.children.length-1),n.emit("added",this)}return e[0]},/**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */e.prototype.addChildAt=function(t,e){if(e<0||e>this.children.length)throw Error(t+"addChildAt: The index "+e+" supplied is out of bounds "+this.children.length);return t.parent&&t.parent.removeChild(t),t.parent=this,this.sortDirty=!0,// ensure child transform will be recalculated
t.transform._parentID=-1,this.children.splice(e,0,t),// ensure bounds will be recalculated
this._boundsID++,// TODO - lets either do all callbacks or all events.. not both!
this.onChildrenChange(e),t.emit("added",this),this.emit("childAdded",t,this,e),t},/**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */e.prototype.swapChildren=function(t,e){if(t!==e){var i=this.getChildIndex(t),r=this.getChildIndex(e);this.children[i]=e,this.children[r]=t,this.onChildrenChange(i<r?i:r)}},/**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */e.prototype.getChildIndex=function(t){var e=this.children.indexOf(t);if(-1===e)throw Error("The supplied DisplayObject must be a child of the caller");return e},/**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */e.prototype.setChildIndex=function(t,e){if(e<0||e>=this.children.length)throw Error("The index "+e+" supplied is out of bounds "+this.children.length);var i=this.getChildIndex(t);im(this.children,i,1),this.children.splice(e,0,t),this.onChildrenChange(e)},/**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */e.prototype.getChildAt=function(t){if(t<0||t>=this.children.length)throw Error("getChildAt: Index ("+t+") does not exist.");return this.children[t]},/**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */e.prototype.removeChild=function(){for(var t=arguments,e=[],i=0;i<arguments.length;i++)e[i]=t[i];// if there is only one argument we can bypass looping through the them
if(e.length>1)for(var r=0;r<e.length;r++)this.removeChild(e[r]);else{var n=e[0],s=this.children.indexOf(n);if(-1===s)return null;n.parent=null,// ensure child transform will be recalculated
n.transform._parentID=-1,im(this.children,s,1),// ensure bounds will be recalculated
this._boundsID++,// TODO - lets either do all callbacks or all events.. not both!
this.onChildrenChange(s),n.emit("removed",this),this.emit("childRemoved",n,this,s)}return e[0]},/**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */e.prototype.removeChildAt=function(t){var e=this.getChildAt(t);return(// ensure child transform will be recalculated..
e.parent=null,e.transform._parentID=-1,im(this.children,t,1),// ensure bounds will be recalculated
this._boundsID++,// TODO - lets either do all callbacks or all events.. not both!
this.onChildrenChange(t),e.emit("removed",this),this.emit("childRemoved",e,this,t),e)},/**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {PIXI.DisplayObject[]} List of removed children
     */e.prototype.removeChildren=function(t,e){void 0===t&&(t=0),void 0===e&&(e=this.children.length);var i,r=t,n=e,s=n-r;if(s>0&&s<=n){i=this.children.splice(r,s);for(var o=0;o<i.length;++o)i[o].parent=null,i[o].transform&&(i[o].transform._parentID=-1);this._boundsID++,this.onChildrenChange(t);for(var o=0;o<i.length;++o)i[o].emit("removed",this),this.emit("childRemoved",i[o],this,o);return i}if(0===s&&0===this.children.length)return[];throw RangeError("removeChildren: numeric values are outside the acceptable range.")},/**
     * Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex.
     */e.prototype.sortChildren=function(){for(var t=!1,e=0,i=this.children.length;e<i;++e){var r=this.children[e];r._lastSortedIndex=e,t||0===r.zIndex||(t=!0)}t&&this.children.length>1&&this.children.sort(i6),this.sortDirty=!1},/**
     * Updates the transform on all children of this container for rendering
     */e.prototype.updateTransform=function(){this.sortableChildren&&this.sortDirty&&this.sortChildren(),this._boundsID++,this.transform.updateTransform(this.parent.transform),// TODO: check render flags, how to process stuff here
this.worldAlpha=this.alpha*this.parent.worldAlpha;for(var t=0,e=this.children.length;t<e;++t){var i=this.children[t];i.visible&&i.updateTransform()}},/**
     * Recalculates the bounds of the container.
     *
     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds
     * is limited to its mask's bounds or filterArea, if any is applied.
     */e.prototype.calculateBounds=function(){this._bounds.clear(),this._calculateBounds();for(var t=0;t<this.children.length;t++){var e=this.children[t];if(e.visible&&e.renderable){// TODO: filter+mask, need to mask both somehow
if(e.calculateBounds(),e._mask){var i=e._mask.maskObject||e._mask;i.calculateBounds(),this._bounds.addBoundsMask(e._bounds,i._bounds)}else e.filterArea?this._bounds.addBoundsArea(e._bounds,e.filterArea):this._bounds.addBounds(e._bounds)}}this._bounds.updateID=this._boundsID},/**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()
     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @param {boolean} [skipChildrenUpdate=false] - Setting to `true` will stop re-calculation of children transforms,
     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */e.prototype.getLocalBounds=function(e,i){void 0===i&&(i=!1);var r=t.prototype.getLocalBounds.call(this,e);if(!i)for(var n=0,s=this.children.length;n<s;++n){var o=this.children[n];o.visible&&o.updateTransform()}return r},/**
     * Recalculates the content bounds of this object. This should be overriden to
     * calculate the bounds of this specific object (not including children).
     *
     * @protected
     */e.prototype._calculateBounds=function(){// FILL IN//
},/**
     * Renders the object using the WebGL renderer.
     *
     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the
     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all
     * children afterward.
     *
     * If `renderable` or `visible` is false or if `worldAlpha` is not positive, this implementation will entirely
     * skip rendering. See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,
     * setting alpha to zero is not recommended for purely skipping rendering.
     *
     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is
     * advised to employ **culling** to automatically skip rendering objects outside of the current screen. The
     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and
     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} packages do this out of the box.
     *
     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or
     * filtering is applied on a container. This does, however, break batching and can affect performance when
     * masking and filtering is applied extensively throughout the scene graph.
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype.render=function(t){// if the object is not visible or the alpha is 0 then no need to render this element
if(this.visible&&!(this.worldAlpha<=0)&&this.renderable){// do a quick check to see if this element has a mask or a filter.
if(this._mask||this.filters&&this.filters.length)this.renderAdvanced(t);else{this._render(t);// simple render children!
for(var e=0,i=this.children.length;e<i;++e)this.children[e].render(t)}}},/**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype.renderAdvanced=function(t){t.batch.flush();var e=this.filters,i=this._mask;// push filter first as we need to ensure the stencil buffer is correct for any masking
if(e){this._enabledFilters||(this._enabledFilters=[]),this._enabledFilters.length=0;for(var r=0;r<e.length;r++)e[r].enabled&&this._enabledFilters.push(e[r]);this._enabledFilters.length&&t.filter.push(this,this._enabledFilters)}i&&t.mask.push(this,this._mask),// add this object to the batch, only rendered if it has a texture.
this._render(t);// now loop through the children and make sure they get rendered
for(var r=0,n=this.children.length;r<n;r++)this.children[r].render(t);t.batch.flush(),i&&t.mask.pop(this),e&&this._enabledFilters&&this._enabledFilters.length&&t.filter.pop()},/**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._render=function(t){// this is where content itself gets rendered...
},/**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */e.prototype.destroy=function(e){t.prototype.destroy.call(this),this.sortDirty=!1;var i="boolean"==typeof e?e:e&&e.children,r=this.removeChildren(0,this.children.length);if(i)for(var n=0;n<r.length;++n)r[n].destroy(e)},Object.defineProperty(e.prototype,"width",{/**
         * The width of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this.scale.x*this.getLocalBounds().width},set:function(t){var e=this.getLocalBounds().width;0!==e?this.scale.x=t/e:this.scale.x=1,this._width=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this.scale.y*this.getLocalBounds().height},set:function(t){var e=this.getLocalBounds().height;0!==e?this.scale.y=t/e:this.scale.y=1,this._height=t},enumerable:!1,configurable:!0}),e}(i5);/**
 * Container default updateTransform, does update children of container.
 * Will crash if there's no parent element.
 *
 * @memberof PIXI.Container#
 * @method containerUpdateTransform
 */i8.prototype.containerUpdateTransform=i8.prototype.updateTransform;/**
 * Default property values of accessible objects
 * used by {@link PIXI.AccessibilityManager}.
 *
 * @private
 * @function accessibleTarget
 * @memberof PIXI
 * @type {Object}
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.accessibleTarget
 *      );
 */var i7={/**
     *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
     *   shadow div with attributes set
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */accessible:!1,/**
     * Sets the title attribute of the shadow div
     * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
     *
     * @member {?string}
     * @memberof PIXI.DisplayObject#
     */accessibleTitle:null,/**
     * Sets the aria-label attribute of the shadow div
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     */accessibleHint:null,/**
     * @member {number}
     * @memberof PIXI.DisplayObject#
     * @private
     * @todo Needs docs.
     */tabIndex:0,/**
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @todo Needs docs.
     */_accessibleActive:!1,/**
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @todo Needs docs.
     */_accessibleDiv:null,/**
     * Specify the type of div the accessible layer is. Screen readers treat the element differently
     * depending on this type. Defaults to button.
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     * @default 'button'
     */accessibleType:"button",/**
     * Specify the pointer-events the accessible div will use
     * Defaults to auto.
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     * @default 'auto'
     */accessiblePointerEvents:"auto",/**
     * Setting to false will prevent any children inside this container to
     * be accessible. Defaults to true.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     * @default true
     */accessibleChildren:!0,renderId:-1};i5.mixin(i7);/**
 * The Accessibility manager recreates the ability to tab and have content read by screen readers.
 * This is very important as it can possibly help people with disabilities access PixiJS content.
 *
 * A DisplayObject can be made accessible just like it can be made interactive. This manager will map the
 * events as if the mouse was being used, minimizing the effort required to implement.
 *
 * An instance of this class is automatically created by default, and can be found at `renderer.plugins.accessibility`
 *
 * @class
 * @memberof PIXI
 */var i9=/** @class */function(){/**
     * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer
     */function t(t){/** Setting this to true will visually show the divs. */this.debug=!1,/** Internal variable, see isActive getter. */this._isActive=!1,/** Internal variable, see isMobileAccessibility getter. */this._isMobileAccessibility=!1,/** A simple pool for storing divs. */this.pool=[],/** This is a tick used to check if an object is no longer being rendered. */this.renderId=0,/** The array of currently active accessible items. */this.children=[],/** Count to throttle div updates on android devices. */this.androidUpdateCount=0,/**  The frequency to update the div elements. */this.androidUpdateFrequency=500,this._hookDiv=null,(eu.tablet||eu.phone)&&this.createTouchHook();// first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
var e=document.createElement("div");e.style.width="100px",e.style.height="100px",e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.zIndex="2",this.div=e,this.renderer=t,/**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */this._onKeyDown=this._onKeyDown.bind(this),/**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */this._onMouseMove=this._onMouseMove.bind(this),// let listen for tab.. once pressed we can fire up and show the accessibility layer
self.addEventListener("keydown",this._onKeyDown,!1)}return Object.defineProperty(t.prototype,"isActive",{/**
         * Value of `true` if accessibility is currently active and accessibility layers are showing.
         * @member {boolean}
         * @readonly
         */get:function(){return this._isActive},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"isMobileAccessibility",{/**
         * Value of `true` if accessibility is enabled for touch devices.
         * @member {boolean}
         * @readonly
         */get:function(){return this._isMobileAccessibility},enumerable:!1,configurable:!0}),/**
     * Creates the touch hooks.
     *
     * @private
     */t.prototype.createTouchHook=function(){var t=this,e=document.createElement("button");e.style.width="1px",e.style.height="1px",e.style.position="absolute",e.style.top="-1000px",e.style.left="-1000px",e.style.zIndex="2",e.style.backgroundColor="#FF0000",e.title="select to enable accessibility for this content",e.addEventListener("focus",function(){t._isMobileAccessibility=!0,t.activate(),t.destroyTouchHook()}),document.body.appendChild(e),this._hookDiv=e},/**
     * Destroys the touch hooks.
     *
     * @private
     */t.prototype.destroyTouchHook=function(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)},/**
     * Activating will cause the Accessibility layer to be shown.
     * This is called when a user presses the tab key.
     *
     * @private
     */t.prototype.activate=function(){var t;this._isActive||(this._isActive=!0,self.document.addEventListener("mousemove",this._onMouseMove,!0),self.removeEventListener("keydown",this._onKeyDown,!1),this.renderer.on("postrender",this.update,this),null===(t=this.renderer.view.parentNode)||void 0===t||t.appendChild(this.div))},/**
     * Deactivating will cause the Accessibility layer to be hidden.
     * This is called when a user moves the mouse.
     *
     * @private
     */t.prototype.deactivate=function(){var t;this._isActive&&!this._isMobileAccessibility&&(this._isActive=!1,self.document.removeEventListener("mousemove",this._onMouseMove,!0),self.addEventListener("keydown",this._onKeyDown,!1),this.renderer.off("postrender",this.update),null===(t=this.div.parentNode)||void 0===t||t.removeChild(this.div))},/**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */t.prototype.updateAccessibleObjects=function(t){if(t.visible&&t.accessibleChildren){t.accessible&&t.interactive&&(t._accessibleActive||this.addChild(t),t.renderId=this.renderId);for(var e=t.children,i=0;i<e.length;i++)this.updateAccessibleObjects(e[i])}},/**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */t.prototype.update=function(){/* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,
        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,
        *  so I am just running update every half a second, seems to fix it.
        */var t=performance.now();if((!eu.android.device||!(t<this.androidUpdateCount))&&(this.androidUpdateCount=t+this.androidUpdateFrequency,this.renderer.renderingToScreen)){this.renderer._lastObjectRendered&&this.updateAccessibleObjects(this.renderer._lastObjectRendered);var e=this.renderer.view.getBoundingClientRect(),i=e.left,r=e.top,n=e.width,s=e.height,o=this.renderer,a=o.width,h=o.height,l=o.resolution,u=n/a*l,c=s/h*l,d=this.div;d.style.left=i+"px",d.style.top=r+"px",d.style.width=a+"px",d.style.height=h+"px";for(var p=0;p<this.children.length;p++){var f=this.children[p];if(f.renderId!==this.renderId)f._accessibleActive=!1,im(this.children,p,1),this.div.removeChild(f._accessibleDiv),this.pool.push(f._accessibleDiv),f._accessibleDiv=null,p--;else{// map div to display..
d=f._accessibleDiv;var m=f.hitArea,g=f.worldTransform;f.hitArea?(d.style.left=(g.tx+m.x*g.a)*u+"px",d.style.top=(g.ty+m.y*g.d)*c+"px",d.style.width=m.width*g.a*u+"px",d.style.height=m.height*g.d*c+"px"):(m=f.getBounds(),this.capHitArea(m),d.style.left=m.x*u+"px",d.style.top=m.y*c+"px",d.style.width=m.width*u+"px",d.style.height=m.height*c+"px",d.title!==f.accessibleTitle&&null!==f.accessibleTitle&&(d.title=f.accessibleTitle),d.getAttribute("aria-label")!==f.accessibleHint&&null!==f.accessibleHint&&d.setAttribute("aria-label",f.accessibleHint)),(f.accessibleTitle!==d.title||f.tabIndex!==d.tabIndex)&&(d.title=f.accessibleTitle,d.tabIndex=f.tabIndex,this.debug&&this.updateDebugHTML(d))}}// increment the render id..
this.renderId++}},/**
     * private function that will visually add the information to the
     * accessability div
     *
     * @param {HTMLElement} div
     */t.prototype.updateDebugHTML=function(t){t.innerHTML="type: "+t.type+"</br> title : "+t.title+"</br> tabIndex: "+t.tabIndex},/**
     * Adjust the hit area based on the bounds of a display object
     *
     * @param {PIXI.Rectangle} hitArea - Bounds of the child
     */t.prototype.capHitArea=function(t){t.x<0&&(t.width+=t.x,t.x=0),t.y<0&&(t.height+=t.y,t.y=0);var e=this.renderer,i=e.width,r=e.height;t.x+t.width>i&&(t.width=i-t.x),t.y+t.height>r&&(t.height=r-t.y)},/**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {PIXI.DisplayObject} displayObject - The child to make accessible.
     */t.prototype.addChild=function(t){//    this.activate();
var e=this.pool.pop();e||((e=document.createElement("button")).style.width="100px",e.style.height="100px",e.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",e.style.position="absolute",e.style.zIndex="2",e.style.borderStyle="none",navigator.userAgent.toLowerCase().indexOf("chrome")>-1?e.setAttribute("aria-live","off"):e.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?e.setAttribute("aria-relevant","additions"):e.setAttribute("aria-relevant","text"),e.addEventListener("click",this._onClick.bind(this)),e.addEventListener("focus",this._onFocus.bind(this)),e.addEventListener("focusout",this._onFocusOut.bind(this))),// set pointer events
e.style.pointerEvents=t.accessiblePointerEvents,// set the type, this defaults to button!
e.type=t.accessibleType,t.accessibleTitle&&null!==t.accessibleTitle?e.title=t.accessibleTitle:t.accessibleHint&&null!==t.accessibleHint||(e.title="displayObject "+t.tabIndex),t.accessibleHint&&null!==t.accessibleHint&&e.setAttribute("aria-label",t.accessibleHint),this.debug&&this.updateDebugHTML(e),t._accessibleActive=!0,t._accessibleDiv=e,e.displayObject=t,this.children.push(t),this.div.appendChild(t._accessibleDiv),t._accessibleDiv.tabIndex=t.tabIndex},/**
     * Maps the div button press to pixi's InteractionManager (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */t.prototype._onClick=function(t){var e=this.renderer.plugins.interaction,i=t.target.displayObject,r=e.eventData;e.dispatchEvent(i,"click",r),e.dispatchEvent(i,"pointertap",r),e.dispatchEvent(i,"tap",r)},/**
     * Maps the div focus events to pixi's InteractionManager (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */t.prototype._onFocus=function(t){t.target.getAttribute("aria-live")||t.target.setAttribute("aria-live","assertive");var e=this.renderer.plugins.interaction,i=t.target.displayObject,r=e.eventData;e.dispatchEvent(i,"mouseover",r)},/**
     * Maps the div focus events to pixi's InteractionManager (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */t.prototype._onFocusOut=function(t){t.target.getAttribute("aria-live")||t.target.setAttribute("aria-live","polite");var e=this.renderer.plugins.interaction,i=t.target.displayObject,r=e.eventData;e.dispatchEvent(i,"mouseout",r)},/**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */t.prototype._onKeyDown=function(t){9===t.keyCode&&this.activate()},/**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */t.prototype._onMouseMove=function(t){(0!==t.movementX||0!==t.movementY)&&this.deactivate()},/**
     * Destroys the accessibility manager
     *
     */t.prototype.destroy=function(){this.destroyTouchHook(),this.div=null,self.document.removeEventListener("mousemove",this._onMouseMove,!0),self.removeEventListener("keydown",this._onKeyDown),this.pool=null,this.children=null,this.renderer=null},t}(),rt={};tC(rt,"InteractionData",()=>rs),tC(rt,"InteractionEvent",()=>ra),tC(rt,"InteractionTrackingData",()=>rh),tC(rt,"interactiveTarget",()=>ru),tC(rt,"InteractionManager",()=>rd);/*!
 * @pixi/interaction - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var re={};tC(re,"UPDATE_PRIORITY",()=>bs),tC(re,"Ticker",()=>rr),tC(re,"TickerPlugin",()=>rn),ec.TARGET_FPMS=.06,(vh=bs||(bs={}))[vh.INTERACTION=50]="INTERACTION",vh[vh.HIGH=25]="HIGH",vh[vh.NORMAL=0]="NORMAL",vh[vh.LOW=-25]="LOW",vh[vh.UTILITY=-50]="UTILITY";/**
 * Internal class for handling the priority sorting of ticker handlers.
 *
 * @private
 * @class
 * @memberof PIXI
 */var ri=/** @class */function(){/**
     * Constructor
     * @private
     * @param fn - The listener function to be added for one update
     * @param context - The listener context
     * @param priority - The priority for emitting
     * @param once - If the handler should fire once
     */function t(t,e,i,r){void 0===e&&(e=null),void 0===i&&(i=0),void 0===r&&(r=!1),/** The next item in chain. */this.next=null,/** The previous item in chain. */this.previous=null,/** `true` if this listener has been destroyed already. */this._destroyed=!1,this.fn=t,this.context=e,this.priority=i,this.once=r}return(/**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param fn - The listener function to be added for one update
     * @param context - The listener context
     * @return `true` if the listener match the arguments
     */t.prototype.match=function(t,e){return void 0===e&&(e=null),this.fn===t&&this.context===e},/**
     * Emit by calling the current function.
     * @private
     * @param deltaTime - time since the last emit.
     * @return Next ticker
     */t.prototype.emit=function(t){this.fn&&(this.context?this.fn.call(this.context,t):this.fn(t));var e=this.next;return this.once&&this.destroy(!0),this._destroyed&&(this.next=null),e},/**
     * Connect to the list.
     * @private
     * @param previous - Input node, previous listener
     */t.prototype.connect=function(t){this.previous=t,t.next&&(t.next.previous=this),this.next=t.next,t.next=this},/**
     * Destroy and don't use after this.
     * @private
     * @param hard - `true` to remove the `next` reference, this
     *        is considered a hard destroy. Soft destroy maintains the next reference.
     * @return The listener to redirect while emitting or removing.
     */t.prototype.destroy=function(t){void 0===t&&(t=!1),this._destroyed=!0,this.fn=null,this.context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);// Redirect to the next item
var e=this.next;return(// Remove references
this.next=t?null:e,this.previous=null,e)},t)}(),rr=/** @class */function(){function t(){var t=this;/**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         */this.autoStart=!1,/**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         */this.deltaTime=1,/**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         */this.lastTime=-1,/**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         */this.speed=1,/**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         */this.started=!1,/** Internal current frame request ID */this._requestId=null,/**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         */this._maxElapsedMS=100,/**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         */this._minElapsedMS=0,/** If enabled, deleting is disabled.*/this._protected=!1,/**
         * The last time keyframe was executed.
         * Maintains a relatively fixed interval with the previous value.
         */this._lastFrame=-1,this._head=new ri(null,null,1/0),this.deltaMS=1/ec.TARGET_FPMS,this.elapsedMS=1/ec.TARGET_FPMS,this._tick=function(e){t._requestId=null,t.started&&(// Invoke listeners now
t.update(e),t.started&&null===t._requestId&&t._head.next&&(t._requestId=requestAnimationFrame(t._tick)))}}return(/**
     * Conditionally requests a new animation frame.
     * If a frame has not already been requested, and if the internal
     * emitter has listeners, a new frame is requested.
     *
     * @private
     */t.prototype._requestIfNeeded=function(){null===this._requestId&&this._head.next&&(// ensure callbacks get correct delta
this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))},/**
     * Conditionally cancels a pending animation frame.
     * @private
     */t.prototype._cancelIfNeeded=function(){null!==this._requestId&&(cancelAnimationFrame(this._requestId),this._requestId=null)},/**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */t.prototype._startIfPossible=function(){this.started?this._requestIfNeeded():this.autoStart&&this.start()},/**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param fn - The listener function to be added for updates
     * @param context - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns This instance of a ticker
     */t.prototype.add=function(t,e,i){return void 0===i&&(i=bs.NORMAL),this._addListener(new ri(t,e,i))},/**
     * Add a handler for the tick event which is only execute once.
     *
     * @param fn - The listener function to be added for one update
     * @param context - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns This instance of a ticker
     */t.prototype.addOnce=function(t,e,i){return void 0===i&&(i=bs.NORMAL),this._addListener(new ri(t,e,i,!0))},/**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param listener - Current listener being added.
     * @returns This instance of a ticker
     */t.prototype._addListener=function(t){// For attaching to head
var e=this._head.next,i=this._head;// Add the first item
if(e){// Go from highest to lowest priority
for(;e;){if(t.priority>e.priority){t.connect(i);break}i=e,e=e.next}// Not yet connected
t.previous||t.connect(i)}else t.connect(i);return this._startIfPossible(),this},/**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param fn - The listener function to be removed
     * @param context - The listener context to be removed
     * @returns This instance of a ticker
     */t.prototype.remove=function(t,e){for(var i=this._head.next;i;)// no break to delete all possible matches
// incase a listener was added 2+ times
i=i.match(t,e)?i.destroy():i.next;return this._head.next||this._cancelIfNeeded(),this},Object.defineProperty(t.prototype,"count",{/**
         * The number of listeners on this ticker, calculated by walking through linked list
         *
         * @readonly
         * @member {number}
         */get:function(){if(!this._head)return 0;for(var t=0,e=this._head;e=e.next;)t++;return t},enumerable:!1,configurable:!0}),/**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */t.prototype.start=function(){this.started||(this.started=!0,this._requestIfNeeded())},/**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */t.prototype.stop=function(){this.started&&(this.started=!1,this._cancelIfNeeded())},/**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */t.prototype.destroy=function(){if(!this._protected){this.stop();for(var t=this._head.next;t;)t=t.destroy(!0);this._head.destroy(),this._head=null}},/**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */t.prototype.update=function(t){// If the difference in time is zero or negative, we ignore most of the work done here.
// If there is no valid difference, then should be no reason to let anyone know about it.
// A zero delta, is exactly that, nothing should update.
//
// The difference in time can be negative, and no this does not mean time traveling.
// This can be the result of a race condition between when an animation frame is requested
// on the current JavaScript engine event loop, and when the ticker's start method is invoked
// (which invokes the internal _requestIfNeeded method). If a frame is requested before
// _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
// can receive a time argument that can be less than the lastTime value that was set within
// _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
//
// This check covers this browser engine timing issue, as well as if consumers pass an invalid
// currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
if(void 0===t&&(t=performance.now()),t>this.lastTime){// If not enough time has passed, exit the function.
// Get ready for next frame by setting _lastFrame, but based on _minElapsedMS
// adjustment to ensure a relatively stable interval.
if(// Save uncapped elapsedMS for measurement
(e=this.elapsedMS=t-this.lastTime)>this._maxElapsedMS&&(e=this._maxElapsedMS),e*=this.speed,this._minElapsedMS){var e,i=t-this._lastFrame|0;if(i<this._minElapsedMS)return;this._lastFrame=t-i%this._minElapsedMS}this.deltaMS=e,this.deltaTime=this.deltaMS*ec.TARGET_FPMS;for(// Cache a local reference, in-case ticker is destroyed
// during the emit, we can still check for head.next
var r=this._head,n=r.next;n;)n=n.emit(this.deltaTime);r.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=t},Object.defineProperty(t.prototype,"FPS",{/**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.Ticker#speed}, which is specific
         * to scaling {@link PIXI.Ticker#deltaTime}.
         *
         * @member {number}
         * @readonly
         */get:function(){return 1e3/this.elapsedMS},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"minFPS",{/**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This value is used to cap {@link PIXI.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         *
         * @member {number}
         * @default 10
         */get:function(){return 1e3/this._maxElapsedMS},set:function(t){// Must be at least 0, but below 1 / settings.TARGET_FPMS
var e=Math.min(Math.max(0,Math.min(this.maxFPS,t))/1e3,ec.TARGET_FPMS);this._maxElapsedMS=1/e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"maxFPS",{/**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This will effect the measured value of {@link PIXI.Ticker#FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         *
         * @member {number}
         * @default 0
         */get:function(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0},set:function(t){if(0===t)this._minElapsedMS=0;else{// Max must be at least the minFPS
var e=Math.max(this.minFPS,t);this._minElapsedMS=1/(e/1e3)}},enumerable:!1,configurable:!0}),Object.defineProperty(t,"shared",{/**
         * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
         * {@link PIXI.VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         *
         * @example
         * let ticker = PIXI.Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the PIXI.Ticker.shared instance.
         * ticker.autoStart = false;
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         *
         * @example
         * // You may use the shared ticker to render...
         * let renderer = PIXI.autoDetectRenderer();
         * let stage = new PIXI.Container();
         * document.body.appendChild(renderer.view);
         * ticker.add(function (time) {
         *     renderer.render(stage);
         * });
         *
         * @example
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * function animate(time) {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * }
         * animate(performance.now());
         *
         * @member {PIXI.Ticker}
         * @static
         */get:function(){if(!t._shared){var e=t._shared=new t;e.autoStart=!0,e._protected=!0}return t._shared},enumerable:!1,configurable:!0}),Object.defineProperty(t,"system",{/**
         * The system ticker instance used by {@link PIXI.InteractionManager} and by
         * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
         * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         *
         * @member {PIXI.Ticker}
         * @static
         */get:function(){if(!t._system){var e=t._system=new t;e.autoStart=!0,e._protected=!0}return t._system},enumerable:!1,configurable:!0}),t)}(),rn=/** @class */function(){function t(){}return(/**
     * Initialize the plugin with scope of application instance
     *
     * @static
     * @private
     * @param {object} [options] - See application options
     */t.init=function(t){var e=this;// Set default
t=Object.assign({autoStart:!0,sharedTicker:!1},t),// Create ticker setter
Object.defineProperty(this,"ticker",{set:function(t){this._ticker&&this._ticker.remove(this.render,this),this._ticker=t,t&&t.add(this.render,this,bs.LOW)},get:function(){return this._ticker}}),/**
         * Convenience method for stopping the render.
         *
         * @method
         * @memberof PIXI.Application
         * @instance
         */this.stop=function(){e._ticker.stop()},/**
         * Convenience method for starting the render.
         *
         * @method
         * @memberof PIXI.Application
         * @instance
         */this.start=function(){e._ticker.start()},/**
         * Internal reference to the ticker.
         *
         * @type {PIXI.Ticker}
         * @name _ticker
         * @memberof PIXI.Application#
         * @private
         */this._ticker=null,/**
         * Ticker for doing render updates.
         *
         * @type {PIXI.Ticker}
         * @name ticker
         * @memberof PIXI.Application#
         * @default PIXI.Ticker.shared
         */this.ticker=t.sharedTicker?rr.shared:new rr,t.autoStart&&this.start()},/**
     * Clean up the ticker, scoped to application.
     *
     * @static
     * @private
     */t.destroy=function(){if(this._ticker){var t=this._ticker;this.ticker=null,t.destroy()}},t)}(),rs=/** @class */function(){function t(){this.pressure=0,this.rotationAngle=0,this.twist=0,this.tangentialPressure=0,/**
         * This point stores the global coords of where the touch/mouse event happened
         *
         * @member {PIXI.Point}
         */this.global=new ij,/**
         * The target Sprite that was interacted with
         *
         * @member {PIXI.Sprite}
         */this.target=null,/**
         * When passed to an event handler, this will be the original DOM Event that was captured
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
         * @member {MouseEvent|TouchEvent|PointerEvent}
         */this.originalEvent=null,/**
         * Unique identifier for this interaction
         *
         * @member {number}
         */this.identifier=null,/**
         * Indicates whether or not the pointer device that created the event is the primary pointer.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
         * @type {Boolean}
         */this.isPrimary=!1,/**
         * Indicates which button was pressed on the mouse or pointer device to trigger the event.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
         * @type {number}
         */this.button=0,/**
         * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
         * @type {number}
         */this.buttons=0,/**
         * The width of the pointer's contact along the x-axis, measured in CSS pixels.
         * radiusX of TouchEvents will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
         * @type {number}
         */this.width=0,/**
         * The height of the pointer's contact along the y-axis, measured in CSS pixels.
         * radiusY of TouchEvents will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
         * @type {number}
         */this.height=0,/**
         * The angle, in degrees, between the pointer device and the screen.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
         * @type {number}
         */this.tiltX=0,/**
         * The angle, in degrees, between the pointer device and the screen.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
         * @type {number}
         */this.tiltY=0,/**
         * The type of pointer that triggered the event.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
         * @type {string}
         */this.pointerType=null,/**
         * Pressure applied by the pointing device during the event. A Touch's force property
         * will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
         * @type {number}
         */this.pressure=0,/**
         * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
         * @type {number}
         */this.rotationAngle=0,/**
         * Twist of a stylus pointer.
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         * @type {number}
         */this.twist=0,/**
         * Barrel pressure on a stylus pointer.
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         * @type {number}
         */this.tangentialPressure=0}return Object.defineProperty(t.prototype,"pointerId",{/**
         * The unique identifier of the pointer. It will be the same as `identifier`.
         * @readonly
         * @member {number}
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
         */get:function(){return this.identifier},enumerable:!1,configurable:!0}),/**
     * This will return the local coordinates of the specified displayObject for this InteractionData
     *
     * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
     *  coords off
     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise
     *  will create a new point)
     * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional
     *  (otherwise will use the current global coords)
     * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative
     *  to the DisplayObject
     */t.prototype.getLocalPosition=function(t,e,i){return t.worldTransform.applyInverse(i||this.global,e)},/**
     * Copies properties from normalized event data.
     *
     * @param {Touch|MouseEvent|PointerEvent} event - The normalized event data
     */t.prototype.copyEvent=function(t){"isPrimary"in t&&t.isPrimary&&(this.isPrimary=!0),this.button="button"in t&&t.button;// event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard
// event.which property instead, which conveys the same information.
var e="buttons"in t&&t.buttons;this.buttons=Number.isInteger(e)?e:"which"in t&&t.which,this.width="width"in t&&t.width,this.height="height"in t&&t.height,this.tiltX="tiltX"in t&&t.tiltX,this.tiltY="tiltY"in t&&t.tiltY,this.pointerType="pointerType"in t&&t.pointerType,this.pressure="pressure"in t&&t.pressure,this.rotationAngle="rotationAngle"in t&&t.rotationAngle,this.twist="twist"in t&&t.twist||0,this.tangentialPressure="tangentialPressure"in t&&t.tangentialPressure||0},/**
     * Resets the data for pooling.
     */t.prototype.reset=function(){// isPrimary is the only property that we really need to reset - everything else is
// guaranteed to be overwritten
this.isPrimary=!1},t}(),ro=function(t,e){return(ro=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},ra=/** @class */function(){function t(){/**
         * Whether this event will continue propagating in the tree.
         *
         * Remaining events for the {@link stopsPropagatingAt} object
         * will still be dispatched.
         *
         * @member {boolean}
         */this.stopped=!1,/**
         * At which object this event stops propagating.
         *
         * @private
         * @member {PIXI.DisplayObject}
         */this.stopsPropagatingAt=null,/**
         * Whether we already reached the element we want to
         * stop propagating at. This is important for delayed events,
         * where we start over deeper in the tree again.
         *
         * @private
         * @member {boolean}
         */this.stopPropagationHint=!1,/**
         * The object which caused this event to be dispatched.
         * For listener callback see {@link PIXI.InteractionEvent.currentTarget}.
         *
         * @member {PIXI.DisplayObject}
         */this.target=null,/**
         * The object whose event listeners callback is currently being invoked.
         *
         * @member {PIXI.DisplayObject}
         */this.currentTarget=null,/**
         * Type of the event
         *
         * @member {string}
         */this.type=null,/**
         * InteractionData related to this event
         *
         * @member {PIXI.InteractionData}
         */this.data=null}return(/**
     * Prevents event from reaching any objects other than the current object.
     *
     */t.prototype.stopPropagation=function(){this.stopped=!0,this.stopPropagationHint=!0,this.stopsPropagatingAt=this.currentTarget},/**
     * Resets the event.
     */t.prototype.reset=function(){this.stopped=!1,this.stopsPropagatingAt=null,this.stopPropagationHint=!1,this.currentTarget=null,this.target=null},t)}(),rh=/** @class */function(){/**
     * @param {number} pointerId - Unique pointer id of the event
     * @private
     */function t(e){this._pointerId=e,this._flags=t.FLAGS.NONE}return(/**
     *
     * @private
     * @param {number} flag - The interaction flag to set
     * @param {boolean} yn - Should the flag be set or unset
     */t.prototype._doSet=function(t,e){e?this._flags=this._flags|t:this._flags=this._flags&~t},Object.defineProperty(t.prototype,"pointerId",{/**
         * Unique pointer id of the event
         *
         * @readonly
         * @private
         * @member {number}
         */get:function(){return this._pointerId},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"flags",{/**
         * State of the tracking data, expressed as bit flags
         *
         * @private
         * @member {number}
         */get:function(){return this._flags},set:function(t){this._flags=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"none",{/**
         * Is the tracked event inactive (not over or down)?
         *
         * @private
         * @member {number}
         */get:function(){return this._flags===t.FLAGS.NONE},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"over",{/**
         * Is the tracked event over the DisplayObject?
         *
         * @private
         * @member {boolean}
         */get:function(){return(this._flags&t.FLAGS.OVER)!=0},set:function(e){this._doSet(t.FLAGS.OVER,e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"rightDown",{/**
         * Did the right mouse button come down in the DisplayObject?
         *
         * @private
         * @member {boolean}
         */get:function(){return(this._flags&t.FLAGS.RIGHT_DOWN)!=0},set:function(e){this._doSet(t.FLAGS.RIGHT_DOWN,e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"leftDown",{/**
         * Did the left mouse button come down in the DisplayObject?
         *
         * @private
         * @member {boolean}
         */get:function(){return(this._flags&t.FLAGS.LEFT_DOWN)!=0},set:function(e){this._doSet(t.FLAGS.LEFT_DOWN,e)},enumerable:!1,configurable:!0}),t.FLAGS=Object.freeze({NONE:0,OVER:1,LEFT_DOWN:2,RIGHT_DOWN:4}),t)}(),rl=/** @class */function(){function t(){this._tempPoint=new ij}return(/**
     * Recursive implementation for findHit
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @param {boolean} [interactive] - Whether the displayObject is interactive
     * @return {boolean} returns true if the displayObject hit the point
     */t.prototype.recursiveFindHit=function(t,e,i,r,n){if(!e||!e.visible)return!1;var s=t.data.global;// Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^
//
// This function will now loop through all objects and then only hit test the objects it HAS
// to, not all of them. MUCH faster..
// An object will be hit test if the following is true:
//
// 1: It is interactive.
// 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
//
// As another little optimization once an interactive object has been hit we can carry on
// through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
// A final optimization is that an object is not hit test directly if a child has already been hit.
n=e.interactive||n;var o=!1,a=n,h=!0;// ** FREE TIP **! If an object is not interactive or has no buttons in it
// (such as a game scene!) set interactiveChildren to false for that displayObject.
// This will allow PixiJS to completely ignore and bypass checking the displayObjects children.
if(e.hitArea?(r&&(e.worldTransform.applyInverse(s,this._tempPoint),e.hitArea.contains(this._tempPoint.x,this._tempPoint.y)?o=!0:(r=!1,h=!1)),a=!1):e._mask&&r&&!(e._mask.containsPoint&&e._mask.containsPoint(s))&&(r=!1),h&&e.interactiveChildren&&e.children)for(var l=e.children,u=l.length-1;u>=0;u--){var c=l[u],d=this.recursiveFindHit(t,c,i,r,a);if(d){// its a good idea to check if a child has lost its parent.
// this means it has been removed whilst looping so its best
if(!c.parent)continue;// we no longer need to hit test any more objects in this container as we we
// now know the parent has been hit
a=!1,d&&(t.target&&(r=!1),o=!0)}}return n&&(r&&!t.target&&!e.hitArea&&e.containsPoint&&e.containsPoint(s)&&(o=!0),e.interactive&&(o&&!t.target&&(t.target=e),i&&i(t,e,!!o))),o},/**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
     * @return {boolean} returns true if the displayObject hit the point
     */t.prototype.findHit=function(t,e,i,r){this.recursiveFindHit(t,e,i,r,!1)},t)}(),ru={interactive:!1,interactiveChildren:!0,hitArea:null,/**
     * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
     * Setting this changes the 'cursor' property to `'pointer'`.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.buttonMode = true;
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */get buttonMode(){return"pointer"===this.cursor},set buttonMode(value){value?this.cursor="pointer":"pointer"===this.cursor&&(this.cursor=null)},/**
     * This defines what cursor mode is used when the mouse cursor
     * is hovered over the displayObject.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.interactive = true;
     * sprite.cursor = 'wait';
     * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
     *
     * @member {string}
     * @memberof PIXI.DisplayObject#
     */cursor:null,/**
     * Internal set of all active pointers, by identifier
     *
     * @member {Map<number, InteractionTrackingData>}
     * @memberof PIXI.DisplayObject#
     * @private
     */get trackedPointers(){return void 0===this._trackedPointers&&(this._trackedPointers={}),this._trackedPointers},/**
     * Map of all tracked pointers, by identifier. Use trackedPointers to access.
     *
     * @private
     * @type {Map<number, InteractionTrackingData>}
     */_trackedPointers:void 0};i5.mixin(ru);// helpers for hitTest() - only used inside hitTest()
var rc={target:null,data:{global:null}},rd=/** @class */function(t){/**
     * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer
     * @param {object} [options] - The options for the manager.
     * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.
     * @param {number} [options.interactionFrequency=10] - Maximum frequency (ms) at pointer over/out states will be checked.
     * @param {number} [options.useSystemTicker=true] - Whether to add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
     */function e(e,i){var r=t.call(this)||this;return i=i||{},/**
         * The renderer this interaction manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */r.renderer=e,/**
         * Should default browser actions automatically be prevented.
         * Does not apply to pointer events for backwards compatibility
         * preventDefault on pointer events stops mouse events from firing
         * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
         *
         * @member {boolean}
         * @default true
         */r.autoPreventDefault=void 0===i.autoPreventDefault||i.autoPreventDefault,/**
         * Maximum frequency in milliseconds at which pointer over/out states will be checked by {@link tickerUpdate}.
         *
         * @member {number}
         * @default 10
         */r.interactionFrequency=i.interactionFrequency||10,/**
         * The mouse data
         *
         * @member {PIXI.InteractionData}
         */r.mouse=new rs,r.mouse.identifier=1,// setting the mouse to start off far off screen will mean that mouse over does
//  not get called before we even move the mouse.
r.mouse.global.set(-999999),/**
         * Actively tracked InteractionData
         *
         * @private
         * @member {Object.<number,PIXI.InteractionData>}
         */r.activeInteractionData={},r.activeInteractionData[1]=r.mouse,/**
         * Pool of unused InteractionData
         *
         * @private
         * @member {PIXI.InteractionData[]}
         */r.interactionDataPool=[],/**
         * An event data object to handle all the event tracking/dispatching
         *
         * @member {object}
         */r.eventData=new ra,/**
         * The DOM element to bind to.
         *
         * @protected
         * @member {HTMLElement}
         */r.interactionDOMElement=null,/**
         * This property determines if mousemove and touchmove events are fired only when the cursor
         * is over the object.
         * Setting to true will make things work more in line with how the DOM version works.
         * Setting to false can make things easier for things like dragging
         * It is currently set to false as this is how PixiJS used to work. This will be set to true in
         * future versions of pixi.
         *
         * @member {boolean}
         * @default false
         */r.moveWhenInside=!1,/**
         * Have events been attached to the dom element?
         *
         * @protected
         * @member {boolean}
         */r.eventsAdded=!1,/**
         * Has the system ticker been added?
         *
         * @protected
         * @member {boolean}
         */r.tickerAdded=!1,/**
         * Is the mouse hovering over the renderer? If working in worker mouse considered to be over renderer by default.
         *
         * @protected
         * @member {boolean}
         */r.mouseOverRenderer=!("PointerEvent"in self),/**
         * Does the device support touch events
         * https://www.w3.org/TR/touch-events/
         *
         * @readonly
         * @member {boolean}
         */r.supportsTouchEvents="ontouchstart"in self,/**
         * Does the device support pointer events
         * https://www.w3.org/Submission/pointer-events/
         *
         * @readonly
         * @member {boolean}
         */r.supportsPointerEvents=!!self.PointerEvent,// this will make it so that you don't have to call bind all the time
/**
         * @private
         * @member {Function}
         */r.onPointerUp=r.onPointerUp.bind(r),r.processPointerUp=r.processPointerUp.bind(r),/**
         * @private
         * @member {Function}
         */r.onPointerCancel=r.onPointerCancel.bind(r),r.processPointerCancel=r.processPointerCancel.bind(r),/**
         * @private
         * @member {Function}
         */r.onPointerDown=r.onPointerDown.bind(r),r.processPointerDown=r.processPointerDown.bind(r),/**
         * @private
         * @member {Function}
         */r.onPointerMove=r.onPointerMove.bind(r),r.processPointerMove=r.processPointerMove.bind(r),/**
         * @private
         * @member {Function}
         */r.onPointerOut=r.onPointerOut.bind(r),r.processPointerOverOut=r.processPointerOverOut.bind(r),/**
         * @private
         * @member {Function}
         */r.onPointerOver=r.onPointerOver.bind(r),/**
         * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
         * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
         * and functions are called instead of changing the CSS.
         * Default CSS cursor values are provided for 'default' and 'pointer' modes.
         * @member {Object.<string, Object>}
         */r.cursorStyles={default:"inherit",pointer:"pointer"},/**
         * The mode of the cursor that is being used.
         * The value of this is a key from the cursorStyles dictionary.
         *
         * @member {string}
         */r.currentCursorMode=null,/**
         * Internal cached let.
         *
         * @private
         * @member {string}
         */r.cursor=null,/**
         * The current resolution / device pixel ratio.
         *
         * @member {number}
         * @default 1
         */r.resolution=1,/**
         * Delayed pointer events. Used to guarantee correct ordering of over/out events.
         *
         * @private
         * @member {Array}
         */r.delayedEvents=[],/**
         * TreeSearch component that is used to hitTest stage tree
         *
         * @private
         * @member {PIXI.TreeSearch}
         */r.search=new rl,/**
         * Used as a last rendered object in case renderer doesnt have _lastObjectRendered
         * @member {DisplayObject}
         * @private
         */r._tempDisplayObject=new i4,/**
         * An options object specifies characteristics about the event listener.
         * @private
         * @readonly
         * @member {Object.<string, boolean>}
         */r._eventListenerOptions={capture:!0,passive:!1},/**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
         * object.
         *
         * @event PIXI.InteractionManager#mousedown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object.
         *
         * @event PIXI.InteractionManager#rightdown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object.
         *
         * @event PIXI.InteractionManager#mouseup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object.
         *
         * @event PIXI.InteractionManager#rightup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object.
         *
         * @event PIXI.InteractionManager#click
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object.
         *
         * @event PIXI.InteractionManager#rightclick
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.InteractionManager#event:mousedown}.
         *
         * @event PIXI.InteractionManager#mouseupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.InteractionManager#event:rightdown}.
         *
         * @event PIXI.InteractionManager#rightupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved while over the display object
         *
         * @event PIXI.InteractionManager#mousemove
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved onto the display object
         *
         * @event PIXI.InteractionManager#mouseover
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved off the display object
         *
         * @event PIXI.InteractionManager#mouseout
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is pressed on the display object.
         *
         * @event PIXI.InteractionManager#pointerdown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is released over the display object.
         * Not always fired when some buttons are held down while others are released. In those cases,
         * use [mousedown]{@link PIXI.InteractionManager#event:mousedown} and
         * [mouseup]{@link PIXI.InteractionManager#event:mouseup} instead.
         *
         * @event PIXI.InteractionManager#pointerup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when the operating system cancels a pointer event
         *
         * @event PIXI.InteractionManager#pointercancel
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is pressed and released on the display object.
         *
         * @event PIXI.InteractionManager#pointertap
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.InteractionManager#event:pointerdown}.
         *
         * @event PIXI.InteractionManager#pointerupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved while over the display object
         *
         * @event PIXI.InteractionManager#pointermove
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved onto the display object
         *
         * @event PIXI.InteractionManager#pointerover
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved off the display object
         *
         * @event PIXI.InteractionManager#pointerout
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is placed on the display object.
         *
         * @event PIXI.InteractionManager#touchstart
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is removed from the display object.
         *
         * @event PIXI.InteractionManager#touchend
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when the operating system cancels a touch
         *
         * @event PIXI.InteractionManager#touchcancel
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is placed and removed from the display object.
         *
         * @event PIXI.InteractionManager#tap
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.InteractionManager#event:touchstart}.
         *
         * @event PIXI.InteractionManager#touchendoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is moved along the display object.
         *
         * @event PIXI.InteractionManager#touchmove
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mousedown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#rightdown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is released over the display
         * object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mouseup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#rightup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#click
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#rightclick
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button (usually a mouse left-button) is released outside the
         * display object that initially registered a
         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mouseupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device secondary button (usually a mouse right-button) is released
         * outside the display object that initially registered a
         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#rightupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mousemove
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mouseover
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device (usually a mouse) is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#mouseout
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is pressed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointerdown
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is released over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointerup
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when the operating system cancels a pointer event.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointercancel
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is pressed and released on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointertap
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device button is released outside the display object that initially
         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointerupoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved while over the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointermove
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved onto the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointerover
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a pointer device is moved off the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#pointerout
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is placed on the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#touchstart
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#touchend
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when the operating system cancels a touch.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#touchcancel
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is placed and removed from the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#tap
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is removed outside of the display object that initially
         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#touchendoutside
         * @param {PIXI.InteractionEvent} event - Interaction event
         *//**
         * Fired when a touch point is moved along the display object.
         * DisplayObject's `interactive` property must be set to `true` to fire event.
         *
         * This comes from the @pixi/interaction package.
         *
         * @event PIXI.DisplayObject#touchmove
         * @param {PIXI.InteractionEvent} event - Interaction event
         */r._useSystemTicker=void 0===i.useSystemTicker||i.useSystemTicker,r.setTargetElement(r.renderer.view,r.renderer.resolution),r}return!function(t,e){function i(){this.constructor=t}ro(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),Object.defineProperty(e.prototype,"useSystemTicker",{/**
         * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
         *
         * @member {boolean}
         * @default true
         */get:function(){return this._useSystemTicker},set:function(t){this._useSystemTicker=t,t?this.addTickerListener():this.removeTickerListener()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"lastObjectRendered",{/**
         * Last rendered object or temp object
         * @readonly
         * @protected
         * @member {PIXI.DisplayObject}
         */get:function(){return this.renderer._lastObjectRendered||this._tempDisplayObject},enumerable:!1,configurable:!0}),/**
     * Hit tests a point against the display tree, returning the first interactive object that is hit.
     *
     * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.
     * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults
     * to the last rendered root of the associated renderer.
     * @return {PIXI.DisplayObject} The hit display object, if any.
     */e.prototype.hitTest=function(t,e){// return our found object - it'll be null if we didn't hit anything
return(// clear the target for our hit test
rc.target=null,// assign the global point
rc.data.global=t,e||(e=this.lastObjectRendered),// run the hit test
this.processInteractive(rc,e,null,!0),rc.target)},/**
     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate
     * another DOM element to receive those events.
     *
     * @param {HTMLElement} element - the DOM element which will receive mouse and touch events.
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).
     */e.prototype.setTargetElement=function(t,e){void 0===e&&(e=1),this.removeTickerListener(),this.removeEvents(),this.interactionDOMElement=t,this.resolution=e,this.addEvents(),this.addTickerListener()},/**
     * Add the ticker listener
     *
     * @private
     */e.prototype.addTickerListener=function(){!this.tickerAdded&&this.interactionDOMElement&&this._useSystemTicker&&(rr.system.add(this.tickerUpdate,this,bs.INTERACTION),this.tickerAdded=!0)},/**
     * Remove the ticker listener
     *
     * @private
     */e.prototype.removeTickerListener=function(){this.tickerAdded&&(rr.system.remove(this.tickerUpdate,this),this.tickerAdded=!1)},/**
     * Registers all the DOM events
     *
     * @private
     */e.prototype.addEvents=function(){if(!this.eventsAdded&&this.interactionDOMElement){var t=this.interactionDOMElement.style;self.navigator.msPointerEnabled?(t.msContentZooming="none",t.msTouchAction="none"):this.supportsPointerEvents&&(t.touchAction="none"),this.supportsPointerEvents?(self.document.addEventListener("pointermove",this.onPointerMove,this._eventListenerOptions),this.interactionDOMElement.addEventListener("pointerdown",this.onPointerDown,this._eventListenerOptions),// pointerout is fired in addition to pointerup (for touch events) and pointercancel
// we already handle those, so for the purposes of what we do in onPointerOut, we only
// care about the pointerleave event
this.interactionDOMElement.addEventListener("pointerleave",this.onPointerOut,this._eventListenerOptions),this.interactionDOMElement.addEventListener("pointerover",this.onPointerOver,this._eventListenerOptions),self.addEventListener("pointercancel",this.onPointerCancel,this._eventListenerOptions),self.addEventListener("pointerup",this.onPointerUp,this._eventListenerOptions)):(self.document.addEventListener("mousemove",this.onPointerMove,this._eventListenerOptions),this.interactionDOMElement.addEventListener("mousedown",this.onPointerDown,this._eventListenerOptions),this.interactionDOMElement.addEventListener("mouseout",this.onPointerOut,this._eventListenerOptions),this.interactionDOMElement.addEventListener("mouseover",this.onPointerOver,this._eventListenerOptions),self.addEventListener("mouseup",this.onPointerUp,this._eventListenerOptions)),this.supportsTouchEvents&&(this.interactionDOMElement.addEventListener("touchstart",this.onPointerDown,this._eventListenerOptions),this.interactionDOMElement.addEventListener("touchcancel",this.onPointerCancel,this._eventListenerOptions),this.interactionDOMElement.addEventListener("touchend",this.onPointerUp,this._eventListenerOptions),this.interactionDOMElement.addEventListener("touchmove",this.onPointerMove,this._eventListenerOptions)),this.eventsAdded=!0}},/**
     * Removes all the DOM events that were previously registered
     *
     * @private
     */e.prototype.removeEvents=function(){if(this.eventsAdded&&this.interactionDOMElement){var t=this.interactionDOMElement.style;self.navigator.msPointerEnabled?(t.msContentZooming="",t.msTouchAction=""):this.supportsPointerEvents&&(t.touchAction=""),this.supportsPointerEvents?(self.document.removeEventListener("pointermove",this.onPointerMove,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("pointerdown",this.onPointerDown,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("pointerleave",this.onPointerOut,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("pointerover",this.onPointerOver,this._eventListenerOptions),self.removeEventListener("pointercancel",this.onPointerCancel,this._eventListenerOptions),self.removeEventListener("pointerup",this.onPointerUp,this._eventListenerOptions)):(self.document.removeEventListener("mousemove",this.onPointerMove,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("mousedown",this.onPointerDown,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("mouseout",this.onPointerOut,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("mouseover",this.onPointerOver,this._eventListenerOptions),self.removeEventListener("mouseup",this.onPointerUp,this._eventListenerOptions)),this.supportsTouchEvents&&(this.interactionDOMElement.removeEventListener("touchstart",this.onPointerDown,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("touchcancel",this.onPointerCancel,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("touchend",this.onPointerUp,this._eventListenerOptions),this.interactionDOMElement.removeEventListener("touchmove",this.onPointerMove,this._eventListenerOptions)),this.interactionDOMElement=null,this.eventsAdded=!1}},/**
     * Updates the state of interactive objects if at least {@link interactionFrequency}
     * milliseconds have passed since the last invocation.
     *
     * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.
     *
     * @param {number} deltaTime - time delta since the last call
     */e.prototype.tickerUpdate=function(t){this._deltaTime+=t,this._deltaTime<this.interactionFrequency||(this._deltaTime=0,this.update())},/**
     * Updates the state of interactive objects.
     */e.prototype.update=function(){if(this.interactionDOMElement){// if the user move the mouse this check has already been done using the mouse move!
if(this._didMove){this._didMove=!1;return}// Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
// but there was a scenario of a display object moving under a static mouse cursor.
// In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function
for(var t in this.cursor=null,this.activeInteractionData)if(this.activeInteractionData.hasOwnProperty(t)){var e=this.activeInteractionData[t];if(e.originalEvent&&"touch"!==e.pointerType){var i=this.configureInteractionEventForDOMEvent(this.eventData,e.originalEvent,e);this.processInteractive(i,this.lastObjectRendered,this.processPointerOverOut,!0)}}this.setCursorMode(this.cursor)}},/**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
     */e.prototype.setCursorMode=function(t){t=t||"default";var e=!0;// if the mode didn't actually change, bail early
if(self.OffscreenCanvas&&this.interactionDOMElement instanceof OffscreenCanvas&&(e=!1),this.currentCursorMode!==t){this.currentCursorMode=t;var i=this.cursorStyles[t];// only do things if there is a cursor style for it
if(i)switch(typeof i){case"string":// string styles are handled as cursor CSS
e&&(this.interactionDOMElement.style.cursor=i);break;case"function":// functions are just called, and passed the cursor mode
i(t);break;case"object":// if it is an object, assume that it is a dictionary of CSS styles,
// apply it to the interactionDOMElement
e&&Object.assign(this.interactionDOMElement.style,i)}else e&&"string"==typeof t&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,t)&&// for the mode, then assume that the dev wants it to be CSS for the cursor.
(this.interactionDOMElement.style.cursor=t)}},/**
     * Dispatches an event on the display object that was interacted with
     *
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {PIXI.InteractionEvent} eventData - the event data object
     * @private
     */e.prototype.dispatchEvent=function(t,e,i){// Even if the event was stopped, at least dispatch any remaining events
// for the same display object.
(!i.stopPropagationHint||t===i.stopsPropagatingAt)&&(i.currentTarget=t,i.type=e,t.emit(e,i),t[e]&&t[e](i))},/**
     * Puts a event on a queue to be dispatched later. This is used to guarantee correct
     * ordering of over/out events.
     *
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the display object in question
     * @param {string} eventString - the name of the event (e.g, mousedown)
     * @param {object} eventData - the event data object
     * @private
     */e.prototype.delayDispatchEvent=function(t,e,i){this.delayedEvents.push({displayObject:t,eventString:e,eventData:i})},/**
     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {PIXI.IPointData} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */e.prototype.mapPositionToPoint=function(t,e,i){r=this.interactionDOMElement.parentElement?this.interactionDOMElement.getBoundingClientRect():{x:0,y:0,width:this.interactionDOMElement.width,height:this.interactionDOMElement.height,left:0,top:0};var r,n=1/this.resolution;t.x=(e-r.left)*(this.interactionDOMElement.width/r.width)*n,t.y=(i-r.top)*(this.interactionDOMElement.height/r.height)*n},/**
     * This function is provides a neat way of crawling through the scene graph and running a
     * specified function on all interactive objects it finds. It will also take care of hit
     * testing the interactive objects and passes the hit across in the function.
     *
     * @protected
     * @param {PIXI.InteractionEvent} interactionEvent - event containing the point that
     *  is tested for collision
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - the displayObject
     *  that will be hit test (recursively crawls its children)
     * @param {Function} [func] - the function that will be called on each interactive object. The
     *  interactionEvent, displayObject and hit will be passed to the function
     * @param {boolean} [hitTest] - indicates whether we want to calculate hits
     *  or just iterate through all interactive objects
     */e.prototype.processInteractive=function(t,e,i,r){var n=this.search.findHit(t,e,i,r),s=this.delayedEvents;if(!s.length)return n;// Reset the propagation hint, because we start deeper in the tree again.
t.stopPropagationHint=!1;var o=s.length;this.delayedEvents=[];for(var a=0;a<o;a++){var h=s[a],l=h.displayObject,u=h.eventString,c=h.eventData;c.stopsPropagatingAt===l&&(c.stopPropagationHint=!0),this.dispatchEvent(l,u,c)}return n},/**
     * Is called when the pointer button is pressed down on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
     */e.prototype.onPointerDown=function(t){// if we support touch events, then only use those for touch events, not pointer events
if(!this.supportsTouchEvents||"touch"!==t.pointerType){var e=this.normalizeToPointerData(t);/*
         * No need to prevent default on natural pointer events, as there are no side effects
         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
         * so still need to be prevented.
         */// Guaranteed that there will be at least one event in events, and all events must have the same pointer type
this.autoPreventDefault&&e[0].isNormalized&&(t.cancelable||!("cancelable"in t))&&t.preventDefault();for(var i=e.length,r=0;r<i;r++){var n=e[r],s=this.getInteractionDataForPointerId(n),o=this.configureInteractionEventForDOMEvent(this.eventData,n,s);if(o.data.originalEvent=t,this.processInteractive(o,this.lastObjectRendered,this.processPointerDown,!0),this.emit("pointerdown",o),"touch"===n.pointerType)this.emit("touchstart",o);else if("mouse"===n.pointerType||"pen"===n.pointerType){var a=2===n.button;this.emit(a?"rightdown":"mousedown",this.eventData)}}}},/**
     * Processes the result of the pointer down check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */e.prototype.processPointerDown=function(t,e,i){var r=t.data,n=t.data.identifier;if(i){if(e.trackedPointers[n]||(e.trackedPointers[n]=new rh(n)),this.dispatchEvent(e,"pointerdown",t),"touch"===r.pointerType)this.dispatchEvent(e,"touchstart",t);else if("mouse"===r.pointerType||"pen"===r.pointerType){var s=2===r.button;s?e.trackedPointers[n].rightDown=!0:e.trackedPointers[n].leftDown=!0,this.dispatchEvent(e,s?"rightdown":"mousedown",t)}}},/**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
     * @param {boolean} cancelled - true if the pointer is cancelled
     * @param {Function} func - Function passed to {@link processInteractive}
     */e.prototype.onPointerComplete=function(t,e,i){for(var r=this.normalizeToPointerData(t),n=r.length,s=t.target!==this.interactionDOMElement?"outside":"",o=0;o<n;o++){var a=r[o],h=this.getInteractionDataForPointerId(a),l=this.configureInteractionEventForDOMEvent(this.eventData,a,h);if(l.data.originalEvent=t,// perform hit testing for events targeting our canvas or cancel events
this.processInteractive(l,this.lastObjectRendered,i,e||!s),this.emit(e?"pointercancel":"pointerup"+s,l),"mouse"===a.pointerType||"pen"===a.pointerType){var u=2===a.button;this.emit(u?"rightup"+s:"mouseup"+s,l)}else"touch"===a.pointerType&&(this.emit(e?"touchcancel":"touchend"+s,l),this.releaseInteractionDataForPointerId(a.pointerId))}},/**
     * Is called when the pointer button is cancelled
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */e.prototype.onPointerCancel=function(t){// if we support touch events, then only use those for touch events, not pointer events
this.supportsTouchEvents&&"touch"===t.pointerType||this.onPointerComplete(t,!0,this.processPointerCancel)},/**
     * Processes the result of the pointer cancel check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     */e.prototype.processPointerCancel=function(t,e){var i=t.data,r=t.data.identifier;void 0!==e.trackedPointers[r]&&(delete e.trackedPointers[r],this.dispatchEvent(e,"pointercancel",t),"touch"===i.pointerType&&this.dispatchEvent(e,"touchcancel",t))},/**
     * Is called when the pointer button is released on the renderer element
     *
     * @private
     * @param {PointerEvent} event - The DOM event of a pointer button being released
     */e.prototype.onPointerUp=function(t){// if we support touch events, then only use those for touch events, not pointer events
this.supportsTouchEvents&&"touch"===t.pointerType||this.onPointerComplete(t,!1,this.processPointerUp)},/**
     * Processes the result of the pointer up check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */e.prototype.processPointerUp=function(t,e,i){var r=t.data,n=t.data.identifier,s=e.trackedPointers[n],o="touch"===r.pointerType,a="mouse"===r.pointerType||"pen"===r.pointerType,h=!1;// Mouse only
if(a){var l=2===r.button,u=rh.FLAGS,c=l?u.RIGHT_DOWN:u.LEFT_DOWN,d=void 0!==s&&s.flags&c;i?(this.dispatchEvent(e,l?"rightup":"mouseup",t),d&&(this.dispatchEvent(e,l?"rightclick":"click",t),// because we can confirm that the mousedown happened on this object, flag for later emit of pointertap
h=!0)):d&&this.dispatchEvent(e,l?"rightupoutside":"mouseupoutside",t),s&&(l?s.rightDown=!1:s.leftDown=!1)}i?(this.dispatchEvent(e,"pointerup",t),o&&this.dispatchEvent(e,"touchend",t),s&&((!a||h)&&this.dispatchEvent(e,"pointertap",t),o&&(this.dispatchEvent(e,"tap",t),// touches are no longer over (if they ever were) when we get the touchend
// so we should ensure that we don't keep pretending that they are
s.over=!1))):s&&(this.dispatchEvent(e,"pointerupoutside",t),o&&this.dispatchEvent(e,"touchendoutside",t)),s&&s.none&&delete e.trackedPointers[n]},/**
     * Is called when the pointer moves across the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
     */e.prototype.onPointerMove=function(t){// if we support touch events, then only use those for touch events, not pointer events
if(!this.supportsTouchEvents||"touch"!==t.pointerType){var e=this.normalizeToPointerData(t);("mouse"===e[0].pointerType||"pen"===e[0].pointerType)&&(this._didMove=!0,this.cursor=null);for(var i=e.length,r=0;r<i;r++){var n=e[r],s=this.getInteractionDataForPointerId(n),o=this.configureInteractionEventForDOMEvent(this.eventData,n,s);o.data.originalEvent=t,this.processInteractive(o,this.lastObjectRendered,this.processPointerMove,!0),this.emit("pointermove",o),"touch"===n.pointerType&&this.emit("touchmove",o),("mouse"===n.pointerType||"pen"===n.pointerType)&&this.emit("mousemove",o)}"mouse"===e[0].pointerType&&this.setCursorMode(this.cursor)}},/**
     * Processes the result of the pointer move check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */e.prototype.processPointerMove=function(t,e,i){var r=t.data,n="touch"===r.pointerType,s="mouse"===r.pointerType||"pen"===r.pointerType;s&&this.processPointerOverOut(t,e,i),(!this.moveWhenInside||i)&&(this.dispatchEvent(e,"pointermove",t),n&&this.dispatchEvent(e,"touchmove",t),s&&this.dispatchEvent(e,"mousemove",t))},/**
     * Is called when the pointer is moved out of the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
     */e.prototype.onPointerOut=function(t){// if we support touch events, then only use those for touch events, not pointer events
if(!this.supportsTouchEvents||"touch"!==t.pointerType){// Only mouse and pointer can call onPointerOut, so events will always be length 1
var e=this.normalizeToPointerData(t)[0];"mouse"===e.pointerType&&(this.mouseOverRenderer=!1,this.setCursorMode(null));var i=this.getInteractionDataForPointerId(e),r=this.configureInteractionEventForDOMEvent(this.eventData,e,i);r.data.originalEvent=e,this.processInteractive(r,this.lastObjectRendered,this.processPointerOverOut,!1),this.emit("pointerout",r),"mouse"===e.pointerType||"pen"===e.pointerType?this.emit("mouseout",r):// introduce memory leaks
this.releaseInteractionDataForPointerId(i.identifier)}},/**
     * Processes the result of the pointer over/out check and dispatches the event if need be
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
     * @param {PIXI.Container|PIXI.Sprite|PIXI.TilingSprite} displayObject - The display object that was tested
     * @param {boolean} hit - the result of the hit test on the display object
     */e.prototype.processPointerOverOut=function(t,e,i){var r=t.data,n=t.data.identifier,s="mouse"===r.pointerType||"pen"===r.pointerType,o=e.trackedPointers[n];i&&!o&&(o=e.trackedPointers[n]=new rh(n)),void 0!==o&&(i&&this.mouseOverRenderer?(!o.over&&(o.over=!0,this.delayDispatchEvent(e,"pointerover",t),s&&this.delayDispatchEvent(e,"mouseover",t)),s&&null===this.cursor&&(this.cursor=e.cursor)):o.over&&(o.over=!1,this.dispatchEvent(e,"pointerout",this.eventData),s&&this.dispatchEvent(e,"mouseout",t),o.none&&delete e.trackedPointers[n]))},/**
     * Is called when the pointer is moved into the renderer element
     *
     * @private
     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
     */e.prototype.onPointerOver=function(t){// Only mouse and pointer can call onPointerOver, so events will always be length 1
var e=this.normalizeToPointerData(t)[0],i=this.getInteractionDataForPointerId(e),r=this.configureInteractionEventForDOMEvent(this.eventData,e,i);r.data.originalEvent=e,"mouse"===e.pointerType&&(this.mouseOverRenderer=!0),this.emit("pointerover",r),("mouse"===e.pointerType||"pen"===e.pointerType)&&this.emit("mouseover",r)},/**
     * Get InteractionData for a given pointerId. Store that data as well
     *
     * @private
     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
     * @return {PIXI.InteractionData} - Interaction data for the given pointer identifier
     */e.prototype.getInteractionDataForPointerId=function(t){var e,i=t.pointerId;return 1===i||"mouse"===t.pointerType?e=this.mouse:this.activeInteractionData[i]?e=this.activeInteractionData[i]:((e=this.interactionDataPool.pop()||new rs).identifier=i,this.activeInteractionData[i]=e),// copy properties from the event, so that we can make sure that touch/pointer specific
// data is available
e.copyEvent(t),e},/**
     * Return unused InteractionData to the pool, for a given pointerId
     *
     * @private
     * @param {number} pointerId - Identifier from a pointer event
     */e.prototype.releaseInteractionDataForPointerId=function(t){var e=this.activeInteractionData[t];e&&(delete this.activeInteractionData[t],e.reset(),this.interactionDataPool.push(e))},/**
     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
     *
     * @private
     * @param {PIXI.InteractionEvent} interactionEvent - The event to be configured
     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
     * @param {PIXI.InteractionData} interactionData - The InteractionData that will be paired
     *        with the InteractionEvent
     * @return {PIXI.InteractionEvent} the interaction event that was passed in
     */e.prototype.configureInteractionEventForDOMEvent=function(t,e,i){return t.data=i,this.mapPositionToPoint(i.global,e.clientX,e.clientY),"touch"===e.pointerType&&(e.globalX=i.global.x,e.globalY=i.global.y),i.originalEvent=e,t.reset(),t},/**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @private
     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */e.prototype.normalizeToPointerData=function(t){var e=[];if(this.supportsTouchEvents&&t instanceof TouchEvent)for(var i=0,r=t.changedTouches.length;i<r;i++){var n=t.changedTouches[i];void 0===n.button&&(n.button=t.touches.length?1:0),void 0===n.buttons&&(n.buttons=t.touches.length?1:0),void 0===n.isPrimary&&(n.isPrimary=1===t.touches.length&&"touchstart"===t.type),void 0===n.width&&(n.width=n.radiusX||1),void 0===n.height&&(n.height=n.radiusY||1),void 0===n.tiltX&&(n.tiltX=0),void 0===n.tiltY&&(n.tiltY=0),void 0===n.pointerType&&(n.pointerType="touch"),void 0===n.pointerId&&(n.pointerId=n.identifier||0),void 0===n.pressure&&(n.pressure=n.force||.5),void 0===n.twist&&(n.twist=0),void 0===n.tangentialPressure&&(n.tangentialPressure=0),void 0===n.layerX&&(n.layerX=n.offsetX=n.clientX),void 0===n.layerY&&(n.layerY=n.offsetY=n.clientY),// mark the touch as normalized, just so that we know we did it
n.isNormalized=!0,e.push(n)}else(!self.MouseEvent||t instanceof MouseEvent&&(!this.supportsPointerEvents||!(t instanceof self.PointerEvent)))&&(void 0===t.isPrimary&&(t.isPrimary=!0),void 0===t.width&&(t.width=1),void 0===t.height&&(t.height=1),void 0===t.tiltX&&(t.tiltX=0),void 0===t.tiltY&&(t.tiltY=0),void 0===t.pointerType&&(t.pointerType="mouse"),void 0===t.pointerId&&(t.pointerId=1),void 0===t.pressure&&(t.pressure=.5),void 0===t.twist&&(t.twist=0),void 0===t.tangentialPressure&&(t.tangentialPressure=0),// mark the mouse event as normalized, just so that we know we did it
t.isNormalized=!0),e.push(t);return e},/**
     * Destroys the interaction manager
     *
     */e.prototype.destroy=function(){this.removeEvents(),this.removeTickerListener(),this.removeAllListeners(),this.renderer=null,this.mouse=null,this.eventData=null,this.interactionDOMElement=null,this.onPointerDown=null,this.processPointerDown=null,this.onPointerUp=null,this.processPointerUp=null,this.onPointerCancel=null,this.processPointerCancel=null,this.onPointerMove=null,this.processPointerMove=null,this.onPointerOut=null,this.processPointerOverOut=null,this.onPointerOver=null,this.search=null},e}(/*@__PURE__*/tP(ed)),rp={};tC(rp,"Application",()=>sy);/*!
 * @pixi/app - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var rf={};tC(rf,"INSTALLED",()=>ry),tC(rf,"autoDetectResource",()=>r_),tC(rf,"Resource",()=>rE),tC(rf,"BufferResource",()=>rT),tC(rf,"BaseTexture",()=>rS),tC(rf,"AbstractMultiResource",()=>rM),tC(rf,"ArrayResource",()=>rA),tC(rf,"BaseImageResource",()=>rR),tC(rf,"CanvasResource",()=>rC),tC(rf,"CubeResource",()=>rP),tC(rf,"ImageResource",()=>rI),tC(rf,"SVGResource",()=>rO),tC(rf,"VideoResource",()=>rL),tC(rf,"ImageBitmapResource",()=>rN),tC(rf,"Framebuffer",()=>rB),tC(rf,"BaseRenderTexture",()=>rU),tC(rf,"TextureUvs",()=>rG),tC(rf,"Texture",()=>rH),tC(rf,"RenderTexture",()=>rj),tC(rf,"RenderTexturePool",()=>rV),tC(rf,"Attribute",()=>rX),tC(rf,"Buffer",()=>rY),tC(rf,"Geometry",()=>r$),tC(rf,"Quad",()=>rQ),tC(rf,"QuadUv",()=>r0),tC(rf,"UniformGroup",()=>r2),tC(rf,"FilterState",()=>r3),tC(rf,"FilterSystem",()=>r6),tC(rf,"ObjectRenderer",()=>r8),tC(rf,"BatchSystem",()=>r7),tC(rf,"ContextSystem",()=>nt),tC(rf,"GLFramebuffer",()=>ne),tC(rf,"FramebufferSystem",()=>nr),tC(rf,"GeometrySystem",()=>ns),tC(rf,"MaskData",()=>no),tC(rf,"getTestContext",()=>np),tC(rf,"uniformParsers",()=>nv),tC(rf,"checkMaxIfStatementsInShader",()=>nE),tC(rf,"Program",()=>nS),tC(rf,"Shader",()=>nM),tC(rf,"State",()=>nA),tC(rf,"Filter",()=>nR),tC(rf,"TextureMatrix",()=>nP),tC(rf,"SpriteMaskFilter",()=>nI),tC(rf,"MaskSystem",()=>nO),tC(rf,"ScissorSystem",()=>nN),tC(rf,"StencilSystem",()=>nD),tC(rf,"ProjectionSystem",()=>nF),tC(rf,"RenderTextureSystem",()=>nG),tC(rf,"createUBOElements",()=>nj),tC(rf,"getUBOData",()=>nV),tC(rf,"generateUniformBufferSync",()=>nX),tC(rf,"IGLUniformData",()=>nW),tC(rf,"GLProgram",()=>nY),tC(rf,"generateProgram",()=>nq),tC(rf,"ShaderSystem",()=>nZ),tC(rf,"StateSystem",()=>n$),tC(rf,"TextureGCSystem",()=>nQ),tC(rf,"GLTexture",()=>n0),tC(rf,"TextureSystem",()=>n1),tC(rf,"AbstractRenderer",()=>n5),tC(rf,"Renderer",()=>n8),tC(rf,"autoDetectRenderer",()=>n7),tC(rf,"defaultVertex",()=>n9),tC(rf,"defaultFilterVertex",()=>st),tC(rf,"System",()=>se),tC(rf,"BatchDrawCall",()=>si),tC(rf,"BatchTextureArray",()=>sr),tC(rf,"ViewableBuffer",()=>sn),tC(rf,"AbstractBatchRenderer",()=>ss),tC(rf,"BatchShaderGenerator",()=>so),tC(rf,"BatchGeometry",()=>sa),tC(rf,"BatchPluginFactory",()=>su),tC(rf,"BatchRenderer",()=>sc),tC(rf,"resources",()=>sd),tC(rf,"systems",()=>sm);/*!
 * @pixi/core - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var rm={};tC(rm,"Runner",()=>rg);/*!
 * @pixi/runner - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * A Runner is a highly performant and simple alternative to signals. Best used in situations
 * where events are dispatched to many objects at high frequency (say every frame!)
 *
 *
 * like a signal..
 * ```
 * import { Runner } from '@pixi/runner';
 *
 * const myObject = {
 *     loaded: new Runner('loaded')
 * }
 *
 * const listener = {
 *     loaded: function(){
 *         // thin
 *     }
 * }
 *
 * myObject.loaded.add(listener);
 *
 * myObject.loaded.emit();
 * ```
 *
 * Or for handling calling the same function on many items
 * ```
 * import { Runner } from '@pixi/runner';
 *
 * const myGame = {
 *     update: new Runner('update')
 * }
 *
 * const gameObject = {
 *     update: function(time){
 *         // update my gamey state
 *     }
 * }
 *
 * myGame.update.add(gameObject);
 *
 * myGame.update.emit(time);
 * ```
 * @class
 * @memberof PIXI
 */var rg=/** @class */function(){/**
     *  @param {string} name - the function name that will be executed on the listeners added to this Runner.
     */function t(t){this.items=[],this._name=t,this._aliasCount=0}return(/**
     * Dispatch/Broadcast Runner to all listeners added to the queue.
     * @param {...any} params - optional parameters to pass to each listener
     * @return {PIXI.Runner}
     */t.prototype.emit=function(t,e,i,r,n,s,o,a){if(arguments.length>8)throw Error("max arguments reached");var h=this.name,l=this.items;this._aliasCount++;for(var u=0,c=l.length;u<c;u++)l[u][h](t,e,i,r,n,s,o,a);return l===this.items&&this._aliasCount--,this},t.prototype.ensureNonAliasedItems=function(){this._aliasCount>0&&this.items.length>1&&(this._aliasCount=0,this.items=this.items.slice(0))},/**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * import { Runner } from '@pixi/runner';
     *
     * const complete = new Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     * @return {PIXI.Runner}
     */t.prototype.add=function(t){return t[this._name]&&(this.ensureNonAliasedItems(),this.remove(t),this.items.push(t)),this},/**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listener that you would like to remove.
     * @return {PIXI.Runner}
     */t.prototype.remove=function(t){var e=this.items.indexOf(t);return -1!==e&&(this.ensureNonAliasedItems(),this.items.splice(e,1)),this},/**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */t.prototype.contains=function(t){return -1!==this.items.indexOf(t)},/**
     * Remove all listeners from the Runner
     * @return {PIXI.Runner}
     */t.prototype.removeAll=function(){return this.ensureNonAliasedItems(),this.items.length=0,this},/**
     * Remove all references, don't use after this.
     */t.prototype.destroy=function(){this.removeAll(),this.items=null,this._name=null},Object.defineProperty(t.prototype,"empty",{/**
         * `true` if there are no this Runner contains no listeners
         *
         * @member {boolean}
         * @readonly
         */get:function(){return 0===this.items.length},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"name",{/**
         * The name of the runner.
         *
         * @member {string}
         * @readonly
         */get:function(){return this._name},enumerable:!1,configurable:!0}),t)}();Object.defineProperties(rg.prototype,{/**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method dispatch
     * @see PIXI.Runner#emit
     */dispatch:{value:rg.prototype.emit},/**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method run
     * @see PIXI.Runner#emit
     */run:{value:rg.prototype.emit}}),ec.PREFER_ENV=eu.any?xY.WEBGL:xY.WEBGL2,ec.STRICT_TEXTURE_CACHE=!1;/**
 * Collection of installed resource types, class must extend {@link PIXI.Resource}.
 * @example
 * class CustomResource extends PIXI.Resource {
 *   // MUST have source, options constructor signature
 *   // for auto-detected resources to be created.
 *   constructor(source, options) {
 *     super();
 *   }
 *   upload(renderer, baseTexture, glTexture) {
 *     // upload with GL
 *     return true;
 *   }
 *   // used to auto-detect resource
 *   static test(source, extension) {
 *     return extension === 'xyz'|| source instanceof SomeClass;
 *   }
 * }
 * // Install the new resource type
 * PIXI.INSTALLED.push(CustomResource);
 *
 * @memberof PIXI
 * @type {Array<PIXI.IResourcePlugin>}
 * @static
 * @readonly
 */var ry=[];/**
 * Create a resource element from a single source element. This
 * auto-detects which type of resource to create. All resources that
 * are auto-detectable must have a static `test` method and a constructor
 * with the arguments `(source, options?)`. Currently, the supported
 * resources for auto-detection include:
 *  - {@link PIXI.ImageResource}
 *  - {@link PIXI.CanvasResource}
 *  - {@link PIXI.VideoResource}
 *  - {@link PIXI.SVGResource}
 *  - {@link PIXI.BufferResource}
 * @static
 * @memberof PIXI
 * @function autoDetectResource
 * @param {string|*} source - Resource source, this can be the URL to the resource,
 *        a typed-array (for BufferResource), HTMLVideoElement, SVG data-uri
 *        or any other resource that can be auto-detected. If not resource is
 *        detected, it's assumed to be an ImageResource.
 * @param {object} [options] - Pass-through options to use for Resource
 * @param {number} [options.width] - Width of BufferResource or SVG rasterization
 * @param {number} [options.height] - Height of BufferResource or SVG rasterization
 * @param {boolean} [options.autoLoad=true] - Image, SVG and Video flag to start loading
 * @param {number} [options.scale=1] - SVG source scale. Overridden by width, height
 * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - Image option to create Bitmap object
 * @param {boolean} [options.crossorigin=true] - Image and Video option to set crossOrigin
 * @param {boolean} [options.autoPlay=true] - Video option to start playing video immediately
 * @param {number} [options.updateFPS=0] - Video option to update how many times a second the
 *        texture should be updated from the video. Leave at 0 to update at every render
 * @return {PIXI.Resource} The created resource.
 */function r_(t,e){if(!t)return null;var i="";if("string"==typeof t){// search for file extension: period, 3-4 chars, then ?, # or EOL
var r=/\.(\w{3,4})(?:$|\?|#)/i.exec(t);r&&(i=r[1].toLowerCase())}for(var n=ry.length-1;n>=0;--n){var s=ry[n];if(s.test&&s.test(t,i))return new s(t,e)}throw Error("Unrecognized source type to auto-detect Resource")}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var rv=function(t,e){return(rv=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function rx(t,e){function i(){this.constructor=t}rv(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var rb=function(){return(rb=Object.assign||function(t){for(var e,i=arguments,r=1,n=arguments.length;r<n;r++)for(var s in e=i[r])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)},rE=/** @class */function(){/**
     * @param {number} [width=0] - Width of the resource
     * @param {number} [height=0] - Height of the resource
     */function t(t,e){void 0===t&&(t=0),void 0===e&&(e=0),/**
         * Internal width of the resource
         * @member {number}
         * @protected
         */this._width=t,/**
         * Internal height of the resource
         * @member {number}
         * @protected
         */this._height=e,/**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */this.destroyed=!1,/**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */this.internal=!1,/**
         * Mini-runner for handling resize events
         * accepts 2 parameters: width, height
         *
         * @member {Runner}
         * @private
         */this.onResize=new rg("setRealSize"),/**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */this.onUpdate=new rg("update"),/**
         * Handle internal errors, such as loading errors
         * accepts 1 param: error
         *
         * @member {Runner}
         * @private
         */this.onError=new rg("onError")}return(/**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */t.prototype.bind=function(t){this.onResize.add(t),this.onUpdate.add(t),this.onError.add(t),(this._width||this._height)&&this.onResize.emit(this._width,this._height)},/**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */t.prototype.unbind=function(t){this.onResize.remove(t),this.onUpdate.remove(t),this.onError.remove(t)},/**
     * Trigger a resize event
     * @param {number} width - X dimension
     * @param {number} height - Y dimension
     */t.prototype.resize=function(t,e){(t!==this._width||e!==this._height)&&(this._width=t,this._height=e,this.onResize.emit(t,e))},Object.defineProperty(t.prototype,"valid",{/**
         * Has been validated
         * @readonly
         * @member {boolean}
         */get:function(){return!!this._width&&!!this._height},enumerable:!1,configurable:!0}),/**
     * Has been updated trigger event
     */t.prototype.update=function(){this.destroyed||this.onUpdate.emit()},/**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */t.prototype.load=function(){return Promise.resolve(this)},Object.defineProperty(t.prototype,"width",{/**
         * The width of the resource.
         *
         * @member {number}
         * @readonly
         */get:function(){return this._width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{/**
         * The height of the resource.
         *
         * @member {number}
         * @readonly
         */get:function(){return this._height},enumerable:!1,configurable:!0}),/**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */t.prototype.style=function(t,e,i){return!1},/**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */t.prototype.dispose=function(){// override
},/**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */t.prototype.destroy=function(){this.destroyed||(this.destroyed=!0,this.dispose(),this.onError.removeAll(),this.onError=null,this.onResize.removeAll(),this.onResize=null,this.onUpdate.removeAll(),this.onUpdate=null)},/**
     * Abstract, used to auto-detect resource type
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */t.test=function(t,e){return!1},t)}(),rT=/** @class */function(t){/**
     * @param {Float32Array|Uint8Array|Uint32Array} source - Source buffer
     * @param {object} options - Options
     * @param {number} options.width - Width of the texture
     * @param {number} options.height - Height of the texture
     */function e(e,i){var r=this,n=i||{},s=n.width,o=n.height;if(!s||!o)throw Error("BufferResource width or height invalid");return(/**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */(r=t.call(this,s,o)||this).data=e,r)}return rx(e,t),/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture - glTexture
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i){var r=t.gl;r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===x4.UNPACK);var n=e.realWidth,s=e.realHeight;return i.width===n&&i.height===s?r.texSubImage2D(e.target,0,0,0,n,s,e.format,i.type,this.data):(i.width=n,i.height=s,r.texImage2D(e.target,0,i.internalFormat,n,s,0,e.format,i.type,this.data)),!0},/**
     * Destroy and don't use after this
     * @override
     */e.prototype.dispose=function(){this.data=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */e.test=function(t){return t instanceof Float32Array||t instanceof Uint8Array||t instanceof Uint32Array},e}(rE),rw={scaleMode:x2.NEAREST,format:x$.RGBA,alphaMode:x4.NPM},rS=/** @class */function(t){/**
     * @param {PIXI.Resource|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} [resource=null] -
     *        The current resource to use, for things that aren't Resource objects, will be converted
     *        into a Resource.
     * @param {Object} [options] - Collection of options
     * @param {PIXI.MIPMAP_MODES} [options.mipmap=PIXI.settings.MIPMAP_TEXTURES] - If mipmapping is enabled for texture
     * @param {number} [options.anisotropicLevel=PIXI.settings.ANISOTROPIC_LEVEL] - Anisotropic filtering level of texture
     * @param {PIXI.WRAP_MODES} [options.wrapMode=PIXI.settings.WRAP_MODE] - Wrap mode for textures
     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - Default scale mode, linear, nearest
     * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type
     * @param {PIXI.TYPES} [options.type=PIXI.TYPES.UNSIGNED_BYTE] - GL data type
     * @param {PIXI.TARGETS} [options.target=PIXI.TARGETS.TEXTURE_2D] - GL texture target
     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Pre multiply the image alpha
     * @param {number} [options.width=0] - Width of the texture
     * @param {number} [options.height=0] - Height of the texture
     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture
     * @param {object} [options.resourceOptions] - Optional resource options,
     *        see {@link PIXI.autoDetectResource autoDetectResource}
     */function e(e,i){void 0===e&&(e=null),void 0===i&&(i=null);var r=t.call(this)||this,n=(i=i||{}).alphaMode,s=i.mipmap,o=i.anisotropicLevel,a=i.scaleMode,h=i.width,l=i.height,u=i.wrapMode,c=i.format,d=i.type,p=i.target,f=i.resolution,m=i.resourceOptions;return!e||e instanceof rE||((e=r_(e,m)).internal=!0),r.resolution=f||ec.RESOLUTION,r.width=Math.round((h||0)*r.resolution)/r.resolution,r.height=Math.round((l||0)*r.resolution)/r.resolution,r._mipmap=void 0!==s?s:ec.MIPMAP_TEXTURES,r.anisotropicLevel=void 0!==o?o:ec.ANISOTROPIC_LEVEL,r._wrapMode=u||ec.WRAP_MODE,r._scaleMode=void 0!==a?a:ec.SCALE_MODE,r.format=c||x$.RGBA,r.type=d||x0.UNSIGNED_BYTE,r.target=p||xQ.TEXTURE_2D,r.alphaMode=void 0!==n?n:x4.UNPACK,r.uid=i_(),r.touched=0,r.isPowerOfTwo=!1,r._refreshPOT(),r._glTextures={},r.dirtyId=0,r.dirtyStyleId=0,r.cacheId=null,r.valid=h>0&&l>0,r.textureCacheIds=[],r.destroyed=!1,r.resource=null,r._batchEnabled=0,r._batchLocation=0,r.parentTextureArray=null,/**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         *//**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         * @param {ErrorEvent} event - Load error event.
         *//**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         *//**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         *//**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */// Set the resource
r.setResource(e),r}return rx(e,t),Object.defineProperty(e.prototype,"realWidth",{/**
         * Pixel width of the source of this texture
         *
         * @readonly
         * @member {number}
         */get:function(){return Math.round(this.width*this.resolution)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"realHeight",{/**
         * Pixel height of the source of this texture
         *
         * @readonly
         * @member {number}
         */get:function(){return Math.round(this.height*this.resolution)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"mipmap",{/**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */get:function(){return this._mipmap},set:function(t){this._mipmap!==t&&(this._mipmap=t,this.dirtyStyleId++)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"scaleMode",{/**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */get:function(){return this._scaleMode},set:function(t){this._scaleMode!==t&&(this._scaleMode=t,this.dirtyStyleId++)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"wrapMode",{/**
         * How the texture wraps
         * @member {PIXI.WRAP_MODES}
         * @default PIXI.settings.WRAP_MODE
         */get:function(){return this._wrapMode},set:function(t){this._wrapMode!==t&&(this._wrapMode=t,this.dirtyStyleId++)},enumerable:!1,configurable:!0}),/**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setStyle=function(t,e){var i;return void 0!==t&&t!==this.scaleMode&&(this.scaleMode=t,i=!0),void 0!==e&&e!==this.mipmap&&(this.mipmap=e,i=!0),i&&this.dirtyStyleId++,this},/**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} desiredWidth - Desired visual width
     * @param {number} desiredHeight - Desired visual height
     * @param {number} [resolution] - Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setSize=function(t,e,i){return i=i||this.resolution,this.setRealSize(t*i,e*i,i)},/**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth - Full rendered width
     * @param {number} realHeight - Full rendered height
     * @param {number} [resolution] - Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setRealSize=function(t,e,i){return this.resolution=i||this.resolution,this.width=Math.round(t)/this.resolution,this.height=Math.round(e)/this.resolution,this._refreshPOT(),this.update(),this},/**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */e.prototype._refreshPOT=function(){this.isPowerOfTwo=id(this.realWidth)&&id(this.realHeight)},/**
     * Changes resolution
     *
     * @param {number} resolution - res
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setResolution=function(t){var e=this.resolution;return e===t||(this.resolution=t,this.valid&&(this.width=Math.round(this.width*e)/t,this.height=Math.round(this.height*e)/t,this.emit("update",this)),this._refreshPOT()),this},/**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.Resource} resource - that is managing this BaseTexture
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setResource=function(t){if(this.resource===t)return this;if(this.resource)throw Error("Resource can be set only once");return t.bind(this),this.resource=t,this},/**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */e.prototype.update=function(){this.valid?(this.dirtyId++,this.dirtyStyleId++,this.emit("update",this)):this.width>0&&this.height>0&&(this.valid=!0,this.emit("loaded",this),this.emit("update",this))},/**
     * Handle errors with resources.
     * @private
     * @param {ErrorEvent} event - Error event emitted.
     */e.prototype.onError=function(t){this.emit("error",this,t)},/**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */e.prototype.destroy=function(){this.resource&&(this.resource.unbind(this),this.resource.internal&&this.resource.destroy(),this.resource=null),this.cacheId&&(delete iT[this.cacheId],delete iE[this.cacheId],this.cacheId=null),// finally let the WebGL renderer know..
this.dispose(),e.removeFromCache(this),this.textureCacheIds=null,this.destroyed=!0},/**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */e.prototype.dispose=function(){this.emit("dispose",this)},/**
     * Utility function for BaseTexture|Texture cast
     */e.prototype.castToBaseTexture=function(){return this},/**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
     * @returns {PIXI.BaseTexture} The new base texture.
     */e.from=function(t,i,r){void 0===r&&(r=ec.STRICT_TEXTURE_CACHE);var n="string"==typeof t,s=null;if(n)s=t;else{if(!t._pixiId){var o=i&&i.pixiIdPrefix||"pixiid";t._pixiId=o+"_"+i_()}s=t._pixiId}var a=iT[s];// Strict-mode rejects invalid cacheIds
if(n&&r&&!a)throw Error('The cacheId "'+s+'" does not exist in BaseTextureCache.');return a||((a=new e(t,i)).cacheId=s,e.addToCache(a,s)),a},/**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */e.fromBuffer=function(t,i,r,n){t=t||new Float32Array(i*r*4);var s=new rT(t,{width:i,height:r}),o=t instanceof Float32Array?x0.FLOAT:x0.UNSIGNED_BYTE;return new e(s,Object.assign(rw,n||{width:i,height:r,type:o}))},/**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */e.addToCache=function(t,e){e&&(-1===t.textureCacheIds.indexOf(e)&&t.textureCacheIds.push(e),iT[e]&&console.warn("BaseTexture added to the cache with an id ["+e+"] that already had an entry"),iT[e]=t)},/**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */e.removeFromCache=function(t){if("string"==typeof t){var e=iT[t];if(e){var i=e.textureCacheIds.indexOf(t);return i>-1&&e.textureCacheIds.splice(i,1),delete iT[t],e}}else if(t&&t.textureCacheIds){for(var r=0;r<t.textureCacheIds.length;++r)delete iT[t.textureCacheIds[r]];return t.textureCacheIds.length=0,t}return null},/**
     * Global number of the texture batch, used by multi-texture renderers
     *
     * @static
     * @member {number}
     */e._globalBatch=0,e}(/*@__PURE__*/tP(ed)),rM=/** @class */function(t){/**
     * @param {number} length
     * @param {object} [options] - Options to for Resource constructor
     * @param {number} [options.width] - Width of the resource
     * @param {number} [options.height] - Height of the resource
     */function e(e,i){var r=this,n=i||{},s=n.width,o=n.height;/**
         * Collection of partial baseTextures that correspond to resources
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */(r=t.call(this,s,o)||this).items=[],/**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */r.itemDirtyIds=[];for(var a=0;a<e;a++){var h=new rS;r.items.push(h),// -2 - first run of texture array upload
// -1 - texture item was allocated
// >=0 - texture item uploaded , in sync with items[i].dirtyId
r.itemDirtyIds.push(-2)}return(/**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */r.length=e,/**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */r._load=null,/**
         * Bound baseTexture, there can only be one
         * @member {PIXI.BaseTexture}
         */r.baseTexture=null,r)}return rx(e,t),/**
     * used from ArrayResource and CubeResource constructors
     * @param {Array<*>} resources - Can be resources, image elements, canvas, etc. ,
     *  length should be same as constructor length
     * @param {object} [options] - detect options for resources
     * @protected
     */e.prototype.initFromArray=function(t,e){for(var i=0;i<this.length;i++)t[i]&&(t[i].castToBaseTexture?this.addBaseTextureAt(t[i].castToBaseTexture(),i):t[i]instanceof rE?this.addResourceAt(t[i],i):this.addResourceAt(r_(t[i],e),i))},/**
     * Destroy this BaseImageResource
     * @override
     */e.prototype.dispose=function(){for(var t=0,e=this.length;t<e;t++)this.items[t].destroy();this.items=null,this.itemDirtyIds=null,this._load=null},/**
     * Set a resource by ID
     *
     * @param {PIXI.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.ArrayResource} Instance for chaining
     */e.prototype.addResourceAt=function(t,e){if(!this.items[e])throw Error("Index "+e+" is out of bounds");return t.valid&&!this.valid&&this.resize(t.width,t.height),this.items[e].setResource(t),this},/**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.bind=function(e){if(null!==this.baseTexture)throw Error("Only one base texture per TextureArray is allowed");t.prototype.bind.call(this,e);for(var i=0;i<this.length;i++)this.items[i].parentTextureArray=e,this.items[i].on("update",e.update,e)},/**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.unbind=function(e){t.prototype.unbind.call(this,e);for(var i=0;i<this.length;i++)this.items[i].parentTextureArray=null,this.items[i].off("update",e.update,e)},/**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */e.prototype.load=function(){var t=this;if(this._load)return this._load;// TODO: also implement load part-by-part strategy
var e=this.items.map(function(t){return t.resource}).filter(function(t){return t}).map(function(t){return t.load()});return this._load=Promise.all(e).then(function(){var e=t.items[0],i=e.realWidth,r=e.realHeight;return t.resize(i,r),Promise.resolve(t)}),this._load},e}(rE),rA=/** @class */function(t){/**
     * @param {number|Array<*>} source - Number of items in array or the collection
     *        of image URLs to use. Can also be resources, image elements, canvas, etc.
     * @param {object} [options] - Options to apply to {@link PIXI.autoDetectResource}
     * @param {number} [options.width] - Width of the resource
     * @param {number} [options.height] - Height of the resource
     */function e(e,i){var r,n,s=this,o=i||{},a=o.width,h=o.height;return Array.isArray(e)?(r=e,n=e.length):n=e,s=t.call(this,n,{width:a,height:h})||this,r&&s.initFromArray(r,i),s}return rx(e,t),/**
     * Set a baseTexture by ID,
     * ArrayResource just takes resource from it, nothing more
     *
     * @param {PIXI.BaseTexture} baseTexture
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.ArrayResource} Instance for chaining
     */e.prototype.addBaseTextureAt=function(t,e){if(t.resource)this.addResourceAt(t.resource,e);else throw Error("ArrayResource does not support RenderTexture");return this},/**
     * Add binding
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.bind=function(e){t.prototype.bind.call(this,e),e.target=xQ.TEXTURE_2D_ARRAY},/**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */e.prototype.upload=function(t,e,i){var r=this.length,n=this.itemDirtyIds,s=this.items,o=t.gl;i.dirtyId<0&&o.texImage3D(o.TEXTURE_2D_ARRAY,0,i.internalFormat,this._width,this._height,r,0,e.format,i.type,null);for(var a=0;a<r;a++){var h=s[a];n[a]<h.dirtyId&&(n[a]=h.dirtyId,h.valid&&o.texSubImage3D(o.TEXTURE_2D_ARRAY,0,0,0,a,h.resource.width,h.resource.height,1,e.format,i.type,h.resource.source))}return!0},e}(rM),rR=/** @class */function(t){/**
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} source
     */function e(e){var i=this,r=e.naturalWidth||e.videoWidth||e.width,n=e.naturalHeight||e.videoHeight||e.height;return(/**
         * The source element
         * @member {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement}
         * @readonly
         */(i=t.call(this,r,n)||this).source=e,/**
         * If set to `true`, will force `texImage2D` over `texSubImage2D` for uploading.
         * Certain types of media (e.g. video) using `texImage2D` is more performant.
         * @member {boolean}
         * @default false
         * @private
         */i.noSubImage=!1,i)}return rx(e,t),/**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */e.crossOrigin=function(t,e,i){void 0===i&&0!==e.indexOf("data:")?t.crossOrigin=iP(e):!1!==i&&(t.crossOrigin="string"==typeof i?i:"anonymous")},/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] - (optional)
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i,r){var n=t.gl,s=e.realWidth,o=e.realHeight;return r=r||this.source,n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===x4.UNPACK),this.noSubImage||e.target!==n.TEXTURE_2D||i.width!==s||i.height!==o?(i.width=s,i.height=o,n.texImage2D(e.target,0,i.internalFormat,e.format,i.type,r)):n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.format,i.type,r),!0},/**
     * Checks if source width/height was changed, resize can cause extra baseTexture update.
     * Triggers one update in any case.
     */e.prototype.update=function(){if(!this.destroyed){var e=this.source,i=e.naturalWidth||e.videoWidth||e.width,r=e.naturalHeight||e.videoHeight||e.height;this.resize(i,r),t.prototype.update.call(this)}},/**
     * Destroy this BaseImageResource
     * @override
     */e.prototype.dispose=function(){this.source=null},e}(rE),rC=/** @class */function(t){/**
     * @param {HTMLCanvasElement} source - Canvas element to use
     */// eslint-disable-next-line @typescript-eslint/no-useless-constructor
function e(e){return t.call(this,e)||this}return rx(e,t),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {HTMLCanvasElement|OffscreenCanvas} source - The source object
     * @return {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas
     */e.test=function(t){var e=self.OffscreenCanvas;return(// Check for browsers that don't yet support OffscreenCanvas
!!e&&t instanceof e||self.HTMLCanvasElement&&t instanceof HTMLCanvasElement)},e}(rR),rP=/** @class */function(t){/**
     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources
     *        to use as the sides of the cube.
     * @param {object} [options] - ImageResource options
     * @param {number} [options.width] - Width of resource
     * @param {number} [options.height] - Height of resource
     * @param {number} [options.autoLoad=true] - Whether to auto-load resources
     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,
     *   whether to copy them or use
     */function e(i,r){var n=this,s=r||{},o=s.width,a=s.height,h=s.autoLoad,l=s.linkBaseTexture;if(i&&i.length!==e.SIDES)throw Error("Invalid length. Got "+i.length+", expected 6");n=t.call(this,6,{width:o,height:a})||this;for(var u=0;u<e.SIDES;u++)n.items[u].target=xQ.TEXTURE_CUBE_MAP_POSITIVE_X+u;return(/**
         * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself
         * @member {boolean}
         * @protected
         */n.linkBaseTexture=!1!==l,i&&n.initFromArray(i,r),!1!==h&&n.load(),n)}return rx(e,t),/**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */e.prototype.bind=function(e){t.prototype.bind.call(this,e),e.target=xQ.TEXTURE_CUBE_MAP},e.prototype.addBaseTextureAt=function(t,e,i){if(void 0===i&&(i=this.linkBaseTexture),!this.items[e])throw Error("Index "+e+" is out of bounds");if(!this.linkBaseTexture||t.parentTextureArray||Object.keys(t._glTextures).length>0){// copy mode
if(t.resource)this.addResourceAt(t.resource,e);else throw Error("CubeResource does not support copying of renderTexture.")}else // link mode, the difficult one!
t.target=xQ.TEXTURE_CUBE_MAP_POSITIVE_X+e,t.parentTextureArray=this.baseTexture,this.items[e]=t;return t.valid&&!this.valid&&this.resize(t.realWidth,t.realHeight),this.items[e]=t,this},/**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,i,r){for(var n=this.itemDirtyIds,s=0;s<e.SIDES;s++){var o=this.items[s];n[s]<o.dirtyId&&(o.valid&&o.resource?(o.resource.upload(t,o,r),n[s]=o.dirtyId):n[s]<-1&&(// either item is not valid yet, either its a renderTexture
// allocate the memory
t.gl.texImage2D(o.target,0,r.internalFormat,i.realWidth,i.realHeight,0,i.format,r.type,null),n[s]=-1))}return!0},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {object} source - The source object
     * @return {boolean} `true` if source is an array of 6 elements
     */e.test=function(t){return Array.isArray(t)&&t.length===e.SIDES},/**
     * Number of texture sides to store for CubeResources
     *
     * @name PIXI.CubeResource.SIDES
     * @static
     * @member {number}
     * @default 6
     */e.SIDES=6,e}(rM),rI=/** @class */function(t){/**
     * @param {HTMLImageElement|string} source - image source or URL
     * @param {object} [options]
     * @param {boolean} [options.autoLoad=true] - start loading process
     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create
     *        a bitmap before upload
     * @param {boolean} [options.crossorigin=true] - Load image using cross origin
     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap
     */function e(e,i){var r=this;if(i=i||{},!(e instanceof HTMLImageElement)){var n=new Image;rR.crossOrigin(n,e,i.crossorigin),n.src=e,e=n}return r=t.call(this,e)||this,!e.complete&&r._width&&r._height&&(r._width=0,r._height=0),/**
         * URL of the image source
         * @member {string}
         */r.url=e.src,/**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */r._process=null,/**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */r.preserveBitmap=!1,/**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */r.createBitmap=(void 0!==i.createBitmap?i.createBitmap:ec.CREATE_IMAGE_BITMAP)&&!!self.createImageBitmap,/**
         * Controls texture alphaMode field
         * Copies from options
         * Default is `null`, copies option from baseTexture
         *
         * @member {PIXI.ALPHA_MODES|null}
         * @readonly
         */r.alphaMode="number"==typeof i.alphaMode?i.alphaMode:null,/**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */r.bitmap=null,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */r._load=null,!1!==i.autoLoad&&r.load(),r}return rx(e,t),/**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap] - whether process image into bitmap
     * @returns {Promise<void>}
     */e.prototype.load=function(t){var e=this;return this._load||(void 0!==t&&(this.createBitmap=t),this._load=new Promise(function(t,i){var r=e.source;e.url=r.src;var n=function(){e.destroyed||(r.onload=null,r.onerror=null,e.resize(r.width,r.height),e._load=null,e.createBitmap?t(e.process()):t(e))};r.complete&&r.src?n():(r.onload=n,r.onerror=function(t){// Avoids Promise freezing when resource broken
i(t),e.onError.emit(t)})})),this._load},/**
     * Called when we need to convert image into BitmapImage.
     * Can be called multiple times, real promise is cached inside.
     *
     * @returns {Promise<void>} cached promise to fill that bitmap
     */e.prototype.process=function(){var t=this,e=this.source;if(null!==this._process)return this._process;if(null!==this.bitmap||!self.createImageBitmap)return Promise.resolve(this);var i=self.createImageBitmap,r=!e.crossOrigin||"anonymous"===e.crossOrigin;return this._process=fetch(e.src,{mode:r?"cors":"no-cors"}).then(function(t){return t.blob()}).then(function(r){return i(r,0,0,e.width,e.height,{premultiplyAlpha:t.alphaMode===x4.UNPACK?"premultiply":"none"})}).then(function(e){return t.destroyed?Promise.reject():(t.bitmap=e,t.update(),t._process=null,Promise.resolve(t))}),this._process},/**
     * Upload the image resource to GPU.
     *
     * @param {PIXI.Renderer} renderer - Renderer to upload to
     * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
     * @param {PIXI.GLTexture} glTexture - GLTexture to use
     * @returns {boolean} true is success
     */e.prototype.upload=function(e,i,r){if("number"==typeof this.alphaMode&&(i.alphaMode=this.alphaMode),!this.createBitmap)return t.prototype.upload.call(this,e,i,r);if(!this.bitmap&&(// yeah, ignore the output
this.process(),!this.bitmap))return!1;if(t.prototype.upload.call(this,e,i,r,this.bitmap),!this.preserveBitmap){// checks if there are other renderers that possibly need this bitmap
var n=!0,s=i._glTextures;for(var o in s){var a=s[o];if(a!==r&&a.dirtyId!==i.dirtyId){n=!1;break}}n&&(this.bitmap.close&&this.bitmap.close(),this.bitmap=null)}return!0},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){this.source.onload=null,this.source.onerror=null,t.prototype.dispose.call(this),this.bitmap&&(this.bitmap.close(),this.bitmap=null),this._process=null,this._load=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {string|HTMLImageElement} source - The source object
     * @return {boolean} `true` if source is string or HTMLImageElement
     */e.test=function(t){return"string"==typeof t||t instanceof HTMLImageElement},e}(rR),rO=/** @class */function(t){/**
     * @param {string} source - Base64 encoded SVG element or URL for SVG file.
     * @param {object} [options] - Options to use
     * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...
     * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.
     * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.
     * @param {boolean} [options.autoLoad=true] - Start loading right away.
     */function e(e,i){var r=this;return i=i||{},(r=t.call(this,document.createElement("canvas"))||this)._width=0,r._height=0,/**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */r.svg=e,/**
         * The source scale to apply when rasterizing on load
         * @readonly
         * @member {number}
         */r.scale=i.scale||1,/**
         * A width override for rasterization on load
         * @readonly
         * @member {number}
         */r._overrideWidth=i.width,/**
         * A height override for rasterization on load
         * @readonly
         * @member {number}
         */r._overrideHeight=i.height,/**
         * Call when completely loaded
         * @private
         * @member {function}
         */r._resolve=null,/**
         * Cross origin value to use
         * @private
         * @member {boolean|string}
         */r._crossorigin=i.crossorigin,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */r._load=null,!1!==i.autoLoad&&r.load(),r}return rx(e,t),e.prototype.load=function(){var t=this;return this._load||(this._load=new Promise(function(e){// Convert SVG inline string to data-uri
if(// Save this until after load is finished
t._resolve=function(){t.resize(t.source.width,t.source.height),e(t)},/^\<svg/.test(t.svg.trim())){if(!btoa)throw Error("Your browser doesn't support base64 conversions.");t.svg="data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(t.svg)))}t._loadSvg()})),this._load},/**
     * Loads an SVG image from `imageUrl` or `data URL`.
     *
     * @private
     */e.prototype._loadSvg=function(){var t=this,e=new Image;rR.crossOrigin(e,this.svg,this._crossorigin),e.src=this.svg,e.onerror=function(i){t._resolve&&(e.onerror=null,t.onError.emit(i))},e.onload=function(){if(t._resolve){var i=e.width,r=e.height;if(!i||!r)throw Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");// Set render size
var n=i*t.scale,s=r*t.scale;(t._overrideWidth||t._overrideHeight)&&(n=t._overrideWidth||t._overrideHeight/r*i,s=t._overrideHeight||t._overrideWidth/i*r),n=Math.round(n),s=Math.round(s);// Create a canvas element
var o=t.source;o.width=n,o.height=s,o._pixiId="canvas_"+i_(),// Draw the Svg to the canvas
o.getContext("2d").drawImage(e,0,0,i,r,0,0,n,s),t._resolve(),t._resolve=null}}},/**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.ISize} image extension
     */e.getSize=function(t){var i=e.SVG_SIZE.exec(t),r={};return i&&(r[i[1]]=Math.round(parseFloat(i[3])),r[i[5]]=Math.round(parseFloat(i[7]))),r},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){t.prototype.dispose.call(this),this._resolve=null,this._crossorigin=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */e.test=function(t,i){// url file extension is SVG
return"svg"===i||"string"==typeof t&&/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)||"string"==typeof t&&e.SVG_XML.test(t)},/**
     * RegExp for SVG XML document.
     *
     * @example &lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!-- image/svg --&gt;&lt;svg
     */e.SVG_XML=/^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,/**
     * RegExp for SVG size.
     *
     * @static
     * @constant {RegExp|string} SVG_SIZE
     * @memberof PIXI.SVGResource
     * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
     */e.SVG_SIZE=/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i,e}(rR),rL=/** @class */function(t){/**
     * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.
     * @param {object} [options] - Options to use
     * @param {boolean} [options.autoLoad=true] - Start loading the video immediately
     * @param {boolean} [options.autoPlay=true] - Start playing video immediately
     * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.
     * Leave at 0 to update at every render.
     * @param {boolean} [options.crossorigin=true] - Load image using cross origin
     */function e(i,r){var n=this;if(r=r||{},!(i instanceof HTMLVideoElement)){var s=document.createElement("video");// workaround for https://github.com/pixijs/pixi.js/issues/5996
s.setAttribute("preload","auto"),s.setAttribute("webkit-playsinline",""),s.setAttribute("playsinline",""),"string"==typeof i&&(i=[i]);var o=i[0].src||i[0];rR.crossOrigin(s,o,r.crossorigin);// array of objects or strings
for(var a=0;a<i.length;++a){var h=document.createElement("source"),l=i[a],u=l.src,c=l.mime,d=(u=u||i[a]).split("?").shift().toLowerCase(),p=d.substr(d.lastIndexOf(".")+1);c=c||e.MIME_TYPES[p]||"video/"+p,h.src=u,h.type=c,s.appendChild(h)}// Override the source
i=s}return(n=t.call(this,i)||this).noSubImage=!0,/**
         * `true` to use PIXI.Ticker.shared to auto update the base texture.
         *
         * @type {boolean}
         * @default true
         * @private
         */n._autoUpdate=!0,/**
         * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update the base texture.
         *
         * @type {boolean}
         * @default false
         * @private
         */n._isConnectedToTicker=!1,n._updateFPS=r.updateFPS||0,n._msToNextUpdate=0,/**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */n.autoPlay=!1!==r.autoPlay,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */n._load=null,/**
         * Callback when completed with load.
         * @member {function}
         * @private
         */n._resolve=null,// Bind for listeners
n._onCanPlay=n._onCanPlay.bind(n),n._onError=n._onError.bind(n),!1!==r.autoLoad&&n.load(),n}return rx(e,t),/**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */e.prototype.update=function(e){if(!this.destroyed){// account for if video has had its playbackRate changed
var i=rr.shared.elapsedMS*this.source.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-i),(!this._updateFPS||this._msToNextUpdate<=0)&&(t.prototype.update.call(this),this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0)}},/**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */e.prototype.load=function(){var t=this;if(this._load)return this._load;var e=this.source;return(e.readyState===e.HAVE_ENOUGH_DATA||e.readyState===e.HAVE_FUTURE_DATA)&&e.width&&e.height&&(e.complete=!0),e.addEventListener("play",this._onPlayStart.bind(this)),e.addEventListener("pause",this._onPlayStop.bind(this)),this._isSourceReady()?this._onCanPlay():(e.addEventListener("canplay",this._onCanPlay),e.addEventListener("canplaythrough",this._onCanPlay),e.addEventListener("error",this._onError,!0)),this._load=new Promise(function(i){t.valid?i(t):(t._resolve=i,e.load())}),this._load},/**
     * Handle video error events.
     *
     * @private
     */e.prototype._onError=function(t){this.source.removeEventListener("error",this._onError,!0),this.onError.emit(t)},/**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */e.prototype._isSourcePlaying=function(){var t=this.source;return t.currentTime>0&&!1===t.paused&&!1===t.ended&&t.readyState>2},/**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */e.prototype._isSourceReady=function(){var t=this.source;return 3===t.readyState||4===t.readyState},/**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */e.prototype._onPlayStart=function(){this.valid||this._onCanPlay(),this.autoUpdate&&!this._isConnectedToTicker&&(rr.shared.add(this.update,this),this._isConnectedToTicker=!0)},/**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */e.prototype._onPlayStop=function(){this._isConnectedToTicker&&(rr.shared.remove(this.update,this),this._isConnectedToTicker=!1)},/**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */e.prototype._onCanPlay=function(){var t=this.source;t.removeEventListener("canplay",this._onCanPlay),t.removeEventListener("canplaythrough",this._onCanPlay);var e=this.valid;this.resize(t.videoWidth,t.videoHeight),!e&&this._resolve&&(this._resolve(this),this._resolve=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&t.play()},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){this._isConnectedToTicker&&(rr.shared.remove(this.update,this),this._isConnectedToTicker=!1);var e=this.source;e&&(e.removeEventListener("error",this._onError,!0),e.pause(),e.src="",e.load()),t.prototype.dispose.call(this)},Object.defineProperty(e.prototype,"autoUpdate",{/**
         * Should the base texture automatically update itself, set to true by default
         *
         * @member {boolean}
         */get:function(){return this._autoUpdate},set:function(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(rr.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._isSourcePlaying()&&(rr.shared.add(this.update,this),this._isConnectedToTicker=!0))},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"updateFPS",{/**
         * How many times a second to update the texture from the video. Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         *
         * @member {number}
         */get:function(){return this._updateFPS},set:function(t){t!==this._updateFPS&&(this._updateFPS=t)},enumerable:!1,configurable:!0}),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */e.test=function(t,i){return self.HTMLVideoElement&&t instanceof HTMLVideoElement||e.TYPES.indexOf(i)>-1},/**
     * List of common video file extensions supported by VideoResource.
     * @constant
     * @member {Array<string>}
     * @static
     * @readonly
     */e.TYPES=["mp4","m4v","webm","ogg","ogv","h264","avi","mov"],/**
     * Map of video MIME types that can't be directly derived from file extensions.
     * @constant
     * @member {object}
     * @static
     * @readonly
     */e.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"},e}(rR),rN=/** @class */function(t){/**
     * @param {ImageBitmap} source - Image element to use
     */// eslint-disable-next-line @typescript-eslint/no-useless-constructor
function e(e){return t.call(this,e)||this}return rx(e,t),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {ImageBitmap} source - The source object
     * @return {boolean} `true` if source is an ImageBitmap
     */e.test=function(t){return!!self.createImageBitmap&&t instanceof ImageBitmap},e}(rR);ry.push(rI,rN,rC,rL,rO,rT,rP,rA);var rD={__proto__:null,Resource:rE,BaseImageResource:rR,INSTALLED:ry,autoDetectResource:r_,AbstractMultiResource:rM,ArrayResource:rA,BufferResource:rT,CanvasResource:rC,CubeResource:rP,ImageResource:rI,SVGResource:rO,VideoResource:rL,ImageBitmapResource:rN},rF=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return rx(e,t),/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture - glTexture
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i){var r=t.gl;r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===x4.UNPACK);var n=e.realWidth,s=e.realHeight;return i.width===n&&i.height===s?r.texSubImage2D(e.target,0,0,0,n,s,e.format,i.type,this.data):(i.width=n,i.height=s,r.texImage2D(e.target,0,i.internalFormat,n,s,0,e.format,i.type,this.data)),!0},e}(rT),rB=/** @class */function(){/**
     * @param {number} width - Width of the frame buffer
     * @param {number} height - Height of the frame buffer
     */function t(t,e){/**
         * Width of framebuffer in pixels
         * @member {number}
         */this.width=Math.round(t||100),/**
         * Height of framebuffer in pixels
         * @member {number}
         */this.height=Math.round(e||100),this.stencil=!1,this.depth=!1,this.dirtyId=0,this.dirtyFormat=0,this.dirtySize=0,this.depthTexture=null,this.colorTextures=[],this.glFramebuffers={},this.disposeRunner=new rg("disposeFramebuffer"),/**
         * Desired number of samples for antialiasing. 0 means AA should not be used.
         *
         * Experimental WebGL2 feature, allows to use antialiasing in individual renderTextures.
         * Antialiasing is the same as for main buffer with renderer `antialias:true` options.
         * Seriously affects GPU memory consumption and GPU performance.
         *
         *```js
         * renderTexture.framebuffer.multisample = PIXI.MSAA_QUALITY.HIGH;
         * //...
         * renderer.render(myContainer, {renderTexture});
         * renderer.framebuffer.blit(); // copies data from MSAA framebuffer to texture
         *  ```
         *
         * @member {PIXI.MSAA_QUALITY}
         * @default PIXI.MSAA_QUALITY.NONE
         */this.multisample=bt.NONE}return Object.defineProperty(t.prototype,"colorTexture",{/**
         * Reference to the colorTexture.
         *
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */get:function(){return this.colorTextures[0]},enumerable:!1,configurable:!0}),/**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.BaseTexture} [texture] - Texture to add to the array
     */t.prototype.addColorTexture=function(t,e){return void 0===t&&(t=0),// TODO add some validation to the texture - same width / height etc?
this.colorTextures[t]=e||new rS(null,{scaleMode:x2.NEAREST,resolution:1,mipmap:x5.OFF,width:this.width,height:this.height}),this.dirtyId++,this.dirtyFormat++,this},/**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.BaseTexture} [texture] - Texture to add
     */t.prototype.addDepthTexture=function(t){return(/* eslint-disable max-len */this.depthTexture=t||new rS(new rF(null,{width:this.width,height:this.height}),{scaleMode:x2.NEAREST,resolution:1,width:this.width,height:this.height,mipmap:x5.OFF,format:x$.DEPTH_COMPONENT,type:x0.UNSIGNED_SHORT}),this.dirtyId++,this.dirtyFormat++,this)},/**
     * Enable depth on the frame buffer
     */t.prototype.enableDepth=function(){return this.depth=!0,this.dirtyId++,this.dirtyFormat++,this},/**
     * Enable stencil on the frame buffer
     */t.prototype.enableStencil=function(){return this.stencil=!0,this.dirtyId++,this.dirtyFormat++,this},/**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */t.prototype.resize=function(t,e){if(t=Math.round(t),e=Math.round(e),t!==this.width||e!==this.height){this.width=t,this.height=e,this.dirtyId++,this.dirtySize++;for(var i=0;i<this.colorTextures.length;i++){var r=this.colorTextures[i],n=r.resolution;// take into account the fact the texture may have a different resolution..
r.setSize(t/n,e/n)}if(this.depthTexture){var n=this.depthTexture.resolution;this.depthTexture.setSize(t/n,e/n)}}},/**
     * Disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys and removes the depth texture added to this framebuffer.
     */t.prototype.destroyDepthTexture=function(){this.depthTexture&&(this.depthTexture.destroy(),this.depthTexture=null,++this.dirtyId,++this.dirtyFormat)},t}(),rU=/** @class */function(t){/**
     * @param {object} [options]
     * @param {number} [options.width=100] - The width of the base render texture.
     * @param {number} [options.height=100] - The height of the base render texture.
     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES}
     *   for possible values.
     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio
     *   of the texture being generated.
     * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.
     */function e(e){var i=this;if("number"==typeof e){/* eslint-disable prefer-rest-params */// Backward compatibility of signature
var r=arguments[0],n=arguments[1],s=arguments[2],o=arguments[3];e={width:r,height:n,scaleMode:s,resolution:o};/* eslint-enable prefer-rest-params */}return e.width=e.width||100,e.height=e.height||100,e.multisample=void 0!==e.multisample?e.multisample:bt.NONE,// Set defaults
(i=t.call(this,null,e)||this).mipmap=x5.OFF,i.valid=!0,i.clearColor=[0,0,0,0],i.framebuffer=new rB(i.realWidth,i.realHeight).addColorTexture(0,i),i.framebuffer.multisample=e.multisample,// TODO - could this be added the systems?
/**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.MaskData[]}
         */i.maskStack=[],/**
         * The data structure for the filters.
         *
         * @member {Object[]}
         */i.filterStack=[{}],i}return rx(e,t),/**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} desiredWidth - The desired width to resize to.
     * @param {number} desiredHeight - The desired height to resize to.
     */e.prototype.resize=function(t,e){this.framebuffer.resize(t*this.resolution,e*this.resolution),this.setRealSize(this.framebuffer.width,this.framebuffer.height)},/**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */e.prototype.dispose=function(){this.framebuffer.dispose(),t.prototype.dispose.call(this)},/**
     * Destroys this texture.
     */e.prototype.destroy=function(){t.prototype.destroy.call(this),this.framebuffer.destroyDepthTexture(),this.framebuffer=null},e}(rS),rG=/** @class */function(){function t(){/**
         * X-component of top-left corner `(x0,y0)`.
         *
         * @member {number}
         */this.x0=0,/**
         * Y-component of top-left corner `(x0,y0)`.
         *
         * @member {number}
         */this.y0=0,/**
         * X-component of top-right corner `(x1,y1)`.
         *
         * @member {number}
         */this.x1=1,/**
         * Y-component of top-right corner `(x1,y1)`.
         *
         * @member {number}
         */this.y1=0,/**
         * X-component of bottom-right corner `(x2,y2)`.
         *
         * @member {number}
         */this.x2=1,/**
         * Y-component of bottom-right corner `(x2,y2)`.
         *
         * @member {number}
         */this.y2=1,/**
         * X-component of bottom-left corner `(x3,y3)`.
         *
         * @member {number}
         */this.x3=0,/**
         * Y-component of bottom-right corner `(x3,y3)`.
         *
         * @member {number}
         */this.y3=1,this.uvsFloat32=new Float32Array(8)}return(/**
     * Sets the texture Uvs based on the given frame information.
     *
     * @protected
     * @param {PIXI.Rectangle} frame - The frame of the texture
     * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
     * @param {number} rotate - Rotation of frame, see {@link PIXI.groupD8}
     */t.prototype.set=function(t,e,i){var r=e.width,n=e.height;if(i){// width and height div 2 div baseFrame size
var s=t.width/2/r,o=t.height/2/n,a=t.x/r+s,h=t.y/n+o;i=iQ.add(i,iQ.NW),this.x0=a+s*iQ.uX(i),this.y0=h+o*iQ.uY(i),i=iQ.add(i,2),this.x1=a+s*iQ.uX(i),this.y1=h+o*iQ.uY(i),i=iQ.add(i,2),this.x2=a+s*iQ.uX(i),this.y2=h+o*iQ.uY(i),i=iQ.add(i,2),this.x3=a+s*iQ.uX(i),this.y3=h+o*iQ.uY(i)}else this.x0=t.x/r,this.y0=t.y/n,this.x1=(t.x+t.width)/r,this.y1=t.y/n,this.x2=(t.x+t.width)/r,this.y2=(t.y+t.height)/n,this.x3=t.x/r,this.y3=(t.y+t.height)/n;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3},t.prototype.toString=function(){return"[@pixi/core:TextureUvs x0="+this.x0+" y0="+this.y0+" "+("x1="+this.x1+" y1="+this.y1)+" x2="+this.x2+" "+("y2="+this.y2+" x3=")+this.x3+" y3="+this.y3+"]"},t)}(),rk=new rG,rH=/** @class */function(t){/**
     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     * @param {PIXI.Rectangle} [orig] - The area of original texture
     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}
     * @param {PIXI.IPointData} [anchor] - Default anchor point used for sprite placement / rotation
     */function e(i,r,n,s,o,a){var h=t.call(this)||this;if(/**
         * Does this Texture have any frame data assigned to it?
         *
         * This mode is enabled automatically if no frame was passed inside constructor.
         *
         * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.
         *
         * Beware, after loading or resize of baseTexture event can fired two times!
         * If you want more control, subscribe on baseTexture itself.
         *
         * ```js
         * texture.on('update', () => {});
         * ```
         *
         * Any assignment of `frame` switches off `noFrame` mode.
         *
         * @member {boolean}
         */h.noFrame=!1,r||(h.noFrame=!0,r=new iU(0,0,1,1)),i instanceof e&&(i=i.baseTexture),/**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */h.baseTexture=i,/**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */h._frame=r,/**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */h.trim=s,/**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */h.valid=!1,/**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */h._uvs=rk,/**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */h.uvMatrix=null,/**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */h.orig=n||r,h._rotate=Number(o||0),!0===o)h._rotate=2;else if(h._rotate%2!=0)throw Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");return(/**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */h.defaultAnchor=a?new ij(a.x,a.y):new ij(0,0),/**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */h._updateID=0,/**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */h.textureCacheIds=[],i.valid?h.noFrame?i.valid&&h.onBaseTextureUpdated(i):h.frame=r:i.once("loaded",h.onBaseTextureUpdated,h),h.noFrame&&i.on("update",h.onBaseTextureUpdated,h),h)}return rx(e,t),/**
     * Updates this texture on the gpu.
     *
     * Calls the TextureResource update.
     *
     * If you adjusted `frame` manually, please call `updateUvs()` instead.
     *
     */e.prototype.update=function(){this.baseTexture.resource&&this.baseTexture.resource.update()},/**
     * Called when the base texture is updated
     *
     * @protected
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */e.prototype.onBaseTextureUpdated=function(t){if(this.noFrame){if(!this.baseTexture.valid)return;this._frame.width=t.width,this._frame.height=t.height,this.valid=!0,this.updateUvs()}else // if user gave us frame that has bigger size than resized texture it can be a problem
this.frame=this._frame;this.emit("update",this)},/**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
     */e.prototype.destroy=function(t){if(this.baseTexture){if(t){var i=this.baseTexture.resource;i&&i.url&&iE[i.url]&&e.removeFromCache(i.url),this.baseTexture.destroy()}this.baseTexture.off("loaded",this.onBaseTextureUpdated,this),this.baseTexture.off("update",this.onBaseTextureUpdated,this),this.baseTexture=null}this._frame=null,this._uvs=null,this.trim=null,this.orig=null,this.valid=!1,e.removeFromCache(this),this.textureCacheIds=null},/**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */e.prototype.clone=function(){var t=this._frame.clone(),i=this._frame===this.orig?t:this.orig.clone(),r=new e(this.baseTexture,!this.noFrame&&t,i,this.trim&&this.trim.clone(),this.rotate,this.defaultAnchor);return this.noFrame&&(r._frame=t),r},/**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */e.prototype.updateUvs=function(){this._uvs===rk&&(this._uvs=new rG),this._uvs.set(this._frame,this.baseTexture,this.rotate),this._updateID++},/**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source -
     *        Source to create texture from
     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
     * @return {PIXI.Texture} The newly created texture
     */e.from=function(t,i,r){void 0===i&&(i={}),void 0===r&&(r=ec.STRICT_TEXTURE_CACHE);var n="string"==typeof t,s=null;if(n)s=t;else{if(!t._pixiId){var o=i&&i.pixiIdPrefix||"pixiid";t._pixiId=o+"_"+i_()}s=t._pixiId}var a=iE[s];// Strict-mode rejects invalid cacheIds
if(n&&r&&!a)throw Error('The cacheId "'+s+'" does not exist in TextureCache.');// lets assume its a base texture!
return a||(i.resolution||(i.resolution=iI(t)),(a=new e(new rS(t,i))).baseTexture.cacheId=s,rS.addToCache(a.baseTexture,s),e.addToCache(a,s)),a},/**
     * Useful for loading textures via URLs. Use instead of `Texture.from` because
     * it does a better job of handling failed URLs more effectively. This also ignores
     * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.
     * @param {string} url - The remote URL to load.
     * @param {object} [options] - Optional options to include
     * @return {Promise<PIXI.Texture>} A Promise that resolves to a Texture.
     */e.fromURL=function(t,i){var r=Object.assign({autoLoad:!1},null==i?void 0:i.resourceOptions),n=e.from(t,Object.assign({resourceOptions:r},i),!1),s=n.baseTexture.resource;return(// The texture was already loaded
n.baseTexture.valid?Promise.resolve(n):s.load().then(function(){return Promise.resolve(n)}))},/**
     * Create a new Texture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The resulting new BaseTexture
     */e.fromBuffer=function(t,i,r,n){return new e(rS.fromBuffer(t,i,r,n))},/**
     * Create a texture from a source and add to the cache.
     *
     * @static
     * @param {HTMLImageElement|HTMLCanvasElement|string} source - The input source.
     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
     * @param {String} [name] - Human readable name for the texture cache. If no name is
     *        specified, only `imageUrl` will be used as the cache ID.
     * @return {PIXI.Texture} Output texture
     */e.fromLoader=function(t,i,r,n){var s=new rS(t,Object.assign({scaleMode:ec.SCALE_MODE,resolution:iI(i)},n)),o=s.resource;o instanceof rI&&(o.url=i);var a=new e(s);return(// Generally images are valid right away
(r||(r=i),// lets also add the frame to pixi's global cache for 'fromLoader' function
rS.addToCache(a.baseTexture,r),e.addToCache(a,r),r!==i&&(rS.addToCache(a.baseTexture,i),e.addToCache(a,i)),a.baseTexture.valid)?Promise.resolve(a):new Promise(function(t){a.baseTexture.once("loaded",function(){return t(a)})}))},/**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */e.addToCache=function(t,e){e&&(-1===t.textureCacheIds.indexOf(e)&&t.textureCacheIds.push(e),iE[e]&&console.warn("Texture added to the cache with an id ["+e+"] that already had an entry"),iE[e]=t)},/**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */e.removeFromCache=function(t){if("string"==typeof t){var e=iE[t];if(e){var i=e.textureCacheIds.indexOf(t);return i>-1&&e.textureCacheIds.splice(i,1),delete iE[t],e}}else if(t&&t.textureCacheIds){for(var r=0;r<t.textureCacheIds.length;++r)iE[t.textureCacheIds[r]]===t&&delete iE[t.textureCacheIds[r]];return t.textureCacheIds.length=0,t}return null},Object.defineProperty(e.prototype,"resolution",{/**
         * Returns resolution of baseTexture
         *
         * @member {number}
         * @readonly
         */get:function(){return this.baseTexture.resolution},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"frame",{/**
         * The frame specifies the region of the base texture that this texture uses.
         * Please call `updateUvs()` after you change coordinates of `frame` manually.
         *
         * @member {PIXI.Rectangle}
         */get:function(){return this._frame},set:function(t){this._frame=t,this.noFrame=!1;var e=t.x,i=t.y,r=t.width,n=t.height,s=e+r>this.baseTexture.width,o=i+n>this.baseTexture.height;if(s||o)throw Error("Texture Error: frame does not fit inside the base Texture dimensions: "+("X: "+e+" + "+r+" = "+(e+r)+" > "+this.baseTexture.width+" ")+(s&&o?"and":"or")+" "+("Y: "+i+" + "+n+" = "+(i+n))+" > "+this.baseTexture.height);this.valid=r&&n&&this.baseTexture.valid,this.trim||this.rotate||(this.orig=t),this.valid&&this.updateUvs()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"rotate",{/**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.groupD8} for explanation
         *
         * @member {number}
         */get:function(){return this._rotate},set:function(t){this._rotate=t,this.valid&&this.updateUvs()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"width",{/**
         * The width of the Texture in pixels.
         *
         * @member {number}
         */get:function(){return this.orig.width},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the Texture in pixels.
         *
         * @member {number}
         */get:function(){return this.orig.height},enumerable:!1,configurable:!0}),/**
     * Utility function for BaseTexture|Texture cast
     */e.prototype.castToBaseTexture=function(){return this.baseTexture},e}(/*@__PURE__*/tP(ed));function rz(t){t.destroy=function(){},t.on=function(){},t.once=function(){},t.emit=function(){}}/**
 * An empty texture, used often to not have to create multiple empty textures.
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */rH.EMPTY=new rH(new rS),rz(rH.EMPTY),rz(rH.EMPTY.baseTexture),/**
 * A white texture of 16x16 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */rH.WHITE=((vl=document.createElement("canvas")).width=16,vl.height=16,(vu=vl.getContext("2d")).fillStyle="white",vu.fillRect(0,0,16,16),new rH(new rS(new rC(vl)))),rz(rH.WHITE),rz(rH.WHITE.baseTexture);/**
 * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * __Hint-2__: The actual memory allocation will happen on first render.
 * You shouldn't create renderTextures each frame just to delete them after, try to reuse them.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer();
 * let renderTexture = PIXI.RenderTexture.create({ width: 800, height: 600 });
 * let sprite = PIXI.Sprite.from("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, {renderTexture});
 * ```
 * Note that you should not create a new renderer, but reuse the same one as the rest of the application.
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let renderTexture = new PIXI.RenderTexture.create({ width: 100, height: 100 });
 *
 * renderer.render(sprite, {renderTexture});  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 */var rj=/** @class */function(t){/**
     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The base texture object that this texture uses
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     */function e(e,i){var r=t.call(this,e,i)||this;return(/**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */r.valid=!0,/**
         * Stores `sourceFrame` when this texture is inside current filter stack.
         * You can read it inside filters.
         *
         * @readonly
         * @member {PIXI.Rectangle}
         */r.filterFrame=null,/**
         * The key for pooled texture of FilterSystem
         * @protected
         * @member {string}
         */r.filterPoolKey=null,r.updateUvs(),r)}return rx(e,t),Object.defineProperty(e.prototype,"framebuffer",{/**
         * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
         * @member {PIXI.Framebuffer}
         * @readonly
         */get:function(){return this.baseTexture.framebuffer},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"multisample",{/**
         * Shortcut to `this.framebuffer.multisample`.
         *
         * @member {PIXI.MSAA_QUALITY}
         * @default PIXI.MSAA_QUALITY.NONE
         */get:function(){return this.framebuffer.multisample},set:function(t){this.framebuffer.multisample=t},enumerable:!1,configurable:!0}),/**
     * Resizes the RenderTexture.
     *
     * @param {number} desiredWidth - The desired width to resize to.
     * @param {number} desiredHeight - The desired height to resize to.
     * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
     */e.prototype.resize=function(t,e,i){void 0===i&&(i=!0);var r=this.baseTexture.resolution,n=Math.round(t*r)/r,s=Math.round(e*r)/r;// TODO - could be not required..
this.valid=n>0&&s>0,this._frame.width=this.orig.width=n,this._frame.height=this.orig.height=s,i&&this.baseTexture.resize(n,s),this.updateUvs()},/**
     * Changes the resolution of baseTexture, but does not change framebuffer size.
     *
     * @param {number} resolution - The new resolution to apply to RenderTexture
     */e.prototype.setResolution=function(t){var e=this.baseTexture;e.resolution!==t&&(e.setResolution(t),this.resize(e.width,e.height,!1))},e.create=function(t){for(var i=arguments,r=[],n=1;n<arguments.length;n++)r[n-1]=i[n];return"number"==typeof t&&(ix("6.0.0","Arguments (width, height, scaleMode, resolution) have been deprecated."),/* eslint-disable prefer-rest-params */t={width:t,height:r[0],scaleMode:r[1],resolution:r[2]}),new e(new rU(t))},e}(rH),rV=/** @class */function(){/**
     * @param {object} [textureOptions] - options that will be passed to BaseRenderTexture constructor
     * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
     */function t(t){this.texturePool={},this.textureOptions=t||{},/**
         * Allow renderTextures of the same size as screen, not just pow2
         *
         * Automatically sets to true after `setScreenSize`
         *
         * @member {boolean}
         * @default false
         */this.enableFullScreen=!1,this._pixelsWidth=0,this._pixelsHeight=0}return(/**
     * creates of texture with params that were specified in pool constructor
     *
     * @param {number} realWidth - width of texture in pixels
     * @param {number} realHeight - height of texture in pixels
     * @param {PIXI.MSAA_QUALITY} [multisample=PIXI.MSAA_QUALITY.NONE] - number of samples of the framebuffer
     * @returns {RenderTexture}
     */t.prototype.createTexture=function(t,e,i){void 0===i&&(i=bt.NONE);var r=new rU(Object.assign({width:t,height:e,resolution:1,multisample:i},this.textureOptions));return new rj(r)},/**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture.
     * @param {number} minHeight - The minimum height of the render texture.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @param {PIXI.MSAA_QUALITY} [multisample=PIXI.MSAA_QUALITY.NONE] - Number of samples of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */t.prototype.getOptimalTexture=function(t,e,i,r){void 0===i&&(i=1),void 0===r&&(r=bt.NONE),t=Math.ceil(t*i),e=Math.ceil(e*i),this.enableFullScreen&&t===this._pixelsWidth&&e===this._pixelsHeight?n=r>1?-r:-1:(n=((65535&(t=ic(t)))<<16|65535&(e=ic(e)))>>>0,r>1&&(n+=4294967296*r)),this.texturePool[n]||(this.texturePool[n]=[]);var n,s=this.texturePool[n].pop();return s||(s=this.createTexture(t,e,r)),s.filterPoolKey=n,s.setResolution(i),s},/**
     * Gets extra texture of the same size as input renderTexture
     *
     * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
     *
     * @param {PIXI.RenderTexture} input - renderTexture from which size and resolution will be copied
     * @param {number} [resolution] - override resolution of the renderTexture
     *  It overrides, it does not multiply
     * @param {PIXI.MSAA_QUALITY} [multisample=PIXI.MSAA_QUALITY.NONE] - number of samples of the renderTexture
     * @returns {PIXI.RenderTexture}
     */t.prototype.getFilterTexture=function(t,e,i){var r=this.getOptimalTexture(t.width,t.height,e||t.resolution,i||bt.NONE);return r.filterFrame=t.filterFrame,r},/**
     * Place a render texture back into the pool.
     * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
     */t.prototype.returnTexture=function(t){var e=t.filterPoolKey;t.filterFrame=null,this.texturePool[e].push(t)},/**
     * Alias for returnTexture, to be compliant with FilterSystem interface
     * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
     */t.prototype.returnFilterTexture=function(t){this.returnTexture(t)},/**
     * Clears the pool
     *
     * @param {boolean} [destroyTextures=true] - destroy all stored textures
     */t.prototype.clear=function(t){if(t=!1!==t)for(var e in this.texturePool){var i=this.texturePool[e];if(i)for(var r=0;r<i.length;r++)i[r].destroy(!0)}this.texturePool={}},/**
     * If screen size was changed, drops all screen-sized textures,
     * sets new screen size, sets `enableFullScreen` to true
     *
     * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
     *
     * @param {PIXI.ISize} size - Initial size of screen
     */t.prototype.setScreenSize=function(t){if(t.width!==this._pixelsWidth||t.height!==this._pixelsHeight){for(var e in this.enableFullScreen=t.width>0&&t.height>0,this.texturePool)if(0>Number(e)){var i=this.texturePool[e];if(i)for(var r=0;r<i.length;r++)i[r].destroy(!0);this.texturePool[e]=[]}this._pixelsWidth=t.width,this._pixelsHeight=t.height}},/**
     * Key that is used to store fullscreen renderTextures in a pool
     *
     * @static
     * @const {number}
     */t.SCREEN_KEY=-1,t)}(),rX=/** @class */function(){/**
     * @param {string} buffer - the id of the buffer that this attribute will look for
     * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.
     * @param {Boolean} [normalized=false] - should the data be normalized.
     * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
     * @param {Number} [stride=0] - How far apart (in floats) the start of each value is. (used for interleaving data)
     * @param {Number} [start=0] - How far into the array to start reading values (used for interleaving data)
     */function t(t,e,i,r,n,s,o){void 0===e&&(e=0),void 0===i&&(i=!1),void 0===r&&(r=x0.FLOAT),this.buffer=t,this.size=e,this.normalized=i,this.type=r,this.stride=n,this.start=s,this.instance=o}return(/**
     * Destroys the Attribute.
     */t.prototype.destroy=function(){this.buffer=null},/**
     * Helper function that creates an Attribute based on the information provided
     *
     * @static
     * @param {string} buffer - the id of the buffer that this attribute will look for
     * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
     * @param {Boolean} [normalized=false] - should the data be normalized.
     * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
     * @param {Number} [stride=0] - How far apart (in floats) the start of each value is. (used for interleaving data)
     *
     * @returns {PIXI.Attribute} A new {@link PIXI.Attribute} based on the information provided
     */t.from=function(e,i,r,n,s){return new t(e,i,r,n,s)},t)}(),rW=0,rY=/** @class */function(){/**
     * @param {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} data - the data to store in the buffer.
     * @param {boolean} [_static=true] - `true` for static buffer
     * @param {boolean} [index=false] - `true` for index buffer
     */function t(t,e,i){void 0===e&&(e=!0),void 0===i&&(i=!1),/**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer | ArrayBufferView}
         */this.data=t||new Float32Array(1),/**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */this._glBuffers={},this._updateID=0,this.index=i,this.static=e,this.id=rW++,this.disposeRunner=new rg("disposeBuffer")}return(// TODO could explore flagging only a partial upload?
/**
     * flags this buffer as requiring an upload to the GPU
     * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|number[]} [data] - the data to update in the buffer.
     */t.prototype.update=function(t){t instanceof Array&&(t=new Float32Array(t)),this.data=t||this.data,this._updateID++},/**
     * disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys the buffer
     */t.prototype.destroy=function(){this.dispose(),this.data=null},Object.defineProperty(t.prototype,"index",{get:function(){return this.type===be.ELEMENT_ARRAY_BUFFER},/**
         * Flags whether this is an index buffer.
         *
         * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
         * the buffer of type `ARRAY_BUFFER`.
         *
         * For backwards compatibility.
         */set:function(t){this.type=t?be.ELEMENT_ARRAY_BUFFER:be.ARRAY_BUFFER},enumerable:!1,configurable:!0}),/**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */t.from=function(e){return e instanceof Array&&(e=new Float32Array(e)),new t(e)},t)}(),rq={Float32Array:Float32Array,Uint32Array:Uint32Array,Int32Array:Int32Array,Uint8Array:Uint8Array},rK={5126:4,5123:2,5121:1},rJ=0,rZ={Float32Array:Float32Array,Uint32Array:Uint32Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array},r$=/** @class */function(){/**
     * @param {PIXI.Buffer[]} [buffers] - an array of buffers. optional.
     * @param {object} [attributes] - of the geometry, optional structure of the attributes layout
     */function t(t,e){void 0===t&&(t=[]),void 0===e&&(e={}),this.buffers=t,this.indexBuffer=null,this.attributes=e,/**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */this.glVertexArrayObjects={},this.id=rJ++,this.instanced=!1,/**
         * Number of instances in this geometry, pass it to `GeometrySystem.draw()`
         * @member {number}
         * @default 1
         */this.instanceCount=1,this.disposeRunner=new rg("disposeGeometry"),/**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {number}
         */this.refCount=0}return(/**
    *
    * Adds an attribute to the geometry
    * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] - should the data be normalized.
    * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride] - How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start] - How far into the array to start reading values (used for interleaving data)
    * @param {boolean} [instance=false] - Instancing flag
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */t.prototype.addAttribute=function(t,e,i,r,n,s,o,a){if(void 0===i&&(i=0),void 0===r&&(r=!1),void 0===a&&(a=!1),!e)throw Error("You must pass a buffer when creating an attribute");e instanceof rY||(e instanceof Array&&(e=new Float32Array(e)),e=new rY(e));var h=t.split("|");if(h.length>1){for(var l=0;l<h.length;l++)this.addAttribute(h[l],e,i,r,n);return this}var u=this.buffers.indexOf(e);return -1===u&&(this.buffers.push(e),u=this.buffers.length-1),this.attributes[t]=new rX(u,i,r,n,s,o,a),// assuming that if there is instanced data then this will be drawn with instancing!
this.instanced=this.instanced||a,this},/**
     * returns the requested attribute
     *
     * @param {String} id - the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */t.prototype.getAttribute=function(t){return this.attributes[t]},/**
     * returns the requested buffer
     *
     * @param {String} id - the name of the buffer required
     * @return {PIXI.Buffer} the buffer requested.
     */t.prototype.getBuffer=function(t){return this.buffers[this.getAttribute(t).buffer]},/**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, ). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer|number[]} [buffer] - the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */t.prototype.addIndex=function(t){return t instanceof rY||(t instanceof Array&&(t=new Uint16Array(t)),t=new rY(t)),t.type=be.ELEMENT_ARRAY_BUFFER,this.indexBuffer=t,-1===this.buffers.indexOf(t)&&this.buffers.push(t),this},/**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */t.prototype.getIndex=function(){return this.indexBuffer},/**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */t.prototype.interleave=function(){// a simple check to see if buffers are already interleaved..
if(1===this.buffers.length||2===this.buffers.length&&this.indexBuffer)return this;// assume already that no buffers are interleaved
var t,e=[],i=[],r=new rY;for(t in this.attributes){var n=this.attributes[t],s=this.buffers[n.buffer];e.push(s.data),i.push(n.size*rK[n.type]/4),n.buffer=0}for(t=0,r.data=function(t,e){for(var i=0,r=0,n={},s=0;s<t.length;s++)r+=e[s],i+=t[s].length;for(var o=new ArrayBuffer(4*i),a=null,h=0,s=0;s<t.length;s++){var l=e[s],u=t[s],c=ih(u);n[c]||(n[c]=new rq[c](o)),a=n[c];for(var d=0;d<u.length;d++)a[(d/l|0)*r+h+d%l]=u[d];h+=l}return new Float32Array(o)}(e,i);t<this.buffers.length;t++)this.buffers[t]!==this.indexBuffer&&this.buffers[t].destroy();return this.buffers=[r],this.indexBuffer&&this.buffers.push(this.indexBuffer),this},t.prototype.getSize=function(){for(var t in this.attributes){var e=this.attributes[t];return this.buffers[e.buffer].data.length/(e.stride/4||e.size)}return 0},/**
     * disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys the geometry.
     */t.prototype.destroy=function(){this.dispose(),this.buffers=null,this.indexBuffer=null,this.attributes=null},/**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */t.prototype.clone=function(){for(var e=new t,i=0;i<this.buffers.length;i++)e.buffers[i]=new rY(this.buffers[i].data.slice(0));for(var i in this.attributes){var r=this.attributes[i];e.attributes[i]=new rX(r.buffer,r.size,r.normalized,r.type,r.stride,r.start,r.instance)}return this.indexBuffer&&(e.indexBuffer=e.buffers[this.buffers.indexOf(this.indexBuffer)],e.indexBuffer.type=be.ELEMENT_ARRAY_BUFFER),e},/**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries - array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */t.merge=function(e){// pass one.. get sizes..
for(var i,r=new t,n=[],s=[],o=[],a=0;a<e.length;a++){i=e[a];for(var h=0;h<i.buffers.length;h++)s[h]=s[h]||0,s[h]+=i.buffers[h].data.length,o[h]=0}// build the correct size arrays..
for(var a=0;a<i.buffers.length;a++)// TODO types!
n[a]=new rZ[ih(i.buffers[a].data)](s[a]),r.buffers[a]=new rY(n[a]);// pass to set data..
for(var a=0;a<e.length;a++){i=e[a];for(var h=0;h<i.buffers.length;h++)n[h].set(i.buffers[h].data,o[h]),o[h]+=i.buffers[h].data.length}if(r.attributes=i.attributes,i.indexBuffer){r.indexBuffer=r.buffers[i.buffers.indexOf(i.indexBuffer)],r.indexBuffer.type=be.ELEMENT_ARRAY_BUFFER;// get a buffer
for(var l=0,u=0,c=0,d=0,a=0;a<i.buffers.length;a++)if(i.buffers[a]!==i.indexBuffer){d=a;break}// figure out the stride of one buffer..
for(var a in i.attributes){var p=i.attributes[a];(0|p.buffer)===d&&(u+=p.size*rK[p.type]/4)}// time to off set all indexes..
for(var a=0;a<e.length;a++){for(var f=e[a].indexBuffer.data,h=0;h<f.length;h++)r.indexBuffer.data[h+c]+=l;l+=e[a].buffers[d].data.length/u,c+=f.length}}return r},t)}(),rQ=/** @class */function(t){function e(){var e=t.call(this)||this;return e.addAttribute("aVertexPosition",new Float32Array([0,0,1,0,1,1,0,1])).addIndex([0,1,3,2]),e}return rx(e,t),e}(r$),r0=/** @class */function(t){function e(){var e=t.call(this)||this;return(/**
         * An array of vertices
         *
         * @member {Float32Array}
         */e.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),/**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */e.uvs=new Float32Array([0,0,1,0,1,1,0,1]),e.vertexBuffer=new rY(e.vertices),e.uvBuffer=new rY(e.uvs),e.addAttribute("aVertexPosition",e.vertexBuffer).addAttribute("aTextureCoord",e.uvBuffer).addIndex([0,1,2,0,2,3]),e)}return rx(e,t),/**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */e.prototype.map=function(t,e){var i=0,r=0;// destinationFrame.x / targetTextureFrame.width;
return this.uvs[0]=i,this.uvs[1]=r,this.uvs[2]=i+e.width/t.width,this.uvs[3]=r,this.uvs[4]=i+e.width/t.width,this.uvs[5]=r+e.height/t.height,this.uvs[6]=i,this.uvs[7]=r+e.height/t.height,i=e.x,r=e.y,this.vertices[0]=i,this.vertices[1]=r,this.vertices[2]=i+e.width,this.vertices[3]=r,this.vertices[4]=i+e.width,this.vertices[5]=r+e.height,this.vertices[6]=i,this.vertices[7]=r+e.height,this.invalidate(),this},/**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */e.prototype.invalidate=function(){return this.vertexBuffer._updateID++,this.uvBuffer._updateID++,this},e}(r$),r1=0,r2=/** @class */function(){/**
     * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer
     * @param {boolean} [isStatic] - Uniforms wont be changed after creation
     * @param {boolean} [isUbo] - if true, will treat this uniform group as a uniform buffer object
     */function t(t,e,i){/**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */this.group=!0,// lets generate this when the shader ?
this.syncUniforms={},/**
         * dirty version
         * @protected
         * @member {number}
         */this.dirtyId=0,/**
         * unique id
         * @protected
         * @member {number}
         */this.id=r1++,/**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */this.static=!!e,/**
         * Flags whether this group is treated like a uniform buffer object.
         * @member {boolean}
         */this.ubo=!!i,t instanceof rY?(this.buffer=t,this.buffer.type=be.UNIFORM_BUFFER,this.autoManage=!1,this.ubo=!0):(/**
             * uniform values
             * @member {object}
             * @readonly
             */this.uniforms=t,this.ubo&&(this.buffer=new rY(new Float32Array(1)),this.buffer.type=be.UNIFORM_BUFFER,this.autoManage=!0))}return t.prototype.update=function(){this.dirtyId++,!this.autoManage&&this.buffer&&this.buffer.update()},t.prototype.add=function(e,i,r){if(this.ubo)throw Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");this.uniforms[e]=new t(i,r)},t.from=function(e,i,r){return new t(e,i,r)},/**
     * A short hand function for creating a static UBO UniformGroup.
     *
     * @param uniforms - the ubo item
     * @param _static - should this be updated each time it is used? defaults to true here!
     */t.uboFrom=function(e,i){return new t(e,null==i||i,!0)},t}(),r3=/** @class */function(){function t(){this.renderTexture=null,/**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */this.target=null,/**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */this.legacy=!1,/**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */this.resolution=1,/**
         * Number of samples
         * @member {PIXI.MSAA_QUALITY}
         * @default MSAA_QUALITY.NONE
         * @private
         */this.multisample=bt.NONE,// next three fields are created only for root
// re-assigned for everything else
/**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */this.sourceFrame=new iU,/**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */this.destinationFrame=new iU,/**
         * Original render-target source frame
         * @private
         */this.bindingSourceFrame=new iU,/**
         * Original render-target destination frame
         * @private
         */this.bindingDestinationFrame=new iU,/**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */this.filters=[],/**
         * Projection system transform saved by link.
         * @member {PIXI.Matrix}
         * @private
         */this.transform=null}return(/**
     * clears the state
     * @private
     */t.prototype.clear=function(){this.target=null,this.filters=null,this.renderTexture=null},t)}(),r5=[new ij,new ij,new ij,new ij],r4=new iX,r6=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */this.defaultFilterStack=[{}],/**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */this.texturePool=new rV,this.texturePool.setScreenSize(t.view),/**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */this.statePool=[],/**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */this.quad=new rQ,/**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */this.quadUv=new r0,/**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */this.tempRect=new iU,/**
         * Active state
         * @member {object}
         */this.activeState={},/**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Float32Array} filterClamp
         */this.globalUniforms=new r2({outputFrame:new iU,inputSize:new Float32Array(4),inputPixel:new Float32Array(4),inputClamp:new Float32Array(4),resolution:1,// legacy variables
filterArea:new Float32Array(4),filterClamp:new Float32Array(4)},!0),/**
         * Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}
         * @member {boolean}
         */this.forceClear=!1,/**
         * Old padding behavior is to use the max amount instead of sum padding.
         * Use this flag if you need the old behavior.
         * @member {boolean}
         * @default false
         */this.useMaxPadding=!1}return(/**
     * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an
     * input render-texture for the rest of the filtering pipeline.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */t.prototype.push=function(t,e){for(var i=this.renderer,r=this.defaultFilterStack,n=this.statePool.pop()||new r3,s=this.renderer.renderTexture,o=e[0].resolution,a=e[0].multisample,h=e[0].padding,l=e[0].autoFit,u=e[0].legacy,c=1;c<e.length;c++){var d=e[c];// let's use the lowest resolution
o=Math.min(o,d.resolution),// let's use the lowest number of samples
a=Math.min(a,d.multisample),// figure out the padding required for filters
h=this.useMaxPadding?Math.max(h,d.padding):h+d.padding,// only auto fit if all filters are autofit
l=l&&d.autoFit,u=u||d.legacy}if(1===r.length&&(this.defaultFilterStack[0].renderTexture=s.current),r.push(n),n.resolution=o,n.multisample=a,n.legacy=u,n.target=t,n.sourceFrame.copyFrom(t.filterArea||t.getBounds(!0)),n.sourceFrame.pad(h),l){var p=this.tempRect.copyFrom(s.sourceFrame);i.projection.transform&&this.transformAABB(r4.copyFrom(i.projection.transform).invert(),p),n.sourceFrame.fit(p)}// Round sourceFrame in screen space based on render-texture.
this.roundFrame(n.sourceFrame,s.current?s.current.resolution:i.resolution,s.sourceFrame,s.destinationFrame,i.projection.transform),n.renderTexture=this.getOptimalFilterTexture(n.sourceFrame.width,n.sourceFrame.height,o,a),n.filters=e,n.destinationFrame.width=n.renderTexture.width,n.destinationFrame.height=n.renderTexture.height;var f=this.tempRect;f.x=0,f.y=0,f.width=n.sourceFrame.width,f.height=n.sourceFrame.height,n.renderTexture.filterFrame=n.sourceFrame,n.bindingSourceFrame.copyFrom(s.sourceFrame),n.bindingDestinationFrame.copyFrom(s.destinationFrame),n.transform=i.projection.transform,i.projection.transform=null,s.bind(n.renderTexture,n.sourceFrame,f),i.framebuffer.clear(0,0,0,0)},/**
     * Pops off the filter and applies it.
     */t.prototype.pop=function(){var t=this.defaultFilterStack,e=t.pop(),i=e.filters;this.activeState=e;var r=this.globalUniforms.uniforms;r.outputFrame=e.sourceFrame,r.resolution=e.resolution;var n=r.inputSize,s=r.inputPixel,o=r.inputClamp;// only update the rect if its legacy..
if(n[0]=e.destinationFrame.width,n[1]=e.destinationFrame.height,n[2]=1/n[0],n[3]=1/n[1],s[0]=Math.round(n[0]*e.resolution),s[1]=Math.round(n[1]*e.resolution),s[2]=1/s[0],s[3]=1/s[1],o[0]=.5*s[2],o[1]=.5*s[3],o[2]=e.sourceFrame.width*n[2]-.5*s[2],o[3]=e.sourceFrame.height*n[3]-.5*s[3],e.legacy){var a=r.filterArea;a[0]=e.destinationFrame.width,a[1]=e.destinationFrame.height,a[2]=e.sourceFrame.x,a[3]=e.sourceFrame.y,r.filterClamp=r.inputClamp}this.globalUniforms.update();var h=t[t.length-1];if(this.renderer.framebuffer.blit(),1===i.length)i[0].apply(this,e.renderTexture,h.renderTexture,x6.BLEND,e),this.returnFilterTexture(e.renderTexture);else{var l=e.renderTexture,u=this.getOptimalFilterTexture(l.width,l.height,e.resolution);u.filterFrame=l.filterFrame;var c=0;for(c=0;c<i.length-1;++c){1===c&&e.multisample>1&&((u=this.getOptimalFilterTexture(l.width,l.height,e.resolution)).filterFrame=l.filterFrame),i[c].apply(this,l,u,x6.CLEAR,e);var d=l;l=u,u=d}i[c].apply(this,l,h.renderTexture,x6.BLEND,e),c>1&&e.multisample>1&&this.returnFilterTexture(e.renderTexture),this.returnFilterTexture(l),this.returnFilterTexture(u)}// lastState.renderTexture is blitted when lastState is popped
e.clear(),this.statePool.push(e)},/**
     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.
     *
     * @param {PIXI.RenderTexture} filterTexture - renderTexture to bind, should belong to filter pool or filter stack
     * @param {PIXI.CLEAR_MODES} [clearMode] - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}
     */t.prototype.bindAndClear=function(t,e){void 0===e&&(e=x6.CLEAR);var i=this.renderer,r=i.renderTexture,n=i.state;if(t===this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?this.renderer.projection.transform=this.activeState.transform:this.renderer.projection.transform=null,t&&t.filterFrame){var s=this.tempRect;s.x=0,s.y=0,s.width=t.filterFrame.width,s.height=t.filterFrame.height,r.bind(t,t.filterFrame,s)}else t!==this.defaultFilterStack[this.defaultFilterStack.length-1].renderTexture?r.bind(t):this.renderer.renderTexture.bind(t,this.activeState.bindingSourceFrame,this.activeState.bindingDestinationFrame);// Clear the texture in BLIT mode if blending is disabled or the forceClear flag is set. The blending
// is stored in the 0th bit of the state.
var o=1&n.stateId||this.forceClear;(e===x6.CLEAR||e===x6.BLIT&&o)&&// area over which the shaders are run. This is because filters may sampling outside of it (e.g. blur)
// instead of clamping their arithmetic.
this.renderer.framebuffer.clear(0,0,0,0)},/**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it
     */t.prototype.applyFilter=function(t,e,i,r){var n=this.renderer;// Set state before binding, so bindAndClear gets the blend mode.
n.state.set(t.state),this.bindAndClear(i,r),// set the uniforms..
t.uniforms.uSampler=e,t.uniforms.filterGlobals=this.globalUniforms,// TODO make it so that the order of this does not matter..
// because it does at the moment cos of global uniforms.
// they need to get resynced
n.shader.bind(t),// check to see if the filter is a legacy one..
t.legacy=!!t.program.attributeData.aTextureCoord,t.legacy?(this.quadUv.map(e._frame,e.filterFrame),n.geometry.bind(this.quadUv),n.geometry.draw(xZ.TRIANGLES)):(n.geometry.bind(this.quad),n.geometry.draw(xZ.TRIANGLE_STRIP))},/**
     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
     *
     * Use `outputMatrix * vTextureCoord` in the shader.
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */t.prototype.calculateSpriteMatrix=function(t,e){var i=this.activeState,r=i.sourceFrame,n=i.destinationFrame,s=e._texture.orig,o=t.set(n.width,0,0,n.height,r.x,r.y),a=e.worldTransform.copyTo(iX.TEMP_MATRIX);return a.invert(),o.prepend(a),o.scale(1/s.width,1/s.height),o.translate(e.anchor.x,e.anchor.y),o},/**
     * Destroys this Filter System.
     */t.prototype.destroy=function(){this.renderer=null,// Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem
this.texturePool.clear(!1)},/**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @param {PIXI.MSAA_QUALITY} [multisample=PIXI.MSAA_QUALITY.NONE] - Number of samples of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */t.prototype.getOptimalFilterTexture=function(t,e,i,r){return void 0===i&&(i=1),void 0===r&&(r=bt.NONE),this.texturePool.getOptimalTexture(t,e,i,r)},/**
     * Gets extra render texture to use inside current filter
     * To be compliant with older filters, you can use params in any order
     *
     * @param {PIXI.RenderTexture} [input] - renderTexture from which size and resolution will be copied
     * @param {number} [resolution] - override resolution of the renderTexture
     * @param {PIXI.MSAA_QUALITY} [multisample=PIXI.MSAA_QUALITY.NONE] - number of samples of the renderTexture
     * @returns {PIXI.RenderTexture}
     */t.prototype.getFilterTexture=function(t,e,i){if("number"==typeof t){var r=t;t=e,e=r}t=t||this.activeState.renderTexture;var n=this.texturePool.getOptimalTexture(t.width,t.height,e||t.resolution,i||bt.NONE);return n.filterFrame=t.filterFrame,n},/**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */t.prototype.returnFilterTexture=function(t){this.texturePool.returnTexture(t)},/**
     * Empties the texture pool.
     */t.prototype.emptyPool=function(){this.texturePool.clear(!0)},/**
     * calls `texturePool.resize()`, affects fullScreen renderTextures
     */t.prototype.resize=function(){this.texturePool.setScreenSize(this.renderer.view)},/**
     * @param {PIXI.Matrix} matrix - first param
     * @param {PIXI.Rectangle} rect - second param
     */t.prototype.transformAABB=function(t,e){var i=r5[0],r=r5[1],n=r5[2],s=r5[3];i.set(e.left,e.top),r.set(e.left,e.bottom),n.set(e.right,e.top),s.set(e.right,e.bottom),t.apply(i,i),t.apply(r,r),t.apply(n,n),t.apply(s,s);var o=Math.min(i.x,r.x,n.x,s.x),a=Math.min(i.y,r.y,n.y,s.y),h=Math.max(i.x,r.x,n.x,s.x),l=Math.max(i.y,r.y,n.y,s.y);e.x=o,e.y=a,e.width=h-o,e.height=l-a},t.prototype.roundFrame=function(t,e,i,r,n){if(n){var s=n.a,o=n.b,a=n.c,h=n.d;// Skip if skew/rotation present in matrix, except for multiple of 90 rotation. If rotation
// is a multiple of 90, then either pair of (b,c) or (a,d) will be (0,0).
if((Math.abs(o)>1e-4||Math.abs(a)>1e-4)&&(Math.abs(s)>1e-4||Math.abs(h)>1e-4))return}// Get forward transform from world space to screen space
(n=n?r4.copyFrom(n):r4.identity()).translate(-i.x,-i.y).scale(r.width/i.width,r.height/i.height).translate(r.x,r.y),// Convert frame to screen space
this.transformAABB(n,t),// Round frame in screen space
t.ceil(e),// Project back into world space.
this.transformAABB(n.invert(),t)},t)}(),r8=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this manager works for.
     */function t(t){/**
         * The renderer this manager works for.
         *
         * @member {PIXI.Renderer}
         */this.renderer=t}return(/**
     * Stub method that should be used to empty the current
     * batch by rendering objects now.
     */t.prototype.flush=function(){// flush!
},/**
     * Generic destruction method that frees all resources. This
     * should be called by subclasses.
     */t.prototype.destroy=function(){this.renderer=null},/**
     * Stub method that initializes any state required before
     * rendering starts. It is different from the `prerender`
     * signal, which occurs every frame, in that it is called
     * whenever an object requests _this_ renderer specifically.
     */t.prototype.start=function(){// set the shader..
},/**
     * Stops the renderer. It should free up any state and
     * become dormant.
     */t.prototype.stop=function(){this.flush()},/**
     * Keeps the object to render. It doesn't have to be
     * rendered immediately.
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */t.prototype.render=function(t){// render the object
},t)}(),r7=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */this.emptyRenderer=new r8(t),/**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */this.currentRenderer=this.emptyRenderer}return(/**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */t.prototype.setObjectRenderer=function(t){this.currentRenderer!==t&&(this.currentRenderer.stop(),this.currentRenderer=t,this.currentRenderer.start())},/**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */t.prototype.flush=function(){this.setObjectRenderer(this.emptyRenderer)},/**
     * Reset the system to an empty renderer
     */t.prototype.reset=function(){this.setObjectRenderer(this.emptyRenderer)},/**
     * Handy function for batch renderers: copies bound textures in first maxTextures locations to array
     * sets actual _batchLocation for them
     *
     * @param {PIXI.BaseTexture[]} arr - arr copy destination
     * @param {number} maxTextures - number of copied elements
     */t.prototype.copyBoundTextures=function(t,e){for(var i=this.renderer.texture.boundTextures,r=e-1;r>=0;--r)t[r]=i[r]||null,t[r]&&(t[r]._batchLocation=r)},/**
     * Assigns batch locations to textures in array based on boundTextures state.
     * All textures in texArray should have `_batchEnabled = _batchId`,
     * and their count should be less than `maxTextures`.
     *
     * @param {PIXI.BatchTextureArray} texArray - textures to bound
     * @param {PIXI.BaseTexture[]} boundTextures - current state of bound textures
     * @param {number} batchId - marker for _batchEnabled param of textures in texArray
     * @param {number} maxTextures - number of texture locations to manipulate
     */t.prototype.boundArray=function(t,e,i,r){for(var n=t.elements,s=t.ids,o=t.count,a=0,h=0;h<o;h++){var l=n[h],u=l._batchLocation;if(u>=0&&u<r&&e[u]===l){s[h]=u;continue}for(;a<r;){var c=e[a];if(c&&c._batchEnabled===i&&c._batchLocation===a){a++;continue}s[h]=a,l._batchLocation=a,e[a]=l;break}}},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),r9=0,nt=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */this.webGLVersion=1,/**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension
         */this.extensions={},/**
         * Features supported by current context
         * @member {object}
         * @private
         * @readonly
         * @property {boolean} uint32Indices - Supports of 32-bit indices buffer
         */this.supports={uint32Indices:!1},// Bind functions
this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this),t.view.addEventListener("webglcontextlost",this.handleContextLost,!1),t.view.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}return Object.defineProperty(t.prototype,"isLost",{/**
         * `true` if the context is lost
         * @member {boolean}
         * @readonly
         */get:function(){return!this.gl||this.gl.isContextLost()},enumerable:!1,configurable:!0}),/**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl - new webgl context
     */t.prototype.contextChange=function(t){this.gl=t,this.renderer.gl=t,this.renderer.CONTEXT_UID=r9++,t.isContextLost()&&t.getExtension("WEBGL_lose_context")&&t.getExtension("WEBGL_lose_context").restoreContext()},/**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */t.prototype.initFromContext=function(t){this.gl=t,this.validateContext(t),this.renderer.gl=t,this.renderer.CONTEXT_UID=r9++,this.renderer.runners.contextChange.emit(t)},/**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */t.prototype.initFromOptions=function(t){var e=this.createContext(this.renderer.view,t);this.initFromContext(e)},/**
     * Helper class to create a WebGL Context
     *
     * @param {HTMLCanvasElement} canvas - the canvas element that we will get the context from
     * @param {object} options - An options object that gets passed in to the canvas element containing the
     *    context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */t.prototype.createContext=function(t,e){var i;if(ec.PREFER_ENV>=xY.WEBGL2&&(i=t.getContext("webgl2",e)),i)this.webGLVersion=2;else if(this.webGLVersion=1,!(i=t.getContext("webgl",e)||t.getContext("experimental-webgl",e)))throw Error("This browser does not support WebGL. Try using the canvas renderer");return this.gl=i,this.getExtensions(),this.gl},/**
     * Auto-populate the extensions
     *
     * @protected
     */t.prototype.getExtensions=function(){// time to set up default extensions that Pixi uses.
var t=this.gl,e={anisotropicFiltering:t.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:t.getExtension("OES_texture_float_linear"),s3tc:t.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:t.getExtension("WEBGL_compressed_texture_etc"),etc1:t.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:t.getExtension("WEBGL_compressed_texture_atc"),astc:t.getExtension("WEBGL_compressed_texture_astc")};1===this.webGLVersion?Object.assign(this.extensions,e,{drawBuffers:t.getExtension("WEBGL_draw_buffers"),depthTexture:t.getExtension("WEBGL_depth_texture"),loseContext:t.getExtension("WEBGL_lose_context"),vertexArrayObject:t.getExtension("OES_vertex_array_object")||t.getExtension("MOZ_OES_vertex_array_object")||t.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:t.getExtension("OES_element_index_uint"),// Floats and half-floats
floatTexture:t.getExtension("OES_texture_float"),floatTextureLinear:t.getExtension("OES_texture_float_linear"),textureHalfFloat:t.getExtension("OES_texture_half_float"),textureHalfFloatLinear:t.getExtension("OES_texture_half_float_linear")}):2===this.webGLVersion&&Object.assign(this.extensions,e,{// Floats and half-floats
colorBufferFloat:t.getExtension("EXT_color_buffer_float")})},/**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */t.prototype.handleContextLost=function(t){t.preventDefault()},/**
     * Handles a restored webgl context
     *
     * @protected
     */t.prototype.handleContextRestored=function(){this.renderer.runners.contextChange.emit(this.gl)},t.prototype.destroy=function(){var t=this.renderer.view;this.renderer=null,// remove listeners
t.removeEventListener("webglcontextlost",this.handleContextLost),t.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()},/**
     * Handle the post-render runner event
     *
     * @protected
     */t.prototype.postrender=function(){this.renderer.renderingToScreen&&this.gl.flush()},/**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */t.prototype.validateContext=function(t){var e=t.getContextAttributes(),i="WebGL2RenderingContext"in self&&t instanceof self.WebGL2RenderingContext;i&&(this.webGLVersion=2),e.stencil||/* eslint-disable max-len, no-console */console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");var r=i||!!t.getExtension("OES_element_index_uint");this.supports.uint32Indices=r,r||/* eslint-disable max-len, no-console */console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")},t}(),ne=function(t){/**
         * The WebGL framebuffer
         * @member {WebGLFramebuffer}
         */this.framebuffer=t,/**
         * stencil+depth , usually costs 32bits per pixel
         * @member {WebGLRenderbuffer}
         */this.stencil=null,/**
         * latest known version of framebuffer
         * @member {number}
         * @protected
         */this.dirtyId=-1,/**
         * latest known version of framebuffer format
         * @member {number}
         * @protected
         */this.dirtyFormat=-1,/**
         * latest known version of framebuffer size
         * @member {number}
         * @protected
         */this.dirtySize=-1,/**
         * Detected AA samples number
         * @member {PIXI.MSAA_QUALITY}
         */this.multisample=bt.NONE,/**
         * In case MSAA, we use this Renderbuffer instead of colorTextures[0] when we write info
         * @member {WebGLRenderbuffer}
         */this.msaaBuffer=null,/**
         * In case we use MSAA, this is actual framebuffer that has colorTextures[0]
         * The contents of that framebuffer are read when we use that renderTexture in sprites
         * @member {PIXI.Framebuffer}
         */this.blitFramebuffer=null,/**
         * store the current mipmap of the textures the framebuffer will write too.
         */this.mipLevel=0},ni=new iU,nr=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */this.managedFramebuffers=[],/**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */this.unknownFramebuffer=new rB(10,10),this.msaaSamples=null}return(/**
     * Sets up the renderer context and necessary buffers.
     */t.prototype.contextChange=function(){var t=this.gl=this.renderer.gl;// webgl2
if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.current=this.unknownFramebuffer,this.viewport=new iU,this.hasMRT=!0,this.writeDepthTexture=!0,this.disposeAll(!0),1===this.renderer.context.webGLVersion){// webgl 1!
var e=this.renderer.context.extensions.drawBuffers,i=this.renderer.context.extensions.depthTexture;ec.PREFER_ENV===xY.WEBGL_LEGACY&&(e=null,i=null),e?t.drawBuffers=function(t){return e.drawBuffersWEBGL(t)}:(this.hasMRT=!1,t.drawBuffers=function(){// empty
}),i||(this.writeDepthTexture=!1)}else // cache possible MSAA samples
this.msaaSamples=t.getInternalformatParameter(t.RENDERBUFFER,t.RGBA8,t.SAMPLES)},/**
     * Bind a framebuffer
     *
     * @param {PIXI.Framebuffer} [framebuffer]
     * @param {PIXI.Rectangle} [frame] - frame, default is framebuffer size
     * @param {number} [mipLevel] - optional mip level to set on the framebuffer - defaults to 0
     */t.prototype.bind=function(t,e,i){void 0===i&&(i=0);var r=this.gl;if(t){// TODO caching layer!
var n=t.glFramebuffers[this.CONTEXT_UID]||this.initFramebuffer(t);this.current!==t&&(this.current=t,r.bindFramebuffer(r.FRAMEBUFFER,n.framebuffer)),n.mipLevel!==i&&(t.dirtyId++,t.dirtyFormat++,n.mipLevel=i),n.dirtyId!==t.dirtyId&&(n.dirtyId=t.dirtyId,n.dirtyFormat!==t.dirtyFormat?(n.dirtyFormat=t.dirtyFormat,n.dirtySize=t.dirtySize,this.updateFramebuffer(t,i)):n.dirtySize!==t.dirtySize&&(n.dirtySize=t.dirtySize,this.resizeFramebuffer(t)));for(var s=0;s<t.colorTextures.length;s++){var o=t.colorTextures[s];this.renderer.texture.unbind(o.parentTextureArray||o)}if(t.depthTexture&&this.renderer.texture.unbind(t.depthTexture),e){var a=e.width>>i,h=e.height>>i,l=a/e.width;this.setViewport(e.x*l,e.y*l,a,h)}else{var a=t.width>>i,h=t.height>>i;this.setViewport(0,0,a,h)}}else this.current&&(this.current=null,r.bindFramebuffer(r.FRAMEBUFFER,null)),e?this.setViewport(e.x,e.y,e.width,e.height):this.setViewport(0,0,this.renderer.width,this.renderer.height)},/**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */t.prototype.setViewport=function(t,e,i,r){var n=this.viewport;t=Math.round(t),e=Math.round(e),i=Math.round(i),r=Math.round(r),(n.width!==i||n.height!==r||n.x!==t||n.y!==e)&&(n.x=t,n.y=e,n.width=i,n.height=r,this.gl.viewport(t,e,i,r))},Object.defineProperty(t.prototype,"size",{/**
         * Get the size of the current width and height. Returns object with `width` and `height` values.
         *
         * @member {object}
         * @readonly
         */get:function(){return this.current?{x:0,y:0,width:this.current.width,height:this.current.height}:{x:0,y:0,width:this.renderer.width,height:this.renderer.height}},enumerable:!1,configurable:!0}),/**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
     */t.prototype.clear=function(t,e,i,r,n){void 0===n&&(n=xK.COLOR|xK.DEPTH);var s=this.gl;// TODO clear color can be set only one right?
s.clearColor(t,e,i,r),s.clear(n)},/**
     * Initialize framebuffer for this context
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     * @returns {PIXI.GLFramebuffer} created GLFramebuffer
     */t.prototype.initFramebuffer=function(t){var e=this.gl,i=new ne(e.createFramebuffer());return i.multisample=this.detectSamples(t.multisample),t.glFramebuffers[this.CONTEXT_UID]=i,this.managedFramebuffers.push(t),t.disposeRunner.add(this),i},/**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */t.prototype.resizeFramebuffer=function(t){var e=this.gl,i=t.glFramebuffers[this.CONTEXT_UID];i.msaaBuffer&&(e.bindRenderbuffer(e.RENDERBUFFER,i.msaaBuffer),e.renderbufferStorageMultisample(e.RENDERBUFFER,i.multisample,e.RGBA8,t.width,t.height)),i.stencil&&(e.bindRenderbuffer(e.RENDERBUFFER,i.stencil),i.msaaBuffer?e.renderbufferStorageMultisample(e.RENDERBUFFER,i.multisample,e.DEPTH24_STENCIL8,t.width,t.height):e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,t.width,t.height));var r=t.colorTextures,n=r.length;e.drawBuffers||(n=Math.min(n,1));for(var s=0;s<n;s++){var o=r[s],a=o.parentTextureArray||o;this.renderer.texture.bind(a,0)}t.depthTexture&&this.writeDepthTexture&&this.renderer.texture.bind(t.depthTexture,0)},/**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     * @param {number} mipLevel
     */t.prototype.updateFramebuffer=function(t,e){var i=this.gl,r=t.glFramebuffers[this.CONTEXT_UID],n=t.colorTextures,s=n.length;i.drawBuffers||(s=Math.min(s,1)),r.multisample>1&&this.canMultisampleFramebuffer(t)?(r.msaaBuffer=r.msaaBuffer||i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,r.msaaBuffer),i.renderbufferStorageMultisample(i.RENDERBUFFER,r.multisample,i.RGBA8,t.width,t.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,r.msaaBuffer)):r.msaaBuffer&&(i.deleteRenderbuffer(r.msaaBuffer),r.msaaBuffer=null);for(var o=[],a=0;a<s;a++){var h=n[a],l=h.parentTextureArray||h;this.renderer.texture.bind(l,0),0===a&&r.msaaBuffer||(i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+a,h.target,l._glTextures[this.CONTEXT_UID].texture,e),o.push(i.COLOR_ATTACHMENT0+a))}if(o.length>1&&i.drawBuffers(o),t.depthTexture&&this.writeDepthTexture){var u=t.depthTexture;this.renderer.texture.bind(u,0),i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,u._glTextures[this.CONTEXT_UID].texture,e)}(t.stencil||t.depth)&&!(t.depthTexture&&this.writeDepthTexture)?(r.stencil=r.stencil||i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,r.stencil),r.msaaBuffer?i.renderbufferStorageMultisample(i.RENDERBUFFER,r.multisample,i.DEPTH24_STENCIL8,t.width,t.height):i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_STENCIL,t.width,t.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,r.stencil)):r.stencil&&(i.deleteRenderbuffer(r.stencil),r.stencil=null)},/**
     * Returns true if the frame buffer can be multisampled
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */t.prototype.canMultisampleFramebuffer=function(t){return 1!==this.renderer.context.webGLVersion&&t.colorTextures.length<=1&&!t.depthTexture},/**
     * Detects number of samples that is not more than a param but as close to it as possible
     *
     * @param {PIXI.MSAA_QUALITY} samples - number of samples
     * @returns {PIXI.MSAA_QUALITY} - recommended number of samples
     */t.prototype.detectSamples=function(t){var e=this.msaaSamples,i=bt.NONE;if(t<=1||null===e)return i;for(var r=0;r<e.length;r++)if(e[r]<=t){i=e[r];break}return 1===i&&(i=bt.NONE),i},/**
     * Only works with WebGL2
     *
     * blits framebuffer to another of the same or bigger size
     * after that target framebuffer is bound
     *
     * Fails with WebGL warning if blits multisample framebuffer to different size
     *
     * @param {PIXI.Framebuffer} [framebuffer] - by default it blits "into itself", from renderBuffer to texture.
     * @param {PIXI.Rectangle} [sourcePixels] - source rectangle in pixels
     * @param {PIXI.Rectangle} [destPixels] - dest rectangle in pixels, assumed to be the same as sourcePixels
     */t.prototype.blit=function(t,e,i){var r=this.current,n=this.renderer,s=this.gl,o=this.CONTEXT_UID;if(2===n.context.webGLVersion&&r){var a=r.glFramebuffers[o];if(a){if(!t){if(!a.msaaBuffer)return;a.blitFramebuffer||(a.blitFramebuffer=new rB(r.width,r.height),a.blitFramebuffer.addColorTexture(0,r.colorTextures[0])),(t=a.blitFramebuffer).width=r.width,t.height=r.height}e||((e=ni).width=r.width,e.height=r.height),i||(i=e);var h=e.width===i.width&&e.height===i.height;this.bind(t),s.bindFramebuffer(s.READ_FRAMEBUFFER,a.framebuffer),s.blitFramebuffer(e.x,e.y,e.width,e.height,i.x,i.y,i.width,i.height,s.COLOR_BUFFER_BIT,h?s.NEAREST:s.LINEAR)}}},/**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer - framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] - If context was lost, we suppress all delete function calls
     */t.prototype.disposeFramebuffer=function(t,e){var i=t.glFramebuffers[this.CONTEXT_UID],r=this.gl;if(i){delete t.glFramebuffers[this.CONTEXT_UID];var n=this.managedFramebuffers.indexOf(t);n>=0&&this.managedFramebuffers.splice(n,1),t.disposeRunner.remove(this),!e&&(r.deleteFramebuffer(i.framebuffer),i.msaaBuffer&&r.deleteRenderbuffer(i.msaaBuffer),i.stencil&&r.deleteRenderbuffer(i.stencil))}},/**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] - If context was lost, we suppress all delete function calls
     */t.prototype.disposeAll=function(t){var e=this.managedFramebuffers;this.managedFramebuffers=[];for(var i=0;i<e.length;i++)this.disposeFramebuffer(e[i],t)},/**
     * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.
     * Used by MaskSystem, when its time to use stencil mask for Graphics element.
     *
     * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.
     *
     * @private
     */t.prototype.forceStencil=function(){var t=this.current;if(t){var e=t.glFramebuffers[this.CONTEXT_UID];if(e&&!e.stencil){t.stencil=!0;var i=t.width,r=t.height,n=this.gl,s=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,s),e.msaaBuffer?n.renderbufferStorageMultisample(n.RENDERBUFFER,e.multisample,n.DEPTH24_STENCIL8,i,r):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,i,r),e.stencil=s,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,s)}}},/**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */t.prototype.reset=function(){this.current=this.unknownFramebuffer,this.viewport=new iU},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),nn={5126:4,5123:2,5121:1},ns=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,this._activeGeometry=null,this._activeVao=null,/**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */this.hasVao=!0,/**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */this.hasInstance=!0,/**
         * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`
         * @member {boolean}
         * @readonly
         */this.canUseUInt32ElementIndex=!1,/**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */this.managedGeometries={}}return(/**
     * Sets up the renderer context and necessary buffers.
     */t.prototype.contextChange=function(){this.disposeAll(!0);var t=this.gl=this.renderer.gl,e=this.renderer.context;// webgl2
if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,2!==e.webGLVersion){// webgl 1!
var i=this.renderer.context.extensions.vertexArrayObject;ec.PREFER_ENV===xY.WEBGL_LEGACY&&(i=null),i?(t.createVertexArray=function(){return i.createVertexArrayOES()},t.bindVertexArray=function(t){return i.bindVertexArrayOES(t)},t.deleteVertexArray=function(t){return i.deleteVertexArrayOES(t)}):(this.hasVao=!1,t.createVertexArray=function(){return null},t.bindVertexArray=function(){return null},t.deleteVertexArray=function(){return null})}if(2!==e.webGLVersion){var r=t.getExtension("ANGLE_instanced_arrays");r?(t.vertexAttribDivisor=function(t,e){return r.vertexAttribDivisorANGLE(t,e)},t.drawElementsInstanced=function(t,e,i,n,s){return r.drawElementsInstancedANGLE(t,e,i,n,s)},t.drawArraysInstanced=function(t,e,i,n){return r.drawArraysInstancedANGLE(t,e,i,n)}):this.hasInstance=!1}this.canUseUInt32ElementIndex=2===e.webGLVersion||!!e.extensions.uint32ElementIndex},/**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     *
     * @param {PIXI.Geometry} geometry - instance of geometry to bind
     * @param {PIXI.Shader} [shader] - instance of shader to use vao for
     */t.prototype.bind=function(t,e){e=e||this.renderer.shader.shader;var i=this.gl,r=t.glVertexArrayObjects[this.CONTEXT_UID],n=!1;r||(this.managedGeometries[t.id]=t,t.disposeRunner.add(this),t.glVertexArrayObjects[this.CONTEXT_UID]=r={},n=!0);var s=r[e.program.id]||this.initGeometryVao(t,e,n);this._activeGeometry=t,this._activeVao!==s&&(this._activeVao=s,this.hasVao?i.bindVertexArray(s):this.activateVao(t,e.program)),// TODO - optimise later!
// don't need to loop through if nothing changed!
// maybe look to add an 'autoupdate' to geometry?
this.updateBuffers()},/**
     * Reset and unbind any active VAO and geometry
     */t.prototype.reset=function(){this.unbind()},/**
     * Update buffers
     * @protected
     */t.prototype.updateBuffers=function(){for(var t=this._activeGeometry,e=this.renderer.buffer,i=0;i<t.buffers.length;i++){var r=t.buffers[i];e.update(r)}},/**
     * Check compatibility between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */t.prototype.checkCompatibility=function(t,e){// geometry must have at least all the attributes that the shader requires.
var i=t.attributes,r=e.attributeData;for(var n in r)if(!i[n])throw Error('shader and geometry incompatible, geometry missing the "'+n+'" attribute')},/**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry - to get signature from
     * @param {PIXI.Program} program - to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */t.prototype.getSignature=function(t,e){var i=t.attributes,r=e.attributeData,n=["g",t.id];for(var s in i)r[s]&&n.push(s);return n.join("-")},/**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
     * attribute locations.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Shader} shader - Instance of the shader
     * @param {boolean} [incRefCount=false] - Increment refCount of all geometry buffers
     */t.prototype.initGeometryVao=function(t,e,i){void 0===i&&(i=!0);var r=this.gl,n=this.CONTEXT_UID,s=this.renderer.buffer,o=e.program;o.glPrograms[n]||this.renderer.shader.generateProgram(e),this.checkCompatibility(t,o);var a=this.getSignature(t,o),h=t.glVertexArrayObjects[this.CONTEXT_UID],l=h[a];if(l)return(// this will give us easy access to the vao
h[o.id]=l,l);var u=t.buffers,c=t.attributes,d={},p={};for(var f in u)d[f]=0,p[f]=0;for(var f in c)!c[f].size&&o.attributeData[f]?c[f].size=o.attributeData[f].size:c[f].size||console.warn("PIXI Geometry attribute '"+f+"' size cannot be determined (likely the bound shader does not have the attribute)"),d[c[f].buffer]+=c[f].size*nn[c[f].type];for(var f in c){var m=c[f],g=m.size;void 0===m.stride&&(d[m.buffer]===g*nn[m.type]?m.stride=0:m.stride=d[m.buffer]),void 0===m.start&&(m.start=p[m.buffer],p[m.buffer]+=g*nn[m.type])}l=r.createVertexArray(),r.bindVertexArray(l);// first update - and create the buffers!
// only create a gl buffer if it actually gets
for(var y=0;y<u.length;y++){var _=u[y];s.bind(_),i&&_._glBuffers[n].refCount++}return(// TODO - maybe make this a data object?
// lets wait to see if we need to first!
this.activateVao(t,o),this._activeVao=l,// add it to the cache!
h[o.id]=l,h[a]=l,l)},/**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry - Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */t.prototype.disposeGeometry=function(t,e){if(this.managedGeometries[t.id]){delete this.managedGeometries[t.id];var i,r=t.glVertexArrayObjects[this.CONTEXT_UID],n=this.gl,s=t.buffers,o=null===(i=this.renderer)||void 0===i?void 0:i.buffer;if(t.disposeRunner.remove(this),r){// bufferSystem may have already been destroyed..
// if this is the case, there is no need to destroy the geometry buffers...
// they already have been!
if(o)for(var a=0;a<s.length;a++){var h=s[a]._glBuffers[this.CONTEXT_UID];// my be null as context may have changed right before the dispose is called
h&&(h.refCount--,0!==h.refCount||e||o.dispose(s[a],e))}if(!e){for(var l in r)if("g"===l[0]){var u=r[l];this._activeVao===u&&this.unbind(),n.deleteVertexArray(u)}}delete t.glVertexArrayObjects[this.CONTEXT_UID]}}},/**
     * dispose all WebGL resources of all managed geometries
     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
     */t.prototype.disposeAll=function(t){for(var e=Object.keys(this.managedGeometries),i=0;i<e.length;i++)this.disposeGeometry(this.managedGeometries[e[i]],t)},/**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */t.prototype.activateVao=function(t,e){var i=this.gl,r=this.CONTEXT_UID,n=this.renderer.buffer,s=t.buffers,o=t.attributes;t.indexBuffer&&n.bind(t.indexBuffer);var a=null;// add a new one!
for(var h in o){var l=o[h],u=s[l.buffer],c=u._glBuffers[r];if(e.attributeData[h]){a!==c&&(n.bind(u),a=c);var d=e.attributeData[h].location;if(// TODO introduce state again
// we can optimise this for older devices that have no VAOs
i.enableVertexAttribArray(d),i.vertexAttribPointer(d,l.size,l.type||i.FLOAT,l.normalized,l.stride,l.start),l.instance){// TODO calculate instance count based of this...
if(this.hasInstance)i.vertexAttribDivisor(d,1);else throw Error("geometry error, GPU Instancing is not supported on this device")}}}},/**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */t.prototype.draw=function(t,e,i,r){var n=this.gl,s=this._activeGeometry;// TODO.. this should not change so maybe cache the function?
if(s.indexBuffer){var o=s.indexBuffer.data.BYTES_PER_ELEMENT,a=2===o?n.UNSIGNED_SHORT:n.UNSIGNED_INT;2===o||4===o&&this.canUseUInt32ElementIndex?s.instanced?/* eslint-disable max-len */n.drawElementsInstanced(t,e||s.indexBuffer.data.length,a,(i||0)*o,r||1):/* eslint-disable max-len */n.drawElements(t,e||s.indexBuffer.data.length,a,(i||0)*o):console.warn("unsupported index buffer type: uint32")}else s.instanced?n.drawArraysInstanced(t,i,e||s.getSize(),r||1):n.drawArrays(t,i,e||s.getSize());return this},/**
     * Unbind/reset everything
     * @protected
     */t.prototype.unbind=function(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),no=/** @class */function(){/**
     * Create MaskData
     *
     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask
     */function t(t){void 0===t&&(t=null),/**
         * Mask type
         * @member {PIXI.MASK_TYPES}
         */this.type=x9.NONE,/**
         * Whether we know the mask type beforehand
         * @member {boolean}
         * @default true
         */this.autoDetect=!0,/**
         * Which element we use to mask
         * @member {PIXI.DisplayObject}
         */this.maskObject=t||null,/**
         * Whether it belongs to MaskSystem pool
         * @member {boolean}
         */this.pooled=!1,/**
         * Indicator of the type
         * @member {boolean}
         */this.isMaskData=!0,/**
         * Resolution of the sprite mask filter.
         * If set to `null` or `0`, the resolution of the current render target is used.
         * @member {number}
         */this.resolution=null,/**
         * Number of samples of the sprite mask filter.
         * If set to `null`, the sample count of the current render target is used.
         * @member {PIXI.MSAA_QUALITY}
         * @default {PIXI.settings.FILTER_MULTISAMPLE}
         */this.multisample=ec.FILTER_MULTISAMPLE,/**
         * Stencil counter above the mask in stack
         * @member {number}
         * @private
         */this._stencilCounter=0,/**
         * Scissor counter above the mask in stack
         * @member {number}
         * @private
         */this._scissorCounter=0,/**
         * Scissor operation above the mask in stack.
         * Null if _scissorCounter is zero, rectangle instance if positive.
         * @member {PIXI.Rectangle}
         */this._scissorRect=null,/**
         * Targeted element. Temporary variable set by MaskSystem
         * @member {PIXI.DisplayObject}
         * @private
         */this._target=null}return(/**
     * resets the mask data after popMask()
     */t.prototype.reset=function(){this.pooled&&(this.maskObject=null,this.type=x9.NONE,this.autoDetect=!0),this._target=null},/**
     * copies counters from maskData above, called from pushMask()
     * @param {PIXI.MaskData|null} maskAbove
     */t.prototype.copyCountersOrReset=function(t){t?(this._stencilCounter=t._stencilCounter,this._scissorCounter=t._scissorCounter,this._scissorRect=t._scissorRect):(this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null)},t)}();/**
 * @private
 * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}
 * @param {Number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param {string} src - The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */function na(t,e,i){var r=t.createShader(e);return t.shaderSource(r,i),t.compileShader(r),r}/**
 * will log a shader error highlighting the lines with the error
 * also will add numbers along the side.
 *
 * @param gl - the WebGLContext
 * @param shader - the shader to log errors for
 */function nh(t,e){var i=t.getShaderSource(e).split("\n").map(function(t,e){return e+": "+t}),r=t.getShaderInfoLog(e),n=r.split("\n"),s={},o=n.map(function(t){return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))}).filter(function(t){return!!t&&!s[t]&&(s[t]=!0,!0)}),a=[""];o.forEach(function(t){i[t-1]="%c"+i[t-1]+"%c",a.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});var h=i.join("\n");a[0]=h,console.error(r),// eslint-disable-next-line no-console
console.groupCollapsed("click to view full shader code"),console.warn.apply(console,a),// eslint-disable-next-line no-console
console.groupEnd()}function nl(t){for(var e=Array(t),i=0;i<e.length;i++)e[i]=!1;return e}/**
 * @method defaultValue
 * @memberof PIXI.glCore.shader
 * @param {string} type - Type of value
 * @param {number} size
 * @private
 */function nu(t,e){switch(t){case"float":case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"vec2":return new Float32Array(2*e);case"vec3":return new Float32Array(3*e);case"vec4":return new Float32Array(4*e);case"ivec2":return new Int32Array(2*e);case"ivec3":return new Int32Array(3*e);case"ivec4":return new Int32Array(4*e);case"uvec2":return new Uint32Array(2*e);case"uvec3":return new Uint32Array(3*e);case"uvec4":return new Uint32Array(4*e);case"bool":return!1;case"bvec2":return nl(2*e);case"bvec3":return nl(3*e);case"bvec4":return nl(4*e);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}var nc={},nd=nc;/**
 * returns a little WebGL context to use for program inspection.
 *
 * @static
 * @private
 * @returns {WebGLRenderingContext} a gl context to test with
 */function np(){if(nd===nc||nd&&nd.isContextLost()){var t=document.createElement("canvas"),e=void 0;ec.PREFER_ENV>=xY.WEBGL2&&(e=t.getContext("webgl2",{})),e||((e=t.getContext("webgl",{})||t.getContext("experimental-webgl",{}))?e.getExtension("WEBGL_draw_buffers"):e=null),nd=e}return nd}/**
 * Sets the float precision on the shader, ensuring the device supports the request precision.
 * If the precision is already present, it just ensures that the device is able to handle it.
 *
 * @private
 * @param {string} src - The shader source
 * @param {PIXI.PRECISION} requestedPrecision - The request float precision of the shader.
 * @param {PIXI.PRECISION} maxSupportedPrecision - The maximum precision the shader supports.
 *
 * @return {string} modified shader source
 */function nf(t,e,i){if("precision"!==t.substring(0,9)){// no precision supplied, so PixiJS will add the requested level.
var r=e;return e===x7.HIGH&&i!==x7.HIGH&&(r=x7.MEDIUM),"precision "+r+" float;\n"+t}return i!==x7.HIGH&&"precision highp"===t.substring(0,15)?t.replace("precision highp","precision mediump"):t}var nm={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1},ng=null,ny={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function n_(t,e){if(!ng){var i=Object.keys(ny);ng={};for(var r=0;r<i.length;++r){var n=i[r];ng[t[n]]=ny[n]}}return ng[e]}/* eslint-disable @typescript-eslint/explicit-module-boundary-types */// Parsers, each one of these will take a look at the type of shader property and uniform.
// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.
// Shader upload code is automagically generated with these parsers.
// If no parser is valid then the default upload functions are used.
// exposing Parsers means that custom upload logic can be added to pixi's shaders.
// A good example would be a pixi rectangle can be directly set on a uniform.
// If the shader sees it it knows how to upload the rectangle structure as a vec4
// format is as follows:
//
// {
//     test: (data, uniform) => {} <--- test is this code should be used for this uniform
//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform
//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the
//                                         uniform to a uniform buffer
// }
var nv=[// a float cache layer
{test:function(t){return"float"===t.type&&1===t.size},code:function(t){return'\n            if(uv["'+t+'"] !== ud["'+t+'"].value)\n            {\n                ud["'+t+'"].value = uv["'+t+'"]\n                gl.uniform1f(ud["'+t+'"].location, uv["'+t+'"])\n            }\n            '}},// handling samplers
{test:function(t){// eslint-disable-next-line max-len
return("sampler2D"===t.type||"samplerCube"===t.type||"sampler2DArray"===t.type)&&1===t.size&&!t.isArray},code:function(t){return't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["'+t+'"], t);\n\n            if(ud["'+t+'"].value !== t)\n            {\n                ud["'+t+'"].value = t;\n                gl.uniform1i(ud["'+t+'"].location, t);\n; // eslint-disable-line max-len\n            }'}},// uploading pixi matrix object to mat3
{test:function(t,e){return"mat3"===t.type&&1===t.size&&void 0!==e.a},code:function(t){// TODO and some smart caching dirty ids here!
return'\n            gl.uniformMatrix3fv(ud["'+t+'"].location, false, uv["'+t+'"].toArray(true));\n            '},codeUbo:function(t){return"\n                var "+t+"_matrix = uv."+t+".toArray(true);\n\n                data[offset] = "+t+"_matrix[0];\n                data[offset+1] = "+t+"_matrix[1];\n                data[offset+2] = "+t+"_matrix[2];\n        \n                data[offset + 4] = "+t+"_matrix[3];\n                data[offset + 5] = "+t+"_matrix[4];\n                data[offset + 6] = "+t+"_matrix[5];\n        \n                data[offset + 8] = "+t+"_matrix[6];\n                data[offset + 9] = "+t+"_matrix[7];\n                data[offset + 10] = "+t+"_matrix[8];\n            "}},// uploading a pixi point as a vec2 with caching layer
{test:function(t,e){return"vec2"===t.type&&1===t.size&&void 0!==e.x},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["'+t+'"].location, v.x, v.y);\n                }'},codeUbo:function(t){return"\n                v = uv."+t+";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            "}},// caching layer for a vec2
{test:function(t){return"vec2"===t.type&&1===t.size},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["'+t+'"].location, v[0], v[1]);\n                }\n            '}},// upload a pixi rectangle as a vec4 with caching layer
{test:function(t,e){return"vec4"===t.type&&1===t.size&&void 0!==e.width},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["'+t+'"].location, v.x, v.y, v.width, v.height)\n                }'},codeUbo:function(t){return"\n                    v = uv."+t+";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                "}},// a caching layer for vec4 uploading
{test:function(t){return"vec4"===t.type&&1===t.size},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["'+t+'"].location, v[0], v[1], v[2], v[3])\n                }'}}],nx={float:"\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",vec2:"\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",vec3:"\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",vec4:"gl.uniform4f(location, v[0], v[1], v[2], v[3])",int:"gl.uniform1i(location, v)",ivec2:"gl.uniform2i(location, v[0], v[1])",ivec3:"gl.uniform3i(location, v[0], v[1], v[2])",ivec4:"gl.uniform4i(location, v[0], v[1], v[2], v[3])",uint:"gl.uniform1ui(location, v)",uvec2:"gl.uniform2ui(location, v[0], v[1])",uvec3:"gl.uniform3ui(location, v[0], v[1], v[2])",uvec4:"gl.uniform4ui(location, v[0], v[1], v[2], v[3])",bool:"gl.uniform1i(location, v)",bvec2:"gl.uniform2i(location, v[0], v[1])",bvec3:"gl.uniform3i(location, v[0], v[1], v[2])",bvec4:"gl.uniform4i(location, v[0], v[1], v[2], v[3])",mat2:"gl.uniformMatrix2fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",sampler2D:"gl.uniform1i(location, v)",samplerCube:"gl.uniform1i(location, v)",sampler2DArray:"gl.uniform1i(location, v)"},nb={float:"gl.uniform1fv(location, v)",vec2:"gl.uniform2fv(location, v)",vec3:"gl.uniform3fv(location, v)",vec4:"gl.uniform4fv(location, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat2:"gl.uniformMatrix2fv(location, false, v)",int:"gl.uniform1iv(location, v)",ivec2:"gl.uniform2iv(location, v)",ivec3:"gl.uniform3iv(location, v)",ivec4:"gl.uniform4iv(location, v)",uint:"gl.uniform1uiv(location, v)",uvec2:"gl.uniform2uiv(location, v)",uvec3:"gl.uniform3uiv(location, v)",uvec4:"gl.uniform4uiv(location, v)",bool:"gl.uniform1iv(location, v)",bvec2:"gl.uniform2iv(location, v)",bvec3:"gl.uniform3iv(location, v)",bvec4:"gl.uniform4iv(location, v)",sampler2D:"gl.uniform1iv(location, v)",samplerCube:"gl.uniform1iv(location, v)",sampler2DArray:"gl.uniform1iv(location, v)"};function nE(t,e){if(0===t)throw Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");for(var i=e.createShader(e.FRAGMENT_SHADER);;){var r="precision mediump float;\nvoid main(void){\nfloat test = 0.1;\n%forloop%\ngl_FragColor = vec4(0.0);\n}".replace(/%forloop%/gi,function(t){for(var e="",i=0;i<t;++i)i>0&&(e+="\nelse "),i<t-1&&(e+="if(test == "+i+".0){}");return e}(t));if(e.shaderSource(i,r),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS))break;t=t/2|0}return t}var nT=0,nw={},nS=/** @class */function(){/**
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {string} [name] - Name for shader
     */function t(e,i,r){void 0===r&&(r="pixi-shader"),this.id=nT++,/**
         * The vertex shader.
         *
         * @member {string}
         */this.vertexSrc=e||t.defaultVertexSrc,/**
         * The fragment shader.
         *
         * @member {string}
         */this.fragmentSrc=i||t.defaultFragmentSrc,this.vertexSrc=this.vertexSrc.trim(),this.fragmentSrc=this.fragmentSrc.trim(),"#version"!==this.vertexSrc.substring(0,8)&&(nw[r=r.replace(/\s+/g,"-")]?(nw[r]++,r+="-"+nw[r]):nw[r]=1,this.vertexSrc="#define SHADER_NAME "+r+"\n"+this.vertexSrc,this.fragmentSrc="#define SHADER_NAME "+r+"\n"+this.fragmentSrc,this.vertexSrc=nf(this.vertexSrc,ec.PRECISION_VERTEX,x7.HIGH),this.fragmentSrc=nf(this.fragmentSrc,ec.PRECISION_FRAGMENT,function(){if(!bo){bo=x7.MEDIUM;var t=np();t&&t.getShaderPrecisionFormat&&(bo=t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision?x7.HIGH:x7.MEDIUM)}return bo}())),// currently this does not extract structs only default types
// this is where we store shader references..
this.glPrograms={},this.syncUniforms=null}return Object.defineProperty(t,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @constant
         * @member {string}
         */get:function(){return"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"},enumerable:!1,configurable:!0}),Object.defineProperty(t,"defaultFragmentSrc",{/**
         * The default fragment shader source
         *
         * @static
         * @constant
         * @member {string}
         */get:function(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"},enumerable:!1,configurable:!0}),/**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {string} [name=pixi-shader] - Name for shader
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */t.from=function(e,i,r){var n=e+i,s=ib[n];return s||(ib[n]=s=new t(e,i,r)),s},t}(),nM=/** @class */function(){/**
     * @param {PIXI.Program} [program] - The program the shader will use.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     */function t(t,e){/**
         * used internally to bind uniform buffer objects
         * @ignore
         */this.uniformBindCount=0,/**
         * Program that the shader uses
         *
         * @member {PIXI.Program}
         */this.program=t,e?e instanceof r2?this.uniformGroup=e:this.uniformGroup=new r2(e):this.uniformGroup=new r2({})}return(// TODO move to shader system..
t.prototype.checkUniformExists=function(t,e){if(e.uniforms[t])return!0;for(var i in e.uniforms){var r=e.uniforms[i];if(r.group&&this.checkUniformExists(t,r))return!0}return!1},t.prototype.destroy=function(){// usage count on programs?
// remove if not used!
this.uniformGroup=null},Object.defineProperty(t.prototype,"uniforms",{/**
         * Shader uniform values, shortcut for `uniformGroup.uniforms`
         * @readonly
         * @member {object}
         */get:function(){return this.uniformGroup.uniforms},enumerable:!1,configurable:!0}),/**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */t.from=function(e,i,r){var n=nS.from(e,i);return new t(n,r)},t)}(),nA=/** @class */function(){function t(){this.data=0,this.blendMode=xJ.NORMAL,this.polygonOffset=0,this.blend=!0,this.depthMask=!0;//  this.depthTest = true;
}return Object.defineProperty(t.prototype,"blend",{/**
         * Activates blending of the computed fragment color values
         *
         * @member {boolean}
         */get:function(){return!!(1&this.data)},set:function(t){!!(1&this.data)!==t&&(this.data^=1)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"offsets",{/**
         * Activates adding an offset to depth values of polygon's fragments
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(2&this.data)},set:function(t){!!(2&this.data)!==t&&(this.data^=2)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"culling",{/**
         * Activates culling of polygons.
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(4&this.data)},set:function(t){!!(4&this.data)!==t&&(this.data^=4)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"depthTest",{/**
         * Activates depth comparisons and updates to the depth buffer.
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(8&this.data)},set:function(t){!!(8&this.data)!==t&&(this.data^=8)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"depthMask",{/**
         * Enables or disables writing to the depth buffer.
         *
         * @member {boolean}
         * @default true
         */get:function(){return!!(32&this.data)},set:function(t){!!(32&this.data)!==t&&(this.data^=32)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"clockwiseFrontFace",{/**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @member {boolean}
         * @default false
         */get:function(){return!!(16&this.data)},set:function(t){!!(16&this.data)!==t&&(this.data^=16)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"blendMode",{/**
         * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */get:function(){return this._blendMode},set:function(t){this.blend=t!==xJ.NONE,this._blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"polygonOffset",{/**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         *
         * @member {number}
         * @default 0
         */get:function(){return this._polygonOffset},set:function(t){this.offsets=!!t,this._polygonOffset=t},enumerable:!1,configurable:!0}),t.prototype.toString=function(){return"[@pixi/core:State blendMode="+this.blendMode+" clockwiseFrontFace="+this.clockwiseFrontFace+" culling="+this.culling+" depthMask="+this.depthMask+" polygonOffset="+this.polygonOffset+"]"},t.for2d=function(){var e=new t;return e.depthTest=!1,e.blend=!0,e},t}(),nR=/** @class */function(t){/**
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     */function e(i,r,n){var s=this,o=nS.from(i||e.defaultVertexSrc,r||e.defaultFragmentSrc);return(/**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */(s=t.call(this,o,n)||this).padding=0,/**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */s.resolution=ec.FILTER_RESOLUTION,/**
         * The samples of the filter.
         *
         * @member {PIXI.MSAA_QUALITY}
         */s.multisample=ec.FILTER_MULTISAMPLE,/**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */s.enabled=!0,/**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */s.autoFit=!0,/**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */s.state=new nA,s)}return rx(e,t),/**
     * Applies the filter
     *
     * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */e.prototype.apply=function(t,e,i,r,n){// do as you please!
t.applyFilter(this,e,i,r);// or just do a regular render..
},Object.defineProperty(e.prototype,"blendMode",{/**
         * Sets the blendmode of the filter
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         */get:function(){return this.state.blendMode},set:function(t){this.state.blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(e,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"},enumerable:!1,configurable:!0}),Object.defineProperty(e,"defaultFragmentSrc",{/**
         * The default fragment shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"},enumerable:!1,configurable:!0}),e}(nM),nC=new iX,nP=/** @class */function(){/**
     *
     * @param {PIXI.Texture} texture - observed texture
     * @param {number} [clampMargin] - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
     * @constructor
     */function t(t,e){this._texture=t,/**
         * Matrix operation that converts texture region coords to texture coords
         * @member {PIXI.Matrix}
         * @readonly
         */this.mapCoord=new iX,/**
         * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.
         * Calculated based on clampOffset.
         * @member {Float32Array}
         * @readonly
         */this.uClampFrame=new Float32Array(4),/**
         * Normalized clamp offset.
         * Calculated based on clampOffset.
         * @member {Float32Array}
         * @readonly
         */this.uClampOffset=new Float32Array(2),/**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */this._textureID=-1,/**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */this._updateID=0,/**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */this.clampOffset=0,/**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */this.clampMargin=void 0===e?.5:e,/**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */this.isSimple=!1}return Object.defineProperty(t.prototype,"texture",{/**
         * texture property
         * @member {PIXI.Texture}
         */get:function(){return this._texture},set:function(t){this._texture=t,this._textureID=-1},enumerable:!1,configurable:!0}),/**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs - mesh uvs
     * @param {Float32Array} [out=uvs] - output
     * @returns {Float32Array} output
     */t.prototype.multiplyUvs=function(t,e){void 0===e&&(e=t);for(var i=this.mapCoord,r=0;r<t.length;r+=2){var n=t[r],s=t[r+1];e[r]=n*i.a+s*i.c+i.tx,e[r+1]=n*i.b+s*i.d+i.ty}return e},/**
     * updates matrices if texture was changed
     * @param {boolean} [forceUpdate=false] - if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */t.prototype.update=function(t){var e=this._texture;if(!e||!e.valid||!t&&this._textureID===e._updateID)return!1;this._textureID=e._updateID,this._updateID++;var i=e._uvs;this.mapCoord.set(i.x1-i.x0,i.y1-i.y0,i.x3-i.x0,i.y3-i.y0,i.x0,i.y0);var r=e.orig,n=e.trim;n&&(nC.set(r.width/n.width,0,0,r.height/n.height,-n.x/n.width,-n.y/n.height),this.mapCoord.append(nC));var s=e.baseTexture,o=this.uClampFrame,a=this.clampMargin/s.resolution,h=this.clampOffset;return o[0]=(e._frame.x+a+h)/s.width,o[1]=(e._frame.y+a+h)/s.height,o[2]=(e._frame.x+e._frame.width-a+h)/s.width,o[3]=(e._frame.y+e._frame.height-a+h)/s.height,this.uClampOffset[0]=h/s.realWidth,this.uClampOffset[1]=h/s.realHeight,this.isSimple=e._frame.width===s.width&&e._frame.height===s.height&&0===e.rotate,!0},t}(),nI=/** @class */function(t){/**
     * @param {PIXI.Sprite} sprite - the target sprite
     */function e(e){var i=this,r=new iX;return i=t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n","varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n")||this,e.renderable=!1,/**
         * Sprite mask
         * @member {PIXI.Sprite}
         */i.maskSprite=e,/**
         * Mask matrix
         * @member {PIXI.Matrix}
         */i.maskMatrix=r,i}return rx(e,t),/**
     * Applies the filter
     *
     * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} clearMode - Should the output be cleared before rendering to it.
     */e.prototype.apply=function(t,e,i,r){var n=this.maskSprite,s=n._texture;s.valid&&(s.uvMatrix||// assuming that atlas textures were made with 1-pixel padding
(s.uvMatrix=new nP(s,0)),s.uvMatrix.update(),this.uniforms.npmAlpha=s.baseTexture.alphaMode?0:1,this.uniforms.mask=s,// get _normalized sprite texture coords_ and convert them to _normalized atlas texture coords_ with `prepend`
this.uniforms.otherMatrix=t.calculateSpriteMatrix(this.maskMatrix,n).prepend(s.uvMatrix.mapCoord),this.uniforms.alpha=n.worldAlpha,this.uniforms.maskClamp=s.uvMatrix.uClampFrame,t.applyFilter(this,e,i,r))},e}(nR),nO=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * Enable scissor masking.
         *
         * @member {boolean}
         * @readonly
         */this.enableScissor=!0,/**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */this.alphaMaskPool=[],/**
         * Pool of mask data
         * @member {PIXI.MaskData[]}
         * @readonly
         */this.maskDataPool=[],this.maskStack=[],/**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */this.alphaMaskIndex=0}return(/**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.MaskData[]} maskStack - The mask stack
     */t.prototype.setMaskStack=function(t){this.maskStack=t,this.renderer.scissor.setMaskStack(t),this.renderer.stencil.setMaskStack(t)},/**
     * Enables the mask and appends it to the current mask stack.
     *
     * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskData - The masking data.
     */t.prototype.push=function(t,e){var i=e;if(!i.isMaskData){var r=this.maskDataPool.pop()||new no;r.pooled=!0,r.maskObject=e,i=r}switch(i.autoDetect&&this.detect(i),i.copyCountersOrReset(this.maskStack[this.maskStack.length-1]),i._target=t,i.type){case x9.SCISSOR:this.maskStack.push(i),this.renderer.scissor.push(i);break;case x9.STENCIL:this.maskStack.push(i),this.renderer.stencil.push(i);break;case x9.SPRITE:i.copyCountersOrReset(null),this.pushSpriteMask(i),this.maskStack.push(i)}},/**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     */t.prototype.pop=function(t){var e=this.maskStack.pop();if(e&&e._target===t){switch(e.type){case x9.SCISSOR:this.renderer.scissor.pop();break;case x9.STENCIL:this.renderer.stencil.pop(e.maskObject);break;case x9.SPRITE:this.popSpriteMask()}e.reset(),e.pooled&&this.maskDataPool.push(e)}},/**
     * Sets type of MaskData based on its maskObject
     * @param {PIXI.MaskData} maskData
     */t.prototype.detect=function(t){var e=t.maskObject;if(e.isSprite){t.type=x9.SPRITE;return}// detect scissor in graphics
if(t.type=x9.STENCIL,this.enableScissor&&e.isFastRect&&e.isFastRect()){var i=e.worldTransform,r=Math.atan2(i.b,i.a),n=Math.atan2(i.d,i.c);n=((n=Math.round(n*(180/Math.PI)*100)-// use the nearest degree to 0.01
(r=Math.round(r*(180/Math.PI)*100)))%18e3+18e3)%18e3,0==(r=(r%9e3+9e3)%9e3)&&9e3===n&&(t.type=x9.SCISSOR)}},/**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.MaskData} maskData - Sprite to be used as the mask
     */t.prototype.pushSpriteMask=function(t){var e,i,r,n,s=t.maskObject,o=t._target,a=this.alphaMaskPool[this.alphaMaskIndex];a||(a=this.alphaMaskPool[this.alphaMaskIndex]=[new nI(s)]);var h=this.renderer,l=h.renderTexture;if(l.current){var u=l.current;r=t.resolution||u.resolution,n=null!==(e=t.multisample)&&void 0!==e?e:u.multisample}else r=t.resolution||h.resolution,n=null!==(i=t.multisample)&&void 0!==i?i:h.multisample;a[0].resolution=r,a[0].multisample=n,a[0].maskSprite=s;var c=o.filterArea;o.filterArea=s.getBounds(!0),h.filter.push(o,a),o.filterArea=c,this.alphaMaskIndex++},/**
     * Removes the last filter from the filter stack and doesn't return it.
     */t.prototype.popSpriteMask=function(){this.renderer.filter.pop(),this.alphaMaskIndex--},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),nL=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * The mask stack
         * @member {PIXI.MaskData[]}
         */this.maskStack=[],/**
         * Constant for gl.enable
         * @member {number}
         * @private
         */this.glConst=0}return(/**
     * gets count of masks of certain type
     * @returns {number}
     */t.prototype.getStackLength=function(){return this.maskStack.length},/**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.MaskData[]} maskStack - The mask stack
     */t.prototype.setMaskStack=function(t){var e=this.renderer.gl,i=this.getStackLength();this.maskStack=t;var r=this.getStackLength();r!==i&&(0===r?e.disable(this.glConst):(e.enable(this.glConst),this._useCurrent()))},/**
     * Setup renderer to use the current mask data.
     * @private
     */t.prototype._useCurrent=function(){// OVERWRITE;
},/**
     * Destroys the mask stack.
     *
     */t.prototype.destroy=function(){this.renderer=null,this.maskStack=null},t)}(),nN=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i.glConst=WebGLRenderingContext.SCISSOR_TEST,i}return rx(e,t),e.prototype.getStackLength=function(){var t=this.maskStack[this.maskStack.length-1];return t?t._scissorCounter:0},/**
     * Applies the Mask and adds it to the current stencil stack.
     *
     * @author alvin
     * @param {PIXI.MaskData} maskData - The mask data
     */e.prototype.push=function(t){var e=t.maskObject;e.renderable=!0;var i=t._scissorRect,r=e.getBounds(!0),n=this.renderer.gl;e.renderable=!1,i?r.fit(i):n.enable(n.SCISSOR_TEST),t._scissorCounter++,t._scissorRect=r,this._useCurrent()},/**
     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the
     * last mask in the stack.
     *
     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.
     */e.prototype.pop=function(){var t=this.renderer.gl;this.getStackLength()>0?this._useCurrent():t.disable(t.SCISSOR_TEST)},/**
     * Setup renderer to use the current scissor data.
     * @private
     */e.prototype._useCurrent=function(){var t=this.maskStack[this.maskStack.length-1]._scissorRect,e=this.renderer.renderTexture.current,i=this.renderer.projection,r=i.transform,n=i.sourceFrame,s=i.destinationFrame,o=e?e.resolution:this.renderer.resolution,a=s.width/n.width,h=s.height/n.height,l=((t.x-n.x)*a+s.x)*o,u=((t.y-n.y)*h+s.y)*o,c=t.width*a*o,d=t.height*h*o;r&&(l+=r.tx*o,u+=r.ty*o),e||(u=this.renderer.height-d-u),l=Math.round(l),u=Math.round(u),c=Math.round(c),d=Math.round(d),this.renderer.gl.scissor(l,u,c,d)},e}(nL),nD=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i.glConst=WebGLRenderingContext.STENCIL_TEST,i}return rx(e,t),e.prototype.getStackLength=function(){var t=this.maskStack[this.maskStack.length-1];return t?t._stencilCounter:0},/**
     * Applies the Mask and adds it to the current stencil stack.
     *
     * @param {PIXI.MaskData} maskData - The mask data
     */e.prototype.push=function(t){var e=t.maskObject,i=this.renderer.gl,r=t._stencilCounter;0===r&&(// force use stencil texture in current framebuffer
this.renderer.framebuffer.forceStencil(),i.enable(i.STENCIL_TEST)),t._stencilCounter++,// Increment the reference stencil value where the new mask overlaps with the old ones.
i.colorMask(!1,!1,!1,!1),i.stencilFunc(i.EQUAL,r,this._getBitwiseMask()),i.stencilOp(i.KEEP,i.KEEP,i.INCR),e.renderable=!0,e.render(this.renderer),this.renderer.batch.flush(),e.renderable=!1,this._useCurrent()},/**
     * Pops stencil mask. MaskData is already removed from stack
     *
     * @param {PIXI.DisplayObject} maskObject - object of popped mask data
     */e.prototype.pop=function(t){var e=this.renderer.gl;0===this.getStackLength()?(// the stack is empty!
e.disable(e.STENCIL_TEST),e.clear(e.STENCIL_BUFFER_BIT),e.clearStencil(0)):(// Decrement the reference stencil value where the popped mask overlaps with the other ones
e.colorMask(!1,!1,!1,!1),e.stencilOp(e.KEEP,e.KEEP,e.DECR),t.renderable=!0,t.render(this.renderer),this.renderer.batch.flush(),t.renderable=!1,this._useCurrent())},/**
     * Setup renderer to use the current stencil data.
     * @private
     */e.prototype._useCurrent=function(){var t=this.renderer.gl;t.colorMask(!0,!0,!0,!0),t.stencilFunc(t.EQUAL,this.getStackLength(),this._getBitwiseMask()),t.stencilOp(t.KEEP,t.KEEP,t.KEEP)},/**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */e.prototype._getBitwiseMask=function(){return(1<<this.getStackLength())-1},e}(nL),nF=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * The destination frame used to calculate the current projection matrix.
         *
         * The destination frame is the rectangle in the render-target into which contents are rendered. If rendering
         * to the screen, the origin is on the top-left. If rendering to a framebuffer, the origin is on the
         * bottom-left. This "flipping" phenomenon is because of WebGL convention for (shader) texture coordinates, where
         * the bottom-left corner is (0,0). It allows display-objects to map their (0,0) position in local-space (top-left)
         * to (0,0) in texture space (bottom-left). In other words, a sprite's top-left corner actually renders the
         * texture's bottom-left corner. You will also notice this when using a tool like SpectorJS to view your textures
         * at runtime.
         *
         * The destination frame's dimensions (width,height) should be equal to the source frame. This is because,
         * otherwise, the contents will be scaled to fill the destination frame. Similarly, the destination frame's (x,y)
         * coordinates are (0,0) unless you know what you're doing.
         *
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.destinationFrame=null,/**
         * The source frame used to calculate the current projection matrix.
         *
         * The source frame is the rectangle in world space containing the contents to be rendered.
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.sourceFrame=null,/**
         * Default destination frame
         *
         * This is not used internally. It is not advised to use this feature specifically unless you know what
         * you're doing. The `update` method will default to this frame if you do not pass the destination frame.
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.defaultFrame=null,/**
         * Projection matrix
         *
         * This matrix can be used to transform points from world space to normalized device coordinates, and is calculated
         * from the sourceFrame  destinationFrame mapping provided.
         *
         * The renderer's `globalUniforms` keeps a reference to this, and so it is available for all shaders to use as a
         * uniform.
         *
         * @member {PIXI.Matrix}
         * @readonly
         */this.projectionMatrix=new iX,/**
         * A transform to be appended to the projection matrix.
         *
         * This can be used to transform points in world-space one last time before they are outputted by the shader. You can
         * use to rotate the whole scene, for example. Remember to clear it once you've rendered everything.
         *
         * @member {PIXI.Matrix}
         */this.transform=null}return(/**
     * Updates the projection-matrix based on the sourceFrame  destinationFrame mapping provided.
     *
     * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because
     * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.
     *
     * NOTE-2: {@link RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture. It is expected
     * that you dirty the current bindings when calling this manually.
     *
     * @param {PIXI.Rectangle} destinationFrame - The rectangle in the render-target to render the contents
     *  into. If rendering to the canvas, the origin is on the top-left; if rendering to a render-texture, the origin
     *  is on the bottom-left.
     * @param {PIXI.Rectangle} sourceFrame - The rectangle in world space that contains the contents being rendered.
     * @param {Number} resolution - The resolution of the render-target, which is the ratio of world-space (or CSS) pixels
     *  to physical pixels.
     * @param {boolean} root - Whether the render-target is the screen. This is required because rendering to textures
     *  is y-flipped (i.e. upside down relative to the screen).
     */t.prototype.update=function(t,e,i,r){this.destinationFrame=t||this.destinationFrame||this.defaultFrame,this.sourceFrame=e||this.sourceFrame||t,// Calculate object-space to clip-space projection
this.calculateProjection(this.destinationFrame,this.sourceFrame,i,r),this.transform&&this.projectionMatrix.append(this.transform);var n=this.renderer;n.globalUniforms.uniforms.projectionMatrix=this.projectionMatrix,n.globalUniforms.update(),n.shader.shader&&n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)},/**
     * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame in the render-target.
     * @param {PIXI.Rectangle} sourceFrame - The source frame in world space.
     * @param {Number} resolution - The render-target's resolution, i.e. ratio of CSS to physical pixels.
     * @param {boolean} root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection
     *  is y-flipped.
     */t.prototype.calculateProjection=function(t,e,i,r){var n=this.projectionMatrix,s=r?-1:1;n.identity(),n.a=1/e.width*2,n.d=s*(1/e.height*2),n.tx=-1-e.x*n.a,n.ty=-s-e.y*n.d},/**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */t.prototype.setTransform=function(t){// this._activeRenderTarget.transform = matrix;
},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),nB=new iU,nU=new iU,nG=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * The clear background color as rgba
         * @member {number[]}
         */this.clearColor=t._backgroundColorRgba,// TODO move this property somewhere else!
/**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */this.defaultMaskStack=[],// empty render texture?
/**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */this.current=null,/**
         * The source frame for the render-target's projection mapping.
         *
         * See {@link PIXI.ProjectionSystem#sourceFrame} for more details.
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.sourceFrame=new iU,/**
         * The destination frame for the render-target's projection mapping.
         *
         * See {@link PIXI.Projection#destinationFrame} for more details.
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.destinationFrame=new iU,/**
         * The viewport frame for the render-target's viewport binding. This is equal to the destination-frame
         * for render-textures, while it is y-flipped when rendering to the screen (i.e. its origin is always on
         * the bottom-left).
         *
         * @member {PIXI.Rectangle}
         * @readonly
         */this.viewportFrame=new iU}return(/**
     * Bind the current render texture
     *
     * @param {PIXI.RenderTexture} [renderTexture] - RenderTexture to bind, by default its `null`, the screen
     * @param {PIXI.Rectangle} [sourceFrame] - part of screen that is mapped to the renderTexture
     * @param {PIXI.Rectangle} [destinationFrame] - part of renderTexture, by default it has the same size as sourceFrame
     */t.prototype.bind=function(t,e,i){void 0===t&&(t=null);var r,n,s,o=this.renderer;this.current=t,t?(s=(r=t.baseTexture).resolution,e||(nB.width=t.frame.width,nB.height=t.frame.height,e=nB),i||(nU.x=t.frame.x,nU.y=t.frame.y,nU.width=e.width,nU.height=e.height,i=nU),n=r.framebuffer):(s=o.resolution,e||(nB.width=o.screen.width,nB.height=o.screen.height,e=nB),i||((i=nB).width=e.width,i.height=e.height));var a=this.viewportFrame;a.x=i.x*s,a.y=i.y*s,a.width=i.width*s,a.height=i.height*s,t||(a.y=o.view.height-(a.y+a.height)),a.ceil(),this.renderer.framebuffer.bind(n,a),this.renderer.projection.update(i,e,s,!n),t?this.renderer.mask.setMaskStack(r.maskStack):this.renderer.mask.setMaskStack(this.defaultMaskStack),this.sourceFrame.copyFrom(e),this.destinationFrame.copyFrom(i)},/**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
     * @return {PIXI.Renderer} Returns itself.
     */t.prototype.clear=function(t,e){t=this.current?t||this.current.baseTexture.clearColor:t||this.clearColor;var i=this.destinationFrame,r=this.current?this.current.baseTexture:this.renderer.screen,n=i.width!==r.width||i.height!==r.height;if(n){var s=this.viewportFrame,o=s.x,a=s.y,h=s.width,l=s.height;o=Math.round(o),a=Math.round(a),h=Math.round(h),l=Math.round(l),// TODO: ScissorSystem should cache whether the scissor test is enabled or not.
this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),this.renderer.gl.scissor(o,a,h,l)}this.renderer.framebuffer.clear(t[0],t[1],t[2],t[3],e),n&&this.renderer.scissor.pop()},t.prototype.resize=function(){// resize the root only!
this.bind(null)},/**
     * Resets renderTexture state
     */t.prototype.reset=function(){this.bind(null)},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}();function nk(t,e,i,r,n){i.buffer.update(n)}// cv = CachedValue
// v = value
// ud = uniformData
// uv = uniformValue
// l = location
var nH={float:"\n        data[offset] = v;\n    ",vec2:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",vec3:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",vec4:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",mat2:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",mat3:"\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",mat4:"\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "},nz={float:4,vec2:8,vec3:12,vec4:16,int:4,ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:32,mat3:48,mat4:64};/**
 * @ignore
 *
 * logic originally from here: https://github.com/sketchpunk/FunWithWebGL2/blob/master/lesson_022/Shaders.js
 * rewrote it, but this was a great starting point to get a solid understanding of whats going on :)
 *
 * @param uniformData
 */function nj(t){for(var e=t.map(function(t){return{data:t,offset:0,dataLen:0,dirty:0}}),i=0,r=0,n=0,s=0;s<e.length;s++){var o=e[s];// add some size offset..
// must align to the nearest 16 bytes or internally nearest round size
if(i=nz[o.data.type],o.data.size>1&&(i=Math.max(i,16)*o.data.size),o.dataLen=i,r%i!=0&&r<16){// diff required to line up..
var a=r%i%16;r+=a,n+=a}r+i>16?(n=16*Math.ceil(n/16),o.offset=n,n+=i,r=i):(o.offset=n,r+=i,n+=i)}return{uboElements:e,size:n=16*Math.ceil(n/16)}}function nV(t,e){var i=[];// build..
for(var r in t)e[r]&&i.push(e[r]);return(// sort them out by index!
i.sort(function(t,e){return t.index-e.index}),i)}function nX(t,e){if(!t.autoManage)return{size:0,syncFunc:nk};for(var i=nj(nV(t.uniforms,e)),r=i.uboElements,n=i.size,s=["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "],o=0;o<r.length;o++){for(var a=r[o],h=t.uniforms[a.data.name],l=a.data.name,u=!1,c=0;c<nv.length;c++){var d=nv[c];if(d.codeUbo&&d.test(a.data,h)){s.push("offset = "+a.offset/4+";",nv[c].codeUbo(a.data.name,h)),u=!0;break}}if(!u){if(a.data.size>1){var p=nm[a.data.type],f=Math.max(nz[a.data.type]/16,1),m=p/f,g=(4-m%4)%4;s.push("\n                cv = ud."+l+".value;\n                v = uv."+l+";\n                offset = "+a.offset/4+";\n\n                t = 0;\n\n                for(var i=0; i < "+a.data.size*f+"; i++)\n                {\n                    for(var j = 0; j < "+m+"; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += "+g+";\n                }\n\n                ")}else{var y=nH[a.data.type];s.push("\n                cv = ud."+l+".value;\n                v = uv."+l+";\n                offset = "+a.offset/4+";\n                "+y+";\n                ")}}}return s.push("\n       renderer.buffer.update(buffer);\n    "),{size:n,// eslint-disable-next-line no-new-func
syncFunc:Function("ud","uv","renderer","syncData","buffer",s.join("\n"))}}/**
 * @private
 */var nW=function(){},nY=/** @class */function(){/**
     * Makes a new Pixi program
     *
     * @param {WebGLProgram} program - webgl program
     * @param {Object} uniformData - uniforms
     */function t(t,e){/**
         * The shader program
         *
         * @member {WebGLProgram}
         */this.program=t,/**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */this.uniformData=e,/**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBufferBindings={}}return(/**
     * Destroys this program
     */t.prototype.destroy=function(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBufferBindings=null,this.program=null},t)}();/**
 * generates a WebGL Program object from a high level Pixi Program.
 *
 * @param gl - a rendering context on which to generate the program
 * @param program - the high level Pixi Program.
 */function nq(t,e){var i=na(t,t.VERTEX_SHADER,e.vertexSrc),r=na(t,t.FRAGMENT_SHADER,e.fragmentSrc),n=t.createProgram();t.attachShader(n,i),t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS)&&(t.getProgramParameter(n,t.LINK_STATUS)||(t.getShaderParameter(i,t.COMPILE_STATUS)||nh(t,i),t.getShaderParameter(r,t.COMPILE_STATUS)||nh(t,r),console.error("PixiJS Error: Could not initialize shader."),""!==t.getProgramInfoLog(n)&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",t.getProgramInfoLog(n)))),e.attributeData=/**
 * returns the attribute data from the program
 * @private
 *
 * @param {WebGLProgram} [program] - the WebGL program
 * @param {WebGLRenderingContext} [gl] - the WebGL context
 *
 * @returns {object} the attribute data for this program
 */function(t,e){for(var i={},r=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES),n=0;n<r;n++){var s=e.getActiveAttrib(t,n);if(!s.name.startsWith("gl_")){var o=n_(e,s.type),a={type:o,name:s.name,size:nm[o],location:n};i[s.name]=a}}return i}(n,t),e.uniformData=/**
 * returns the uniform data from the program
 * @private
 *
 * @param program - the webgl program
 * @param gl - the WebGL context
 *
 * @returns {object} the uniform data for this program
 */function(t,e){for(var i={},r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),n=0;n<r;n++){var s=e.getActiveUniform(t,n),o=s.name.replace(/\[.*?\]$/,""),a=!!s.name.match(/\[.*?\]$/),h=n_(e,s.type);i[o]={name:o,index:n,type:h,size:s.size,isArray:a,value:nu(h,s.size)}}return i}(n,t);var s=Object.keys(e.attributeData);s.sort(function(t,e){return t>e?1:-1});for(var o=0;o<s.length;o++)e.attributeData[s[o]].location=o,t.bindAttribLocation(n,o,s[o]);t.linkProgram(n),t.deleteShader(i),t.deleteShader(r);var a={};for(var o in e.uniformData){var h=e.uniformData[o];a[o]={location:t.getUniformLocation(n,o),value:nu(h.type,h.size)}}return new nY(n,a)}var nK=0,nJ={textureCount:0,uboCount:0},nZ=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.destroyed=!1,this.renderer=t,// Validation check that this environment support `new Function`
this.systemCheck(),/**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */this.gl=null,this.shader=null,this.program=null,/**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */this.cache={},this._uboCache={},this.id=nK++}return(/**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */t.prototype.systemCheck=function(){if(!/**
 * Not all platforms allow to generate function code (e.g., `new Function`).
 * this provides the platform-level detection.
 *
 * @private
 * @returns {boolean}
 */function(){if("boolean"==typeof ba)return ba;try{/* eslint-disable no-new-func */var t=Function("param1","param2","param3","return param1[param2] === param3;");/* eslint-enable no-new-func */ba=!0===t({a:"b"},"a","b")}catch(t){ba=!1}return ba}())throw Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")},t.prototype.contextChange=function(t){this.gl=t,this.reset()},/**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} [dontSync] - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */t.prototype.bind=function(t,e){t.uniforms.globals=this.renderer.globalUniforms;var i=t.program,r=i.glPrograms[this.renderer.CONTEXT_UID]||this.generateProgram(t);return this.shader=t,this.program!==i&&(this.program=i,this.gl.useProgram(r.program)),e||(nJ.textureCount=0,nJ.uboCount=0,this.syncUniformGroup(t.uniformGroup,nJ)),r},/**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */t.prototype.setUniforms=function(t){var e=this.shader.program,i=e.glPrograms[this.renderer.CONTEXT_UID];e.syncUniforms(i.uniformData,t,this.renderer)},/* eslint-disable @typescript-eslint/explicit-module-boundary-types *//**
     *
     * syncs uniforms on the group
     * @param group - the uniform group to sync
     * @param syncData - this is data that is passed to the sync function and any nested sync functions
     */t.prototype.syncUniformGroup=function(t,e){var i=this.getGlProgram();t.static&&t.dirtyId===i.uniformDirtyGroups[t.id]||(i.uniformDirtyGroups[t.id]=t.dirtyId,this.syncUniforms(t,i,e))},/**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUniforms instead.
     *
     * @private
     */t.prototype.syncUniforms=function(t,e,i){(t.syncUniforms[this.shader.program.id]||this.createSyncGroups(t))(e.uniformData,t.uniforms,this.renderer,i)},t.prototype.createSyncGroups=function(t){var e=this.getSignature(t,this.shader.program.uniformData,"u");return this.cache[e]||(this.cache[e]=function(t,e){var i=["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];for(var r in t.uniforms){var n=e[r];if(!n){t.uniforms[r].group&&(t.uniforms[r].ubo?i.push("\n                        renderer.shader.syncUniformBufferGroup(uv."+r+", '"+r+"');\n                    "):i.push("\n                        renderer.shader.syncUniformGroup(uv."+r+", syncData);\n                    "));continue}for(var s=t.uniforms[r],o=!1,a=0;a<nv.length;a++)if(nv[a].test(n,s)){i.push(nv[a].code(r,s)),o=!0;break}if(!o){var h=(1===n.size?nx:nb)[n.type].replace("location",'ud["'+r+'"].location');i.push('\n            cv = ud["'+r+'"].value;\n            v = uv["'+r+'"];\n            '+h+";")}}/*
     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly
     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used
     * no matter which group is being used
     *
     */// eslint-disable-next-line no-new-func
return Function("ud","uv","renderer","syncData",i.join("\n"))}(t,this.shader.program.uniformData)),t.syncUniforms[this.shader.program.id]=this.cache[e],t.syncUniforms[this.shader.program.id]},/**
     * Syncs uniform buffers
     *
     * @param group - the uniform buffer group to sync
     * @param name - the name of the uniform buffer
     */t.prototype.syncUniformBufferGroup=function(t,e){var i=this.getGlProgram();if(!t.static||0!==t.dirtyId||!i.uniformGroups[t.id]){t.dirtyId=0;var r=i.uniformGroups[t.id]||this.createSyncBufferGroup(t,i,e);// TODO wrap update in a cache??
t.buffer.update(),r(i.uniformData,t.uniforms,this.renderer,nJ,t.buffer)}this.renderer.buffer.bindBufferBase(t.buffer,i.uniformBufferBindings[e])},/**
     * Will create a function that uploads a uniform buffer using the STD140 standard.
     * The upload function will then be cached for future calls
     * If a group is manually managed, then a simple upload function is generated
     *
     * @param group - the uniform buffer group to sync
     * @param glProgram - the gl program to attach the uniform bindings to
     * @param name - the name of the uniform buffer (must exist on the shader)
     */t.prototype.createSyncBufferGroup=function(t,e,i){var r=this.renderer.gl;this.renderer.buffer.bind(t.buffer);// bind them...
var n=this.gl.getUniformBlockIndex(e.program,i);e.uniformBufferBindings[i]=this.shader.uniformBindCount,r.uniformBlockBinding(e.program,n,this.shader.uniformBindCount),this.shader.uniformBindCount++;var s=this.getSignature(t,this.shader.program.uniformData,"ubo"),o=this._uboCache[s];if(o||(o=this._uboCache[s]=nX(t,this.shader.program.uniformData)),t.autoManage){var a=new Float32Array(o.size/4);t.buffer.update(a)}return e.uniformGroups[t.id]=o.syncFunc,e.uniformGroups[t.id]},/**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group - the uniform group to get signature of
     * @param {Object} uniformData - uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */t.prototype.getSignature=function(t,e,i){var r=t.uniforms,n=[i+"-"];for(var s in r)n.push(s),e[s]&&n.push(e[s].type);return n.join("-")},/**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */t.prototype.getGlProgram=function(){return this.shader?this.shader.program.glPrograms[this.renderer.CONTEXT_UID]:null},/**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader - the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */t.prototype.generateProgram=function(t){var e=this.gl,i=t.program,r=nq(e,i);return i.glPrograms[this.renderer.CONTEXT_UID]=r,r},/**
     * Resets ShaderSystem state, does not affect WebGL state
     */t.prototype.reset=function(){this.program=null,this.shader=null},/**
     * Destroys this System and removes all its textures
     */t.prototype.destroy=function(){this.renderer=null,// TODO implement destroy method for ShaderSystem
this.destroyed=!0},t)}(),n$=/** @class */function(){function t(){/**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */this.gl=null,/**
         * State ID
         * @member {number}
         * @readonly
         */this.stateId=0,/**
         * Polygon offset
         * @member {number}
         * @readonly
         */this.polygonOffset=0,/**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */this.blendMode=xJ.NONE,/**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */this._blendEq=!1,/**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */this.map=[],// map functions for when we set state..
this.map[0]=this.setBlend,this.map[1]=this.setOffset,this.map[2]=this.setCullFace,this.map[3]=this.setDepthTest,this.map[4]=this.setFrontFace,this.map[5]=this.setDepthMask,/**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */this.checks=[],/**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */this.defaultState=new nA,this.defaultState.blend=!0}return t.prototype.contextChange=function(t){var e;this.gl=t,this.blendModes=(void 0===e&&(e=[]),// TODO - premultiply alpha would be different.
// add a boolean for that!
e[xJ.NORMAL]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.ADD]=[t.ONE,t.ONE],e[xJ.MULTIPLY]=[t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.SCREEN]=[t.ONE,t.ONE_MINUS_SRC_COLOR,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.OVERLAY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.DARKEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.LIGHTEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.COLOR_DODGE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.COLOR_BURN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.HARD_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.SOFT_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.DIFFERENCE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.EXCLUSION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.HUE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.SATURATION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.COLOR]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.LUMINOSITY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.NONE]=[0,0],// not-premultiplied blend modes
e[xJ.NORMAL_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[xJ.ADD_NPM]=[t.SRC_ALPHA,t.ONE,t.ONE,t.ONE],e[xJ.SCREEN_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_COLOR,t.ONE,t.ONE_MINUS_SRC_ALPHA],// composite operations
e[xJ.SRC_IN]=[t.DST_ALPHA,t.ZERO],e[xJ.SRC_OUT]=[t.ONE_MINUS_DST_ALPHA,t.ZERO],e[xJ.SRC_ATOP]=[t.DST_ALPHA,t.ONE_MINUS_SRC_ALPHA],e[xJ.DST_OVER]=[t.ONE_MINUS_DST_ALPHA,t.ONE],e[xJ.DST_IN]=[t.ZERO,t.SRC_ALPHA],e[xJ.DST_OUT]=[t.ZERO,t.ONE_MINUS_SRC_ALPHA],e[xJ.DST_ATOP]=[t.ONE_MINUS_DST_ALPHA,t.SRC_ALPHA],e[xJ.XOR]=[t.ONE_MINUS_DST_ALPHA,t.ONE_MINUS_SRC_ALPHA],// SUBTRACT from flash
e[xJ.SUBTRACT]=[t.ONE,t.ONE,t.ONE,t.ONE,t.FUNC_REVERSE_SUBTRACT,t.FUNC_ADD],e),this.set(this.defaultState),this.reset()},/**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */t.prototype.set=function(t){// TODO maybe to an object check? ( this.state === state )?
if(t=t||this.defaultState,this.stateId!==t.data){// order from least to most common
for(var e=this.stateId^t.data,i=0;e;)1&e&&this.map[i].call(this,!!(t.data&1<<i)),e>>=1,i++;this.stateId=t.data}// based on the above settings we check for specific modes..
// for example if blend is active we check and set the blend modes
// or of polygon offset is active we check the poly depth.
for(var i=0;i<this.checks.length;i++)this.checks[i](this,t)},/**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */t.prototype.forceState=function(t){t=t||this.defaultState;for(var e=0;e<this.map.length;e++)this.map[e].call(this,!!(t.data&1<<e));for(var e=0;e<this.checks.length;e++)this.checks[e](this,t);this.stateId=t.data},/**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */t.prototype.setBlend=function(e){this.updateCheck(t.checkBlendMode,e),this.gl[e?"enable":"disable"](this.gl.BLEND)},/**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */t.prototype.setOffset=function(e){this.updateCheck(t.checkPolygonOffset,e),this.gl[e?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)},/**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */t.prototype.setDepthTest=function(t){this.gl[t?"enable":"disable"](this.gl.DEPTH_TEST)},/**
     * Sets whether to enable or disable depth mask.
     *
     * @param {boolean} value - Turn on or off webgl depth mask.
     */t.prototype.setDepthMask=function(t){this.gl.depthMask(t)},/**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */t.prototype.setCullFace=function(t){this.gl[t?"enable":"disable"](this.gl.CULL_FACE)},/**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */t.prototype.setFrontFace=function(t){this.gl.frontFace(this.gl[t?"CW":"CCW"])},/**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */t.prototype.setBlendMode=function(t){if(t!==this.blendMode){this.blendMode=t;var e=this.blendModes[t],i=this.gl;2===e.length?i.blendFunc(e[0],e[1]):i.blendFuncSeparate(e[0],e[1],e[2],e[3]),6===e.length?(this._blendEq=!0,i.blendEquationSeparate(e[4],e[5])):this._blendEq&&(this._blendEq=!1,i.blendEquationSeparate(i.FUNC_ADD,i.FUNC_ADD))}},/**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */t.prototype.setPolygonOffset=function(t,e){this.gl.polygonOffset(t,e)},// used
/**
     * Resets all the logic and disables the vaos
     */t.prototype.reset=function(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode=-1,this.setBlendMode(0)},/**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func - the checking function to add or remove
     * @param {boolean} value - should the check function be added or removed.
     */t.prototype.updateCheck=function(t,e){var i=this.checks.indexOf(t);e&&-1===i?this.checks.push(t):e||-1===i||this.checks.splice(i,1)},/**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System - the System to perform the state check on
     * @param {PIXI.State} state - the state that the blendMode will pulled from
     */t.checkBlendMode=function(t,e){t.setBlendMode(e.blendMode)},/**
     * A private little wrapper function that we call to check the polygon offset.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System - the System to perform the state check on
     * @param {PIXI.State} state - the state that the blendMode will pulled from
     */t.checkPolygonOffset=function(t,e){t.setPolygonOffset(1,e.polygonOffset)},/**
     * @ignore
     */t.prototype.destroy=function(){this.gl=null},t}(),nQ=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,/**
         * Count
         * @member {number}
         * @readonly
         */this.count=0,/**
         * Check count
         * @member {number}
         * @readonly
         */this.checkCount=0,/**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */this.maxIdle=ec.GC_MAX_IDLE,/**
         * Maximum number of item to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */this.checkCountMax=ec.GC_MAX_CHECK_COUNT,/**
         * Current garbage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */this.mode=ec.GC_MODE}return(/**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */t.prototype.postrender=function(){this.renderer.renderingToScreen&&(this.count++,this.mode!==x8.MANUAL&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))},/**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */t.prototype.run=function(){for(var t=this.renderer.texture,e=t.managedTextures,i=!1,r=0;r<e.length;r++){var n=e[r];// only supports non generated textures at the moment!
!n.framebuffer&&this.count-n.touched>this.maxIdle&&(t.destroyTexture(n,!0),e[r]=null,i=!0)}if(i){for(var s=0,r=0;r<e.length;r++)null!==e[r]&&(e[s++]=e[r]);e.length=s}},/**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */t.prototype.unload=function(t){var e=this.renderer.texture,i=t._texture;// only destroy non generated textures
i&&!i.framebuffer&&e.destroyTexture(i);for(var r=t.children.length-1;r>=0;r--)this.unload(t.children[r])},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),n0=function(t){/**
         * The WebGL texture
         * @member {WebGLTexture}
         */this.texture=t,/**
         * Width of texture that was used in texImage2D
         * @member {number}
         */this.width=-1,/**
         * Height of texture that was used in texImage2D
         * @member {number}
         */this.height=-1,/**
         * Texture contents dirty flag
         * @member {number}
         */this.dirtyId=-1,/**
         * Texture style dirty flag
         * @member {number}
         */this.dirtyStyleId=-1,/**
         * Whether mip levels has to be generated
         * @member {boolean}
         */this.mipmap=!1,/**
         * WrapMode copied from baseTexture
         * @member {number}
         */this.wrapMode=33071,/**
         * Type copied from baseTexture
         * @member {number}
         */this.type=x0.UNSIGNED_BYTE,/**
         * Type copied from baseTexture
         * @member {number}
         */this.internalFormat=x$.RGBA,this.samplerType=0},n1=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,// TODO set to max textures...
/**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */this.boundTextures=[],/**
         * Current location
         * @member {number}
         * @readonly
         */this.currentLocation=-1,/**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */this.managedTextures=[],/**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */this._unknownBoundTextures=!1,/**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */this.unknownTexture=new rS,this.hasIntegerTextures=!1}return(/**
     * Sets up the renderer context and necessary buffers.
     */t.prototype.contextChange=function(){var t,e,i,r,n,s,o,a,h,l,u,c,d,p,f,m,g,y,_,v,x,b,E,T=this.gl=this.renderer.gl;this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.webGLVersion=this.renderer.context.webGLVersion,this.internalFormats=("WebGL2RenderingContext"in self&&T instanceof self.WebGL2RenderingContext?((t={})[x0.UNSIGNED_BYTE]=((e={})[x$.RGBA]=T.RGBA8,e[x$.RGB]=T.RGB8,e[x$.RG]=T.RG8,e[x$.RED]=T.R8,e[x$.RGBA_INTEGER]=T.RGBA8UI,e[x$.RGB_INTEGER]=T.RGB8UI,e[x$.RG_INTEGER]=T.RG8UI,e[x$.RED_INTEGER]=T.R8UI,e[x$.ALPHA]=T.ALPHA,e[x$.LUMINANCE]=T.LUMINANCE,e[x$.LUMINANCE_ALPHA]=T.LUMINANCE_ALPHA,e),t[x0.BYTE]=((i={})[x$.RGBA]=T.RGBA8_SNORM,i[x$.RGB]=T.RGB8_SNORM,i[x$.RG]=T.RG8_SNORM,i[x$.RED]=T.R8_SNORM,i[x$.RGBA_INTEGER]=T.RGBA8I,i[x$.RGB_INTEGER]=T.RGB8I,i[x$.RG_INTEGER]=T.RG8I,i[x$.RED_INTEGER]=T.R8I,i),t[x0.UNSIGNED_SHORT]=((r={})[x$.RGBA_INTEGER]=T.RGBA16UI,r[x$.RGB_INTEGER]=T.RGB16UI,r[x$.RG_INTEGER]=T.RG16UI,r[x$.RED_INTEGER]=T.R16UI,r[x$.DEPTH_COMPONENT]=T.DEPTH_COMPONENT16,r),t[x0.SHORT]=((n={})[x$.RGBA_INTEGER]=T.RGBA16I,n[x$.RGB_INTEGER]=T.RGB16I,n[x$.RG_INTEGER]=T.RG16I,n[x$.RED_INTEGER]=T.R16I,n),t[x0.UNSIGNED_INT]=((s={})[x$.RGBA_INTEGER]=T.RGBA32UI,s[x$.RGB_INTEGER]=T.RGB32UI,s[x$.RG_INTEGER]=T.RG32UI,s[x$.RED_INTEGER]=T.R32UI,s[x$.DEPTH_COMPONENT]=T.DEPTH_COMPONENT24,s),t[x0.INT]=((o={})[x$.RGBA_INTEGER]=T.RGBA32I,o[x$.RGB_INTEGER]=T.RGB32I,o[x$.RG_INTEGER]=T.RG32I,o[x$.RED_INTEGER]=T.R32I,o),t[x0.FLOAT]=((a={})[x$.RGBA]=T.RGBA32F,a[x$.RGB]=T.RGB32F,a[x$.RG]=T.RG32F,a[x$.RED]=T.R32F,a[x$.DEPTH_COMPONENT]=T.DEPTH_COMPONENT32F,a),t[x0.HALF_FLOAT]=((h={})[x$.RGBA]=T.RGBA16F,h[x$.RGB]=T.RGB16F,h[x$.RG]=T.RG16F,h[x$.RED]=T.R16F,h),t[x0.UNSIGNED_SHORT_5_6_5]=((l={})[x$.RGB]=T.RGB565,l),t[x0.UNSIGNED_SHORT_4_4_4_4]=((u={})[x$.RGBA]=T.RGBA4,u),t[x0.UNSIGNED_SHORT_5_5_5_1]=((c={})[x$.RGBA]=T.RGB5_A1,c),t[x0.UNSIGNED_INT_2_10_10_10_REV]=((d={})[x$.RGBA]=T.RGB10_A2,d[x$.RGBA_INTEGER]=T.RGB10_A2UI,d),t[x0.UNSIGNED_INT_10F_11F_11F_REV]=((p={})[x$.RGB]=T.R11F_G11F_B10F,p),t[x0.UNSIGNED_INT_5_9_9_9_REV]=((f={})[x$.RGB]=T.RGB9_E5,f),t[x0.UNSIGNED_INT_24_8]=((m={})[x$.DEPTH_STENCIL]=T.DEPTH24_STENCIL8,m),t[x0.FLOAT_32_UNSIGNED_INT_24_8_REV]=((g={})[x$.DEPTH_STENCIL]=T.DEPTH32F_STENCIL8,g),E=t):((y={})[x0.UNSIGNED_BYTE]=((_={})[x$.RGBA]=T.RGBA,_[x$.RGB]=T.RGB,_[x$.ALPHA]=T.ALPHA,_[x$.LUMINANCE]=T.LUMINANCE,_[x$.LUMINANCE_ALPHA]=T.LUMINANCE_ALPHA,_),y[x0.UNSIGNED_SHORT_5_6_5]=((v={})[x$.RGB]=T.RGB,v),y[x0.UNSIGNED_SHORT_4_4_4_4]=((x={})[x$.RGBA]=T.RGBA,x),y[x0.UNSIGNED_SHORT_5_5_5_1]=((b={})[x$.RGBA]=T.RGBA,b),E=y),E);var w=T.getParameter(T.MAX_TEXTURE_IMAGE_UNITS);this.boundTextures.length=w;for(var S=0;S<w;S++)this.boundTextures[S]=null;// TODO move this.. to a nice make empty textures class..
this.emptyTextures={};var M=new n0(T.createTexture());T.bindTexture(T.TEXTURE_2D,M.texture),T.texImage2D(T.TEXTURE_2D,0,T.RGBA,1,1,0,T.RGBA,T.UNSIGNED_BYTE,new Uint8Array(4)),this.emptyTextures[T.TEXTURE_2D]=M,this.emptyTextures[T.TEXTURE_CUBE_MAP]=new n0(T.createTexture()),T.bindTexture(T.TEXTURE_CUBE_MAP,this.emptyTextures[T.TEXTURE_CUBE_MAP].texture);for(var S=0;S<6;S++)T.texImage2D(T.TEXTURE_CUBE_MAP_POSITIVE_X+S,0,T.RGBA,1,1,0,T.RGBA,T.UNSIGNED_BYTE,null);T.texParameteri(T.TEXTURE_CUBE_MAP,T.TEXTURE_MAG_FILTER,T.LINEAR),T.texParameteri(T.TEXTURE_CUBE_MAP,T.TEXTURE_MIN_FILTER,T.LINEAR);for(var S=0;S<this.boundTextures.length;S++)this.bind(null,S)},/**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture_ - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */t.prototype.bind=function(t,e){void 0===e&&(e=0);var i=this.gl;// cannot bind partial texture
// TODO: report a warning
if((t=null==t?void 0:t.castToBaseTexture())&&t.valid&&!t.parentTextureArray){t.touched=this.renderer.textureGC.count;var r=t._glTextures[this.CONTEXT_UID]||this.initTexture(t);this.boundTextures[e]!==t&&(this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),i.bindTexture(t.target,r.texture)),r.dirtyId!==t.dirtyId&&(this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),this.updateTexture(t)),this.boundTextures[e]=t}else this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),i.bindTexture(i.TEXTURE_2D,this.emptyTextures[i.TEXTURE_2D].texture),this.boundTextures[e]=null},/**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */t.prototype.reset=function(){this._unknownBoundTextures=!0,this.hasIntegerTextures=!1,this.currentLocation=-1;for(var t=0;t<this.boundTextures.length;t++)this.boundTextures[t]=this.unknownTexture},/**
     * Unbind a texture
     * @param {PIXI.BaseTexture} texture - Texture to bind
     */t.prototype.unbind=function(t){var e=this.gl,i=this.boundTextures;if(this._unknownBoundTextures){this._unknownBoundTextures=!1;// someone changed webGL state,
// we have to be sure that our texture does not appear in multi-texture renderer samplers
for(var r=0;r<i.length;r++)i[r]===this.unknownTexture&&this.bind(null,r)}for(var r=0;r<i.length;r++)i[r]===t&&(this.currentLocation!==r&&(e.activeTexture(e.TEXTURE0+r),this.currentLocation=r),e.bindTexture(t.target,this.emptyTextures[t.target].texture),i[r]=null)},/**
     * Ensures that current boundTextures all have FLOAT sampler type,
     * see {@link PIXI.SAMPLER_TYPES} for explanation.
     *
     * @param maxTextures - number of locations to check
     */t.prototype.ensureSamplerType=function(t){var e=this.boundTextures,i=this.hasIntegerTextures,r=this.CONTEXT_UID;if(i)for(var n=t-1;n>=0;--n){var s=e[n];s&&s._glTextures[r].samplerType!==x1.FLOAT&&this.renderer.texture.unbind(s)}},/**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */t.prototype.initTexture=function(t){var e=new n0(this.gl.createTexture());return(// guarantee an update..
e.dirtyId=-1,t._glTextures[this.CONTEXT_UID]=e,this.managedTextures.push(t),t.on("dispose",this.destroyTexture,this),e)},t.prototype.initTextureType=function(t,e){var i,r;e.internalFormat=null!==(r=null===(i=this.internalFormats[t.type])||void 0===i?void 0:i[t.format])&&void 0!==r?r:t.format,2===this.webGLVersion&&t.type===x0.HALF_FLOAT?// we have to convert it to WebGL HALF_FLOAT
e.type=this.gl.HALF_FLOAT:e.type=t.type},/**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */t.prototype.updateTexture=function(t){var e=t._glTextures[this.CONTEXT_UID];if(e){var i=this.renderer;if(this.initTextureType(t,e),t.resource&&t.resource.upload(i,t,e))e.samplerType!==x1.FLOAT&&(this.hasIntegerTextures=!0);else{// default, renderTexture-like logic
var r=t.realWidth,n=t.realHeight,s=i.gl;(e.width!==r||e.height!==n||e.dirtyId<0)&&(e.width=r,e.height=n,s.texImage2D(t.target,0,e.internalFormat,r,n,0,t.format,e.type,null))}t.dirtyStyleId!==e.dirtyStyleId&&this.updateTextureStyle(t),e.dirtyId=t.dirtyId}},/**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture_ - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */t.prototype.destroyTexture=function(t,e){var i=this.gl;if((t=t.castToBaseTexture())._glTextures[this.CONTEXT_UID]&&(this.unbind(t),i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),t.off("dispose",this.destroyTexture,this),delete t._glTextures[this.CONTEXT_UID],!e)){var r=this.managedTextures.indexOf(t);-1!==r&&im(this.managedTextures,r,1)}},/**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */t.prototype.updateTextureStyle=function(t){var e=t._glTextures[this.CONTEXT_UID];e&&(t.mipmap!==x5.POW2&&2===this.webGLVersion||t.isPowerOfTwo?e.mipmap=t.mipmap>=1:e.mipmap=!1,2===this.webGLVersion||t.isPowerOfTwo?e.wrapMode=t.wrapMode:e.wrapMode=x3.CLAMP,t.resource&&t.resource.style(this.renderer,t,e)||this.setStyle(t,e),e.dirtyStyleId=t.dirtyStyleId)},/**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {PIXI.GLTexture} glTexture
     */t.prototype.setStyle=function(t,e){var i=this.gl;if(e.mipmap&&t.mipmap!==x5.ON_MANUAL&&i.generateMipmap(t.target),i.texParameteri(t.target,i.TEXTURE_WRAP_S,e.wrapMode),i.texParameteri(t.target,i.TEXTURE_WRAP_T,e.wrapMode),e.mipmap){/* eslint-disable max-len */i.texParameteri(t.target,i.TEXTURE_MIN_FILTER,t.scaleMode===x2.LINEAR?i.LINEAR_MIPMAP_LINEAR:i.NEAREST_MIPMAP_NEAREST);/* eslint-disable max-len */var r=this.renderer.context.extensions.anisotropicFiltering;if(r&&t.anisotropicLevel>0&&t.scaleMode===x2.LINEAR){var n=Math.min(t.anisotropicLevel,i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));i.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY_EXT,n)}}else i.texParameteri(t.target,i.TEXTURE_MIN_FILTER,t.scaleMode===x2.LINEAR?i.LINEAR:i.NEAREST);i.texParameteri(t.target,i.TEXTURE_MAG_FILTER,t.scaleMode===x2.LINEAR?i.LINEAR:i.NEAREST)},/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},t)}(),n2={__proto__:null,FilterSystem:r6,BatchSystem:r7,ContextSystem:nt,FramebufferSystem:nr,GeometrySystem:ns,MaskSystem:nO,ScissorSystem:nN,StencilSystem:nD,ProjectionSystem:nF,RenderTextureSystem:nG,ShaderSystem:nZ,StateSystem:n$,TextureGCSystem:nQ,TextureSystem:n1},n3=new iX,n5=/** @class */function(t){/**
     * @param system - The name of the system this renderer is for.
     * @param [options] - The optional renderer parameters.
     * @param {number} [options.width=800] - The width of the screen.
     * @param {number} [options.height=600] - The height of the screen.
     * @param {HTMLCanvasElement} [options.view] - The canvas to use as a view, optional.
     * @param {boolean} [options.useContextAlpha=true] - Pass-through value for canvas' context `alpha` property.
     *   If you want to set transparency, please use `backgroundAlpha`. This option is for cases where the
     *   canvas needs to be opaque, possibly for performance reasons on some older devices.
     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
     *   resolutions other than 1.
     * @param {boolean} [options.antialias=false] - Sets antialias
     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the renderer.
     * @param {boolean} [options.preserveDrawingBuffer=false] - Enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the WebGL context.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
     *      not before the new render pass.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {number} [options.backgroundAlpha=1] - Value from 0 (fully transparent) to 1 (fully opaque).
     */function e(e,i){void 0===e&&(e=xq.UNKNOWN);var r=t.call(this)||this;return(// Add the default render options
i=Object.assign({},ec.RENDER_OPTIONS,i),/**
         * The supplied constructor options.
         *
         * @member {Object}
         * @readOnly
         */r.options=i,/**
         * The type of the renderer.
         *
         * @member {number}
         * @default PIXI.RENDERER_TYPE.UNKNOWN
         * @see PIXI.RENDERER_TYPE
         */r.type=e,/**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         *
         * @member {PIXI.Rectangle}
         */r.screen=new iU(0,0,i.width,i.height),/**
         * The canvas element that everything is drawn to.
         *
         * @member {HTMLCanvasElement}
         */r.view=i.view||document.createElement("canvas"),/**
         * The resolution / device pixel ratio of the renderer.
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */r.resolution=i.resolution||ec.RESOLUTION,/**
         * Pass-thru setting for the the canvas' context `alpha` property. This is typically
         * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.
         *
         * @member {boolean}
         */r.useContextAlpha=i.useContextAlpha,/**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         *
         * @member {boolean}
         */r.autoDensity=!!i.autoDensity,/**
         * The value of the preserveDrawingBuffer flag affects whether or not the contents of
         * the stencil buffer is retained after rendering.
         *
         * @member {boolean}
         */r.preserveDrawingBuffer=i.preserveDrawingBuffer,/**
         * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
         * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every
         * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect
         * to clear the canvas every frame. Disable this by setting this to false. For example, if
         * your game has a canvas filling background image you often don't need this set.
         *
         * @member {boolean}
         * @default
         */r.clearBeforeRender=i.clearBeforeRender,/**
         * The background color as a number.
         *
         * @member {number}
         * @protected
         */r._backgroundColor=0,/**
         * The background color as an [R, G, B, A] array.
         *
         * @member {number[]}
         * @protected
         */r._backgroundColorRgba=[0,0,0,1],/**
         * The background color as a string.
         *
         * @member {string}
         * @protected
         */r._backgroundColorString="#000000",r.backgroundColor=i.backgroundColor||r._backgroundColor,r.backgroundAlpha=i.backgroundAlpha,void 0!==i.transparent&&(ix("6.0.0","Option transparent is deprecated, please use backgroundAlpha instead."),r.useContextAlpha=i.transparent,r.backgroundAlpha=i.transparent?0:1),/**
         * The last root object that the renderer tried to render.
         *
         * @member {PIXI.DisplayObject}
         * @protected
         */r._lastObjectRendered=null,/**
         * Collection of plugins.
         * @readonly
         * @member {object}
         */r.plugins={},r)}return rx(e,t),/**
     * Initialize the plugins.
     *
     * @protected
     * @param {object} staticMap - The dictionary of statically saved plugins.
     */e.prototype.initPlugins=function(t){for(var e in t)this.plugins[e]=new t[e](this)},Object.defineProperty(e.prototype,"width",{/**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         *
         * @member {number}
         * @readonly
         * @default 800
         */get:function(){return this.view.width},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         *
         * @member {number}
         * @readonly
         * @default 600
         */get:function(){return this.view.height},enumerable:!1,configurable:!0}),/**
     * Resizes the screen and canvas as close as possible to the specified width and height.
     * Canvas dimensions are multiplied by resolution and rounded to the nearest integers.
     * The new canvas dimensions divided by the resolution become the new screen dimensions.
     *
     * @param desiredScreenWidth - The desired width of the screen.
     * @param desiredScreenHeight - The desired height of the screen.
     */e.prototype.resize=function(t,e){this.view.width=Math.round(t*this.resolution),this.view.height=Math.round(e*this.resolution);var i=this.view.width/this.resolution,r=this.view.height/this.resolution;this.screen.width=i,this.screen.height=r,this.autoDensity&&(this.view.style.width=i+"px",this.view.style.height=r+"px"),/**
         * Fired after view has been resized.
         *
         * @event PIXI.Renderer#resize
         * @param {number} screenWidth - The new width of the screen.
         * @param {number} screenHeight - The new height of the screen.
         */this.emit("resize",i,r)},/**
     * @ignore
     */e.prototype.generateTexture=function(t,e,i,r){void 0===e&&(e={}),"number"==typeof e&&(ix("6.1.0","generateTexture options (scaleMode, resolution, region) are now object options."),e={scaleMode:e,resolution:i,region:r});var n=e.region,s=function(t,e){var i={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&0>e.indexOf(r)&&(i[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols)for(var n=0,r=Object.getOwnPropertySymbols(t);n<r.length;n++)0>e.indexOf(r[n])&&(i[r[n]]=t[r[n]]);return i}(e,["region"]);0===(r=n||t.getLocalBounds(null,!0)).width&&(r.width=1),0===r.height&&(r.height=1);var o=rj.create(rb({width:r.width,height:r.height},s));return n3.tx=-r.x,n3.ty=-r.y,this.render(t,{renderTexture:o,clear:!1,transform:n3,skipUpdateTransform:!!t.parent}),o},/**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param [removeView=false] - Removes the Canvas element from the DOM.
     */e.prototype.destroy=function(t){for(var e in this.plugins)this.plugins[e].destroy(),this.plugins[e]=null;t&&this.view.parentNode&&this.view.parentNode.removeChild(this.view),// null-ing all objects, that's a tradition!
this.plugins=null,this.type=xq.UNKNOWN,this.view=null,this.screen=null,this._tempDisplayObjectParent=null,this.options=null,this._backgroundColorRgba=null,this._backgroundColorString=null,this._lastObjectRendered=null},Object.defineProperty(e.prototype,"backgroundColor",{/**
         * The background color to fill if not transparent
         *
         * @member {number}
         */get:function(){return this._backgroundColor},set:function(t){this._backgroundColor=t,this._backgroundColorString=e7(t),e8(t,this._backgroundColorRgba)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"backgroundAlpha",{/**
         * The background color alpha. Setting this to 0 will make the canvas transparent.
         *
         * @member {number}
         */get:function(){return this._backgroundColorRgba[3]},set:function(t){this._backgroundColorRgba[3]=t},enumerable:!1,configurable:!0}),e}(/*@__PURE__*/tP(ed)),n4=function(t){this.buffer=t||null,this.updateID=-1,this.byteLength=-1,this.refCount=0},n6=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function t(t){this.renderer=t,this.managedBuffers={},this.boundBufferBases={}}return(/**
     * @ignore
     */t.prototype.destroy=function(){this.renderer=null},/**
     * Sets up the renderer context and necessary buffers.
     */t.prototype.contextChange=function(){this.disposeAll(!0),this.gl=this.renderer.gl,// TODO fill out...
this.CONTEXT_UID=this.renderer.CONTEXT_UID},/**
     * This binds specified buffer. On first run, it will create the webGL buffers for the context too
     *
     * @param buffer - the buffer to bind to the renderer
     */t.prototype.bind=function(t){var e=this.gl,i=this.CONTEXT_UID,r=t._glBuffers[i]||this.createGLBuffer(t);e.bindBuffer(t.type,r.buffer)},/**
     * Binds an uniform buffer to at the given index.
     *
     * A cache is used so a buffer will not be bound again if already bound.
     *
     * @param buffer - the buffer to bind
     * @param index - the base index to bind it to.
     */t.prototype.bindBufferBase=function(t,e){var i=this.gl,r=this.CONTEXT_UID;if(this.boundBufferBases[e]!==t){var n=t._glBuffers[r]||this.createGLBuffer(t);this.boundBufferBases[e]=t,i.bindBufferBase(i.UNIFORM_BUFFER,e,n.buffer)}},/**
     * Binds a buffer whilst also binding its range.
     * This will make the buffer start from the offset supplied rather than 0 when it is read.
     *
     * @param buffer - the buffer to bind
     * @param index - the base index to bind at, defaults to 0
     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
     */t.prototype.bindBufferRange=function(t,e,i){var r=this.gl,n=this.CONTEXT_UID;i=i||0;var s=t._glBuffers[n]||this.createGLBuffer(t);r.bindBufferRange(r.UNIFORM_BUFFER,e||0,s.buffer,256*i,256)},/**
     * Will ensure sure the the data in the buffer is uploaded to the GPU.
     *
     * @param {PIXI.Buffer} buffer - the buffer to update
     */t.prototype.update=function(t){var e=this.gl,i=this.CONTEXT_UID,r=t._glBuffers[i];if(t._updateID!==r.updateID){if(r.updateID=t._updateID,e.bindBuffer(t.type,r.buffer),r.byteLength>=t.data.byteLength)e.bufferSubData(t.type,0,t.data);else{var n=t.static?e.STATIC_DRAW:e.DYNAMIC_DRAW;r.byteLength=t.data.byteLength,e.bufferData(t.type,t.data,n)}}},/**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer - buffer with data
     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */t.prototype.dispose=function(t,e){if(this.managedBuffers[t.id]){delete this.managedBuffers[t.id];var i=t._glBuffers[this.CONTEXT_UID],r=this.gl;t.disposeRunner.remove(this),i&&(e||r.deleteBuffer(i.buffer),delete t._glBuffers[this.CONTEXT_UID])}},/**
     * dispose all WebGL resources of all managed buffers
     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
     */t.prototype.disposeAll=function(t){for(var e=Object.keys(this.managedBuffers),i=0;i<e.length;i++)this.dispose(this.managedBuffers[e[i]],t)},/**
     * creates and attaches a GLBuffer object tied to the current context.
     * @protected
     */t.prototype.createGLBuffer=function(t){var e=this.CONTEXT_UID,i=this.gl;return t._glBuffers[e]=new n4(i.createBuffer()),this.managedBuffers[t.id]=t,t.disposeRunner.add(this),t._glBuffers[e]},t)}(),n8=/** @class */function(t){/**
     * @param [options] - The optional renderer parameters.
     * @param {number} [options.width=800] - The width of the screen.
     * @param {number} [options.height=600] - The height of the screen.
     * @param {HTMLCanvasElement} [options.view] - The canvas to use as a view, optional.
     * @param {boolean} [options.useContextAlpha=true] - Pass-through value for canvas' context `alpha` property.
     *   If you want to set transparency, please use `backgroundAlpha`. This option is for cases where the
     *   canvas needs to be opaque, possibly for performance reasons on some older devices.
     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
     *   resolutions other than 1.
     * @param {boolean} [options.antialias=false] - Sets antialias. If not available natively then FXAA
     *  antialiasing is used.
     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the renderer.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear
     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
     *  preserveDrawingBuffer to `true`.
     * @param {boolean} [options.preserveDrawingBuffer=false] - Enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the WebGL context.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {number} [options.backgroundAlpha=1] - Value from 0 (fully transparent) to 1 (fully opaque).
     * @param {string} [options.powerPreference] - Parameter passed to WebGL context, set to "high-performance"
     *  for devices with dual graphics card.
     * @param {object} [options.context] - If WebGL context already exists, all parameters must be taken from it.
     * @public
     */function e(i){var r=t.call(this,xq.WEBGL,i)||this;return(// the options will have been modified here in the super constructor with pixi's default settings..
i=r.options,/**
         * WebGL context, set by the contextSystem (this.context)
         *
         * @readonly
         * @member {WebGLRenderingContext}
         */r.gl=null,r.CONTEXT_UID=0,/**
         * Internal signal instances of **runner**, these
         * are assigned to each system created.
         * @see PIXI.Runner
         * @name runners
         * @private
         * @type {object}
         * @readonly
         * @property {PIXI.Runner} destroy - Destroy runner
         * @property {PIXI.Runner} contextChange - Context change runner
         * @property {PIXI.Runner} reset - Reset runner
         * @property {PIXI.Runner} update - Update runner
         * @property {PIXI.Runner} postrender - Post-render runner
         * @property {PIXI.Runner} prerender - Pre-render runner
         * @property {PIXI.Runner} resize - Resize runner
         */r.runners={destroy:new rg("destroy"),contextChange:new rg("contextChange"),reset:new rg("reset"),update:new rg("update"),postrender:new rg("postrender"),prerender:new rg("prerender"),resize:new rg("resize")},r.runners.contextChange.add(r),/**
         * Global uniforms
         * @member {PIXI.UniformGroup}
         */r.globalUniforms=new r2({projectionMatrix:new iX},!0),/**
         * Mask system instance
         * @member {PIXI.MaskSystem} mask
         * @memberof PIXI.Renderer#
         * @readonly
         */r.addSystem(nO,"mask")/**
             * Context system instance
             * @member {PIXI.ContextSystem} context
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nt,"context")/**
             * State system instance
             * @member {PIXI.StateSystem} state
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(n$,"state")/**
             * Shader system instance
             * @member {PIXI.ShaderSystem} shader
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nZ,"shader")/**
             * Texture system instance
             * @member {PIXI.TextureSystem} texture
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(n1,"texture")/**
             * Geometry system instance
             * @member {PIXI.systems.BufferSystem} buffer
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(n6,"buffer")/**
             * Geometry system instance
             * @member {PIXI.systems.GeometrySystem} geometry
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(ns,"geometry")/**
             * Framebuffer system instance
             * @member {PIXI.FramebufferSystem} framebuffer
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nr,"framebuffer")/**
             * Scissor system instance
             * @member {PIXI.ScissorSystem} scissor
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nN,"scissor")/**
             * Stencil system instance
             * @member {PIXI.StencilSystem} stencil
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nD,"stencil")/**
             * Projection system instance
             * @member {PIXI.ProjectionSystem} projection
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nF,"projection")/**
             * Texture garbage collector system instance
             * @member {PIXI.TextureGCSystem} textureGC
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nQ,"textureGC")/**
             * Filter system instance
             * @member {PIXI.FilterSystem} filter
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(r6,"filter")/**
             * RenderTexture system instance
             * @member {PIXI.RenderTextureSystem} renderTexture
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(nG,"renderTexture")/**
             * Batch system instance
             * @member {PIXI.BatchSystem} batch
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(r7,"batch"),r.initPlugins(e.__plugins),/**
         * The number of msaa samples of the canvas.
         * @member {PIXI.MSAA_QUALITY}
         * @readonly
         */r.multisample=void 0,i.context?r.context.initFromContext(i.context):r.context.initFromOptions({alpha:!!r.useContextAlpha,antialias:i.antialias,premultipliedAlpha:r.useContextAlpha&&"notMultiplied"!==r.useContextAlpha,stencil:!0,preserveDrawingBuffer:i.preserveDrawingBuffer,powerPreference:r.options.powerPreference}),/**
         * Flag if we are rendering to the screen vs renderTexture
         * @member {boolean}
         * @readonly
         * @default true
         */r.renderingToScreen=!0,e5(2===r.context.webGLVersion?"WebGL 2":"WebGL 1"),r.resize(r.options.width,r.options.height),r)}return rx(e,t),/**
     * Create renderer if WebGL is available. Overrideable
     * by the **@pixi/canvas-renderer** package to allow fallback.
     * throws error if WebGL is not available.
     * @static
     * @private
     */e.create=function(t){if(e4())return new e(t);throw Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')},e.prototype.contextChange=function(){var t,e=this.gl;if(1===this.context.webGLVersion){var i=e.getParameter(e.FRAMEBUFFER_BINDING);e.bindFramebuffer(e.FRAMEBUFFER,null),t=e.getParameter(e.SAMPLES),e.bindFramebuffer(e.FRAMEBUFFER,i)}else{var i=e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),t=e.getParameter(e.SAMPLES),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,i)}t>=bt.HIGH?this.multisample=bt.HIGH:t>=bt.MEDIUM?this.multisample=bt.MEDIUM:t>=bt.LOW?this.multisample=bt.LOW:this.multisample=bt.NONE},/**
     * Add a new system to the renderer.
     * @param ClassRef - Class reference
     * @param [name] - Property name for system, if not specified
     *        will use a static `name` property on the class itself. This
     *        name will be assigned as s property on the Renderer so make
     *        sure it doesn't collide with properties on Renderer.
     * @return {PIXI.Renderer} Return instance of renderer
     */e.prototype.addSystem=function(t,e){var i=new t(this);if(this[e])throw Error('Whoops! The name "'+e+'" is already in use');for(var r in this[e]=i,this.runners)this.runners[r].add(i);/**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         *//**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         *//**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */return this},/**
     * @ignore
     */e.prototype.render=function(t,e){// no point rendering if our context has been blown up!
if(e&&(e instanceof rj?(ix("6.0.0","Renderer#render arguments changed, use options instead."),/* eslint-disable prefer-rest-params */i=e,r=arguments[2],n=arguments[3],s=arguments[4]):(i=e.renderTexture,r=e.clear,n=e.transform,s=e.skipUpdateTransform)),// can be handy to know!
this.renderingToScreen=!i,this.runners.prerender.emit(),this.emit("prerender"),// apply a transform at a GPU level
this.projection.transform=n,!this.context.isLost){if(i||(this._lastObjectRendered=t),!s){// update the scene graph
var i,r,n,s,o=t.enableTempParent();t.updateTransform(),t.disableTempParent(o);// displayObject.hitArea = //TODO add a temp hit area
}this.renderTexture.bind(i),this.batch.currentRenderer.start(),(void 0!==r?r:this.clearBeforeRender)&&this.renderTexture.clear(),t.render(this),// apply transform..
this.batch.currentRenderer.flush(),i&&i.baseTexture.update(),this.runners.postrender.emit(),// reset transform after render
this.projection.transform=null,this.emit("postrender")}},/**
     * @override
     * @ignore
     */e.prototype.generateTexture=function(e,i,r,n){void 0===i&&(i={});var s=t.prototype.generateTexture.call(this,e,i,r,n);return this.framebuffer.blit(),s},/**
     * Resizes the WebGL view to the specified width and height.
     *
     * @param desiredScreenWidth - The desired width of the screen.
     * @param desiredScreenHeight - The desired height of the screen.
     */e.prototype.resize=function(e,i){t.prototype.resize.call(this,e,i),this.runners.resize.emit(this.screen.height,this.screen.width)},/**
     * Resets the WebGL state so you can render things however you fancy!
     *
     * @return {PIXI.Renderer} Returns itself.
     */e.prototype.reset=function(){return this.runners.reset.emit(),this},/**
     * Clear the frame buffer
     */e.prototype.clear=function(){this.renderTexture.bind(),this.renderTexture.clear()},/**
     * Removes everything from the renderer (event listeners, spritebatch, etc...)
     *
     * @param [removeView=false] - Removes the Canvas element from the DOM.
     *  See: https://github.com/pixijs/pixi.js/issues/2233
     */e.prototype.destroy=function(e){for(var i in this.runners.destroy.emit(),this.runners)this.runners[i].destroy();// call base destroy
t.prototype.destroy.call(this,e),// TODO nullify all the managers..
this.gl=null},Object.defineProperty(e.prototype,"extract",{/**
         * Please use `plugins.extract` instead.
         * @member {PIXI.Extract} extract
         * @deprecated since 6.0.0
         * @readonly
         */get:function(){return ix("6.0.0","Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."),this.plugins.extract},enumerable:!1,configurable:!0}),/**
     * Adds a plugin to the renderer.
     *
     * @method
     * @param pluginName - The name of the plugin.
     * @param ctor - The constructor function or class for the plugin.
     */e.registerPlugin=function(t,i){e.__plugins=e.__plugins||{},e.__plugins[t]=i},e}(n5);/**
 * This helper function will automatically detect which renderer you should be using.
 * WebGL is the preferred renderer as it is a lot faster. If WebGL is not supported by
 * the browser then this function will return a canvas renderer
 *
 * @memberof PIXI
 * @function autoDetectRenderer
 * @param {object} [options] - The optional renderer parameters
 * @param {number} [options.width=800] - the width of the renderers view
 * @param {number} [options.height=600] - the height of the renderers view
 * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
 * @param {boolean} [options.useContextAlpha=true] - Pass-through value for canvas' context `alpha` property.
 *   If you want to set transparency, please use `backgroundAlpha`. This option is for cases where the
 *   canvas needs to be opaque, possibly for performance reasons on some older devices.
 * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
 *   resolutions other than 1
 * @param {boolean} [options.antialias=false] - sets antialias
 * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
 *  need to call toDataUrl on the webgl context
 * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
 *  (shown if not transparent).
 * @param {number} [options.backgroundAlpha=1] - Value from 0 (fully transparent) to 1 (fully opaque).
 * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
 *   not before the new render pass.
 * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the renderer.
 * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present, this
 *   option only is available when using **pixi.js-legacy** or **@pixi/canvas-renderer** modules, otherwise
 *   it is ignored.
 * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
 *  for devices with dual graphics card **webgl only**
 * @return {PIXI.Renderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
 */function n7(t){return n8.create(t)}/**
 * Default vertex shader
 * @memberof PIXI
 * @member {string} defaultVertex
 *//**
 * Default filter vertex shader
 * @memberof PIXI
 * @member {string} defaultFilterVertex
 */// NOTE: This black magic is so that @microsoft/api-extractor does not complain! This explicitly specifies the types
// of defaultVertex, defaultFilterVertex.
var n9="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",st="attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",se=/** @class */function(){/**
     * @param renderer - Reference to Renderer
     */function t(t){ix("6.1.0","System class is deprecated, implemement ISystem interface instead."),this.renderer=t}return(/** Destroy and don't use after this. */t.prototype.destroy=function(){this.renderer=null},t)}(),si=function(){this.texArray=null,this.blend=0,this.type=xZ.TRIANGLES,this.start=0,this.size=0,/**
         * data for uniforms or custom webgl state
         * @member {object}
         */this.data=null},sr=/** @class */function(){function t(){/**
         * inside textures array
         * @member {PIXI.BaseTexture[]}
         */this.elements=[],/**
         * Respective locations for textures
         * @member {number[]}
         */this.ids=[],/**
         * number of filled elements
         * @member {number}
         */this.count=0}return t.prototype.clear=function(){for(var t=0;t<this.count;t++)this.elements[t]=null;this.count=0},t}(),sn=/** @class */function(){function t(t){"number"==typeof t?/**
             * Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`.
             *
             * @member {ArrayBuffer}
             */this.rawBinaryData=new ArrayBuffer(t):t instanceof Uint8Array?this.rawBinaryData=t.buffer:this.rawBinaryData=t,/**
         * View on the raw binary data as a `Uint32Array`.
         *
         * @member {Uint32Array}
         */this.uint32View=new Uint32Array(this.rawBinaryData),/**
         * View on the raw binary data as a `Float32Array`.
         *
         * @member {Float32Array}
         */this.float32View=new Float32Array(this.rawBinaryData)}return Object.defineProperty(t.prototype,"int8View",{/**
         * View on the raw binary data as a `Int8Array`.
         *
         * @member {Int8Array}
         */get:function(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"uint8View",{/**
         * View on the raw binary data as a `Uint8Array`.
         *
         * @member {Uint8Array}
         */get:function(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"int16View",{/**
         * View on the raw binary data as a `Int16Array`.
         *
         * @member {Int16Array}
         */get:function(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"uint16View",{/**
         * View on the raw binary data as a `Uint16Array`.
         *
         * @member {Uint16Array}
         */get:function(){return this._uint16View||(this._uint16View=new Uint16Array(this.rawBinaryData)),this._uint16View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"int32View",{/**
         * View on the raw binary data as a `Int32Array`.
         *
         * @member {Int32Array}
         */get:function(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View},enumerable:!1,configurable:!0}),/**
     * Returns the view of the given type.
     *
     * @param {string} type - One of `int8`, `uint8`, `int16`,
     *    `uint16`, `int32`, `uint32`, and `float32`.
     * @return {object} typed array of given type
     */t.prototype.view=function(t){return this[t+"View"]},/**
     * Destroys all buffer references. Do not use after calling
     * this.
     */t.prototype.destroy=function(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null},t.sizeOf=function(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw Error(t+" isn't a valid view type")}},t}(),ss=/** @class */function(t){/**
     * This will hook onto the renderer's `contextChange`
     * and `prerender` signals.
     *
     * @param {PIXI.Renderer} renderer - The renderer this works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * This is used to generate a shader that can
         * color each vertex based on a `aTextureId`
         * attribute that points to an texture in `uSampler`.
         *
         * This enables the objects with different textures
         * to be drawn in the same draw call.
         *
         * You can customize your shader by creating your
         * custom shader generator.
         *
         * @member {PIXI.BatchShaderGenerator}
         * @protected
         */i.shaderGenerator=null,/**
         * The class that represents the geometry of objects
         * that are going to be batched with this.
         *
         * @member {object}
         * @default PIXI.BatchGeometry
         * @protected
         */i.geometryClass=null,/**
         * Size of data being buffered per vertex in the
         * attribute buffers (in floats). By default, the
         * batch-renderer plugin uses 6:
         *
         * | aVertexPosition | 2 |
         * |-----------------|---|
         * | aTextureCoords  | 2 |
         * | aColor          | 1 |
         * | aTextureId      | 1 |
         *
         * @member {number}
         * @readonly
         */i.vertexSize=null,/**
         * The WebGL state in which this renderer will work.
         *
         * @member {PIXI.State}
         * @readonly
         */i.state=nA.for2d(),/**
         * The number of bufferable objects before a flush
         * occurs automatically.
         *
         * @member {number}
         * @default settings.SPRITE_BATCH_SIZE * 4
         */i.size=4*ec.SPRITE_BATCH_SIZE,/**
         * Total count of all vertices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */i._vertexCount=0,/**
         * Total count of all indices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */i._indexCount=0,/**
         * Buffer of objects that are yet to be rendered.
         *
         * @member {PIXI.DisplayObject[]}
         * @private
         */i._bufferedElements=[],/**
         * Data for texture batch builder, helps to save a bit of CPU on a pass.
         * @type {PIXI.BaseTexture[]}
         * @private
         */i._bufferedTextures=[],/**
         * Number of elements that are buffered and are
         * waiting to be flushed.
         *
         * @member {number}
         * @private
         */i._bufferSize=0,/**
         * This shader is generated by `this.shaderGenerator`.
         *
         * It is generated specifically to handle the required
         * number of textures being batched together.
         *
         * @member {PIXI.Shader}
         * @protected
         */i._shader=null,/**
         * Pool of `this.geometryClass` geometry objects
         * that store buffers. They are used to pass data
         * to the shader on each draw call.
         *
         * These are never re-allocated again, unless a
         * context change occurs; however, the pool may
         * be expanded if required.
         *
         * @member {PIXI.Geometry[]}
         * @private
         * @see PIXI.AbstractBatchRenderer.contextChange
         */i._packedGeometries=[],/**
         * Size of `this._packedGeometries`. It can be expanded
         * if more than `this._packedGeometryPoolSize` flushes
         * occur in a single frame.
         *
         * @member {number}
         * @private
         */i._packedGeometryPoolSize=2,/**
         * A flush may occur multiple times in a single
         * frame. On iOS devices or when
         * `settings.CAN_UPLOAD_SAME_BUFFER` is false, the
         * batch renderer does not upload data to the same
         * `WebGLBuffer` for performance reasons.
         *
         * This is the index into `packedGeometries` that points to
         * geometry holding the most recent buffers.
         *
         * @member {number}
         * @private
         */i._flushId=0,/**
         * Pool of `ViewableBuffer` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing attributes.
         *
         * The first buffer has a size of 8; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {PIXI.ViewableBuffer[]}
         * @private
         * @see PIXI.AbstractBatchRenderer#getAttributeBuffer
         */i._aBuffers={},/**
         * Pool of `Uint16Array` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing indices.
         *
         * The first buffer has a size of 12; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {Uint16Array[]}
         * @private
         * @see PIXI.AbstractBatchRenderer#getIndexBuffer
         */i._iBuffers={},/**
         * Maximum number of textures that can be uploaded to
         * the GPU under the current context. It is initialized
         * properly in `this.contextChange`.
         *
         * @member {number}
         * @see PIXI.AbstractBatchRenderer#contextChange
         * @readonly
         */i.MAX_TEXTURES=1,i.renderer.on("prerender",i.onPrerender,i),e.runners.contextChange.add(i),i._dcIndex=0,i._aIndex=0,i._iIndex=0,i._attributeBuffer=null,i._indexBuffer=null,i._tempBoundTextures=[],i)}return rx(e,t),/**
     * Handles the `contextChange` signal.
     *
     * It calculates `this.MAX_TEXTURES` and allocating the
     * packed-geometry object pool.
     */e.prototype.contextChange=function(){var t=this.renderer.gl;ec.PREFER_ENV===xY.WEBGL_LEGACY?this.MAX_TEXTURES=1:(// step 1: first check max textures the GPU can handle.
this.MAX_TEXTURES=Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),ec.SPRITE_MAX_TEXTURES),// step 2: check the maximum number of if statements the shader can have too..
this.MAX_TEXTURES=nE(this.MAX_TEXTURES,t)),this._shader=this.shaderGenerator.generateShader(this.MAX_TEXTURES);// we use the second shader as the first one depending on your browser
// may omit aTextureId as it is not used by the shader so is optimized out.
for(var e=0;e<this._packedGeometryPoolSize;e++)/* eslint-disable max-len */this._packedGeometries[e]=new this.geometryClass;this.initFlushBuffers()},/**
     * Makes sure that static and dynamic flush pooled objects have correct dimensions
     */e.prototype.initFlushBuffers=function(){for(var t=e._drawCallPool,i=e._textureArrayPool,r=this.size/4,n=Math.floor(r/this.MAX_TEXTURES)+1;t.length<r;)t.push(new si);for(;i.length<n;)i.push(new sr);for(var s=0;s<this.MAX_TEXTURES;s++)this._tempBoundTextures[s]=null},/**
     * Handles the `prerender` signal.
     *
     * It ensures that flushes start from the first geometry
     * object again.
     */e.prototype.onPrerender=function(){this._flushId=0},/**
     * Buffers the "batchable" object. It need not be rendered
     * immediately.
     *
     * @param {PIXI.DisplayObject} element - the element to render when
     *    using this renderer
     */e.prototype.render=function(t){t._texture.valid&&(this._vertexCount+t.vertexData.length/2>this.size&&this.flush(),this._vertexCount+=t.vertexData.length/2,this._indexCount+=t.indices.length,this._bufferedTextures[this._bufferSize]=t._texture.baseTexture,this._bufferedElements[this._bufferSize++]=t)},e.prototype.buildTexturesAndDrawCalls=function(){var t=this._bufferedTextures,i=this.MAX_TEXTURES,r=e._textureArrayPool,n=this.renderer.batch,s=this._tempBoundTextures,o=this.renderer.textureGC.count,a=++rS._globalBatch,h=0,l=r[0],u=0;n.copyBoundTextures(s,i);for(var c=0;c<this._bufferSize;++c){var d=t[c];t[c]=null,d._batchEnabled!==a&&(l.count>=i&&(n.boundArray(l,s,a,i),this.buildDrawCalls(l,u,c),u=c,l=r[++h],++a),d._batchEnabled=a,d.touched=o,l.elements[l.count++]=d)}l.count>0&&(n.boundArray(l,s,a,i),this.buildDrawCalls(l,u,this._bufferSize),++h,++a);// Clean-up
for(var c=0;c<s.length;c++)s[c]=null;rS._globalBatch=a},/**
     * Populating drawcalls for rendering
     *
     * @param {PIXI.BatchTextureArray} texArray
     * @param {number} start
     * @param {number} finish
     */e.prototype.buildDrawCalls=function(t,i,r){var n=this._bufferedElements,s=this._attributeBuffer,o=this._indexBuffer,a=this.vertexSize,h=e._drawCallPool,l=this._dcIndex,u=this._aIndex,c=this._iIndex,d=h[l];d.start=this._iIndex,d.texArray=t;for(var p=i;p<r;++p){var f=n[p],m=ie[f._texture.baseTexture.alphaMode?1:0][f.blendMode];n[p]=null,i<p&&d.blend!==m&&(d.size=c-d.start,i=p,(d=h[++l]).texArray=t,d.start=c),this.packInterleavedGeometry(f,s,o,u,c),u+=f.vertexData.length/2*a,c+=f.indices.length,d.blend=m}i<r&&(d.size=c-d.start,++l),this._dcIndex=l,this._aIndex=u,this._iIndex=c},/**
     * Bind textures for current rendering
     *
     * @param {PIXI.BatchTextureArray} texArray
     */e.prototype.bindAndClearTexArray=function(t){for(var e=this.renderer.texture,i=0;i<t.count;i++)e.bind(t.elements[i],t.ids[i]),t.elements[i]=null;t.count=0},e.prototype.updateGeometry=function(){var t=this._packedGeometries,e=this._attributeBuffer,i=this._indexBuffer;ec.CAN_UPLOAD_SAME_BUFFER?(// lets use the faster option, always use buffer number 0
t[this._flushId]._buffer.update(e.rawBinaryData),t[this._flushId]._indexBuffer.update(i),this.renderer.geometry.updateBuffers()):(this._packedGeometryPoolSize<=this._flushId&&(this._packedGeometryPoolSize++,t[this._flushId]=new this.geometryClass),t[this._flushId]._buffer.update(e.rawBinaryData),t[this._flushId]._indexBuffer.update(i),this.renderer.geometry.bind(t[this._flushId]),this.renderer.geometry.updateBuffers(),this._flushId++)},e.prototype.drawBatches=function(){// Upload textures and do the draw calls
for(var t=this._dcIndex,i=this.renderer,r=i.gl,n=i.state,s=e._drawCallPool,o=null,a=0;a<t;a++){var h=s[a],l=h.texArray,u=h.type,c=h.size,d=h.start,p=h.blend;o!==l&&(o=l,this.bindAndClearTexArray(l)),this.state.blendMode=p,n.set(this.state),r.drawElements(u,c,r.UNSIGNED_SHORT,2*d)}},/**
     * Renders the content _now_ and empties the current batch.
     */e.prototype.flush=function(){0!==this._vertexCount&&(this._attributeBuffer=this.getAttributeBuffer(this._vertexCount),this._indexBuffer=this.getIndexBuffer(this._indexCount),this._aIndex=0,this._iIndex=0,this._dcIndex=0,this.buildTexturesAndDrawCalls(),this.updateGeometry(),this.drawBatches(),// reset elements buffer for the next flush
this._bufferSize=0,this._vertexCount=0,this._indexCount=0)},/**
     * Starts a new sprite batch.
     */e.prototype.start=function(){this.renderer.state.set(this.state),this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),this.renderer.shader.bind(this._shader),ec.CAN_UPLOAD_SAME_BUFFER&&this.renderer.geometry.bind(this._packedGeometries[this._flushId])},/**
     * Stops and flushes the current batch.
     */e.prototype.stop=function(){this.flush()},/**
     * Destroys this `AbstractBatchRenderer`. It cannot be used again.
     */e.prototype.destroy=function(){for(var e=0;e<this._packedGeometryPoolSize;e++)this._packedGeometries[e]&&this._packedGeometries[e].destroy();this.renderer.off("prerender",this.onPrerender,this),this._aBuffers=null,this._iBuffers=null,this._packedGeometries=null,this._attributeBuffer=null,this._indexBuffer=null,this._shader&&(this._shader.destroy(),this._shader=null),t.prototype.destroy.call(this)},/**
     * Fetches an attribute buffer from `this._aBuffers` that
     * can hold atleast `size` floats.
     *
     * @param {number} size - minimum capacity required
     * @return {ViewableBuffer} - buffer than can hold atleast `size` floats
     * @private
     */e.prototype.getAttributeBuffer=function(t){// 8 vertices is enough for 2 quads
var e=ic(Math.ceil(t/8)),i=ip(e),r=8*e;this._aBuffers.length<=i&&(this._iBuffers.length=i+1);var n=this._aBuffers[r];return n||(this._aBuffers[r]=n=new sn(r*this.vertexSize*4)),n},/**
     * Fetches an index buffer from `this._iBuffers` that can
     * have at least `size` capacity.
     *
     * @param {number} size - minimum required capacity
     * @return {Uint16Array} - buffer that can fit `size`
     *    indices.
     * @private
     */e.prototype.getIndexBuffer=function(t){// 12 indices is enough for 2 quads
var e=ic(Math.ceil(t/12)),i=ip(e),r=12*e;this._iBuffers.length<=i&&(this._iBuffers.length=i+1);var n=this._iBuffers[i];return n||(this._iBuffers[i]=n=new Uint16Array(r)),n},/**
     * Takes the four batching parameters of `element`, interleaves
     * and pushes them into the batching attribute/index buffers given.
     *
     * It uses these properties: `vertexData` `uvs`, `textureId` and
     * `indicies`. It also uses the "tint" of the base-texture, if
     * present.
     *
     * @param {PIXI.Sprite} element - element being rendered
     * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
     * @param {Uint16Array} indexBuffer - index buffer
     * @param {number} aIndex - number of floats already in the attribute buffer
     * @param {number} iIndex - number of indices already in `indexBuffer`
     */e.prototype.packInterleavedGeometry=function(t,e,i,r,n){// lets not worry about tint! for now..
for(var s=e.uint32View,o=e.float32View,a=r/this.vertexSize,h=t.uvs,l=t.indices,u=t.vertexData,c=t._texture.baseTexture._batchLocation,d=Math.min(t.worldAlpha,1),p=d<1&&t._texture.baseTexture.alphaMode?is(t._tintRGB,d):t._tintRGB+(255*d<<24),f=0;f<u.length;f+=2)o[r++]=u[f],o[r++]=u[f+1],o[r++]=h[f],o[r++]=h[f+1],s[r++]=p,o[r++]=c;for(var f=0;f<l.length;f++)i[n++]=a+l[f]},/**
     * Pool of `BatchDrawCall` objects that `flush` used
     * to create "batches" of the objects being rendered.
     *
     * These are never re-allocated again.
     * Shared between all batch renderers because it can be only one "flush" working at the moment.
     *
     * @static
     * @member {PIXI.BatchDrawCall[]}
     */e._drawCallPool=[],/**
     * Pool of `BatchDrawCall` objects that `flush` used
     * to create "batches" of the objects being rendered.
     *
     * These are never re-allocated again.
     * Shared between all batch renderers because it can be only one "flush" working at the moment.
     *
     * @static
     * @member {PIXI.BatchTextureArray[]}
     */e._textureArrayPool=[],e}(r8),so=/** @class */function(){/**
     * @param {string} vertexSrc - Vertex shader
     * @param {string} fragTemplate - Fragment shader template
     */function t(t,e){if(/**
         * Reference to the vertex shader source.
         *
         * @member {string}
         */this.vertexSrc=t,/**
         * Reference to the fragment shader template. Must contain "%count%" and "%forloop%".
         *
         * @member {string}
         */this.fragTemplate=e,this.programCache={},this.defaultGroupCache={},0>e.indexOf("%count%"))throw Error('Fragment template must contain "%count%".');if(0>e.indexOf("%forloop%"))throw Error('Fragment template must contain "%forloop%".')}return t.prototype.generateShader=function(t){if(!this.programCache[t]){for(var e=new Int32Array(t),i=0;i<t;i++)e[i]=i;this.defaultGroupCache[t]=r2.from({uSamplers:e},!0);var r=this.fragTemplate;r=(r=r.replace(/%count%/gi,""+t)).replace(/%forloop%/gi,this.generateSampleSrc(t)),this.programCache[t]=new nS(this.vertexSrc,r)}var n={tint:new Float32Array([1,1,1,1]),translationMatrix:new iX,default:this.defaultGroupCache[t]};return new nM(this.programCache[t],n)},t.prototype.generateSampleSrc=function(t){var e="";e+="\n\n";for(var i=0;i<t;i++)i>0&&(e+="\nelse "),i<t-1&&(e+="if(vTextureId < "+i+".5)"),e+="\n{\n	color = texture2D(uSamplers["+i+"], vTextureCoord);\n}";return e+"\n\n"},t}(),sa=/** @class */function(t){/**
     * @param {boolean} [_static=false] - Optimization flag, where `false`
     *        is updated every frame, `true` doesn't change frame-to-frame.
     */function e(e){void 0===e&&(e=!1);var i=t.call(this)||this;return(/**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */i._buffer=new rY(null,e,!1),/**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */i._indexBuffer=new rY(null,e,!0),i.addAttribute("aVertexPosition",i._buffer,2,!1,x0.FLOAT).addAttribute("aTextureCoord",i._buffer,2,!1,x0.FLOAT).addAttribute("aColor",i._buffer,4,!0,x0.UNSIGNED_BYTE).addAttribute("aTextureId",i._buffer,1,!0,x0.FLOAT).addIndex(i._indexBuffer),i)}return rx(e,t),e}(r$),sh="precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",sl="varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",su=/** @class */function(){function t(){}return(/**
     * Create a new BatchRenderer plugin for Renderer. this convenience can provide an easy way
     * to extend BatchRenderer with all the necessary pieces.
     * @example
     * const fragment = `
     * varying vec2 vTextureCoord;
     * varying vec4 vColor;
     * varying float vTextureId;
     * uniform sampler2D uSamplers[%count%];
     *
     * void main(void){
     *     vec4 color;
     *     %forloop%
     *     gl_FragColor = vColor * vec4(color.a - color.rgb, color.a);
     * }
     * `;
     * const InvertBatchRenderer = PIXI.BatchPluginFactory.create({ fragment });
     * PIXI.Renderer.registerPlugin('invert', InvertBatchRenderer);
     * const sprite = new PIXI.Sprite();
     * sprite.pluginName = 'invert';
     *
     * @static
     * @param {object} [options]
     * @param {string} [options.vertex=PIXI.BatchPluginFactory.defaultVertexSrc] - Vertex shader source
     * @param {string} [options.fragment=PIXI.BatchPluginFactory.defaultFragmentTemplate] - Fragment shader template
     * @param {number} [options.vertexSize=6] - Vertex size
     * @param {object} [options.geometryClass=PIXI.BatchGeometry]
     * @return {*} New batch renderer plugin
     */t.create=function(t){var e=Object.assign({vertex:sh,fragment:sl,geometryClass:sa,vertexSize:6},t),i=e.vertex,r=e.fragment,n=e.vertexSize,s=e.geometryClass;return /** @class */function(t){function e(e){var o=t.call(this,e)||this;return o.shaderGenerator=new so(i,r),o.geometryClass=s,o.vertexSize=n,o}return rx(e,t),e}(ss)},Object.defineProperty(t,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return sh},enumerable:!1,configurable:!0}),Object.defineProperty(t,"defaultFragmentTemplate",{/**
         * The default fragment shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return sl},enumerable:!1,configurable:!0}),t)}(),sc=su.create(),sd={},sp=function(t){Object.defineProperty(sd,t,{get:function(){return ix("6.0.0","PIXI.systems."+t+" has moved to PIXI."+t),rD[t]}})};for(var sf in rD)sp(sf);/**
 * @memberof PIXI
 * @namespace systems
 * @see PIXI
 * @deprecated since 6.0.0
 */var sm={},sg=function(t){Object.defineProperty(sm,t,{get:function(){return ix("6.0.0","PIXI.resources."+t+" has moved to PIXI."+t),n2[t]}})};for(var sf in n2)sg(sf);/**
 * Convenience class to create a new PIXI application.
 *
 * This class automatically creates the renderer, ticker and root container.
 *
 * @example
 * // Create the application
 * const app = new PIXI.Application();
 *
 * // Add the view to the DOM
 * document.body.appendChild(app.view);
 *
 * // ex, add display objects
 * app.stage.addChild(PIXI.Sprite.from('something.png'));
 *
 * @class
 * @memberof PIXI
 */var sy=/** @class */function(){/**
     * @param {object} [options] - The optional renderer parameters.
     * @param {boolean} [options.autoStart=true] - Automatically starts the rendering after the construction.
     *     **Note**: Setting this parameter to false does NOT stop the shared ticker even if you set
     *     options.sharedTicker to true in case that it is already started. Stop it by your own.
     * @param {number} [options.width=800] - The width of the renderers view.
     * @param {number} [options.height=600] - The height of the renderers view.
     * @param {HTMLCanvasElement} [options.view] - The canvas to use as a view, optional.
     * @param {boolean} [options.useContextAlpha=true] - Pass-through value for canvas' context `alpha` property.
     *   If you want to set transparency, please use `backgroundAlpha`. This option is for cases where the
     *   canvas needs to be opaque, possibly for performance reasons on some older devices.
     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
     *   resolutions other than 1.
     * @param {boolean} [options.antialias=false] - Sets antialias
     * @param {boolean} [options.preserveDrawingBuffer=false] - Enables drawing buffer preservation, enable this if you
     *  need to call toDataUrl on the WebGL context.
     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the renderer.
     * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present, this
     *   option only is available when using **pixi.js-legacy** or **@pixi/canvas-renderer** modules, otherwise
     *   it is ignored.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {number} [options.backgroundAlpha=1] - Value from 0 (fully transparent) to 1 (fully opaque).
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
     *   not before the new render pass.
     * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to "high-performance"
     *  for devices with dual graphics card. **(WebGL only)**.
     * @param {boolean} [options.sharedTicker=false] - `true` to use PIXI.Ticker.shared, `false` to create new ticker.
     *  If set to false, you cannot register a handler to occur before anything that runs on the shared ticker.
     *  The system ticker will always run before both the shared ticker and the app ticker.
     * @param {boolean} [options.sharedLoader=false] - `true` to use PIXI.Loader.shared, `false` to create new Loader.
     * @param {Window|HTMLElement} [options.resizeTo] - Element to automatically resize stage to.
     */function t(e){var i=this;/**
         * The root display container that's rendered.
         * @member {PIXI.Container}
         */this.stage=new i8,// The default options
e=Object.assign({forceCanvas:!1},e),this.renderer=n7(e),// install plugins here
t._plugins.forEach(function(t){t.init.call(i,e)})}return(/**
     * Register a middleware plugin for the application
     * @static
     * @param {PIXI.IApplicationPlugin} plugin - Plugin being installed
     */t.registerPlugin=function(e){t._plugins.push(e)},/**
     * Render the current stage.
     */t.prototype.render=function(){this.renderer.render(this.stage)},Object.defineProperty(t.prototype,"view",{/**
         * Reference to the renderer's canvas element.
         * @member {HTMLCanvasElement}
         * @readonly
         */get:function(){return this.renderer.view},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"screen",{/**
         * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
         * @member {PIXI.Rectangle}
         * @readonly
         */get:function(){return this.renderer.screen},enumerable:!1,configurable:!0}),/**
     * Destroy and don't use after this.
     * @param {Boolean} [removeView=false] - Automatically remove canvas from DOM.
     * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'stageOptions' will be passed on to those calls.
     * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
     *  to true. Should it destroy the texture of the child sprite
     * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
     *  to true. Should it destroy the base texture of the child sprite
     */t.prototype.destroy=function(e,i){var r=this,n=t._plugins.slice(0);n.reverse(),n.forEach(function(t){t.destroy.call(r)}),this.stage.destroy(i),this.stage=null,this.renderer.destroy(e),this.renderer=null},/** Collection of installed plugins. */t._plugins=[],t)}(),s_=/** @class */function(){function t(){}return(/**
     * Initialize the plugin with scope of application instance
     * @static
     * @private
     * @param {object} [options] - See application options
     */t.init=function(t){var e=this;Object.defineProperty(this,"resizeTo",/**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */{set:function(t){self.removeEventListener("resize",this.queueResize),this._resizeTo=t,t&&(self.addEventListener("resize",this.queueResize),this.resize())},get:function(){return this._resizeTo}}),/**
         * Resize is throttled, so it's safe to call this multiple times per frame and it'll
         * only be called once.
         *
         * @memberof PIXI.Application#
         * @method queueResize
         * @private
         */this.queueResize=function(){e._resizeTo&&(e.cancelResize(),// // Throttle resize events per raf
e._resizeId=requestAnimationFrame(function(){return e.resize()}))},/**
         * Cancel the resize queue.
         *
         * @memberof PIXI.Application#
         * @method cancelResize
         * @private
         */this.cancelResize=function(){e._resizeId&&(cancelAnimationFrame(e._resizeId),e._resizeId=null)},/**
         * Execute an immediate resize on the renderer, this is not
         * throttled and can be expensive to call many times in a row.
         * Will resize only if `resizeTo` property is set.
         *
         * @memberof PIXI.Application#
         * @method resize
         */this.resize=function(){if(e._resizeTo){// Resize to the window
if(// clear queue resize
e.cancelResize(),e._resizeTo===self)t=self.innerWidth,i=self.innerHeight;else{var t,i,r=e._resizeTo,n=r.clientWidth,s=r.clientHeight;t=n,i=s}e.renderer.resize(t,i)}},// On resize
this._resizeId=null,this._resizeTo=null,this.resizeTo=t.resizeTo||null},/**
     * Clean up the ticker, scoped to application
     *
     * @static
     * @private
     */t.destroy=function(){self.removeEventListener("resize",this.queueResize),this.cancelResize(),this.cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null},t)}();sy.registerPlugin(s_);var sv={};tC(sv,"Extract",()=>sb);/*!
 * @pixi/extract - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var sx=new iU,sb=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - A reference to the current renderer
     */function t(t){this.renderer=t}return(/**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @param {string} [format] - Image format, e.g. "image/jpeg" or "image/webp".
     * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.
     * @return {HTMLImageElement} HTML Image of the target
     */t.prototype.image=function(t,e,i){var r=new Image;return r.src=this.base64(t,e,i),r},/**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `Extract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @param {string} [format] - Image format, e.g. "image/jpeg" or "image/webp".
     * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.
     * @return {string} A base64 encoded string of the texture.
     */t.prototype.base64=function(t,e,i){return this.canvas(t).toDataURL(e,i)},/**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */t.prototype.canvas=function(e){var i,r,n,s=this.renderer,o=!1,a=!1;e&&(e instanceof rj?n=e:(n=this.renderer.generateTexture(e),a=!0)),n?(i=n.baseTexture.resolution,r=n.frame,o=!1,s.renderTexture.bind(n)):(i=this.renderer.resolution,o=!0,(r=sx).width=this.renderer.width,r.height=this.renderer.height,s.renderTexture.bind(null));var h=Math.floor(r.width*i+1e-4),l=Math.floor(r.height*i+1e-4),u=new iM(h,l,1),c=new Uint8Array(4*h*l),d=s.gl;d.readPixels(r.x*i,r.y*i,h,l,d.RGBA,d.UNSIGNED_BYTE,c);// add the pixels to the canvas
var p=u.context.getImageData(0,0,h,l);// pulling pixels
if(t.arrayPostDivide(c,p.data),u.context.putImageData(p,0,0),o){var f=new iM(u.width,u.height,1);f.context.scale(1,-1),// we can't render to itself because we should be empty before render.
f.context.drawImage(u.canvas,0,-l),u.destroy(),u=f}// send the canvas back..
return a&&n.destroy(!0),u.canvas},/**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {Uint8Array} One-dimensional array containing the pixel data of the entire texture
     */t.prototype.pixels=function(e){var i,r,n,s=this.renderer,o=!1;e&&(e instanceof rj?n=e:(n=this.renderer.generateTexture(e),o=!0)),n?(i=n.baseTexture.resolution,r=n.frame,// bind the buffer
s.renderTexture.bind(n)):(i=s.resolution,(r=sx).width=s.width,r.height=s.height,s.renderTexture.bind(null));var a=r.width*i,h=r.height*i,l=new Uint8Array(4*a*h),u=s.gl;return u.readPixels(r.x*i,r.y*i,a,h,u.RGBA,u.UNSIGNED_BYTE,l),o&&n.destroy(!0),t.arrayPostDivide(l,l),l},/**
     * Destroys the extract
     *
     */t.prototype.destroy=function(){this.renderer=null},/**
     * Takes premultiplied pixel data and produces regular pixel data
     *
     * @private
     * @param {number[] | Uint8Array | Uint8ClampedArray} pixels - array of pixel data
     * @param {number[] | Uint8Array | Uint8ClampedArray} out - output array
     */t.arrayPostDivide=function(t,e){for(var i=0;i<t.length;i+=4){var r=e[i+3]=t[i+3];0!==r?(e[i]=Math.round(Math.min(255*t[i]/r,255)),e[i+1]=Math.round(Math.min(255*t[i+1]/r,255)),e[i+2]=Math.round(Math.min(255*t[i+2]/r,255))):(e[i]=t[i],e[i+1]=t[i+1],e[i+2]=t[i+2])}},t)}(),sE={};tC(sE,"LoaderResource",()=>sO),tC(sE,"Loader",()=>sB),tC(sE,"AppLoaderPlugin",()=>sU),tC(sE,"TextureLoader",()=>sG);/*!
 * @pixi/loaders - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//* jshint -W097 *//**
 * @memberof PIXI
 */var sT=/** @class */function(){/**
     * SignalBinding constructor.
     * @constructs SignalBinding
     * @param {Function} fn - Event handler to be called.
     * @param {Boolean} [once=false] - Should this listener be removed after dispatch
     * @param {object} [thisArg] - The context of the callback function.
     * @api private
     */// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function t(t,e,i){void 0===e&&(e=!1),this._fn=t,this._once=e,this._thisArg=i,this._next=this._prev=this._owner=null}return t.prototype.detach=function(){return null!==this._owner&&(this._owner.detach(this),!0)},t}();/**
 * @private
 */function sw(t,e){return t._head?(t._tail._next=e,e._prev=t._tail):t._head=e,t._tail=e,e._owner=t,e}/**
 * @memberof PIXI
 */var sS=/** @class */function(){/**
     * MiniSignal constructor.
     * @example
     * let mySignal = new Signal();
     * let binding = mySignal.add(onSignal);
     * mySignal.dispatch('foo', 'bar');
     * mySignal.detach(binding);
     */function t(){this._head=this._tail=void 0}return(/**
     * Return an array of attached SignalBinding.
     *
     * @param {Boolean} [exists=false] - We only need to know if there are handlers.
     * @returns {PIXI.SignalBinding[]|Boolean} Array of attached SignalBinding or Boolean if called with exists = true
     * @api public
     */t.prototype.handlers=function(t){void 0===t&&(t=!1);var e=this._head;if(t)return!!e;for(var i=[];e;)i.push(e),e=e._next;return i},/**
     * Return true if node is a SignalBinding attached to this MiniSignal
     *
     * @param {PIXI.SignalBinding} node - Node to check.
     * @returns {Boolean} True if node is attache to mini-signal
     */t.prototype.has=function(t){if(!(t instanceof sT))throw Error("MiniSignal#has(): First arg must be a SignalBinding object.");return t._owner===this},/**
     * Dispaches a signal to all registered listeners.
     *
     * @returns {Boolean} Indication if we've emitted an event.
     */t.prototype.dispatch=function(){for(var t=arguments,e=[],i=0;i<arguments.length;i++)e[i]=t[i];var r=this._head;if(!r)return!1;for(;r;)r._once&&this.detach(r),r._fn.apply(r._thisArg,e),r=r._next;return!0},/**
     * Register a new listener.
     *
     * @param {Function} fn - Callback function.
     * @param {object} [thisArg] - The context of the callback function.
     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.
     */t.prototype.add=function(t,e){if(void 0===e&&(e=null),"function"!=typeof t)throw Error("MiniSignal#add(): First arg must be a Function.");return sw(this,new sT(t,!1,e))},/**
     * Register a new listener that will be executed only once.
     *
     * @param {Function} fn - Callback function.
     * @param {object} [thisArg] - The context of the callback function.
     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.
     */t.prototype.once=function(t,e){if(void 0===e&&(e=null),"function"!=typeof t)throw Error("MiniSignal#once(): First arg must be a Function.");return sw(this,new sT(t,!0,e))},/**
     * Remove binding object.
     *
     * @param {PIXI.SignalBinding} node - The binding node that will be removed.
     * @returns {Signal} The instance on which this method was called.
     * @api public */t.prototype.detach=function(t){if(!(t instanceof sT))throw Error("MiniSignal#detach(): First arg must be a SignalBinding object.");return t._owner!==this||(t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t===this._head?(this._head=t._next,null===t._next&&(this._tail=null)):t===this._tail&&(this._tail=t._prev,this._tail._next=null),t._owner=null),this},/**
     * Detach all listeners.
     *
     * @returns {Signal} The instance on which this method was called.
     */t.prototype.detachAll=function(){var t=this._head;if(!t)return this;for(this._head=this._tail=null;t;)t._owner=null,t=t._next;return this},t)}();/**
 * function from npm package `parseUri`, converted to TS to avoid leftpad incident
 * @param {string} str
 * @param [opts] - options
 * @param {boolean} [opts.strictMode] - type of parser
 */function sM(t,e){e=e||{};for(var i={// eslint-disable-next-line max-len
key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{// eslint-disable-next-line max-len
strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,// eslint-disable-next-line max-len
loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},r=i.parser[e.strictMode?"strict":"loose"].exec(t),n={},s=14;s--;)n[i.key[s]]=r[s]||"";return n[i.q.name]={},n[i.key[12]].replace(i.q.parser,function(t,e,r){e&&(n[i.q.name][e]=r)}),n}// tests if CORS is supported in XHR, if not we need to use XDR
var sA=!!(self.XDomainRequest&&!("withCredentials"in new XMLHttpRequest)),sR=null;// noop
function sC(){}/**
 * Quick helper to set a value on one of the extension maps. Ensures there is no
 * dot at the start of the extension.
 *
 * @ignore
 * @param map - The map to set on.
 * @param extname - The extension (or key) to set.
 * @param val - The value to set.
 */function sP(t,e,i){e&&0===e.indexOf(".")&&(e=e.substring(1)),e&&(t[e]=i)}/**
 * Quick helper to get string xhr type.
 *
 * @ignore
 * @param xhr - The request to check.
 * @return The type.
 */function sI(t){return t.toString().replace("object ","")}/**
 * Manages the state and loading of a resource and all child resources.
 *
 * Can be extended in `GlobalMixins.LoaderResource`.
 *
 * @memberof PIXI
 */var sO=/** @class */function(){/**
     * @param {string} name - The name of the resource to load.
     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
     *      an array of sources.
     * @param {object} [options] - The options for the load.
     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
     *      determine automatically.
     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes
     *      longer than this time it is cancelled and the load is considered a failure. If this value is
     *      set to `0` then there is no explicit timeout.
     * @param {PIXI.LoaderResource.LOAD_TYPE} [options.loadType=LOAD_TYPE.XHR] - How should this resource
     *      be loaded?
     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} [options.xhrType=XHR_RESPONSE_TYPE.DEFAULT] - How
     *      should the data being loaded be interpreted when using XHR?
     * @param {PIXI.LoaderResource.IMetadata} [options.metadata] - Extra configuration for middleware
     *      and the Resource object.
     */function t(e,i,r){if(/**
         * The `dequeue` method that will be used a storage place for the async queue dequeue method
         * used privately by the loader.
         *
         * @private
         * @member {function}
         */this._dequeue=sC,/**
         * Used a storage place for the on load binding used privately by the loader.
         *
         * @private
         * @member {function}
         */this._onLoadBinding=null,/**
         * The timer for element loads to check if they timeout.
         *
         * @private
         */this._elementTimer=0,/**
         * The `complete` function bound to this resource's context.
         *
         * @private
         * @type {function}
         */this._boundComplete=null,/**
         * The `_onError` function bound to this resource's context.
         *
         * @private
         * @type {function}
         */this._boundOnError=null,/**
         * The `_onProgress` function bound to this resource's context.
         *
         * @private
         * @type {function}
         */this._boundOnProgress=null,/**
         * The `_onTimeout` function bound to this resource's context.
         *
         * @private
         * @type {function}
         */this._boundOnTimeout=null,this._boundXhrOnError=null,this._boundXhrOnTimeout=null,this._boundXhrOnAbort=null,this._boundXhrOnLoad=null,"string"!=typeof e||"string"!=typeof i)throw Error("Both name and url are required for constructing a resource.");r=r||{},this._flags=0,// set data url flag, needs to be set early for some _determineX checks to work.
this._setFlag(t.STATUS_FLAGS.DATA_URL,0===i.indexOf("data:")),this.name=e,this.url=i,this.extension=this._getExtension(),this.data=null,this.crossOrigin=!0===r.crossOrigin?"anonymous":r.crossOrigin,this.timeout=r.timeout||0,this.loadType=r.loadType||this._determineLoadType(),// The type used to load the resource via XHR. If unset, determined automatically.
this.xhrType=r.xhrType,// Extra info for middleware, and controlling specifics about how the resource loads.
// Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
// Meaning it will modify it as it sees fit.
this.metadata=r.metadata||{},// The error that occurred while loading (if any).
this.error=null,// The XHR object that was used to load this resource. This is only set
// when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.
this.xhr=null,// The child resources this resource owns.
this.children=[],// The resource type.
this.type=t.TYPE.UNKNOWN,// The progress chunk owned by this resource.
this.progressChunk=0,// The `dequeue` method that will be used a storage place for the async queue dequeue method
// used privately by the loader.
this._dequeue=sC,// Used a storage place for the on load binding used privately by the loader.
this._onLoadBinding=null,// The timer for element loads to check if they timeout.
this._elementTimer=0,this._boundComplete=this.complete.bind(this),this._boundOnError=this._onError.bind(this),this._boundOnProgress=this._onProgress.bind(this),this._boundOnTimeout=this._onTimeout.bind(this),// xhr callbacks
this._boundXhrOnError=this._xhrOnError.bind(this),this._boundXhrOnTimeout=this._xhrOnTimeout.bind(this),this._boundXhrOnAbort=this._xhrOnAbort.bind(this),this._boundXhrOnLoad=this._xhrOnLoad.bind(this),// Dispatched when the resource beings to load.
this.onStart=new sS,// Dispatched each time progress of this resource load updates.
// Not all resources types and loader systems can support this event
// so sometimes it may not be available. If the resource
// is being loaded on a modern browser, using XHR, and the remote server
// properly sets Content-Length headers, then this will be available.
this.onProgress=new sS,// Dispatched once this resource has loaded, if there was an error it will
// be in the `error` property.
this.onComplete=new sS,// Dispatched after this resource has had all the *after* middleware run on it.
this.onAfterMiddleware=new sS}return(/**
     * Sets the load type to be used for a specific extension.
     *
     * @static
     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
     * @param {PIXI.LoaderResource.LOAD_TYPE} loadType - The load type to set it to.
     */t.setExtensionLoadType=function(e,i){sP(t._loadTypeMap,e,i)},/**
     * Sets the load type to be used for a specific extension.
     *
     * @static
     * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
     */t.setExtensionXhrType=function(e,i){sP(t._xhrTypeMap,e,i)},Object.defineProperty(t.prototype,"isDataUrl",{/**
         * When the resource starts to load.
         *
         * @memberof PIXI.LoaderResource
         * @callback OnStartSignal
         * @param {Resource} resource - The resource that the event happened on.
         *//**
         * When the resource reports loading progress.
         *
         * @memberof PIXI.LoaderResource
         * @callback OnProgressSignal
         * @param {Resource} resource - The resource that the event happened on.
         * @param {number} percentage - The progress of the load in the range [0, 1].
         *//**
         * When the resource finishes loading.
         *
         * @memberof PIXI.LoaderResource
         * @callback OnCompleteSignal
         * @param {Resource} resource - The resource that the event happened on.
         *//**
         * @memberof PIXI.LoaderResource
         * @typedef {object} IMetadata
         * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
         *      element to use for loading, instead of creating one.
         * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
         *      is useful if you want to pass in a `loadElement` that you already added load sources to.
         * @property {string|string[]} [mimeType] - The mime type to use for the source element
         *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
         *      where each index is the mime type to use for the corresponding url index.
         *//**
         * Stores whether or not this url is a data url.
         *
         * @readonly
         * @member {boolean}
         */get:function(){return this._hasFlag(t.STATUS_FLAGS.DATA_URL)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"isComplete",{/**
         * Describes if this resource has finished loading. Is true when the resource has completely
         * loaded.
         *
         * @readonly
         * @member {boolean}
         */get:function(){return this._hasFlag(t.STATUS_FLAGS.COMPLETE)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"isLoading",{/**
         * Describes if this resource is currently loading. Is true when the resource starts loading,
         * and is false again when complete.
         *
         * @readonly
         * @member {boolean}
         */get:function(){return this._hasFlag(t.STATUS_FLAGS.LOADING)},enumerable:!1,configurable:!0}),/**
     * Marks the resource as complete.
     *
     */t.prototype.complete=function(){this._clearEvents(),this._finish()},/**
     * Aborts the loading of this resource, with an optional message.
     *
     * @param {string} message - The message to use for the error
     */t.prototype.abort=function(e){// abort can be called multiple times, ignore subsequent calls.
if(!this.error){// abort the actual loading
if(// store error
this.error=Error(e),// clear events before calling aborts
this._clearEvents(),this.xhr)this.xhr.abort();else if(this.xdr)this.xdr.abort();else if(this.data){// single source
if(this.data.src)this.data.src=t.EMPTY_GIF;else for(;this.data.firstChild;)this.data.removeChild(this.data.firstChild)}// done now.
this._finish()}},/**
     * Kicks off loading of this resource. This method is asynchronous.
     *
     * @param {PIXI.LoaderResource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.
     */t.prototype.load=function(e){var i=this;if(!this.isLoading){if(this.isComplete){e&&setTimeout(function(){return e(i)},1);return}switch(e&&this.onComplete.once(e),this._setFlag(t.STATUS_FLAGS.LOADING,!0),this.onStart.dispatch(this),(!1===this.crossOrigin||"string"!=typeof this.crossOrigin)&&(this.crossOrigin=this._determineCrossOrigin(this.url)),this.loadType){case t.LOAD_TYPE.IMAGE:this.type=t.TYPE.IMAGE,this._loadElement("image");break;case t.LOAD_TYPE.AUDIO:this.type=t.TYPE.AUDIO,this._loadSourceElement("audio");break;case t.LOAD_TYPE.VIDEO:this.type=t.TYPE.VIDEO,this._loadSourceElement("video");break;case t.LOAD_TYPE.XHR:/* falls through */default:sA&&this.crossOrigin?this._loadXdr():this._loadXhr()}}},/**
     * Checks if the flag is set.
     *
     * @param flag - The flag to check.
     * @return True if the flag is set.
     */t.prototype._hasFlag=function(t){return(this._flags&t)!=0},/**
     * (Un)Sets the flag.
     *
     * @param flag - The flag to (un)set.
     * @param value - Whether to set or (un)set the flag.
     */t.prototype._setFlag=function(t,e){this._flags=e?this._flags|t:this._flags&~t},/**
     * Clears all the events from the underlying loading source.
     */t.prototype._clearEvents=function(){clearTimeout(this._elementTimer),this.data&&this.data.removeEventListener&&(this.data.removeEventListener("error",this._boundOnError,!1),this.data.removeEventListener("load",this._boundComplete,!1),this.data.removeEventListener("progress",this._boundOnProgress,!1),this.data.removeEventListener("canplaythrough",this._boundComplete,!1)),this.xhr&&(this.xhr.removeEventListener?(this.xhr.removeEventListener("error",this._boundXhrOnError,!1),this.xhr.removeEventListener("timeout",this._boundXhrOnTimeout,!1),this.xhr.removeEventListener("abort",this._boundXhrOnAbort,!1),this.xhr.removeEventListener("progress",this._boundOnProgress,!1),this.xhr.removeEventListener("load",this._boundXhrOnLoad,!1)):(this.xhr.onerror=null,this.xhr.ontimeout=null,this.xhr.onprogress=null,this.xhr.onload=null))},/**
     * Finalizes the load.
     */t.prototype._finish=function(){if(this.isComplete)throw Error("Complete called again for an already completed resource.");this._setFlag(t.STATUS_FLAGS.COMPLETE,!0),this._setFlag(t.STATUS_FLAGS.LOADING,!1),this.onComplete.dispatch(this)},/**
     * Loads this resources using an element that has a single source,
     * like an HTMLImageElement.
     * @private
     * @param type - The type of element to use.
     */t.prototype._loadElement=function(t){this.metadata.loadElement?this.data=this.metadata.loadElement:"image"===t&&void 0!==self.Image?this.data=new Image:this.data=document.createElement(t),this.crossOrigin&&(this.data.crossOrigin=this.crossOrigin),this.metadata.skipSource||(this.data.src=this.url),this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1),this.timeout&&(this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout))},/**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     * @param type - The type of element to use.
     */t.prototype._loadSourceElement=function(t){if(this.metadata.loadElement?this.data=this.metadata.loadElement:"audio"===t&&void 0!==self.Audio?this.data=new Audio:this.data=document.createElement(t),null===this.data){this.abort("Unsupported element: "+t);return}if(this.crossOrigin&&(this.data.crossOrigin=this.crossOrigin),!this.metadata.skipSource){// support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
if(navigator.isCocoonJS)this.data.src=Array.isArray(this.url)?this.url[0]:this.url;else if(Array.isArray(this.url))for(var e=this.metadata.mimeType,i=0;i<this.url.length;++i)this.data.appendChild(this._createSource(t,this.url[i],Array.isArray(e)?e[i]:e));else{var e=this.metadata.mimeType;this.data.appendChild(this._createSource(t,this.url,Array.isArray(e)?e[0]:e))}}this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1),this.data.addEventListener("canplaythrough",this._boundComplete,!1),this.data.load(),this.timeout&&(this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout))},/**
     * Loads this resources using an XMLHttpRequest.
     */t.prototype._loadXhr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var e=this.xhr=new XMLHttpRequest;// set the request type and url
e.open("GET",this.url,!0),e.timeout=this.timeout,this.xhrType===t.XHR_RESPONSE_TYPE.JSON||this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT?e.responseType=t.XHR_RESPONSE_TYPE.TEXT:e.responseType=this.xhrType,e.addEventListener("error",this._boundXhrOnError,!1),e.addEventListener("timeout",this._boundXhrOnTimeout,!1),e.addEventListener("abort",this._boundXhrOnAbort,!1),e.addEventListener("progress",this._boundOnProgress,!1),e.addEventListener("load",this._boundXhrOnLoad,!1),e.send()},/**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     */t.prototype._loadXdr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var t=this.xhr=new self.XDomainRequest;// eslint-disable-line no-undef
// XDomainRequest has a few quirks. Occasionally it will abort requests
// A way to avoid this is to make sure ALL callbacks are set even if not used
// More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
t.timeout=this.timeout||5e3,t.onerror=this._boundXhrOnError,t.ontimeout=this._boundXhrOnTimeout,t.onprogress=this._boundOnProgress,t.onload=this._boundXhrOnLoad,t.open("GET",this.url,!0),// Note: The xdr.send() call is wrapped in a timeout to prevent an
// issue with the interface where some requests are lost if multiple
// XDomainRequests are being sent at the same time.
// Some info here: https://github.com/photonstorm/phaser/issues/1248
setTimeout(function(){return t.send()},1)},/**
     * Creates a source used in loading via an element.
     * @param type - The element type (video or audio).
     * @param url - The source URL to load from.
     * @param [mime] - The mime type of the video
     * @return The source element.
     */t.prototype._createSource=function(t,e,i){i||(i=t+"/"+this._getExtension(e));var r=document.createElement("source");return r.src=e,r.type=i,r},/**
     * Called if a load errors out.
     *
     * @param event - The error event from the element that emits it.
     */t.prototype._onError=function(t){this.abort("Failed to load element using: "+t.target.nodeName)},/**
     * Called if a load progress event fires for an element or xhr/xdr.
     * @param event - Progress event.
     */t.prototype._onProgress=function(t){t&&t.lengthComputable&&this.onProgress.dispatch(this,t.loaded/t.total)},/**
     * Called if a timeout event fires for an element.
     */t.prototype._onTimeout=function(){this.abort("Load timed out.")},/**
     * Called if an error event fires for xhr/xdr.
     */t.prototype._xhrOnError=function(){var t=this.xhr;this.abort(sI(t)+" Request failed. Status: "+t.status+', text: "'+t.statusText+'"')},/**
     * Called if an error event fires for xhr/xdr.
     */t.prototype._xhrOnTimeout=function(){var t=this.xhr;this.abort(sI(t)+" Request timed out.")},/**
     * Called if an abort event fires for xhr/xdr.
     */t.prototype._xhrOnAbort=function(){var t=this.xhr;this.abort(sI(t)+" Request was aborted by the user.")},/**
     * Called when data successfully loads from an xhr/xdr request.
     */t.prototype._xhrOnLoad=function(){var e=this.xhr,i="",r=void 0===e.status?200:e.status;if((""===e.responseType||"text"===e.responseType||void 0===e.responseType)&&(i=e.responseText),0===r&&(i.length>0||e.responseType===t.XHR_RESPONSE_TYPE.BUFFER)?r=200:1223===r&&(r=204),(r/100|0)==2){// if text, just return it
if(this.xhrType===t.XHR_RESPONSE_TYPE.TEXT)this.data=i,this.type=t.TYPE.TEXT;else if(this.xhrType===t.XHR_RESPONSE_TYPE.JSON)try{this.data=JSON.parse(i),this.type=t.TYPE.JSON}catch(t){this.abort("Error trying to parse loaded json: "+t);return}else if(this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT)try{if(self.DOMParser){var n=new DOMParser;this.data=n.parseFromString(i,"text/xml")}else{var s=document.createElement("div");s.innerHTML=i,this.data=s}this.type=t.TYPE.XML}catch(t){this.abort("Error trying to parse loaded xml: "+t);return}else this.data=e.response||i}else{this.abort("["+e.status+"] "+e.statusText+": "+e.responseURL);return}this.complete()},/**
     * Sets the `crossOrigin` property for this resource based on if the url
     * for this resource is cross-origin. If crossOrigin was manually set, this
     * function does nothing.
     * @private
     * @param url - The url to test.
     * @param [loc=self.location] - The location object to test against.
     * @return The crossOrigin value to use (or empty string for none).
     */// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
t.prototype._determineCrossOrigin=function(t,e){// data: and javascript: urls are considered same-origin
if(0===t.indexOf("data:"))return"";// A sandboxed iframe without the 'allow-same-origin' attribute will have a special
// origin designed not to match self.location.origin, and will always require
// crossOrigin requests regardless of whether the location matches.
if(self.origin!==self.location.origin)return"anonymous";// default is self.location
e=e||self.location,sR||(sR=document.createElement("a")),// let the browser determine the full href for the url of this resource and then
// parse with the node url lib, we can't use the properties of the anchor element
// because they don't work in IE9 :(
sR.href=t;var i=sM(sR.href,{strictMode:!0}),r=!i.port&&""===e.port||i.port===e.port,n=i.protocol?i.protocol+":":"";return(// if cross origin
i.host===e.hostname&&r&&n===e.protocol?"":"anonymous")},/**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {PIXI.LoaderResource.XHR_RESPONSE_TYPE} The responseType to use.
     */t.prototype._determineXhrType=function(){return t._xhrTypeMap[this.extension]||t.XHR_RESPONSE_TYPE.TEXT},/**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {PIXI.LoaderResource.LOAD_TYPE} The loadType to use.
     */t.prototype._determineLoadType=function(){return t._loadTypeMap[this.extension]||t.LOAD_TYPE.XHR},/**
     * Extracts the extension (sans '.') of the file being loaded by the resource.
     *
     * @param [url] - url to parse, `this.url` by default.
     * @return The extension.
     */t.prototype._getExtension=function(t){void 0===t&&(t=this.url);var e="";if(this.isDataUrl){var i=t.indexOf("/");e=t.substring(i+1,t.indexOf(";",i))}else{var r=t.indexOf("?"),n=t.indexOf("#"),s=Math.min(r>-1?r:t.length,n>-1?n:t.length);e=(t=t.substring(0,s)).substring(t.lastIndexOf(".")+1)}return e.toLowerCase()},/**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @param type - The type to get a mime type for.
     * @private
     * @return The mime type to use.
     */t.prototype._getMimeFromXhrType=function(e){switch(e){case t.XHR_RESPONSE_TYPE.BUFFER:return"application/octet-binary";case t.XHR_RESPONSE_TYPE.BLOB:return"application/blob";case t.XHR_RESPONSE_TYPE.DOCUMENT:return"application/xml";case t.XHR_RESPONSE_TYPE.JSON:return"application/json";case t.XHR_RESPONSE_TYPE.DEFAULT:case t.XHR_RESPONSE_TYPE.TEXT:/* falls through */default:return"text/plain"}},t)}();/**
 * Smaller version of the async library constructs.
 * @ignore
 */function sL(){}/** None */(vd=(vc=sO||(sO={})).STATUS_FLAGS||(vc.STATUS_FLAGS={}))[vd.NONE=0]="NONE",/** Data URL */vd[vd.DATA_URL=1]="DATA_URL",/** Complete */vd[vd.COMPLETE=2]="COMPLETE",/** Loading */vd[vd.LOADING=4]="LOADING",/** Unknown */(vp=vc.TYPE||(vc.TYPE={}))[vp.UNKNOWN=0]="UNKNOWN",/** JSON */vp[vp.JSON=1]="JSON",/** XML */vp[vp.XML=2]="XML",/** Image */vp[vp.IMAGE=3]="IMAGE",/** Audio */vp[vp.AUDIO=4]="AUDIO",/** Video */vp[vp.VIDEO=5]="VIDEO",/** Plain text */vp[vp.TEXT=6]="TEXT",/** Uses XMLHttpRequest to load the resource. */(vf=vc.LOAD_TYPE||(vc.LOAD_TYPE={}))[vf.XHR=1]="XHR",/** Uses an `Image` object to load the resource. */vf[vf.IMAGE=2]="IMAGE",/** Uses an `Audio` object to load the resource. */vf[vf.AUDIO=3]="AUDIO",/** Uses a `Video` object to load the resource. */vf[vf.VIDEO=4]="VIDEO",/** string */(vm=vc.XHR_RESPONSE_TYPE||(vc.XHR_RESPONSE_TYPE={})).DEFAULT="text",/** ArrayBuffer */vm.BUFFER="arraybuffer",/** Blob */vm.BLOB="blob",/** Document */vm.DOCUMENT="document",/** Object */vm.JSON="json",/** String */vm.TEXT="text",vc._loadTypeMap={// images
gif:vc.LOAD_TYPE.IMAGE,png:vc.LOAD_TYPE.IMAGE,bmp:vc.LOAD_TYPE.IMAGE,jpg:vc.LOAD_TYPE.IMAGE,jpeg:vc.LOAD_TYPE.IMAGE,tif:vc.LOAD_TYPE.IMAGE,tiff:vc.LOAD_TYPE.IMAGE,webp:vc.LOAD_TYPE.IMAGE,tga:vc.LOAD_TYPE.IMAGE,svg:vc.LOAD_TYPE.IMAGE,"svg+xml":vc.LOAD_TYPE.IMAGE,// audio
mp3:vc.LOAD_TYPE.AUDIO,ogg:vc.LOAD_TYPE.AUDIO,wav:vc.LOAD_TYPE.AUDIO,// videos
mp4:vc.LOAD_TYPE.VIDEO,webm:vc.LOAD_TYPE.VIDEO},vc._xhrTypeMap={// xml
xhtml:vc.XHR_RESPONSE_TYPE.DOCUMENT,html:vc.XHR_RESPONSE_TYPE.DOCUMENT,htm:vc.XHR_RESPONSE_TYPE.DOCUMENT,xml:vc.XHR_RESPONSE_TYPE.DOCUMENT,tmx:vc.XHR_RESPONSE_TYPE.DOCUMENT,svg:vc.XHR_RESPONSE_TYPE.DOCUMENT,// This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
// Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
// this should probably be fine.
tsx:vc.XHR_RESPONSE_TYPE.DOCUMENT,// images
gif:vc.XHR_RESPONSE_TYPE.BLOB,png:vc.XHR_RESPONSE_TYPE.BLOB,bmp:vc.XHR_RESPONSE_TYPE.BLOB,jpg:vc.XHR_RESPONSE_TYPE.BLOB,jpeg:vc.XHR_RESPONSE_TYPE.BLOB,tif:vc.XHR_RESPONSE_TYPE.BLOB,tiff:vc.XHR_RESPONSE_TYPE.BLOB,webp:vc.XHR_RESPONSE_TYPE.BLOB,tga:vc.XHR_RESPONSE_TYPE.BLOB,// json
json:vc.XHR_RESPONSE_TYPE.JSON,// text
text:vc.XHR_RESPONSE_TYPE.TEXT,txt:vc.XHR_RESPONSE_TYPE.TEXT,// fonts
ttf:vc.XHR_RESPONSE_TYPE.BUFFER,otf:vc.XHR_RESPONSE_TYPE.BUFFER},// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif
vc.EMPTY_GIF="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";/**
 * @private
 * @memberof PIXI
 */var sN=/**
     * @private
     */function(t,e){this.data=t,this.callback=e},sD=/** @class */function(){/**
     * @private
     */function t(t,e){var i=this;if(void 0===e&&(e=1),this.workers=0,this.saturated=sL,this.unsaturated=sL,this.empty=sL,this.drain=sL,this.error=sL,this.started=!1,this.paused=!1,this._tasks=[],this._insert=function(t,e,r){if(r&&"function"!=typeof r)throw Error("task callback must be a function");// eslint-disable-next-line no-eq-null,eqeqeq
if(i.started=!0,null==t&&i.idle()){// call drain immediately if there are no tasks
setTimeout(function(){return i.drain()},1);return}var n=new sN(t,"function"==typeof r?r:sL);e?i._tasks.unshift(n):i._tasks.push(n),setTimeout(i.process,1)},this.process=function(){for(;!i.paused&&i.workers<i.concurrency&&i._tasks.length;){var t=i._tasks.shift();0===i._tasks.length&&i.empty(),i.workers+=1,i.workers===i.concurrency&&i.saturated(),i._worker(t.data,/**
 * Ensures a function is only called once.
 * @ignore
 * @param {function} fn - The function to wrap.
 * @return {function} The wrapping function.
 */function(t){return function(){for(var e=arguments,i=[],r=0;r<arguments.length;r++)i[r]=e[r];if(null===t)throw Error("Callback was already called.");var n=t;t=null,n.apply(this,i)}}(i._next(t)))}},this._worker=t,0===e)throw Error("Concurrency must not be zero");this.concurrency=e,this.buffer=e/4}return(/**
     * @private
     */t.prototype._next=function(t){var e=this;return function(){for(var i=arguments,r=[],n=0;n<arguments.length;n++)r[n]=i[n];e.workers-=1,t.callback.apply(t,r),null!=r[0]&&e.error(r[0],t.data),e.workers<=e.concurrency-e.buffer&&e.unsaturated(),e.idle()&&e.drain(),e.process()}},// That was in object
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
t.prototype.push=function(t,e){this._insert(t,!1,e)},t.prototype.kill=function(){this.workers=0,this.drain=sL,this.started=!1,this._tasks=[]},// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
t.prototype.unshift=function(t,e){this._insert(t,!0,e)},t.prototype.length=function(){return this._tasks.length},t.prototype.running=function(){return this.workers},t.prototype.idle=function(){return this._tasks.length+this.workers===0},t.prototype.pause=function(){!0!==this.paused&&(this.paused=!0)},t.prototype.resume=function(){if(!1!==this.paused){this.paused=!1;// Need to call this.process once per concurrent
// worker to preserve full concurrency after pause
for(var t=1;t<=this.concurrency;t++)this.process()}},/**
     * Iterates an array in series.
     *
     * @param {Array.<*>} array - Array to iterate.
     * @param {function} iterator - Function to call for each element.
     * @param {function} callback - Function to call when done, or on error.
     * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.
     */t.eachSeries=function(t,e,i,r){var n=0,s=t.length;!function o(a){if(a||n===s){i&&i(a);return}r?setTimeout(function(){e(t[n++],o)},1):e(t[n++],o)}()},/**
     * Async queue implementation,
     *
     * @param {function} worker - The worker function to call for each task.
     * @param {number} concurrency - How many workers to run in parrallel.
     * @return {*} The async queue object.
     */t.queue=function(e,i){return new t(e,i)},t)}(),sF=/(#[\w-]+)?$/,sB=/** @class */function(){/**
     * @param baseUrl - The base url for all resources loaded by this loader.
     * @param concurrency - The number of resources to load concurrently.
     */function t(e,i){var r=this;void 0===e&&(e=""),void 0===i&&(i=10),/**
         * The middleware to run before loading each resource.
         */this._beforeMiddleware=[],/**
         * The middleware to run after loading each resource.
         */this._afterMiddleware=[],/**
         * The tracks the resources we are currently completing parsing for.
         */this._resourcesParsing=[],/**
         * The `_loadResource` function bound with this object context.
         *
         * @private
         * @member {function}
         * @param {PIXI.LoaderResource} r - The resource to load
         * @param {Function} d - The dequeue function
         * @return {undefined}
         */this._boundLoadResource=function(t,e){return r._loadResource(t,e)},/**
         * All the resources for this loader keyed by name.
         *
         * @member {object<string, PIXI.LoaderResource>}
         */this.resources={},this.baseUrl=e,this.progress=0,this.loading=!1,this.defaultQueryString="",this._beforeMiddleware=[],this._afterMiddleware=[],this._resourcesParsing=[],this._boundLoadResource=function(t,e){return r._loadResource(t,e)},this._queue=sD.queue(this._boundLoadResource,i),this._queue.pause(),this.resources={},this.onProgress=new sS,this.onError=new sS,this.onLoad=new sS,this.onStart=new sS,this.onComplete=new sS;for(var n=0;n<t._plugins.length;++n){var s=t._plugins[n],o=s.pre,a=s.use;o&&this.pre(o),a&&this.use(a)}this._protected=!1}return(/**
     * Same as add, params have strict order
     * @private
     * @param name - The name of the resource to load.
     * @param url - The url for this resource, relative to the baseUrl of this loader.
     * @param options - The options for the load.
     * @param callback - Function to call when this specific resource completes loading.
     * @return {this} Returns itself.
     */t.prototype._add=function(t,e,i,r){// if loading already you can only add resources that have a parent.
if(this.loading&&(!i||!i.parentResource))throw Error("Cannot add resources while the loader is running.");// check if resource already exists.
if(this.resources[t])throw Error('Resource named "'+t+'" already exists.');// if actively loading, make sure to adjust progress chunks for that parent and its children
if(// add base url if this isn't an absolute url
e=this._prepareUrl(e),// create the store the resource
this.resources[t]=new sO(t,e,i),"function"==typeof r&&this.resources[t].onAfterMiddleware.once(r),this.loading){for(var n=i.parentResource,s=[],o=0;o<n.children.length;++o)n.children[o].isComplete||s.push(n.children[o]);var a=n.progressChunk*(s.length+1)/(s.length+2);n.children.push(this.resources[t]),n.progressChunk=a;for(var o=0;o<s.length;++o)s[o].progressChunk=a;this.resources[t].progressChunk=a}return(// add the resource to the queue
this._queue.push(this.resources[t]),this)},/* eslint-enable require-jsdoc,valid-jsdoc *//**
     * Sets up a middleware function that will run *before* the
     * resource is loaded.
     *
     * @param fn - The middleware function to register.
     * @return Returns itself.
     */t.prototype.pre=function(t){return this._beforeMiddleware.push(t),this},/**
     * Sets up a middleware function that will run *after* the
     * resource is loaded.
     *
     * @param fn - The middleware function to register.
     * @return Returns itself.
     */t.prototype.use=function(t){return this._afterMiddleware.push(t),this},/**
     * Resets the queue of the loader to prepare for a new load.
     *
     * @return Returns itself.
     */t.prototype.reset=function(){// abort all resource loads
for(var t in this.progress=0,this.loading=!1,this._queue.kill(),this._queue.pause(),this.resources){var e=this.resources[t];e._onLoadBinding&&e._onLoadBinding.detach(),e.isLoading&&e.abort("loader reset")}return this.resources={},this},/**
     * Starts loading the queued resources.
     * @param [cb] - Optional callback that will be bound to the `complete` event.
     * @return Returns itself.
     */t.prototype.load=function(t){// if the queue has already started we are done here
if("function"==typeof t&&this.onComplete.once(t),this.loading)return this;if(this._queue.idle())this._onStart(),this._onComplete();else{for(var e=100/this._queue._tasks.length,i=0;i<this._queue._tasks.length;++i)this._queue._tasks[i].data.progressChunk=e;// notify we are starting
this._onStart(),// start loading
this._queue.resume()}return this},Object.defineProperty(t.prototype,"concurrency",{/**
         * The number of resources to load concurrently.
         *
         * @member {number}
         * @default 10
         */get:function(){return this._queue.concurrency},// eslint-disable-next-line require-jsdoc
set:function(t){this._queue.concurrency=t},enumerable:!1,configurable:!0}),/**
     * Prepares a url for usage based on the configuration of this object
     * @param url - The url to prepare.
     * @return The prepared url.
     */t.prototype._prepareUrl=function(t){var e,i=sM(t,{strictMode:!0});// if we need to add a default querystring, there is a bit more work
if(e=i.protocol||!i.path||0===t.indexOf("//")?t:this.baseUrl.length&&this.baseUrl.lastIndexOf("/")!==this.baseUrl.length-1&&"/"!==t.charAt(0)?this.baseUrl+"/"+t:this.baseUrl+t,this.defaultQueryString){var r=sF.exec(e)[0];-1!==(e=e.substr(0,e.length-r.length)).indexOf("?")?e+="&"+this.defaultQueryString:e+="?"+this.defaultQueryString,e+=r}return e},/**
     * Loads a single resource.
     *
     * @private
     * @param {PIXI.LoaderResource} resource - The resource to load.
     * @param {function} dequeue - The function to call when we need to dequeue this item.
     */t.prototype._loadResource=function(t,e){var i=this;t._dequeue=e,// run before middleware
sD.eachSeries(this._beforeMiddleware,function(e,r){e.call(i,t,function(){// if the before middleware marks the resource as complete,
// break and don't process any more before middleware
r(t.isComplete?{}:null)})},function(){t.isComplete?i._onLoad(t):(t._onLoadBinding=t.onComplete.once(i._onLoad,i),t.load())},!0)},/**
     * Called once loading has started.
     */t.prototype._onStart=function(){this.progress=0,this.loading=!0,this.onStart.dispatch(this)},/**
     * Called once each resource has loaded.
     */t.prototype._onComplete=function(){this.progress=100,this.loading=!1,this.onComplete.dispatch(this,this.resources)},/**
     * Called each time a resources is loaded.
     * @param resource - The resource that was loaded
     */t.prototype._onLoad=function(t){var e=this;t._onLoadBinding=null,// remove this resource from the async queue, and add it to our list of resources that are being parsed
this._resourcesParsing.push(t),t._dequeue(),// run all the after middleware for this resource
sD.eachSeries(this._afterMiddleware,function(i,r){i.call(e,t,r)},function(){t.onAfterMiddleware.dispatch(t),e.progress=Math.min(100,e.progress+t.progressChunk),e.onProgress.dispatch(e,t),t.error?e.onError.dispatch(t.error,e,t):e.onLoad.dispatch(e,t),e._resourcesParsing.splice(e._resourcesParsing.indexOf(t),1),e._queue.idle()&&0===e._resourcesParsing.length&&e._onComplete()},!0)},/**
     * Destroy the loader, removes references.
     */t.prototype.destroy=function(){this._protected||this.reset()},Object.defineProperty(t,"shared",{/**
         * A premade instance of the loader that can be used to load resources.
         */get:function(){var e=t._shared;return e||((e=new t)._protected=!0,t._shared=e),e},enumerable:!1,configurable:!0}),/**
     * Adds a Loader plugin for the global shared loader and all
     * new Loader instances created.
     *
     * @param plugin - The plugin to add
     * @return Reference to PIXI.Loader for chaining
     */t.registerPlugin=function(e){return t._plugins.push(e),e.add&&e.add(),t},t._plugins=[],t)}();sB.prototype.add=function(t,e,i,r){// special case of an array of objects or urls
if(Array.isArray(t)){for(var n=0;n<t.length;++n)this.add(t[n]);return this}// now that we shifted make sure we have a proper url.
if("object"==typeof t&&(i=t,r=e||i.callback||i.onComplete,e=i.url,t=i.name||i.key||i.url),"string"!=typeof e&&(r=i,i=e,e=t),"string"!=typeof e)throw Error("No url passed to add resource to loader.");return"function"==typeof i&&(r=i,i=null),this._add(t,e,i,r)};/**
 * Application plugin for supporting loader option. Installing the LoaderPlugin
 * is not necessary if using **pixi.js** or **pixi.js-legacy**.
 * @example
 * import {AppLoaderPlugin} from '@pixi/loaders';
 * import {Application} from '@pixi/app';
 * Application.registerPlugin(AppLoaderPlugin);
 * @class
 * @memberof PIXI
 */var sU=/** @class */function(){function t(){}return(/**
     * Called on application constructor
     * @param {object} options
     * @private
     */t.init=function(t){t=Object.assign({sharedLoader:!1},t),/**
         * Loader instance to help with asset loading.
         * @memberof PIXI.Application#
         * @type {PIXI.Loader}
         * @readonly
         */this.loader=t.sharedLoader?sB.shared:new sB},/**
     * Called when application destroyed
     *
     * @private
     */t.destroy=function(){this.loader&&(this.loader.destroy(),this.loader=null)},t)}(),sG=/** @class */function(){function t(){}return(/**
     * Handle SVG elements a text, render with SVGResource.
     */t.add=function(){sO.setExtensionLoadType("svg",sO.LOAD_TYPE.XHR),sO.setExtensionXhrType("svg",sO.XHR_RESPONSE_TYPE.TEXT)},/**
     * Called after a resource is loaded.
     * @see PIXI.Loader.loaderMiddleware
     * @param resource
     * @param {function} next
     */t.use=function(t,e){// create a new texture if the data is an Image object
if(t.data&&(t.type===sO.TYPE.IMAGE||"svg"===t.extension)){var i=t.data,r=t.url,n=t.name,s=t.metadata;rH.fromLoader(i,r,n,s).then(function(i){t.texture=i,e()})// TODO: handle errors in Texture.fromLoader
// so we can pass them to the Loader
.catch(e)}else e()},t)}(),sk=self.URL||self.webkitURL;// parse any blob into more usable objects (e.g. Image)
sB.registerPlugin({use:/**
 * A middleware for transforming XHR loaded Blobs into more useful objects
 *
 * @ignore
 * @function parsing
 * @example
 * import { Loader, middleware } from 'resource-loader';
 * const loader = new Loader();
 * loader.use(middleware.parsing);
 * @param resource - Current Resource
 * @param next - Callback when complete
 */function(t,e){if(!t.data){e();return}// if this was an XHR load of a blob
if(t.xhr&&t.xhrType===sO.XHR_RESPONSE_TYPE.BLOB){// if there is no blob support we probably got a binary string back
if(self.Blob&&"string"!=typeof t.data){if(0===t.data.type.indexOf("image")){var i=sk.createObjectURL(t.data);t.blob=t.data,t.data=new Image,t.data.src=i,t.type=sO.TYPE.IMAGE,// cleanup the no longer used blob after the image loads
// TODO: Is this correct? Will the image be invalid after revoking?
t.data.onload=function(){sk.revokeObjectURL(i),t.data.onload=null,e()};// next will be called on load.
return}}else{var r=t.xhr.getResponseHeader("content-type");// this is an image, convert the binary string into a data url
if(r&&0===r.indexOf("image")){t.data=new Image,t.data.src="data:"+r+";base64,"+/**
 * Encodes binary into base64.
 *
 * @function encodeBinary
 * @param {string} input - The input data to encode.
 * @returns {string} The encoded base64 string
 */function(t){for(var e="",i=0;i<t.length;){for(var r=[0,0,0],n=[0,0,0,0],s=0;s<r.length;++s)i<t.length?// https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
r[s]=255&t.charCodeAt(i++):r[s]=0;switch(// Get each encoded character, 6 bits at a time
// index 1: first 6 bits
n[0]=r[0]>>2,// index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
n[1]=(3&r[0])<<4|r[1]>>4,// index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
n[2]=(15&r[1])<<2|r[2]>>6,// index 3: forth 6 bits (6 least significant bits from input byte 3)
n[3]=63&r[2],i-(t.length-1)){case 2:// Set last 2 characters to padding char
n[3]=64,n[2]=64;break;case 1:// Set last character to padding char
n[3]=64}// Now we will grab each appropriate character out of our keystring
// based on our index array and append it to the output string
for(var s=0;s<n.length;++s)e+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(n[s])}return e}(t.xhr.responseText),t.type=sO.TYPE.IMAGE,// wait until the image loads and then callback
t.data.onload=function(){t.data.onload=null,e()};// next will be called on load
return}}}e()}}),// parse any Image objects into textures
sB.registerPlugin(sG);var sH={};tC(sH,"INTERNAL_FORMATS",()=>bl),tC(sH,"INTERNAL_FORMAT_TO_BYTES_PER_PIXEL",()=>sz),tC(sH,"BlobResource",()=>sX),tC(sH,"CompressedTextureResource",()=>sW),tC(sH,"CompressedTextureLoader",()=>sY),tC(sH,"DDSLoader",()=>sQ),tC(sH,"TYPES_TO_BYTES_PER_COMPONENT",()=>s2),tC(sH,"FORMATS_TO_COMPONENTS",()=>s3),tC(sH,"TYPES_TO_BYTES_PER_PIXEL",()=>s5),tC(sH,"KTXLoader",()=>s4),// WEBGL_compressed_texture_s3tc
(vg=bl||(bl={}))[vg.COMPRESSED_RGB_S3TC_DXT1_EXT=33776]="COMPRESSED_RGB_S3TC_DXT1_EXT",vg[vg.COMPRESSED_RGBA_S3TC_DXT1_EXT=33777]="COMPRESSED_RGBA_S3TC_DXT1_EXT",vg[vg.COMPRESSED_RGBA_S3TC_DXT3_EXT=33778]="COMPRESSED_RGBA_S3TC_DXT3_EXT",vg[vg.COMPRESSED_RGBA_S3TC_DXT5_EXT=33779]="COMPRESSED_RGBA_S3TC_DXT5_EXT",// WEBGL_compressed_texture_s3tc_srgb
vg[vg.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917]="COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",vg[vg.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918]="COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",vg[vg.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919]="COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",vg[vg.COMPRESSED_SRGB_S3TC_DXT1_EXT=35916]="COMPRESSED_SRGB_S3TC_DXT1_EXT",// WEBGL_compressed_texture_etc
vg[vg.COMPRESSED_R11_EAC=37488]="COMPRESSED_R11_EAC",vg[vg.COMPRESSED_SIGNED_R11_EAC=37489]="COMPRESSED_SIGNED_R11_EAC",vg[vg.COMPRESSED_RG11_EAC=37490]="COMPRESSED_RG11_EAC",vg[vg.COMPRESSED_SIGNED_RG11_EAC=37491]="COMPRESSED_SIGNED_RG11_EAC",vg[vg.COMPRESSED_RGB8_ETC2=37492]="COMPRESSED_RGB8_ETC2",vg[vg.COMPRESSED_RGBA8_ETC2_EAC=37496]="COMPRESSED_RGBA8_ETC2_EAC",vg[vg.COMPRESSED_SRGB8_ETC2=37493]="COMPRESSED_SRGB8_ETC2",vg[vg.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37497]="COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",vg[vg.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37494]="COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",vg[vg.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37495]="COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",// WEBGL_compressed_texture_pvrtc
vg[vg.COMPRESSED_RGB_PVRTC_4BPPV1_IMG=35840]="COMPRESSED_RGB_PVRTC_4BPPV1_IMG",vg[vg.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=35842]="COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",vg[vg.COMPRESSED_RGB_PVRTC_2BPPV1_IMG=35841]="COMPRESSED_RGB_PVRTC_2BPPV1_IMG",vg[vg.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG=35843]="COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",// WEBGL_compressed_texture_etc1
vg[vg.COMPRESSED_RGB_ETC1_WEBGL=36196]="COMPRESSED_RGB_ETC1_WEBGL",// WEBGL_compressed_texture_atc
vg[vg.COMPRESSED_RGB_ATC_WEBGL=35986]="COMPRESSED_RGB_ATC_WEBGL",vg[vg.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL=35986]="COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",vg[vg.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL=34798]="COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";/**
 * Maps the compressed texture formats in {@link PIXI.INTERNAL_FORMATS} to the number of bytes taken by
 * each texel.
 *
 * @memberof PIXI
 * @static
 * @ignore
 */var sz=((bh={})[bl.COMPRESSED_RGB_S3TC_DXT1_EXT]=.5,bh[bl.COMPRESSED_RGBA_S3TC_DXT1_EXT]=.5,bh[bl.COMPRESSED_RGBA_S3TC_DXT3_EXT]=1,bh[bl.COMPRESSED_RGBA_S3TC_DXT5_EXT]=1,bh[bl.COMPRESSED_SRGB_S3TC_DXT1_EXT]=.5,bh[bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT]=.5,bh[bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT]=1,bh[bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT]=1,bh[bl.COMPRESSED_R11_EAC]=.5,bh[bl.COMPRESSED_SIGNED_R11_EAC]=.5,bh[bl.COMPRESSED_RG11_EAC]=1,bh[bl.COMPRESSED_SIGNED_RG11_EAC]=1,bh[bl.COMPRESSED_RGB8_ETC2]=.5,bh[bl.COMPRESSED_RGBA8_ETC2_EAC]=1,bh[bl.COMPRESSED_SRGB8_ETC2]=.5,bh[bl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]=1,bh[bl.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]=.5,bh[bl.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]=.5,bh[bl.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]=.5,bh[bl.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]=.5,bh[bl.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]=.25,bh[bl.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]=.25,bh[bl.COMPRESSED_RGB_ETC1_WEBGL]=.5,// WEBGL_compressed_texture_atc
bh[bl.COMPRESSED_RGB_ATC_WEBGL]=.5,bh[bl.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]=1,bh[bl.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]=1,bh),sj=function(t,e){return(sj=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function sV(t,e){function i(){this.constructor=t}sj(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * Resource that fetches texture data over the network and stores it in a buffer.
 *
 * @class
 * @extends PIXI.Resource
 * @memberof PIXI
 */var sX=/** @class */function(t){/**
     * @param {string} url - the URL of the texture file
     * @param {boolean}[autoLoad] - whether to fetch the data immediately;
     *  you can fetch it later via {@link BlobResource#load}
     */function e(e,i){void 0===i&&(i={width:1,height:1,autoLoad:!0});var r,n,s=this;return"string"==typeof e?(r=e,n=new Uint8Array):(r=null,n=e),/**
         * The URL of the texture file
         * @member {string}
         */(s=t.call(this,n,i)||this).origin=r,/**
         * The viewable buffer on the data
         * @member {ViewableBuffer}
         */// HINT: BlobResource allows "null" sources, assuming the child class provides an alternative
s.buffer=n?new sn(n):null,s.origin&&!1!==i.autoLoad&&s.load(),n&&n.length&&(s.loaded=!0,s.onBlobLoaded(s.buffer.rawBinaryData)),s}return sV(e,t),e.prototype.onBlobLoaded=function(t){// TODO: Override this method
},/**
     * Loads the blob
     */e.prototype.load=function(){var t,e,i,r;return t=this,e=void 0,i=Promise,r=function(){var t;return function(t,e){var i,r,n,s,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(i)throw TypeError("Generator is already executing.");for(;o;)try{if(i=1,r&&(n=2&s[0]?r.return:s[0]?r.throw||((n=r.return)&&n.call(r),0):r.next)&&!(n=n.call(r,s[1])).done)return n;switch(r=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(n=(n=o.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){o.label=s[1];break}if(6===s[0]&&o.label<n[1]){o.label=n[1],n=s;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(s);break}n[2]&&o.ops.pop(),o.trys.pop();continue}s=e.call(t,o)}catch(t){s=[6,t],r=0}finally{i=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}(this,function(e){switch(e.label){case 0:return[4/*yield*/,fetch(this.origin)];case 1:return[4/*yield*/,e.sent().blob()];case 2:return[4/*yield*/,e.sent().arrayBuffer()];case 3:return t=e.sent(),this.data=new Uint32Array(t),this.buffer=new sn(t),this.loaded=!0,this.onBlobLoaded(t),this.update(),[2/*return*/,this]}})},new(i||(i=Promise))(function(n,s){function o(t){try{h(r.next(t))}catch(t){s(t)}}function a(t){try{h(r.throw(t))}catch(t){s(t)}}function h(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(o,a)}h((r=r.apply(t,e||[])).next())})},e}(rT),sW=/** @class */function(t){/**
     * @param source - the buffer/URL holding the compressed texture data
     * @param options
     * @param {PIXI.INTERNAL_FORMATS} options.format - the compression format
     * @param {number} options.width - the image width in pixels.
     * @param {number} options.height - the image height in pixels.
     * @param {number} [options.level=1] - the mipmap levels stored in the compressed texture, including level 0.
     * @param {number} [options.levelBuffers] - the buffers for each mipmap level. `CompressedTextureResource` can allows you
     *      to pass `null` for `source`, for cases where each level is stored in non-contiguous memory.
     */function e(i,r){var n=t.call(this,i,r)||this;return n.format=r.format,n.levels=r.levels||1,n._width=r.width,n._height=r.height,n._extension=e._formatToExtension(n.format),(r.levelBuffers||n.buffer)&&(n._levelBuffers=r.levelBuffers||e._createLevelBuffers(i instanceof Uint8Array?i:n.buffer.uint8View,n.format,n.levels,4,4,n.width,n.height)),n}return sV(e,t),/**
     * @override
     * @param renderer - A reference to the current renderer
     * @param _texture - the texture
     * @param _glTexture - texture instance for this webgl context
     */e.prototype.upload=function(t,e,i){var r=t.gl;if(!t.context.extensions[this._extension])throw Error(this._extension+" textures are not supported on the current machine");if(!this._levelBuffers)return!1;for(var n=0,s=this.levels;n<s;n++){var o=this._levelBuffers[n],a=o.levelID,h=o.levelWidth,l=o.levelHeight,u=o.levelBuffer;r.compressedTexImage2D(r.TEXTURE_2D,a,this.format,h,l,0,u)}return!0},/** @protected */e.prototype.onBlobLoaded=function(){this._levelBuffers=e._createLevelBuffers(this.buffer.uint8View,this.format,this.levels,4,4,this.width,this.height)},/**
     * Returns the key (to ContextSystem#extensions) for the WebGL extension supporting the compression format
     *
     * @private
     * @param format - the compression format to get the extension for.
     */e._formatToExtension=function(t){if(t>=33776&&t<=33779)return"s3tc";if(t>=37488&&t<=37497)return"etc";if(t>=35840&&t<=35843)return"pvrtc";if(t>=36196)return"etc1";if(t>=35986&&t<=34798)return"atc";throw Error("Invalid (compressed) texture format given!")},/**
     * Pre-creates buffer views for each mipmap level
     *
     * @private
     * @param buffer -
     * @param format - compression formats
     * @param levels - mipmap levels
     * @param blockWidth -
     * @param blockHeight -
     * @param imageWidth - width of the image in pixels
     * @param imageHeight - height of the image in pixels
     */e._createLevelBuffers=function(t,e,i,r,n,s,o){for(var a=Array(i),h=t.byteOffset,l=s,u=o,c=l+r-1&~(r-1),d=u+n-1&~(n-1),p=c*d*sz[e],f=0;f<i;f++)a[f]={levelID:f,levelWidth:i>1?l:c,levelHeight:i>1?u:d,levelBuffer:new Uint8Array(t.buffer,h,p)},h+=p,u=u>>1||1,p=(c=// Calculate levelBuffer dimensions for next iteration
(l=l>>1||1)+r-1&~(r-1))*(d=u+n-1&~(n-1))*sz[e];return a},e}(sX),sY=/** @class */function(){function t(){}return(/**
     * Called after a compressed-textures manifest is loaded.
     *
     * This will then load the correct compression format for the device. Your manifest should adhere
     * to the following schema:
     *
     * ```js
     * import { INTERNAL_FORMATS } from '@pixi/constants';
     *
     * type CompressedTextureManifest = {
     *  textures: Array<{ src: string, format?: keyof INTERNAL_FORMATS}>,
     *  cacheID: string;
     * };
     * ```
     *
     * This is an example of a .json manifest file
     *
     * ```json
     * {
     *   "cacheID":"asset",
     *   "textures":[
     *     { "src":"asset.fallback.png" },
     *     { "format":"COMPRESSED_RGBA_S3TC_DXT5_EXT", "src":"asset.s3tc.ktx" },
     *     { "format":"COMPRESSED_RGBA8_ETC2_EAC", "src":"asset.etc.ktx" },
     *     { "format":"RGBA_PVRTC_4BPPV1_IMG", "src":"asset.pvrtc.ktx" }
     *   ]
     * }
     * ```
     */t.use=function(e,i){var r=e.data;if(e.type===sO.TYPE.JSON&&r&&r.cacheID&&r.textures){// Search for an extension that holds one the formats
for(var n=r.textures,s=void 0,o=void 0,a=0,h=n.length;a<h;a++){var l=n[a],u=l.src,c=l.format;if(c||(o=u),t.textureFormats[c]){s=u;break}}// Make sure we have a URL
if(!(s=s||o)){i(Error("Cannot load compressed-textures in "+e.url+", make sure you provide a fallback"));return}if(s===e.url){// Prevent infinite loops
i(Error("URL of compressed texture cannot be the same as the manifest's URL"));return}var d={crossOrigin:e.crossOrigin,metadata:e.metadata.imageMetadata,parentResource:e},p=e0.resolve(e.url.replace(this.baseUrl,""),s),f=r.cacheID;// The appropriate loader should register the texture
this.add(f,p,d,function(t){if(t.error){i(t.error);return}var r=t.texture,n=t.textures;// Make sure texture/textures is assigned to parent resource
Object.assign(e,{texture:void 0===r?null:r,textures:void 0===n?{}:n}),// Pass along any error
i()})}else i()},/**
     * Detects the available compressed texture extensions on the device.
     * @ignore
     */t.add=function(){var e=document.createElement("canvas").getContext("webgl");if(!e){console.warn("WebGL not available for compressed textures. Silently failing.");return}var i={s3tc:e.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:e.getExtension("WEBGL_compressed_texture_etc"),etc1:e.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:e.getExtension("WEBGL_compressed_texture_atc"),astc:e.getExtension("WEBGL_compressed_texture_astc")};// Assign all available compressed-texture formats
for(var r in t.textureExtensions=i,t.textureFormats={},i){var n=i[r];n&&Object.assign(t.textureFormats,Object.getPrototypeOf(n))}},t)}();/**
 * Creates base-textures and textures for each compressed-texture resource and adds them into the global
 * texture cache. The first texture has two IDs - `${url}`, `${url}-1`; while the rest have an ID of the
 * form `${url}-i`.
 *
 * @param url - the original address of the resources
 * @param resources - the resources backing texture data
 * @ignore
 */function sq(t,e,i){var r={textures:{},texture:null};return e&&e.map(function(t){return new rH(new rS(t,Object.assign({mipmap:x5.OFF,alphaMode:x4.NO_PREMULTIPLIED_ALPHA},i)))}).forEach(function(e,i){var n=e.baseTexture,s=t+"-"+(i+1);rS.addToCache(n,s),rH.addToCache(e,s),0===i&&(rS.addToCache(n,t),rH.addToCache(e,t),r.texture=e),r.textures[s]=e}),r}sO.setExtensionXhrType("dds",sO.XHR_RESPONSE_TYPE.BUFFER);/**
 * DWORD offsets of the DDS file header fields (relative to file start).
 *
 * @ignore
 */var sK={FOURCC:2},sJ={DXGI_FORMAT:0,RESOURCE_DIMENSION:1,MISC_FLAG:2,ARRAY_SIZE:3};(vy=bd||(bd={}))[vy.DXGI_FORMAT_UNKNOWN=0]="DXGI_FORMAT_UNKNOWN",vy[vy.DXGI_FORMAT_R32G32B32A32_TYPELESS=1]="DXGI_FORMAT_R32G32B32A32_TYPELESS",vy[vy.DXGI_FORMAT_R32G32B32A32_FLOAT=2]="DXGI_FORMAT_R32G32B32A32_FLOAT",vy[vy.DXGI_FORMAT_R32G32B32A32_UINT=3]="DXGI_FORMAT_R32G32B32A32_UINT",vy[vy.DXGI_FORMAT_R32G32B32A32_SINT=4]="DXGI_FORMAT_R32G32B32A32_SINT",vy[vy.DXGI_FORMAT_R32G32B32_TYPELESS=5]="DXGI_FORMAT_R32G32B32_TYPELESS",vy[vy.DXGI_FORMAT_R32G32B32_FLOAT=6]="DXGI_FORMAT_R32G32B32_FLOAT",vy[vy.DXGI_FORMAT_R32G32B32_UINT=7]="DXGI_FORMAT_R32G32B32_UINT",vy[vy.DXGI_FORMAT_R32G32B32_SINT=8]="DXGI_FORMAT_R32G32B32_SINT",vy[vy.DXGI_FORMAT_R16G16B16A16_TYPELESS=9]="DXGI_FORMAT_R16G16B16A16_TYPELESS",vy[vy.DXGI_FORMAT_R16G16B16A16_FLOAT=10]="DXGI_FORMAT_R16G16B16A16_FLOAT",vy[vy.DXGI_FORMAT_R16G16B16A16_UNORM=11]="DXGI_FORMAT_R16G16B16A16_UNORM",vy[vy.DXGI_FORMAT_R16G16B16A16_UINT=12]="DXGI_FORMAT_R16G16B16A16_UINT",vy[vy.DXGI_FORMAT_R16G16B16A16_SNORM=13]="DXGI_FORMAT_R16G16B16A16_SNORM",vy[vy.DXGI_FORMAT_R16G16B16A16_SINT=14]="DXGI_FORMAT_R16G16B16A16_SINT",vy[vy.DXGI_FORMAT_R32G32_TYPELESS=15]="DXGI_FORMAT_R32G32_TYPELESS",vy[vy.DXGI_FORMAT_R32G32_FLOAT=16]="DXGI_FORMAT_R32G32_FLOAT",vy[vy.DXGI_FORMAT_R32G32_UINT=17]="DXGI_FORMAT_R32G32_UINT",vy[vy.DXGI_FORMAT_R32G32_SINT=18]="DXGI_FORMAT_R32G32_SINT",vy[vy.DXGI_FORMAT_R32G8X24_TYPELESS=19]="DXGI_FORMAT_R32G8X24_TYPELESS",vy[vy.DXGI_FORMAT_D32_FLOAT_S8X24_UINT=20]="DXGI_FORMAT_D32_FLOAT_S8X24_UINT",vy[vy.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS=21]="DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS",vy[vy.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT=22]="DXGI_FORMAT_X32_TYPELESS_G8X24_UINT",vy[vy.DXGI_FORMAT_R10G10B10A2_TYPELESS=23]="DXGI_FORMAT_R10G10B10A2_TYPELESS",vy[vy.DXGI_FORMAT_R10G10B10A2_UNORM=24]="DXGI_FORMAT_R10G10B10A2_UNORM",vy[vy.DXGI_FORMAT_R10G10B10A2_UINT=25]="DXGI_FORMAT_R10G10B10A2_UINT",vy[vy.DXGI_FORMAT_R11G11B10_FLOAT=26]="DXGI_FORMAT_R11G11B10_FLOAT",vy[vy.DXGI_FORMAT_R8G8B8A8_TYPELESS=27]="DXGI_FORMAT_R8G8B8A8_TYPELESS",vy[vy.DXGI_FORMAT_R8G8B8A8_UNORM=28]="DXGI_FORMAT_R8G8B8A8_UNORM",vy[vy.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29]="DXGI_FORMAT_R8G8B8A8_UNORM_SRGB",vy[vy.DXGI_FORMAT_R8G8B8A8_UINT=30]="DXGI_FORMAT_R8G8B8A8_UINT",vy[vy.DXGI_FORMAT_R8G8B8A8_SNORM=31]="DXGI_FORMAT_R8G8B8A8_SNORM",vy[vy.DXGI_FORMAT_R8G8B8A8_SINT=32]="DXGI_FORMAT_R8G8B8A8_SINT",vy[vy.DXGI_FORMAT_R16G16_TYPELESS=33]="DXGI_FORMAT_R16G16_TYPELESS",vy[vy.DXGI_FORMAT_R16G16_FLOAT=34]="DXGI_FORMAT_R16G16_FLOAT",vy[vy.DXGI_FORMAT_R16G16_UNORM=35]="DXGI_FORMAT_R16G16_UNORM",vy[vy.DXGI_FORMAT_R16G16_UINT=36]="DXGI_FORMAT_R16G16_UINT",vy[vy.DXGI_FORMAT_R16G16_SNORM=37]="DXGI_FORMAT_R16G16_SNORM",vy[vy.DXGI_FORMAT_R16G16_SINT=38]="DXGI_FORMAT_R16G16_SINT",vy[vy.DXGI_FORMAT_R32_TYPELESS=39]="DXGI_FORMAT_R32_TYPELESS",vy[vy.DXGI_FORMAT_D32_FLOAT=40]="DXGI_FORMAT_D32_FLOAT",vy[vy.DXGI_FORMAT_R32_FLOAT=41]="DXGI_FORMAT_R32_FLOAT",vy[vy.DXGI_FORMAT_R32_UINT=42]="DXGI_FORMAT_R32_UINT",vy[vy.DXGI_FORMAT_R32_SINT=43]="DXGI_FORMAT_R32_SINT",vy[vy.DXGI_FORMAT_R24G8_TYPELESS=44]="DXGI_FORMAT_R24G8_TYPELESS",vy[vy.DXGI_FORMAT_D24_UNORM_S8_UINT=45]="DXGI_FORMAT_D24_UNORM_S8_UINT",vy[vy.DXGI_FORMAT_R24_UNORM_X8_TYPELESS=46]="DXGI_FORMAT_R24_UNORM_X8_TYPELESS",vy[vy.DXGI_FORMAT_X24_TYPELESS_G8_UINT=47]="DXGI_FORMAT_X24_TYPELESS_G8_UINT",vy[vy.DXGI_FORMAT_R8G8_TYPELESS=48]="DXGI_FORMAT_R8G8_TYPELESS",vy[vy.DXGI_FORMAT_R8G8_UNORM=49]="DXGI_FORMAT_R8G8_UNORM",vy[vy.DXGI_FORMAT_R8G8_UINT=50]="DXGI_FORMAT_R8G8_UINT",vy[vy.DXGI_FORMAT_R8G8_SNORM=51]="DXGI_FORMAT_R8G8_SNORM",vy[vy.DXGI_FORMAT_R8G8_SINT=52]="DXGI_FORMAT_R8G8_SINT",vy[vy.DXGI_FORMAT_R16_TYPELESS=53]="DXGI_FORMAT_R16_TYPELESS",vy[vy.DXGI_FORMAT_R16_FLOAT=54]="DXGI_FORMAT_R16_FLOAT",vy[vy.DXGI_FORMAT_D16_UNORM=55]="DXGI_FORMAT_D16_UNORM",vy[vy.DXGI_FORMAT_R16_UNORM=56]="DXGI_FORMAT_R16_UNORM",vy[vy.DXGI_FORMAT_R16_UINT=57]="DXGI_FORMAT_R16_UINT",vy[vy.DXGI_FORMAT_R16_SNORM=58]="DXGI_FORMAT_R16_SNORM",vy[vy.DXGI_FORMAT_R16_SINT=59]="DXGI_FORMAT_R16_SINT",vy[vy.DXGI_FORMAT_R8_TYPELESS=60]="DXGI_FORMAT_R8_TYPELESS",vy[vy.DXGI_FORMAT_R8_UNORM=61]="DXGI_FORMAT_R8_UNORM",vy[vy.DXGI_FORMAT_R8_UINT=62]="DXGI_FORMAT_R8_UINT",vy[vy.DXGI_FORMAT_R8_SNORM=63]="DXGI_FORMAT_R8_SNORM",vy[vy.DXGI_FORMAT_R8_SINT=64]="DXGI_FORMAT_R8_SINT",vy[vy.DXGI_FORMAT_A8_UNORM=65]="DXGI_FORMAT_A8_UNORM",vy[vy.DXGI_FORMAT_R1_UNORM=66]="DXGI_FORMAT_R1_UNORM",vy[vy.DXGI_FORMAT_R9G9B9E5_SHAREDEXP=67]="DXGI_FORMAT_R9G9B9E5_SHAREDEXP",vy[vy.DXGI_FORMAT_R8G8_B8G8_UNORM=68]="DXGI_FORMAT_R8G8_B8G8_UNORM",vy[vy.DXGI_FORMAT_G8R8_G8B8_UNORM=69]="DXGI_FORMAT_G8R8_G8B8_UNORM",vy[vy.DXGI_FORMAT_BC1_TYPELESS=70]="DXGI_FORMAT_BC1_TYPELESS",vy[vy.DXGI_FORMAT_BC1_UNORM=71]="DXGI_FORMAT_BC1_UNORM",vy[vy.DXGI_FORMAT_BC1_UNORM_SRGB=72]="DXGI_FORMAT_BC1_UNORM_SRGB",vy[vy.DXGI_FORMAT_BC2_TYPELESS=73]="DXGI_FORMAT_BC2_TYPELESS",vy[vy.DXGI_FORMAT_BC2_UNORM=74]="DXGI_FORMAT_BC2_UNORM",vy[vy.DXGI_FORMAT_BC2_UNORM_SRGB=75]="DXGI_FORMAT_BC2_UNORM_SRGB",vy[vy.DXGI_FORMAT_BC3_TYPELESS=76]="DXGI_FORMAT_BC3_TYPELESS",vy[vy.DXGI_FORMAT_BC3_UNORM=77]="DXGI_FORMAT_BC3_UNORM",vy[vy.DXGI_FORMAT_BC3_UNORM_SRGB=78]="DXGI_FORMAT_BC3_UNORM_SRGB",vy[vy.DXGI_FORMAT_BC4_TYPELESS=79]="DXGI_FORMAT_BC4_TYPELESS",vy[vy.DXGI_FORMAT_BC4_UNORM=80]="DXGI_FORMAT_BC4_UNORM",vy[vy.DXGI_FORMAT_BC4_SNORM=81]="DXGI_FORMAT_BC4_SNORM",vy[vy.DXGI_FORMAT_BC5_TYPELESS=82]="DXGI_FORMAT_BC5_TYPELESS",vy[vy.DXGI_FORMAT_BC5_UNORM=83]="DXGI_FORMAT_BC5_UNORM",vy[vy.DXGI_FORMAT_BC5_SNORM=84]="DXGI_FORMAT_BC5_SNORM",vy[vy.DXGI_FORMAT_B5G6R5_UNORM=85]="DXGI_FORMAT_B5G6R5_UNORM",vy[vy.DXGI_FORMAT_B5G5R5A1_UNORM=86]="DXGI_FORMAT_B5G5R5A1_UNORM",vy[vy.DXGI_FORMAT_B8G8R8A8_UNORM=87]="DXGI_FORMAT_B8G8R8A8_UNORM",vy[vy.DXGI_FORMAT_B8G8R8X8_UNORM=88]="DXGI_FORMAT_B8G8R8X8_UNORM",vy[vy.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM=89]="DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM",vy[vy.DXGI_FORMAT_B8G8R8A8_TYPELESS=90]="DXGI_FORMAT_B8G8R8A8_TYPELESS",vy[vy.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB=91]="DXGI_FORMAT_B8G8R8A8_UNORM_SRGB",vy[vy.DXGI_FORMAT_B8G8R8X8_TYPELESS=92]="DXGI_FORMAT_B8G8R8X8_TYPELESS",vy[vy.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB=93]="DXGI_FORMAT_B8G8R8X8_UNORM_SRGB",vy[vy.DXGI_FORMAT_BC6H_TYPELESS=94]="DXGI_FORMAT_BC6H_TYPELESS",vy[vy.DXGI_FORMAT_BC6H_UF16=95]="DXGI_FORMAT_BC6H_UF16",vy[vy.DXGI_FORMAT_BC6H_SF16=96]="DXGI_FORMAT_BC6H_SF16",vy[vy.DXGI_FORMAT_BC7_TYPELESS=97]="DXGI_FORMAT_BC7_TYPELESS",vy[vy.DXGI_FORMAT_BC7_UNORM=98]="DXGI_FORMAT_BC7_UNORM",vy[vy.DXGI_FORMAT_BC7_UNORM_SRGB=99]="DXGI_FORMAT_BC7_UNORM_SRGB",vy[vy.DXGI_FORMAT_AYUV=100]="DXGI_FORMAT_AYUV",vy[vy.DXGI_FORMAT_Y410=101]="DXGI_FORMAT_Y410",vy[vy.DXGI_FORMAT_Y416=102]="DXGI_FORMAT_Y416",vy[vy.DXGI_FORMAT_NV12=103]="DXGI_FORMAT_NV12",vy[vy.DXGI_FORMAT_P010=104]="DXGI_FORMAT_P010",vy[vy.DXGI_FORMAT_P016=105]="DXGI_FORMAT_P016",vy[vy.DXGI_FORMAT_420_OPAQUE=106]="DXGI_FORMAT_420_OPAQUE",vy[vy.DXGI_FORMAT_YUY2=107]="DXGI_FORMAT_YUY2",vy[vy.DXGI_FORMAT_Y210=108]="DXGI_FORMAT_Y210",vy[vy.DXGI_FORMAT_Y216=109]="DXGI_FORMAT_Y216",vy[vy.DXGI_FORMAT_NV11=110]="DXGI_FORMAT_NV11",vy[vy.DXGI_FORMAT_AI44=111]="DXGI_FORMAT_AI44",vy[vy.DXGI_FORMAT_IA44=112]="DXGI_FORMAT_IA44",vy[vy.DXGI_FORMAT_P8=113]="DXGI_FORMAT_P8",vy[vy.DXGI_FORMAT_A8P8=114]="DXGI_FORMAT_A8P8",vy[vy.DXGI_FORMAT_B4G4R4A4_UNORM=115]="DXGI_FORMAT_B4G4R4A4_UNORM",vy[vy.DXGI_FORMAT_P208=116]="DXGI_FORMAT_P208",vy[vy.DXGI_FORMAT_V208=117]="DXGI_FORMAT_V208",vy[vy.DXGI_FORMAT_V408=118]="DXGI_FORMAT_V408",vy[vy.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE=119]="DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE",vy[vy.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE=120]="DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE",vy[vy.DXGI_FORMAT_FORCE_UINT=121]="DXGI_FORMAT_FORCE_UINT",(v_=bp||(bp={}))[v_.DDS_DIMENSION_TEXTURE1D=2]="DDS_DIMENSION_TEXTURE1D",v_[v_.DDS_DIMENSION_TEXTURE2D=3]="DDS_DIMENSION_TEXTURE2D",v_[v_.DDS_DIMENSION_TEXTURE3D=6]="DDS_DIMENSION_TEXTURE3D";/**
 * Maps `FOURCC_*` formats to internal formats (see {@link PIXI.INTERNAL_FORMATS}).
 *
 * @ignore
 */var sZ=((bu={})[827611204]=bl.COMPRESSED_RGBA_S3TC_DXT1_EXT,bu[861165636]=bl.COMPRESSED_RGBA_S3TC_DXT3_EXT,bu[894720068]=bl.COMPRESSED_RGBA_S3TC_DXT5_EXT,bu),s$=((bc={})[bd.DXGI_FORMAT_BC1_TYPELESS]=bl.COMPRESSED_RGBA_S3TC_DXT1_EXT,bc[bd.DXGI_FORMAT_BC1_UNORM]=bl.COMPRESSED_RGBA_S3TC_DXT1_EXT,bc[bd.DXGI_FORMAT_BC2_TYPELESS]=bl.COMPRESSED_RGBA_S3TC_DXT3_EXT,bc[bd.DXGI_FORMAT_BC2_UNORM]=bl.COMPRESSED_RGBA_S3TC_DXT3_EXT,bc[bd.DXGI_FORMAT_BC3_TYPELESS]=bl.COMPRESSED_RGBA_S3TC_DXT5_EXT,bc[bd.DXGI_FORMAT_BC3_UNORM]=bl.COMPRESSED_RGBA_S3TC_DXT5_EXT,bc[bd.DXGI_FORMAT_BC1_UNORM_SRGB]=bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,bc[bd.DXGI_FORMAT_BC2_UNORM_SRGB]=bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,bc[bd.DXGI_FORMAT_BC3_UNORM_SRGB]=bl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,bc),sQ=/** @class */function(){function t(){}return(/**
     * Registers a DDS compressed texture
     * @see PIXI.Loader.loaderMiddleware
     * @param resource - loader resource that is checked to see if it is a DDS file
     * @param next - callback Function to call when done
     */t.use=function(e,i){if("dds"===e.extension&&e.data)try{Object.assign(e,sq(e.name||e.url,t.parse(e.data),e.metadata))}catch(t){i(t);return}i()},/** Parses the DDS file header, generates base-textures, and puts them into the texture cache. */t.parse=function(t){var e=new Uint32Array(t);if(542327876!==e[0])throw Error("Invalid DDS file magic word");var i=new Uint32Array(t,0,124/Uint32Array.BYTES_PER_ELEMENT),r=i[3],n=i[4],s=i[7],o=new Uint32Array(t,19*Uint32Array.BYTES_PER_ELEMENT,32/Uint32Array.BYTES_PER_ELEMENT),a=o[1];// File contains compressed texture(s)
if(4&a){var h=o[sK.FOURCC];// File contains one DXTn compressed texture
if(808540228!==h){var l=sZ[h],u=new Uint8Array(t,128);return[new sW(u,{format:l,width:n,height:r,levels:s// CompressedTextureResource will separate the levelBuffers for us!
})]}var c=new Uint32Array(e.buffer,128,20/Uint32Array.BYTES_PER_ELEMENT),d=c[sJ.DXGI_FORMAT],p=c[sJ.RESOURCE_DIMENSION],f=c[sJ.MISC_FLAG],m=c[sJ.ARRAY_SIZE],g=s$[d];if(void 0===g)throw Error("DDSLoader cannot parse texture data with DXGI format "+d);if(4===f)throw Error("DDSLoader does not support cubemap textures");if(p===bp.DDS_DIMENSION_TEXTURE3D)throw Error("DDSLoader does not supported 3D texture data");// Uint8Array buffers of image data, including all mipmap levels in each image
var y=[];if(1===m)y.push(new Uint8Array(t,148));else{for(var _=sz[g],v=0,x=n,b=r,E=0;E<s;E++)v+=Math.max(1,x+3&-4)*Math.max(1,b+3&-4)*_,x>>>=1,b>>>=1;// NOTE: Cubemaps have 6-images per texture (but they aren't supported so ^_^)
for(var T=148,E=0;E<m;E++)y.push(new Uint8Array(t,T,v)),T+=v}// Uint8Array -> CompressedTextureResource, and we're done!
return y.map(function(t){return new sW(t,{format:g,width:n,height:r,levels:s})})}if(64&a)throw Error("DDSLoader does not support uncompressed texture data.");if(512&a)throw Error("DDSLoader does not supported YUV uncompressed texture data.");if(131072&a)throw Error("DDSLoader does not support single-channel (lumninance) texture data!");if(2&a)throw Error("DDSLoader does not support single-channel (alpha) texture data!");throw Error("DDSLoader failed to load a texture file due to an unknown reason!")},t)}();sO.setExtensionXhrType("ktx",sO.XHR_RESPONSE_TYPE.BUFFER);/**
 * The 12-byte KTX file identifier
 *
 * @see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/#2.1
 * @ignore
 */var s0=[171,75,84,88,32,49,49,187,13,10,26,10],s1={ENDIANNESS:12,GL_TYPE:16,GL_FORMAT:24,GL_INTERNAL_FORMAT:28,PIXEL_WIDTH:36,PIXEL_HEIGHT:40,PIXEL_DEPTH:44,NUMBER_OF_ARRAY_ELEMENTS:48,NUMBER_OF_FACES:52,NUMBER_OF_MIPMAP_LEVELS:56,BYTES_OF_KEY_VALUE_DATA:60},s2=((bf={})[x0.UNSIGNED_BYTE]=1,bf[x0.UNSIGNED_SHORT]=2,bf[x0.FLOAT]=4,bf[x0.HALF_FLOAT]=8,bf),s3=((bm={})[x$.RGBA]=4,bm[x$.RGB]=3,bm[x$.LUMINANCE]=1,bm[x$.LUMINANCE_ALPHA]=2,bm[x$.ALPHA]=1,bm),s5=((bg={})[x0.UNSIGNED_SHORT_4_4_4_4]=2,bg[x0.UNSIGNED_SHORT_5_5_5_1]=2,bg[x0.UNSIGNED_SHORT_5_6_5]=2,bg),s4=/** @class */function(){function t(){}return(/**
     * Called after a KTX file is loaded.
     *
     * This will parse the KTX file header and add a {@code BaseTexture} to the texture
     * cache.
     *
     * @see PIXI.Loader.loaderMiddleware
     * @param resource - loader resource that is checked to see if it is a KTX file
     * @param next - callback Function to call when done
     */t.use=function(e,i){if("ktx"===e.extension&&e.data)try{var r=e.name||e.url;Object.assign(e,sq(r,t.parse(r,e.data),e.metadata))}catch(t){i(t);return}i()},/** Parses the KTX file header, generates base-textures, and puts them into the texture cache. */t.parse=function(e,i){var r,n=new DataView(i);if(!t.validate(e,n))return null;var s=67305985===n.getUint32(s1.ENDIANNESS,!0),o=n.getUint32(s1.GL_TYPE,s),a=n.getUint32(s1.GL_FORMAT,s),h=n.getUint32(s1.GL_INTERNAL_FORMAT,s),l=n.getUint32(s1.PIXEL_WIDTH,s),u=n.getUint32(s1.PIXEL_HEIGHT,s)||1,c=n.getUint32(s1.PIXEL_DEPTH,s)||1,d=n.getUint32(s1.NUMBER_OF_ARRAY_ELEMENTS,s)||1,p=n.getUint32(s1.NUMBER_OF_FACES,s),f=n.getUint32(s1.NUMBER_OF_MIPMAP_LEVELS,s),m=n.getUint32(s1.BYTES_OF_KEY_VALUE_DATA,s);// Whether the platform architecture is little endian. If littleEndian !== platformLittleEndian, then the
// file contents must be endian-converted!
// TODO: Endianness conversion
// const platformLittleEndian = new Uint8Array((new Uint32Array([ENDIANNESS])).buffer)[0] === 0x01;
if(0===u||1!==c)throw Error("Only 2D textures are supported");if(1!==p)throw Error("CubeTextures are not supported by KTXLoader yet!");if(1!==d)throw Error("WebGL does not support array textures");var g=l+3&-4,y=u+3&-4,_=Array(d),v=l*u;if(0===o&&(v=g*y),void 0===(r=0!==o?s2[o]?s2[o]*s3[a]:s5[o]:sz[h]))throw Error("Unable to resolve the pixel format stored in the *.ktx file!");for(var x=v*r,b=l,E=u,T=g,w=y,S=64+m,M=0;M<f;M++){for(var A=n.getUint32(S,s),R=S+4,C=0;C<d;C++){// TODO: Maybe support 3D textures? :-)
// for (let zSlice = 0; zSlice < pixelDepth; zSlice)
var P=_[C];P||(P=_[C]=Array(f)),P[M]={levelID:M,levelWidth:f>1?b:T,levelHeight:f>1?E:w,levelBuffer:new Uint8Array(i,R,x)},R+=x}// HINT: Aligns to 4-byte boundary after jumping imageSize (in lieu of mipPadding)
S+=A+4,S=S%4!=0?S+4-S%4:S,E=E>>1||1,// Each mipmap level is 4-times smaller?
x=(T=// Calculate mipWidth, mipHeight for _next_ iteration
(b=b>>1||1)+4-1&-4)*(w=E+4-1&-4)*r}// We use the levelBuffers feature of CompressedTextureResource b/c texture data is image-major, not level-major.
if(0!==o)throw Error("TODO: Uncompressed");return _.map(function(t){return new sW(null,{format:h,width:l,height:u,levels:f,levelBuffers:t})})},/** Checks whether the arrayBuffer contains a valid *.ktx file. */t.validate=function(t,e){// NOTE: Do not optimize this into 3 32-bit integer comparison because the endianness
// of the data is not specified.
for(var i=0;i<s0.length;i++)if(e.getUint8(i)!==s0[i])return console.error(t+" is not a valid *.ktx file!"),!1;return!0},t)}(),s6={};tC(s6,"ParticleContainer",()=>s9),tC(s6,"ParticleRenderer",()=>oe);/*!
 * @pixi/particle-container - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var s8=function(t,e){return(s8=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function s7(t,e){function i(){this.constructor=t}s8(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles.
 *
 * The tradeoff of the ParticleContainer is that most advanced functionality will not work.
 * ParticleContainer implements the basic object transform (position, scale, rotation)
 * and some advanced functionality like tint (as of v4.5.6).
 *
 * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use:
 * ```js
 * let container = new ParticleContainer();
 *
 * for (let i = 0; i < 100; ++i)
 * {
 *     let sprite = PIXI.Sprite.from("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be rendered at the speed of light.
 *
 * @class
 * @extends PIXI.Container
 * @memberof PIXI
 */var s9=/** @class */function(t){/**
     * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.
     *  Affects size of allocated buffers.
     * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.
     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.
     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.
     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.
     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.
     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.
     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.
     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.
     * @param {boolean} [autoResize=false] - If true, container allocates more batches in case
     *  there are more than `maxSize` particles.
     */function e(e,i,r,n){void 0===e&&(e=1500),void 0===r&&(r=16384),void 0===n&&(n=!1);var s=t.call(this)||this;return r>16384&&(r=16384),/**
         * Set properties to be dynamic (true) / static (false)
         *
         * @member {boolean[]}
         * @private
         */s._properties=[!1,!0,!1,!1,!1],/**
         * @member {number}
         * @private
         */s._maxSize=e,/**
         * @member {number}
         * @private
         */s._batchSize=r,/**
         * @member {Array<PIXI.Buffer>}
         * @private
         */s._buffers=null,/**
         * for every batch stores _updateID corresponding to the last change in that batch
         * @member {number[]}
         * @private
         */s._bufferUpdateIDs=[],/**
         * when child inserted, removed or changes position this number goes up
         * @member {number[]}
         * @private
         */s._updateID=0,/**
         * @member {boolean}
         *
         */s.interactiveChildren=!1,/**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`
         * to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */s.blendMode=xJ.NORMAL,/**
         * If true, container allocates more batches in case there are more than `maxSize` particles.
         * @member {boolean}
         * @default false
         */s.autoResize=n,/**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * Default to true here as performance is usually the priority for particles.
         *
         * @member {boolean}
         * @default true
         */s.roundPixels=!0,/**
         * The texture used to render the children.
         *
         * @readonly
         * @member {PIXI.BaseTexture}
         */s.baseTexture=null,s.setProperties(i),/**
         * The tint applied to the container.
         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */s._tint=0,s.tintRgb=new Float32Array(4),s.tint=16777215,s}return s7(e,t),/**
     * Sets the private properties array to dynamic / static based on the passed properties object
     *
     * @param {object} properties - The properties to be uploaded
     */e.prototype.setProperties=function(t){t&&(this._properties[0]="vertices"in t||"scale"in t?!!t.vertices||!!t.scale:this._properties[0],this._properties[1]="position"in t?!!t.position:this._properties[1],this._properties[2]="rotation"in t?!!t.rotation:this._properties[2],this._properties[3]="uvs"in t?!!t.uvs:this._properties[3],this._properties[4]="tint"in t||"alpha"in t?!!t.tint||!!t.alpha:this._properties[4])},/**
     * Updates the object transform for rendering
     *
     * @private
     */e.prototype.updateTransform=function(){// TODO don't need to!
this.displayObjectUpdateTransform()},Object.defineProperty(e.prototype,"tint",{/**
         * The tint applied to the container. This is a hex value.
         * A value of 0xFFFFFF will remove any tint effect.
         ** IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * @member {number}
         * @default 0xFFFFFF
         */get:function(){return this._tint},set:function(t){this._tint=t,e8(t,this.tintRgb)},enumerable:!1,configurable:!0}),/**
     * Renders the container using the WebGL renderer
     *
     * @private
     * @param {PIXI.Renderer} renderer - The webgl renderer
     */e.prototype.render=function(t){var e=this;this.visible&&!(this.worldAlpha<=0)&&this.children.length&&this.renderable&&(this.baseTexture||(this.baseTexture=this.children[0]._texture.baseTexture,this.baseTexture.valid||this.baseTexture.once("update",function(){return e.onChildrenChange(0)})),t.batch.setObjectRenderer(t.plugins.particle),t.plugins.particle.render(this))},/**
     * Set the flag that static data should be updated to true
     *
     * @private
     * @param {number} smallestChildIndex - The smallest child index
     */e.prototype.onChildrenChange=function(t){for(var e=Math.floor(t/this._batchSize);this._bufferUpdateIDs.length<e;)this._bufferUpdateIDs.push(0);this._bufferUpdateIDs[e]=++this._updateID},e.prototype.dispose=function(){if(this._buffers){for(var t=0;t<this._buffers.length;++t)this._buffers[t].destroy();this._buffers=null}},/**
     * Destroys the container
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */e.prototype.destroy=function(e){t.prototype.destroy.call(this,e),this.dispose(),this._properties=null,this._buffers=null,this._bufferUpdateIDs=null},e}(i8),ot=/** @class */function(){/**
     * @private
     * @param {object} properties - The properties to upload.
     * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.
     * @param {number} size - The size of the batch.
     */function t(t,e,i){this.geometry=new r$,this.indexBuffer=null,/**
         * The number of particles the buffer can hold
         *
         * @private
         * @member {number}
         */this.size=i,/**
         * A list of the properties that are dynamic.
         *
         * @private
         * @member {object[]}
         */this.dynamicProperties=[],/**
         * A list of the properties that are static.
         *
         * @private
         * @member {object[]}
         */this.staticProperties=[];for(var r=0;r<t.length;++r){var n=t[r];// Make copy of properties object so that when we edit the offset it doesn't
// change all other instances of the object literal
n={attributeName:n.attributeName,size:n.size,uploadFunction:n.uploadFunction,type:n.type||x0.FLOAT,offset:n.offset},e[r]?this.dynamicProperties.push(n):this.staticProperties.push(n)}this.staticStride=0,this.staticBuffer=null,this.staticData=null,this.staticDataUint32=null,this.dynamicStride=0,this.dynamicBuffer=null,this.dynamicData=null,this.dynamicDataUint32=null,this._updateID=0,this.initBuffers()}return(/**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */t.prototype.initBuffers=function(){var t=this.geometry,e=0;/**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         * @private
         */this.indexBuffer=new rY(ia(this.size),!0,!0),t.addIndex(this.indexBuffer),this.dynamicStride=0;for(var i=0;i<this.dynamicProperties.length;++i){var r=this.dynamicProperties[i];r.offset=e,e+=r.size,this.dynamicStride+=r.size}var n=new ArrayBuffer(this.size*this.dynamicStride*16);this.dynamicData=new Float32Array(n),this.dynamicDataUint32=new Uint32Array(n),this.dynamicBuffer=new rY(this.dynamicData,!1,!1);// static //
var s=0;this.staticStride=0;for(var i=0;i<this.staticProperties.length;++i){var r=this.staticProperties[i];r.offset=s,s+=r.size,this.staticStride+=r.size}var o=new ArrayBuffer(this.size*this.staticStride*16);this.staticData=new Float32Array(o),this.staticDataUint32=new Uint32Array(o),this.staticBuffer=new rY(this.staticData,!0,!1);for(var i=0;i<this.dynamicProperties.length;++i){var r=this.dynamicProperties[i];t.addAttribute(r.attributeName,this.dynamicBuffer,0,r.type===x0.UNSIGNED_BYTE,r.type,4*this.dynamicStride,4*r.offset)}for(var i=0;i<this.staticProperties.length;++i){var r=this.staticProperties[i];t.addAttribute(r.attributeName,this.staticBuffer,0,r.type===x0.UNSIGNED_BYTE,r.type,4*this.staticStride,4*r.offset)}},/**
     * Uploads the dynamic properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */t.prototype.uploadDynamic=function(t,e,i){for(var r=0;r<this.dynamicProperties.length;r++){var n=this.dynamicProperties[r];n.uploadFunction(t,e,i,n.type===x0.UNSIGNED_BYTE?this.dynamicDataUint32:this.dynamicData,this.dynamicStride,n.offset)}this.dynamicBuffer._updateID++},/**
     * Uploads the static properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */t.prototype.uploadStatic=function(t,e,i){for(var r=0;r<this.staticProperties.length;r++){var n=this.staticProperties[r];n.uploadFunction(t,e,i,n.type===x0.UNSIGNED_BYTE?this.staticDataUint32:this.staticData,this.staticStride,n.offset)}this.staticBuffer._updateID++},/**
     * Destroys the ParticleBuffer.
     *
     * @private
     */t.prototype.destroy=function(){this.indexBuffer=null,this.dynamicProperties=null,this.dynamicBuffer=null,this.dynamicData=null,this.dynamicDataUint32=null,this.staticProperties=null,this.staticBuffer=null,this.staticData=null,this.staticDataUint32=null,// all buffers are destroyed inside geometry
this.geometry.destroy()},t)}(),oe=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this sprite batch works for.
     */function e(e){var i=t.call(this,e)||this;return(// 65535 is max vertex index in the index buffer (see ParticleRenderer)
// so max number of particles is 65536 / 4 = 16384
// and max number of element in the index buffer is 16384 * 6 = 98304
// Creating a full index buffer, overhead is 98304 * 2 = 196Ko
// let numIndices = 98304;
/**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */i.shader=null,i.properties=null,i.tempMatrix=new iX,i.properties=[// verticesData
{attributeName:"aVertexPosition",size:2,uploadFunction:i.uploadVertices,offset:0},// positionData
{attributeName:"aPositionCoord",size:2,uploadFunction:i.uploadPosition,offset:0},// rotationData
{attributeName:"aRotation",size:1,uploadFunction:i.uploadRotation,offset:0},// uvsData
{attributeName:"aTextureCoord",size:2,uploadFunction:i.uploadUvs,offset:0},// tintData
{attributeName:"aColor",size:1,type:x0.UNSIGNED_BYTE,uploadFunction:i.uploadTint,offset:0}],i.shader=nM.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n","varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}",{}),/**
         * The WebGL state in which this renderer will work.
         *
         * @member {PIXI.State}
         * @readonly
         */i.state=nA.for2d(),i)}return s7(e,t),/**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */e.prototype.render=function(t){var e=t.children,i=t._maxSize,r=t._batchSize,n=this.renderer,s=e.length;if(0!==s){s>i&&!t.autoResize&&(s=i);var o=t._buffers;o||(o=t._buffers=this.generateBuffers(t));var a=e[0]._texture.baseTexture;// if the uvs have not updated then no point rendering just yet!
this.state.blendMode=ii(t.blendMode,a.alphaMode),n.state.set(this.state);var h=n.gl,l=t.worldTransform.copyTo(this.tempMatrix);l.prepend(n.globalUniforms.uniforms.projectionMatrix),this.shader.uniforms.translationMatrix=l.toArray(!0),this.shader.uniforms.uColor=ir(t.tintRgb,t.worldAlpha,this.shader.uniforms.uColor,a.alphaMode),this.shader.uniforms.uSampler=a,this.renderer.shader.bind(this.shader);// now lets upload and render the buffers..
for(var u=!1,c=0,d=0;c<s;c+=r,d+=1){var p=s-c;p>r&&(p=r),d>=o.length&&o.push(this._generateOneMoreBuffer(t));var f=o[d];// we always upload the dynamic
f.uploadDynamic(e,c,p);var m=t._bufferUpdateIDs[d]||0;(u=u||f._updateID<m)&&(f._updateID=t._updateID,f.uploadStatic(e,c,p)),// bind the buffer
n.geometry.bind(f.geometry),h.drawElements(h.TRIANGLES,6*p,h.UNSIGNED_SHORT,0)}}},/**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */e.prototype.generateBuffers=function(t){for(var e=[],i=t._maxSize,r=t._batchSize,n=t._properties,s=0;s<i;s+=r)e.push(new ot(this.properties,n,r));return e},/**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */e.prototype._generateOneMoreBuffer=function(t){var e=t._batchSize,i=t._properties;return new ot(this.properties,i,e)},/**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */e.prototype.uploadVertices=function(t,e,i,r,n,s){for(var o=0,a=0,h=0,l=0,u=0;u<i;++u){var c=t[e+u],d=c._texture,p=c.scale.x,f=c.scale.y,m=d.trim,g=d.orig;m?(o=// if the sprite is trimmed and is not a tilingsprite then we need to add the
// extra space before transforming the sprite coords..
(a=m.x-c.anchor.x*g.width)+m.width,h=(l=m.y-c.anchor.y*g.height)+m.height):(o=g.width*(1-c.anchor.x),a=-(g.width*c.anchor.x),h=g.height*(1-c.anchor.y),l=-(g.height*c.anchor.y)),r[s]=a*p,r[s+1]=l*f,r[s+n]=o*p,r[s+n+1]=l*f,r[s+2*n]=o*p,r[s+2*n+1]=h*f,r[s+3*n]=a*p,r[s+3*n+1]=h*f,s+=4*n}},/**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */e.prototype.uploadPosition=function(t,e,i,r,n,s){for(var o=0;o<i;o++){var a=t[e+o].position;r[s]=a.x,r[s+1]=a.y,r[s+n]=a.x,r[s+n+1]=a.y,r[s+2*n]=a.x,r[s+2*n+1]=a.y,r[s+3*n]=a.x,r[s+3*n+1]=a.y,s+=4*n}},/**
     * Uploads the rotation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */e.prototype.uploadRotation=function(t,e,i,r,n,s){for(var o=0;o<i;o++){var a=t[e+o].rotation;r[s]=a,r[s+n]=a,r[s+2*n]=a,r[s+3*n]=a,s+=4*n}},/**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */e.prototype.uploadUvs=function(t,e,i,r,n,s){for(var o=0;o<i;++o){var a=t[e+o]._texture._uvs;a?(r[s]=a.x0,r[s+1]=a.y0,r[s+n]=a.x1,r[s+n+1]=a.y1,r[s+2*n]=a.x2,r[s+2*n+1]=a.y2,r[s+3*n]=a.x3,r[s+3*n+1]=a.y3):(// TODO you know this can be easier!
r[s]=0,r[s+1]=0,r[s+n]=0,r[s+n+1]=0,r[s+2*n]=0,r[s+2*n+1]=0,r[s+3*n]=0,r[s+3*n+1]=0),s+=4*n}},/**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */e.prototype.uploadTint=function(t,e,i,r,n,s){for(var o=0;o<i;++o){var a=t[e+o],h=a._texture.baseTexture.alphaMode>0,l=a.alpha,u=l<1&&h?is(a._tintRGB,l):a._tintRGB+(255*l<<24);r[s]=u,r[s+n]=u,r[s+2*n]=u,r[s+3*n]=u,s+=4*n}},/**
     * Destroys the ParticleRenderer.
     */e.prototype.destroy=function(){t.prototype.destroy.call(this),this.shader&&(this.shader.destroy(),this.shader=null),this.tempMatrix=null},e}(r8),oi={};tC(oi,"CountLimiter",()=>oJ),tC(oi,"BasePrepare",()=>o5),tC(oi,"Prepare",()=>o7),tC(oi,"TimeLimiter",()=>o9);/*!
 * @pixi/prepare - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var or={};tC(or,"LINE_JOIN",()=>by),tC(or,"LINE_CAP",()=>b_),tC(or,"GRAPHICS_CURVES",()=>on),tC(or,"FillStyle",()=>os),tC(or,"GraphicsData",()=>oT),tC(or,"GraphicsGeometry",()=>oM),tC(or,"LineStyle",()=>oA),tC(or,"Graphics",()=>oP),tC(or,"graphicsUtils",()=>oI),(vv=by||(by={})).MITER="miter",vv.BEVEL="bevel",vv.ROUND="round",(vx=b_||(b_={})).BUTT="butt",vx.ROUND="round",vx.SQUARE="square";/**
 * Graphics curves resolution settings. If `adaptive` flag is set to `true`,
 * the resolution is calculated based on the curve's length to ensure better visual quality.
 * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name GRAPHICS_CURVES
 * @type {object}
 * @property {boolean} adaptive=true - flag indicating if the resolution should be adaptive
 * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
 * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
 * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
 */var on={adaptive:!0,maxLength:10,minSegments:8,maxSegments:2048,epsilon:1e-4,_segmentsCount:function(t,e){if(void 0===e&&(e=20),!this.adaptive||!t||isNaN(t))return e;var i=Math.ceil(t/this.maxLength);return i<this.minSegments?i=this.minSegments:i>this.maxSegments&&(i=this.maxSegments),i}},os=/** @class */function(){function t(){/**
         * The hex color value used when coloring the Graphics object.
         *
         * @default 0xFFFFFF
         */this.color=16777215,/** The alpha value used when filling the Graphics object. */this.alpha=1,/**
         * The texture to be used for the fill.
         *
         * @member {PIXI.Texture}
         * @default 0
         */this.texture=rH.WHITE,/**
         * The transform applied to the texture.
         *
         * @member {PIXI.Matrix}
         * @default null
         */this.matrix=null,/** If the current fill is visible. */this.visible=!1,this.reset()}return(/**
     * Clones the object
     *
     * @return {PIXI.FillStyle}
     */t.prototype.clone=function(){var e=new t;return e.color=this.color,e.alpha=this.alpha,e.texture=this.texture,e.matrix=this.matrix,e.visible=this.visible,e},/**
     * Reset
     */t.prototype.reset=function(){this.color=16777215,this.alpha=1,this.texture=rH.WHITE,this.matrix=null,this.visible=!1},/**
     * Destroy and don't use after this
     */t.prototype.destroy=function(){this.texture=null,this.matrix=null},t)}(),oo=function(t,e){return(oo=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function oa(t,e){function i(){this.constructor=t}oo(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * Builds a polygon to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */var oh={build:function(t){t.points=t.shape.points.slice()},triangulate:function(t,e){var i=t.points,r=t.holes,n=e.points,s=e.indices;if(i.length>=6){// Process holes..
for(var o=[],a=0;a<r.length;a++){var h=r[a];o.push(i.length/2),i=i.concat(h.points)}var l=/*@__PURE__*/tP(ex)(i,o,2);if(!l)return;for(var u=n.length/2,a=0;a<l.length;a+=3)s.push(l[a]+u),s.push(l[a+1]+u),s.push(l[a+2]+u);for(var a=0;a<i.length;a++)n.push(i[a])}}},ol={build:function(t){// need to convert points to a nice regular data
var e,i,r=t.shape,n=t.points,s=r.x,o=r.y;// TODO - bit hacky??
if(n.length=0,t.type===bn.CIRC)e=r.radius,i=r.radius;else{var a=t.shape;e=a.width,i=a.height}if(0!==e&&0!==i){for(var h=Math.floor(30*Math.sqrt(r.radius))||Math.floor(15*Math.sqrt(e+i)),l=2*Math.PI/(h/=2.3),u=0;u<h-.5;u++)n.push(s+Math.sin(-l*u)*e,o+Math.cos(-l*u)*i);n.push(n[0],n[1])}},triangulate:function(t,e){var i=t.points,r=e.points,n=e.indices,s=r.length/2,o=s,a=t.shape,h=t.matrix,l=a.x,u=a.y;// Push center (special point)
r.push(t.matrix?h.a*l+h.c*u+h.tx:l,t.matrix?h.b*l+h.d*u+h.ty:u);for(var c=0;c<i.length;c+=2)r.push(i[c],i[c+1]),// add some uvs
n.push(s++,o,s)}},ou={build:function(t){// --- //
// need to convert points to a nice regular data
//
var e=t.shape,i=e.x,r=e.y,n=e.width,s=e.height,o=t.points;o.length=0,o.push(i,r,i+n,r,i+n,r+s,i,r+s)},triangulate:function(t,e){var i=t.points,r=e.points,n=r.length/2;r.push(i[0],i[1],i[2],i[3],i[6],i[7],i[4],i[5]),e.indices.push(n,n+1,n+2,n+1,n+2,n+3)}};/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */function oc(t,e,i,r,n,s,o){void 0===o&&(o=[]);for(var a,h,l=o,u=0,c=0,d=0,p=0,f=0,m=0,g=0,y=0;g<=20;++g)// The Green Line
u=t+(i-t)*(y=g/20),c=e+(r-e)*y,d=i+(n-i)*y,p=r+(s-r)*y,// The Black Dot
f=(a=u)+(d-a)*y,m=(h=c)+(p-h)*y,(0!==g||l[l.length-2]!==f||l[l.length-1]!==m)&&l.push(f,m);return l}/**
 * Builds a rounded rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
 * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
 */var od={build:function(t){var e=t.shape,i=t.points,r=e.x,n=e.y,s=e.width,o=e.height,a=Math.max(0,Math.min(e.radius,Math.min(s,o)/2));i.length=0,a?(oc(r,n+a,r,n,r+a,n,i),oc(r+s-a,n,r+s,n,r+s,n+a,i),oc(r+s,n+o-a,r+s,n+o,r+s-a,n+o,i),oc(r+a,n+o,r,n+o,r,n+o-a,i)):i.push(r,n,r+s,n,r+s,n+o,r,n+o)},triangulate:function(t,e){for(var i=t.points,r=e.points,n=e.indices,s=r.length/2,o=/*@__PURE__*/tP(ex)(i,null,2),a=0,h=o.length;a<h;a+=3)n.push(o[a]+s),//     indices.push(triangles[i] + vecPos);
n.push(o[a+1]+s),//   indices.push(triangles[i + 2] + vecPos);
n.push(o[a+2]+s);for(var a=0,h=i.length;a<h;a++)r.push(i[a],i[++a])}};/**
 * Buffers vertices to draw a square cap.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} x - X-coord of end point
 * @param {number} y - Y-coord of end point
 * @param {number} nx - X-coord of line normal pointing inside
 * @param {number} ny - Y-coord of line normal pointing inside
 * @param {Array<number>} verts - vertex buffer
 * @returns {}
 */function op(t,e,i,r,n,s,o,/* rotation for square (true at left end, false at right end) */a){o?(h=r,l=-i):(h=-r,l=i);/* [i|0]x,y extended at cap */var h,l,u=t-i*n+h,c=e-r*n+l,d=t+i*s+h,p=e+r*s+l;return /* Square itself must be inserted clockwise*/a.push(u,c),a.push(d,p),2}/**
 * Buffers vertices to draw an arc at the line joint or cap.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} cx - X-coord of center
 * @param {number} cy - Y-coord of center
 * @param {number} sx - X-coord of arc start
 * @param {number} sy - Y-coord of arc start
 * @param {number} ex - X-coord of arc end
 * @param {number} ey - Y-coord of arc end
 * @param {Array<number>} verts - buffer of vertices
 * @param {boolean} clockwise - orientation of vertices
 * @returns {number} - no. of vertices pushed
 */function of(t,e,i,r,n,s,o,a){var h=i-t,l=r-e,u=Math.atan2(h,l),c=Math.atan2(n-t,s-e);a&&u<c?u+=2*Math.PI:!a&&u>c&&(c+=2*Math.PI);var d=u,p=c-u,f=Math.sqrt(h*h+l*l),m=(15*Math.abs(p)*Math.sqrt(f)/Math.PI>>0)+1,g=p/m;if(d+=g,a){o.push(t,e),o.push(i,r);for(var y=1,_=d;y<m;y++,_+=g)o.push(t,e),o.push(t+Math.sin(_)*f,e+Math.cos(_)*f);o.push(t,e),o.push(n,s)}else{o.push(i,r),o.push(t,e);for(var y=1,_=d;y<m;y++,_+=g)o.push(t+Math.sin(_)*f,e+Math.cos(_)*f),o.push(t,e);o.push(n,s),o.push(t,e)}return 2*m}/**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */function om(t,e){t.lineStyle.native?/**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */function(t,e){var i=0,r=t.shape,n=t.points||r.points,s=r.type!==bn.POLY||r.closeStroke;if(0!==n.length){var o=e.points,a=e.indices,h=n.length/2,l=o.length/2,u=l;for(o.push(n[0],n[1]),i=1;i<h;i++)o.push(n[2*i],n[2*i+1]),a.push(u,u+1),u++;s&&a.push(u,l)}}(t,e):/**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */function(t,e){var i=t.shape,r=t.points||i.points.slice(),n=e.closePointEps;if(0!==r.length){// if the line width is an odd number add 0.5 to align to a whole pixel
// commenting this out fixes #711 and #1620
// if (graphicsData.lineWidth%2)
// {
//     for (i = 0; i < points.length; i++)
//     {
//         points[i] += 0.5;
//     }
// }
var s=t.lineStyle,o=new ij(r[0],r[1]),a=new ij(r[r.length-2],r[r.length-1]),h=i.type!==bn.POLY||i.closeStroke,l=Math.abs(o.x-a.x)<n&&Math.abs(o.y-a.y)<n;// if the first point is the last point - gonna have issues :)
if(h){// need to clone as we are going to slightly modify the shape..
r=r.slice(),l&&(r.pop(),r.pop(),a.set(r[r.length-2],r[r.length-1]));var u=(o.x+a.x)*.5,c=(a.y+o.y)*.5;r.unshift(u,c),r.push(u,c)}var d=e.points,p=r.length/2,f=r.length,m=d.length/2,g=s.width/2,y=g*g,_=s.miterLimit*s.miterLimit,v=r[0],x=r[1],b=r[2],E=r[3],T=0,w=0,S=-(x-E),M=v-b,A=0,R=0,C=Math.sqrt(S*S+M*M);S/=C,M/=C,S*=g,M*=g;var P=s.alignment,I=(1-P)*2,O=2*P;// 0.5;
h||(s.cap===b_.ROUND?f+=of(v-S*(I-O)*.5,x-M*(I-O)*.5,v-S*I,x-M*I,v+S*O,x+M*O,d,!0)+2:s.cap===b_.SQUARE&&(f+=op(v,x,S,M,I,O,!0,d))),// Push first point (below & above vertices)
d.push(v-S*I,x-M*I),d.push(v+S*O,x+M*O);for(var L=1;L<p-1;++L){v=r[(L-1)*2],x=r[(L-1)*2+1],b=r[2*L],E=r[2*L+1],T=r[(L+1)*2],w=r[(L+1)*2+1],C=Math.sqrt((S=-(x-E))*S+(M=v-b)*M),S/=C,M/=C,S*=g,M*=g,C=Math.sqrt((A=-(E-w))*A+(R=b-T)*R),A/=C,R/=C,A*=g,R*=g;/* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */var N=b-v,D=x-E,F=b-T,B=w-E,U=D*F-B*N,G=U<0;/* Going nearly straight? */if(.1>Math.abs(U)){d.push(b-S*I,E-M*I),d.push(b+S*O,E+M*O);continue}/* p[x|y] is the miter point. pdist is the distance between miter point and p1. */var k=(-S+v)*(-M+E)-(-S+b)*(-M+x),H=(-A+T)*(-R+E)-(-A+b)*(-R+w),z=(N*H-F*k)/U,j=(B*k-D*H)/U,V=(z-b)*(z-b)+(j-E)*(j-E),X=b+(z-b)*I,W=E+(j-E)*I,Y=b-(z-b)*O,q=E-(j-E)*O,K=G?I:O;V<=Math.min(N*N+D*D,F*F+B*B)+K*K*y?s.join===by.BEVEL||V/y>_?(G?(d.push(X,W),d.push(b+S*O,E+M*O),d.push(X,W),d.push(b+A*O,E+R*O)):(d.push(b-S*I,E-M*I),d.push(Y,q),d.push(b-A*I,E-R*I),d.push(Y,q)),f+=2):s.join===by.ROUND?G?(d.push(X,W),d.push(b+S*O,E+M*O),f+=of(b,E,b+S*O,E+M*O,b+A*O,E+R*O,d,!0)+4,d.push(X,W),d.push(b+A*O,E+R*O)):(d.push(b-S*I,E-M*I),d.push(Y,q),f+=of(b,E,b-S*I,E-M*I,b-A*I,E-R*I,d,!1)+4,d.push(b-A*I,E-R*I),d.push(Y,q)):(d.push(X,W),d.push(Y,q)):(d.push(b-S*I,E-M*I),d.push(b+S*O,E+M*O),s.join===by.BEVEL||V/y>_||(s.join===by.ROUND?G?f+=of(b,E,b+S*O,E+M*O,b+A*O,E+R*O,d,!0)+2:f+=of(b,E,b-S*I,E-M*I,b-A*I,E-R*I,d,!1)+2:(G?(d.push(Y,q),d.push(Y,q)):(d.push(X,W),d.push(X,W)),f+=2)),d.push(b-A*I,E-R*I),d.push(b+A*O,E+R*O),f+=2)}v=r[(p-2)*2],x=r[(p-2)*2+1],b=r[(p-1)*2],C=Math.sqrt((S=-(x-(E=r[(p-1)*2+1])))*S+(M=v-b)*M),S/=C,M/=C,S*=g,M*=g,d.push(b-S*I,E-M*I),d.push(b+S*O,E+M*O),h||(s.cap===b_.ROUND?f+=of(b-S*(I-O)*.5,E-M*(I-O)*.5,b-S*I,E-M*I,b+S*O,E+M*O,d,!1)+2:s.cap===b_.SQUARE&&(f+=op(b,E,S,M,I,O,!1,d)));// indices.push(indexStart);
for(var J=e.indices,Z=on.epsilon*on.epsilon,L=m;L<f+m-2;++L)v=d[2*L],x=d[2*L+1],b=d[(L+1)*2],E=d[(L+1)*2+1],T=d[(L+2)*2],Math.abs(v*(E-(w=d[(L+2)*2+1]))+b*(w-x)+T*(x-E))<Z||J.push(L,L+1,L+2)}}(t,e)}/**
 * Utilities for arc curves
 * @class
 * @private
 */var og=/** @class */function(){function t(){}return(/**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @private
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.
     */t.curveTo=function(t,e,i,r,n,s){var o=s[s.length-2],a=s[s.length-1]-e,h=o-t,l=r-e,u=i-t,c=Math.abs(a*u-h*l);if(c<1e-8||0===n)return(s[s.length-2]!==t||s[s.length-1]!==e)&&s.push(t,e),null;var d=a*a+h*h,p=l*l+u*u,f=a*l+h*u,m=n*Math.sqrt(d)/c,g=n*Math.sqrt(p)/c,y=m*f/d,_=g*f/p,v=m*u+g*h,x=m*l+g*a,b=Math.atan2(a*(g+y)-x,h*(g+y)-v),E=Math.atan2(l*(m+_)-x,u*(m+_)-v);return{cx:v+t,cy:x+e,radius:n,startAngle:b,endAngle:E,anticlockwise:h*l>u*a}},/* eslint-disable max-len *//**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @private
     * @param {number} startX - Start x location of arc
     * @param {number} startY - Start y location of arc
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} anticlockwise - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @param {number[]} points - Collection of points to add to
     */t.arc=function(t,e,i,r,n,s,o,a,h){for(var l=o-s,u=on._segmentsCount(Math.abs(l)*n,40*Math.ceil(Math.abs(l)/iD)),c=l/(2*u),d=2*c,p=Math.cos(c),f=Math.sin(c),m=u-1,g=m%1/m,y=0;y<=m;++y){var _=c+s+d*(y+g*y),v=Math.cos(_),x=-Math.sin(_);h.push((p*v+f*x)*n+i,(-(p*x)+f*v)*n+r)}},t)}(),oy=/** @class */function(){function t(){}return(/**
     * Calculate length of bezier curve.
     * Analytical solution is impossible, since it involves an integral that does not integrate in general.
     * Therefore numerical solution is used.
     *
     * @private
     * @param {number} fromX - Starting point x
     * @param {number} fromY - Starting point y
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {number} Length of bezier curve
     */t.curveLength=function(t,e,i,r,n,s,o,a){for(var h=0,l=0,u=0,c=0,d=0,p=0,f=0,m=0,g=0,y=0,_=0,v=t,x=e,b=1;b<=10;++b)c=(u=(l=b/10)*l)*l,m=(f=(p=(d=1-l)*d)*d)*t+3*p*l*i+3*d*u*n+c*o,g=f*e+3*p*l*r+3*d*u*s+c*a,y=v-m,_=x-g,v=m,x=g,h+=Math.sqrt(y*y+_*_);return h},/**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Path array to push points into
     */t.curveTo=function(e,i,r,n,s,o,a){var h=a[a.length-2],l=a[a.length-1];a.length-=2;var u=on._segmentsCount(t.curveLength(h,l,e,i,r,n,s,o)),c=0,d=0,p=0,f=0,m=0;a.push(h,l);for(var g=1,y=0;g<=u;++g)p=(d=(c=1-(y=g/u))*c)*c,m=(f=y*y)*y,a.push(p*h+3*d*y*e+3*c*f*r+m*s,p*l+3*d*y*i+3*c*f*n+m*o)},t)}(),o_=/** @class */function(){function t(){}return(/**
     * Calculate length of quadratic curve
     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
     * for the detailed explanation of math behind this.
     *
     * @private
     * @param {number} fromX - x-coordinate of curve start point
     * @param {number} fromY - y-coordinate of curve start point
     * @param {number} cpX - x-coordinate of curve control point
     * @param {number} cpY - y-coordinate of curve control point
     * @param {number} toX - x-coordinate of curve end point
     * @param {number} toY - y-coordinate of curve end point
     * @return {number} Length of quadratic curve
     */t.curveLength=function(t,e,i,r,n,s){var o=t-2*i+n,a=e-2*r+s,h=2*i-2*t,l=2*r-2*e,u=4*(o*o+a*a),c=4*(o*h+a*l),d=h*h+l*l,p=2*Math.sqrt(u+c+d),f=Math.sqrt(u),m=2*u*f,g=2*Math.sqrt(d),y=c/f;return(m*p+f*c*(p-g)+(4*d*u-c*c)*Math.log((2*f+y+p)/(y+g)))/(4*m)},/**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @private
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Points to add segments to.
     */t.curveTo=function(e,i,r,n,s){for(var o=s[s.length-2],a=s[s.length-1],h=on._segmentsCount(t.curveLength(o,a,e,i,r,n)),l=0,u=0,c=1;c<=h;++c){var d=c/h;l=o+(e-o)*d,u=a+(i-a)*d,s.push(l+(e+(r-e)*d-l)*d,u+(i+(n-i)*d-u)*d)}},t)}(),ov=/** @class */function(){function t(){this.reset()}return(/**
     * Begin batch part
     *
     * @param {PIXI.FillStyle | PIXI.LineStyle} style
     * @param {number} startIndex
     * @param {number} attribStart
     */t.prototype.begin=function(t,e,i){this.reset(),this.style=t,this.start=e,this.attribStart=i},/**
     * End batch part
     *
     * @param {number} endIndex
     * @param {number} endAttrib
     */t.prototype.end=function(t,e){this.attribSize=e-this.attribStart,this.size=t-this.start},t.prototype.reset=function(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0},t)}(),ox=((bv={})[bn.POLY]=oh,bv[bn.CIRC]=ol,bv[bn.ELIP]=ol,bv[bn.RECT]=ou,bv[bn.RREC]=od,bv),ob=[],oE=[],oT=/** @class */function(){/**
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw
     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw
     * @param {PIXI.Matrix} [matrix] - Transform matrix
     */function t(t,e,i,r){void 0===e&&(e=null),void 0===i&&(i=null),void 0===r&&(r=null),/** The collection of points. */this.points=[],/**
         * The collection of holes.
         *
         * @member {PIXI.GraphicsData[]}
         */this.holes=[],/**
         * The shape object to draw.
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
         */this.shape=t,/**
         * The style of the line.
         * @member {PIXI.LineStyle}
         */this.lineStyle=i,/**
         * The style of the fill.
         * @member {PIXI.FillStyle}
         */this.fillStyle=e,/**
         * The transform matrix.
         * @member {PIXI.Matrix}
         */this.matrix=r,/**
         * The type of the shape, see the Const.Shapes file for all the existing types,
         * @member {number}
         */this.type=t.type}return(/**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {PIXI.GraphicsData} Cloned GraphicsData object
     */t.prototype.clone=function(){return new t(this.shape,this.fillStyle,this.lineStyle,this.matrix)},/**
     * Destroys the Graphics data.
     *
     */t.prototype.destroy=function(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null},t)}(),ow=new ij,oS=new i1,oM=/** @class */function(t){// eslint-disable-next-line @typescript-eslint/no-useless-constructor
function e(){var e=t.call(this)||this;return(/**
         * Minimal distance between points that are considered different.
         * Affects line tesselation.
         */e.closePointEps=1e-4,/** Padding to add to the bounds. */e.boundsPadding=0,e.uvsFloat32=null,e.indicesUint16=null,e.batchable=!1,/** An array of points to draw, 2 numbers per point */e.points=[],/** The collection of colors */e.colors=[],/** The UVs collection */e.uvs=[],/** The indices of the vertices */e.indices=[],/** Reference to the texture IDs. */e.textureIds=[],/**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         */e.graphicsData=[],/**
         * List of current draw calls drived from the batches.
         *
         * @member {PIXI.BatchDrawCall[]}
         */e.drawCalls=[],/** Batches need to regenerated if the geometry is updated. */e.batchDirty=-1,/**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {PIXI.graphicsUtils.BatchPart[]}
         */e.batches=[],/** Used to detect if the graphics object has changed. */e.dirty=0,/** Used to check if the cache is dirty. */e.cacheDirty=-1,/** Used to detect if we cleared the graphicsData. */e.clearDirty=0,/** Index of the last batched shape in the stack of calls. */e.shapeIndex=0,/**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         */e._bounds=new i1,/** The bounds dirty flag. */e.boundsDirty=-1,e)}return oa(e,t),Object.defineProperty(e.prototype,"bounds",{/**
         * Get the current bounds of the graphic geometry.
         *
         * @member {PIXI.Bounds}
         * @readonly
         */get:function(){return this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds},enumerable:!1,configurable:!0}),/**
     * Call if you changed graphicsData manually.
     * Empties all batch buffers.
     */e.prototype.invalidate=function(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeIndex=0,this.points.length=0,this.colors.length=0,this.uvs.length=0,this.indices.length=0,this.textureIds.length=0;for(var t=0;t<this.drawCalls.length;t++)this.drawCalls[t].texArray.clear(),oE.push(this.drawCalls[t]);this.drawCalls.length=0;for(var t=0;t<this.batches.length;t++){var e=this.batches[t];e.reset(),ob.push(e)}this.batches.length=0},/**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */e.prototype.clear=function(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this},/**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */e.prototype.drawShape=function(t,e,i,r){void 0===e&&(e=null),void 0===i&&(i=null),void 0===r&&(r=null);var n=new oT(t,e,i,r);return this.graphicsData.push(n),this.dirty++,this},/**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */e.prototype.drawHole=function(t,e){if(void 0===e&&(e=null),!this.graphicsData.length)return null;var i=new oT(t,null,null,e),r=this.graphicsData[this.graphicsData.length-1];return i.lineStyle=r.lineStyle,r.holes.push(i),this.dirty++,this},/**
     * Destroys the GraphicsGeometry object.
     *
     */e.prototype.destroy=function(){t.prototype.destroy.call(this);// destroy each of the GraphicsData objects
for(var e=0;e<this.graphicsData.length;++e)this.graphicsData[e].destroy();this.points.length=0,this.points=null,this.colors.length=0,this.colors=null,this.uvs.length=0,this.uvs=null,this.indices.length=0,this.indices=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null},/**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.IPointData} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */e.prototype.containsPoint=function(t){for(var e=this.graphicsData,i=0;i<e.length;++i){var r=e[i];if(r.fillStyle.visible&&r.shape&&(r.matrix?r.matrix.applyInverse(t,ow):ow.copyFrom(t),r.shape.contains(ow.x,ow.y))){var n=!1;if(r.holes){for(var s=0;s<r.holes.length;s++)if(r.holes[s].shape.contains(ow.x,ow.y)){n=!0;break}}if(!n)return!0}}return!1},/**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     *
     * @param {boolean} [allow32Indices] - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices
     */e.prototype.updateBatches=function(t){if(!this.graphicsData.length){this.batchable=!0;return}if(this.validateBatching()){this.cacheDirty=this.dirty;var e=this.uvs,i=this.graphicsData,r=null,n=null;this.batches.length>0&&(n=(r=this.batches[this.batches.length-1]).style);for(var s=this.shapeIndex;s<i.length;s++){this.shapeIndex++;var o=i[s],a=o.fillStyle,h=o.lineStyle;// build out the shapes points..
ox[o.type].build(o),o.matrix&&this.transformPoints(o.points,o.matrix);for(var l=0;l<2;l++){var u=0===l?a:h;if(u.visible){var c=u.texture.baseTexture,d=this.indices.length,p=this.points.length/2;c.wrapMode=x3.REPEAT,0===l?this.processFill(o):this.processLine(o);var f=this.points.length/2-p;0!==f&&(r&&!this._compareStyles(n,u)&&(r.end(d,p),r=null),r||((r=ob.pop()||new ov).begin(u,d,p),this.batches.push(r),n=u),this.addUvs(this.points,e,u.texture,p,f,u.matrix))}}}var m=this.indices.length,g=this.points.length/2;if(r&&r.end(m,g),0===this.batches.length){// there are no visible styles in GraphicsData
// its possible that someone wants Graphics just for the bounds
this.batchable=!0;return}// prevent allocation when length is same as buffer
if(this.indicesUint16&&this.indices.length===this.indicesUint16.length)this.indicesUint16.set(this.indices);else{var y=g>65535&&t;this.indicesUint16=y?new Uint32Array(this.indices):new Uint16Array(this.indices)}// TODO make this a const..
this.batchable=this.isBatchable(),this.batchable?this.packBatches():this.buildDrawCalls()}},/**
     * Affinity check
     *
     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA
     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB
     */e.prototype._compareStyles=function(t,e){return!!t&&!!e&&t.texture.baseTexture===e.texture.baseTexture&&t.color+t.alpha===e.color+e.alpha&&!!t.native==!!e.native},/**
     * Test geometry for batching process.
     *
     * @protected
     */e.prototype.validateBatching=function(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(var t=0,e=this.graphicsData.length;t<e;t++){var i=this.graphicsData[t],r=i.fillStyle,n=i.lineStyle;if(r&&!r.texture.baseTexture.valid||n&&!n.texture.baseTexture.valid)return!1}return!0},/**
     * Offset the indices so that it works with the batcher.
     *
     * @protected
     */e.prototype.packBatches=function(){this.batchDirty++,this.uvsFloat32=new Float32Array(this.uvs);for(var t=this.batches,e=0,i=t.length;e<i;e++)for(var r=t[e],n=0;n<r.size;n++){var s=r.start+n;this.indicesUint16[s]=this.indicesUint16[s]-r.attribStart}},/**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     *
     * @protected
     */e.prototype.isBatchable=function(){// prevent heavy mesh batching
if(this.points.length>131070)return!1;for(var t=this.batches,i=0;i<t.length;i++)if(t[i].style.native)return!1;return this.points.length<2*e.BATCHABLE_SIZE},/**
     * Converts intermediate batches data to drawCalls.
     *
     * @protected
     */e.prototype.buildDrawCalls=function(){for(var t=++rS._globalBatch,e=0;e<this.drawCalls.length;e++)this.drawCalls[e].texArray.clear(),oE.push(this.drawCalls[e]);this.drawCalls.length=0;var i=this.colors,r=this.textureIds,n=oE.pop();n||((n=new si).texArray=new sr),n.texArray.count=0,n.start=0,n.size=0,n.type=xZ.TRIANGLES;var s=0,o=null,a=0,h=!1,l=xZ.TRIANGLES,u=0;this.drawCalls.push(n);// TODO - this can be simplified
for(var e=0;e<this.batches.length;e++){var c=this.batches[e],d=c.style,p=d.texture.baseTexture;!!d.native!==h&&(l=(h=!!d.native)?xZ.LINES:xZ.TRIANGLES,// force the batch to break!
o=null,s=8,t++),o!==p&&(o=p,p._batchEnabled!==t&&(8===s&&(t++,s=0,n.size>0&&((n=oE.pop())||((n=new si).texArray=new sr),this.drawCalls.push(n)),n.start=u,n.size=0,n.texArray.count=0,n.type=l),// TODO add this to the render part..
// Hack! Because texture has protected `touched`
p.touched=1,p._batchEnabled=t,p._batchLocation=s,p.wrapMode=x3.REPEAT,n.texArray.elements[n.texArray.count++]=p,s++)),n.size+=c.size,u+=c.size,a=p._batchLocation,this.addColors(i,d.color,d.alpha,c.attribSize,c.attribStart),this.addTextureIds(r,a,c.attribSize,c.attribStart)}rS._globalBatch=t,// upload..
// merge for now!
this.packAttributes()},/**
     * Packs attributes to single buffer.
     *
     * @protected
     */e.prototype.packAttributes=function(){for(var t=this.points,e=this.uvs,i=this.colors,r=this.textureIds,n=new ArrayBuffer(12*t.length),s=new Float32Array(n),o=new Uint32Array(n),a=0,h=0;h<t.length/2;h++)s[a++]=t[2*h],s[a++]=t[2*h+1],s[a++]=e[2*h],s[a++]=e[2*h+1],o[a++]=i[h],s[a++]=r[h];this._buffer.update(n),this._indexBuffer.update(this.indicesUint16)},/**
     * Process fill part of Graphics.
     *
     * @param {PIXI.GraphicsData} data
     * @protected
     */e.prototype.processFill=function(t){t.holes.length?(this.processHoles(t.holes),oh.triangulate(t,this)):ox[t.type].triangulate(t,this)},/**
     * Process line part of Graphics.
     *
     * @param {PIXI.GraphicsData} data
     * @protected
     */e.prototype.processLine=function(t){om(t,this);for(var e=0;e<t.holes.length;e++)om(t.holes[e],this)},/**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */e.prototype.processHoles=function(t){for(var e=0;e<t.length;e++){var i=t[e];ox[i.type].build(i),i.matrix&&this.transformPoints(i.points,i.matrix)}},/**
     * Update the local bounds of the object. Expensive to use performance-wise.
     *
     * @protected
     */e.prototype.calculateBounds=function(){var t=this._bounds,e=iX.IDENTITY;this._bounds.clear(),oS.clear();for(var i=0;i<this.graphicsData.length;i++){var r=this.graphicsData[i],n=r.shape,s=r.type,o=r.lineStyle,a=r.matrix||iX.IDENTITY,h=0;if(o&&o.visible){var l=o.alignment;h=o.width,s===bn.POLY?/**
 * Determine if polygon is clockwise or counterclockwise.
 * @see {@link https://stackoverflow.com/questions/1165647}
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {Polygon} polygon
 * @return {boolean}
 */function(t){for(var e=t.points,i=0,r=0;r<e.length-2;r+=2)i+=(e[r+2]-e[r])*(e[r+3]+e[r+1]);return i>0}(n)?h*=1-l:h*=l:h*=Math.max(0,l)}e!==a&&(oS.isEmpty()||(t.addBoundsMatrix(oS,e),oS.clear()),e=a),s===bn.RECT||s===bn.RREC?oS.addFramePad(n.x,n.y,n.x+n.width,n.y+n.height,h,h):s===bn.CIRC?oS.addFramePad(n.x,n.y,n.x,n.y,n.radius+h,n.radius+h):s===bn.ELIP?oS.addFramePad(n.x,n.y,n.x,n.y,n.width+h,n.height+h):// adding directly to the bounds
t.addVerticesMatrix(e,n.points,0,n.points.length,h,h)}oS.isEmpty()||t.addBoundsMatrix(oS,e),t.pad(this.boundsPadding,this.boundsPadding)},/**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */e.prototype.transformPoints=function(t,e){for(var i=0;i<t.length/2;i++){var r=t[2*i],n=t[2*i+1];t[2*i]=e.a*r+e.c*n+e.tx,t[2*i+1]=e.b*r+e.d*n+e.ty}},/**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     * @param {number} offset
     */e.prototype.addColors=function(t,e,i,r,n){void 0===n&&(n=0);var s=is((e>>16)+(65280&e)+((255&e)<<16),i);t.length=Math.max(t.length,n+r);for(var o=0;o<r;o++)t[n+o]=s},/**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     * @param {number} offset
     */e.prototype.addTextureIds=function(t,e,i,r){void 0===r&&(r=0),t.length=Math.max(t.length,r+i);for(var n=0;n<i;n++)t[r+n]=e},/**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */e.prototype.addUvs=function(t,e,i,r,n,s){void 0===s&&(s=null);for(var o=0,a=e.length,h=i.frame;o<n;){var l=t[(r+o)*2],u=t[(r+o)*2+1];if(s){var c=s.a*l+s.c*u+s.tx;u=s.b*l+s.d*u+s.ty,l=c}o++,e.push(l/h.width,u/h.height)}var d=i.baseTexture;(h.width<d.width||h.height<d.height)&&this.adjustUvs(e,i,a,n)},/**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     *
     * @param {number[]} uvs - array
     * @param {PIXI.Texture} texture - region
     * @param {number} start - starting index for uvs
     * @param {number} size - how many points to adjust
     */e.prototype.adjustUvs=function(t,e,i,r){for(var n=e.baseTexture,s=i+2*r,o=e.frame,a=o.width/n.width,h=o.height/n.height,l=o.x/o.width,u=o.y/o.height,c=Math.floor(t[i]+1e-6),d=Math.floor(t[i+1]+1e-6),p=i+2;p<s;p+=2)c=Math.min(c,Math.floor(t[p]+1e-6)),d=Math.min(d,Math.floor(t[p+1]+1e-6));l-=c,u-=d;for(var p=i;p<s;p+=2)t[p]=(t[p]+l)*a,t[p+1]=(t[p+1]+u)*h},/**
     * The maximum number of points to consider an object "batchable",
     * able to be batched by the renderer's batch system.
\    */e.BATCHABLE_SIZE=100,e}(sa),oA=/** @class */function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return(/** The width (thickness) of any lines drawn. */e.width=0,/** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */e.alignment=.5,/** If true the lines will be draw using LINES instead of TRIANGLE_STRIP */e.native=!1,/**
         * Line cap style.
         *
         * @member {PIXI.LINE_CAP}
         * @default PIXI.LINE_CAP.BUTT
         */e.cap=b_.BUTT,/**
         * Line join style.
         *
         * @member {PIXI.LINE_JOIN}
         * @default PIXI.LINE_JOIN.MITER
         */e.join=by.MITER,/** Miter limit. */e.miterLimit=10,e)}return oa(e,t),/**
     * Clones the object
     *
     * @return {PIXI.LineStyle}
     */e.prototype.clone=function(){var t=new e;return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.native=this.native,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t},/**
     * Reset the line style to default.
     */e.prototype.reset=function(){t.prototype.reset.call(this),// Override default line style color
this.color=0,this.alignment=.5,this.width=0,this.native=!1},e}(os),oR=new Float32Array(3),oC={},oP=/** @class */function(t){/**
     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted
     *        will create a new GraphicsGeometry instance.
     */function e(e){void 0===e&&(e=null);var i=t.call(this)||this;return(/**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         *
         * @member {PIXI.Shader}
         */i.shader=null,/** Renderer plugin for batching */i.pluginName="batch",/**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @readonly
         */i.currentPath=null,/**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @member {PIXI.IGraphicsBatchElement[]}
         */i.batches=[],/** Update dirty for limiting calculating tints for batches. */i.batchTint=-1,/** Update dirty for limiting calculating batches.*/i.batchDirty=-1,/** Copy of the object vertex data. */i.vertexData=null,/**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         */i._fillStyle=new os,/**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         */i._lineStyle=new oA,/**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         */i._matrix=null,/**  Current hole mode is enabled. */i._holeMode=!1,/**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         *
         * @member {PIXI.State}
         */i.state=nA.for2d(),i._geometry=e||new oM,i._geometry.refCount++,/**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */i._transformID=-1,// Set default
i.tint=16777215,i.blendMode=xJ.NORMAL,i)}return oa(e,t),Object.defineProperty(e.prototype,"geometry",{/**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         *
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */get:function(){return this._geometry},enumerable:!1,configurable:!0}),/**
     * Creates a new Graphics object with the same values as this one.
     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */e.prototype.clone=function(){return this.finishPoly(),new e(this._geometry)},Object.defineProperty(e.prototype,"blendMode",{get:function(){return this.state.blendMode},/**
         * The blend mode to be applied to the graphic shape. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
         * primitive in the GraphicsGeometry list is rendered sequentially, modes
         * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
         * be applied per-primitive.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL;
         * @see PIXI.BLEND_MODES
         */set:function(t){this.state.blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tint",{/**
         * The tint applied to each graphic shape. This is a hex value. A value of
         * 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */get:function(){return this._tint},set:function(t){this._tint=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"fill",{/**
         * The current fill style.
         *
         * @member {PIXI.FillStyle}
         * @readonly
         */get:function(){return this._fillStyle},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"line",{/**
         * The current line style.
         *
         * @member {PIXI.LineStyle}
         * @readonly
         */get:function(){return this._lineStyle},enumerable:!1,configurable:!0}),e.prototype.lineStyle=function(t,e,i,r,n){return void 0===t&&(t=null),void 0===e&&(e=0),void 0===i&&(i=1),void 0===r&&(r=.5),void 0===n&&(n=!1),"number"==typeof t&&(t={width:t,color:e,alpha:i,alignment:r,native:n}),this.lineTextureStyle(t)},/**
     * Like line style but support texture for line fill.
     *
     * @param {object} [options] - Collection of options for setting line style.
     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.
     *  Default 0xFFFFFF if texture present.
     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture
     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).
     *        WebGL only.
     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style
     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style
     * @param {number}[options.miterLimit=10] - miter limit ratio
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.lineTextureStyle=function(t){// Apply defaults
t=Object.assign({width:0,texture:rH.WHITE,color:t&&t.texture?16777215:0,alpha:1,matrix:null,alignment:.5,native:!1,cap:b_.BUTT,join:by.MITER,miterLimit:10},t),this.currentPath&&this.startPoly();var e=t.width>0&&t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:e},t)):this._lineStyle.reset(),this},/**
     * Start a polygon object internally
     * @protected
     */e.prototype.startPoly=function(){if(this.currentPath){var t=this.currentPath.points,e=this.currentPath.points.length;e>2&&(this.drawShape(this.currentPath),this.currentPath=new iH,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[e-2],t[e-1]))}else this.currentPath=new iH,this.currentPath.closeStroke=!1},/**
     * Finish the polygon object.
     * @protected
     */e.prototype.finishPoly=function(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)},/**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.moveTo=function(t,e){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=e,this},/**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.lineTo=function(t,e){this.currentPath||this.moveTo(0,0);// remove duplicates..
var i=this.currentPath.points,r=i[i.length-2],n=i[i.length-1];return(r!==t||n!==e)&&i.push(t,e),this},/**
     * Initialize the curve
     *
     * @param {number} [x=0]
     * @param {number} [y=0]
     */e.prototype._initCurve=function(t,e){void 0===t&&(t=0),void 0===e&&(e=0),this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[t,e]):this.moveTo(t,e)},/**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.quadraticCurveTo=function(t,e,i,r){this._initCurve();var n=this.currentPath.points;return 0===n.length&&this.moveTo(0,0),o_.curveTo(t,e,i,r,n),this},/**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.bezierCurveTo=function(t,e,i,r,n,s){return this._initCurve(),oy.curveTo(t,e,i,r,n,s,this.currentPath.points),this},/**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the first tangent point of the arc
     * @param {number} y1 - The y-coordinate of the first tangent point of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.arcTo=function(t,e,i,r,n){this._initCurve(t,e);var s=this.currentPath.points,o=og.curveTo(t,e,i,r,n,s);if(o){var a=o.cx,h=o.cy,l=o.radius,u=o.startAngle,c=o.endAngle,d=o.anticlockwise;this.arc(a,h,l,u,c,d)}return this},/**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.arc=function(t,e,i,r,n,s){if(void 0===s&&(s=!1),r===n||(!s&&n<=r?n+=iD:s&&r<=n&&(r+=iD),0==n-r))return this;var o=t+Math.cos(r)*i,a=e+Math.sin(r)*i,h=this._geometry.closePointEps,l=this.currentPath?this.currentPath.points:null;if(l){// TODO: make a better fix.
// We check how far our start is from the last existing point
var u=Math.abs(l[l.length-2]-o),c=Math.abs(l[l.length-1]-a);u<h&&c<h||l.push(o,a)}else this.moveTo(o,a),l=this.currentPath.points;return og.arc(o,a,t,e,i,r,n,s,l),this},/**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.beginFill=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=1),this.beginTextureFill({texture:rH.WHITE,color:t,alpha:e})},/**
     * Begin the texture fill
     *
     * @param {object} [options] - Object object.
     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [options.color=0xffffff] - Background to fill behind texture
     * @param {number} [options.alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.beginTextureFill=function(t){// Apply defaults
t=Object.assign({texture:rH.WHITE,color:16777215,alpha:1,matrix:null},t),this.currentPath&&this.startPoly();var e=t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:e},t)):this._fillStyle.reset(),this},/**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.endFill=function(){return this.finishPoly(),this._fillStyle.reset(),this},/**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawRect=function(t,e,i,r){return this.drawShape(new iU(t,e,i,r))},/**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawRoundedRect=function(t,e,i,r,n){return this.drawShape(new iz(t,e,i,r,n))},/**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawCircle=function(t,e,i){return this.drawShape(new iG(t,e,i))},/**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawEllipse=function(t,e,i,r){return this.drawShape(new ik(t,e,i,r))},/**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawPolygon=function(){for(var t,e=arguments,i=[],r=0;r<arguments.length;r++)i[r]=e[r];var n=!0,s=i[0];s.points?(n=s.closeStroke,t=s.points):t=Array.isArray(i[0])?i[0]:i;var o=new iH(t);return o.closeStroke=n,this.drawShape(o),this},/**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.drawShape=function(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this},/**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */e.prototype.clear=function(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this},/**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */e.prototype.isFastRect=function(){var t=this._geometry.graphicsData;return 1===t.length&&t[0].shape.type===bn.RECT&&!t[0].holes.length&&!(t[0].lineStyle.visible&&t[0].lineStyle.width)},/**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._render=function(t){this.finishPoly();var e=this._geometry,i=t.context.supports.uint32Indices;// batch part..
// batch it!
e.updateBatches(i),e.batchable?(this.batchDirty!==e.batchDirty&&this._populateBatches(),this._renderBatched(t)):(// no batching...
t.batch.flush(),this._renderDirect(t))},/** Populating batches for rendering. */e.prototype._populateBatches=function(){var t=this._geometry,e=this.blendMode,i=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=i,this.vertexData=new Float32Array(t.points);for(var r=0;r<i;r++){var n=t.batches[r],s=n.style.color,o=new Float32Array(this.vertexData.buffer,8*n.attribStart,2*n.attribSize),a=new Float32Array(t.uvsFloat32.buffer,8*n.attribStart,2*n.attribSize),h={vertexData:o,blendMode:e,indices:new Uint16Array(t.indicesUint16.buffer,2*n.start,n.size),uvs:a,_batchRGB:e8(s),_tintRGB:s,_texture:n.style.texture,alpha:n.style.alpha,worldAlpha:1};this.batches[r]=h}},/**
     * Renders the batches using the BathedRenderer plugin
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._renderBatched=function(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(var e=0,i=this.batches.length;e<i;e++){var r=this.batches[e];r.worldAlpha=this.worldAlpha*r.alpha,t.plugins[this.pluginName].render(r)}}},/**
     * Renders the graphics direct
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._renderDirect=function(t){var e=this._resolveDirectShader(t),i=this._geometry,r=this.tint,n=this.worldAlpha,s=e.uniforms,o=i.drawCalls;// lets set the transfomr
s.translationMatrix=this.transform.worldTransform,// and then lets set the tint..
s.tint[0]=(r>>16&255)/255*n,s.tint[1]=(r>>8&255)/255*n,s.tint[2]=(255&r)/255*n,s.tint[3]=n,// the first draw call, we can set the uniforms of the shader directly here.
// this means that we can tack advantage of the sync function of pixi!
// bind and sync uniforms..
// there is a way to optimise this..
t.shader.bind(e),t.geometry.bind(i,e),// set state..
t.state.set(this.state);// then render the rest of them...
for(var a=0,h=o.length;a<h;a++)this._renderDrawCallDirect(t,i.drawCalls[a])},/**
     * Renders specific DrawCall
     *
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BatchDrawCall} drawCall
     */e.prototype._renderDrawCallDirect=function(t,e){for(var i=e.texArray,r=e.type,n=e.size,s=e.start,o=i.count,a=0;a<o;a++)t.texture.bind(i.elements[a],a);t.geometry.draw(r,n,s)},/**
     * Resolves shader for direct rendering
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._resolveDirectShader=function(t){var e=this.shader,i=this.pluginName;if(!e){// if there is no shader here, we can use the default shader.
// and that only gets created if we actually need it..
// but may be more than one plugins for graphics
if(!oC[i]){for(var r=t.plugins.batch.MAX_TEXTURES,n=new Int32Array(r),s=0;s<r;s++)n[s]=s;var o={tint:new Float32Array([1,1,1,1]),translationMatrix:new iX,default:r2.from({uSamplers:n},!0)},a=t.plugins[i]._shader.program;oC[i]=new nM(a,o)}e=oC[i]}return e},/** Retrieves the bounds of the graphic shape as a rectangle object. */e.prototype._calculateBounds=function(){this.finishPoly();var t=this._geometry;// skipping when graphics is empty, like a container
if(t.graphicsData.length){var e=t.bounds,i=e.minX,r=e.minY,n=e.maxX,s=e.maxY;this._bounds.addFrame(this.transform,i,r,n,s)}},/**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.IPointData} point - the point to test
     * @return {boolean} the result of the test
     */e.prototype.containsPoint=function(t){return this.worldTransform.applyInverse(t,e._TEMP_POINT),this._geometry.containsPoint(e._TEMP_POINT)},/** Recalculate the tint by applying tint to batches using Graphics tint. */e.prototype.calculateTints=function(){if(this.batchTint!==this.tint){this.batchTint=this.tint;for(var t=e8(this.tint,oR),e=0;e<this.batches.length;e++){var i=this.batches[e],r=i._batchRGB,n=(t[0]*r[0]*255<<16)+(t[1]*r[1]*255<<8)+(0|t[2]*r[2]*255);i._tintRGB=(n>>16)+(65280&n)+((255&n)<<16)}}},/**
     * If there's a transform update or a change to the shape of the
     * geometry, recalculate the vertices.
     */e.prototype.calculateVertices=function(){var t=this.transform._worldID;if(this._transformID!==t){this._transformID=t;for(var e=this.transform.worldTransform,i=e.a,r=e.b,n=e.c,s=e.d,o=e.tx,a=e.ty,h=this._geometry.points,l=this.vertexData,u=0,c=0;c<h.length;c+=2){var d=h[c],p=h[c+1];l[u++]=i*d+n*p+o,l[u++]=s*p+r*d+a}}},/**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */e.prototype.closePath=function(){var t=this.currentPath;return t&&(// we don't need to add extra point in the end because buildLine will take care of that
t.closeStroke=!0,// ensure that the polygon is completed, and is available for hit detection
// (even if the graphics is not rendered yet)
this.finishPoly()),this},/**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */e.prototype.setMatrix=function(t){return this._matrix=t,this},/**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */e.prototype.beginHole=function(){return this.finishPoly(),this._holeMode=!0,this},/**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */e.prototype.endHole=function(){return this.finishPoly(),this._holeMode=!1,this},/**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */e.prototype.destroy=function(e){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,t.prototype.destroy.call(this,e)},/**
     * Temporary point to use for containsPoint
     *
     * @static
     * @private
     * @member {PIXI.Point}
     */e._TEMP_POINT=new ij,e}(i8),oI={buildPoly:oh,buildCircle:ol,buildRectangle:ou,buildRoundedRectangle:od,buildLine:om,ArcUtils:og,BezierUtils:oy,QuadraticUtils:o_,BatchPart:ov,FILL_COMMANDS:ox,BATCH_POOL:ob,DRAW_CALL_POOL:oE},oO={};tC(oO,"TEXT_GRADIENT",()=>bx),tC(oO,"TextStyle",()=>oH),tC(oO,"TextMetrics",()=>oX),tC(oO,"Text",()=>oq);/*!
 * @pixi/text - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var oL={};tC(oL,"Sprite",()=>oB);/*!
 * @pixi/sprite - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var oN=function(t,e){return(oN=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},oD=new ij,oF=new Uint16Array([0,1,2,0,2,3]),oB=/** @class */function(t){/**
     * @param {PIXI.Texture} [texture] - The texture for this sprite.
     */function e(e){var i=t.call(this)||this;return(/**
         * The anchor point defines the normalized coordinates
         * in the texture that map to the position of this
         * sprite.
         *
         * By default, this is `(0,0)` (or `texture.defaultAnchor`
         * if you have modified that), which means the position
         * `(x,y)` of this `Sprite` will be the top-left corner.
         *
         * Note: Updating `texture.defaultAnchor` after
         * constructing a `Sprite` does _not_ update its anchor.
         *
         * {@link https://docs.cocos2d-x.org/cocos2d-x/en/sprites/manipulation.html}
         *
         * @default `texture.defaultAnchor`
         * @member {PIXI.ObservablePoint}
         * @private
         */i._anchor=new iV(i._onAnchorUpdate,i,e?e.defaultAnchor.x:0,e?e.defaultAnchor.y:0),/**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */i._texture=null,/**
         * The width of the sprite (this is initially set by the texture)
         *
         * @protected
         * @member {number}
         */i._width=0,/**
         * The height of the sprite (this is initially set by the texture)
         *
         * @protected
         * @member {number}
         */i._height=0,/**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */i._tint=null,/**
         * The tint applied to the sprite. This is a RGB value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 16777215
         */i._tintRGB=null,i.tint=16777215,/**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */i.blendMode=xJ.NORMAL,/**
         * Cached tint value so we can tell when the tint is changed.
         * Value is used for 2d CanvasRenderer.
         *
         * @protected
         * @member {number}
         * @default 0xFFFFFF
         */i._cachedTint=16777215,/**
         * this is used to store the uvs data of the sprite, assigned at the same time
         * as the vertexData in calculateVertices()
         *
         * @private
         * @member {Float32Array}
         */i.uvs=null,// call texture setter
i.texture=e||rH.EMPTY,/**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */i.vertexData=new Float32Array(8),/**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */i.vertexTrimmedData=null,i._transformID=-1,i._textureID=-1,i._transformTrimmedID=-1,i._textureTrimmedID=-1,// Batchable stuff..
// TODO could make this a mixin?
i.indices=oF,/**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'batch'
         */i.pluginName="batch",/**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */i.isSprite=!0,/**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */i._roundPixels=ec.ROUND_PIXELS,i)}return!function(t,e){function i(){this.constructor=t}oN(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * When the texture is updated, this event will fire to update the scale and frame
     *
     * @protected
     */e.prototype._onTextureUpdate=function(){this._textureID=-1,this._textureTrimmedID=-1,this._cachedTint=16777215,this._width&&(this.scale.x=ig(this.scale.x)*this._width/this._texture.orig.width),this._height&&(this.scale.y=ig(this.scale.y)*this._height/this._texture.orig.height)},/**
     * Called when the anchor position updates.
     *
     * @private
     */e.prototype._onAnchorUpdate=function(){this._transformID=-1,this._transformTrimmedID=-1},/**
     * calculates worldTransform * vertices, store it in vertexData
     */e.prototype.calculateVertices=function(){var t=this._texture;if(this._transformID!==this.transform._worldID||this._textureID!==t._updateID){this._textureID!==t._updateID&&(this.uvs=this._texture._uvs.uvsFloat32),this._transformID=this.transform._worldID,this._textureID=t._updateID;// set the vertex data
var e=this.transform.worldTransform,i=e.a,r=e.b,n=e.c,s=e.d,o=e.tx,a=e.ty,h=this.vertexData,l=t.trim,u=t.orig,c=this._anchor,d=0,p=0,f=0,m=0;if(l?(d=// if the sprite is trimmed and is not a tilingsprite then we need to add the extra
// space before transforming the sprite coords.
(p=l.x-c._x*u.width)+l.width,f=(m=l.y-c._y*u.height)+l.height):(d=(p=-c._x*u.width)+u.width,f=(m=-c._y*u.height)+u.height),// xy
h[0]=i*p+n*m+o,h[1]=s*m+r*p+a,// xy
h[2]=i*d+n*m+o,h[3]=s*m+r*d+a,// xy
h[4]=i*d+n*f+o,h[5]=s*f+r*d+a,// xy
h[6]=i*p+n*f+o,h[7]=s*f+r*p+a,this._roundPixels)for(var g=ec.RESOLUTION,y=0;y<h.length;++y)h[y]=Math.round((h[y]*g|0)/g)}},/**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */e.prototype.calculateTrimmedVertices=function(){if(this.vertexTrimmedData){if(this._transformTrimmedID===this.transform._worldID&&this._textureTrimmedID===this._texture._updateID)return}else this.vertexTrimmedData=new Float32Array(8);this._transformTrimmedID=this.transform._worldID,this._textureTrimmedID=this._texture._updateID;// lets do some special trim code!
var t=this._texture,e=this.vertexTrimmedData,i=t.orig,r=this._anchor,n=this.transform.worldTransform,s=n.a,o=n.b,a=n.c,h=n.d,l=n.tx,u=n.ty,c=-r._x*i.width,d=c+i.width,p=-r._y*i.height,f=p+i.height;// xy
e[0]=s*c+a*p+l,e[1]=h*p+o*c+u,// xy
e[2]=s*d+a*p+l,e[3]=h*p+o*d+u,// xy
e[4]=s*d+a*f+l,e[5]=h*f+o*d+u,// xy
e[6]=s*c+a*f+l,e[7]=h*f+o*c+u},/**
    *
    * Renders the object using the WebGL renderer
    *
    * @protected
    * @param {PIXI.Renderer} renderer - The webgl renderer to use.
    */e.prototype._render=function(t){this.calculateVertices(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this)},/**
     * Updates the bounds of the sprite.
     *
     * @protected
     */e.prototype._calculateBounds=function(){var t=this._texture.trim,e=this._texture.orig;// First lets check to see if the current texture has a trim..
t&&(t.width!==e.width||t.height!==e.height)?(// lets calculate a special trimmed bounds...
this.calculateTrimmedVertices(),this._bounds.addQuad(this.vertexTrimmedData)):(// no trim! lets use the usual calculations..
this.calculateVertices(),this._bounds.addQuad(this.vertexData))},/**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */e.prototype.getLocalBounds=function(e){return(// we can do a fast local bounds if the sprite has no children!
0===this.children.length?(this._bounds.minX=-(this._texture.orig.width*this._anchor._x),this._bounds.minY=-(this._texture.orig.height*this._anchor._y),this._bounds.maxX=this._texture.orig.width*(1-this._anchor._x),this._bounds.maxY=this._texture.orig.height*(1-this._anchor._y),e||(this._localBoundsRect||(this._localBoundsRect=new iU),e=this._localBoundsRect),this._bounds.getRectangle(e)):t.prototype.getLocalBounds.call(this,e))},/**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.IPointData} point - the point to test
     * @return {boolean} the result of the test
     */e.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,oD);var e=this._texture.orig.width,i=this._texture.orig.height,r=-e*this.anchor.x,n=0;return oD.x>=r&&oD.x<r+e&&(n=-i*this.anchor.y,oD.y>=n&&oD.y<n+i)},/**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */e.prototype.destroy=function(e){if(t.prototype.destroy.call(this,e),this._texture.off("update",this._onTextureUpdate,this),this._anchor=null,"boolean"==typeof e?e:e&&e.texture){var i="boolean"==typeof e?e:e&&e.baseTexture;this._texture.destroy(!!i)}this._texture=null},// some helper functions..
/**
     * Helper function that creates a new sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Sprite} The newly created sprite
     */e.from=function(t,i){var r=t instanceof rH?t:rH.from(t,i);return new e(r)},Object.defineProperty(e.prototype,"roundPixels",{get:function(){return this._roundPixels},/**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
         *
         * @member {boolean}
         * @default false
         */set:function(t){this._roundPixels!==t&&(this._transformID=-1),this._roundPixels=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"width",{/**
         * The width of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return Math.abs(this.scale.x)*this._texture.orig.width},set:function(t){var e=ig(this.scale.x)||1;this.scale.x=e*t/this._texture.orig.width,this._width=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return Math.abs(this.scale.y)*this._texture.orig.height},set:function(t){var e=ig(this.scale.y)||1;this.scale.y=e*t/this._texture.orig.height,this._height=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"anchor",{/**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         *
         * @member {PIXI.ObservablePoint}
         */get:function(){return this._anchor},set:function(t){this._anchor.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tint",{/**
         * The tint applied to the sprite. This is a hex value.
         * A value of 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */get:function(){return this._tint},set:function(t){this._tint=t,this._tintRGB=(t>>16)+(65280&t)+((255&t)<<16)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"texture",{/**
         * The texture that the sprite is using
         *
         * @member {PIXI.Texture}
         */get:function(){return this._texture},set:function(t){this._texture!==t&&(this._texture&&this._texture.off("update",this._onTextureUpdate,this),this._texture=t||rH.EMPTY,this._cachedTint=16777215,this._textureID=-1,this._textureTrimmedID=-1,t&&(t.baseTexture.valid?this._onTextureUpdate():t.once("update",this._onTextureUpdate,this)))},enumerable:!1,configurable:!0}),e}(i8),oU=function(t,e){return(oU=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};(vb=bx||(bx={}))[vb.LINEAR_VERTICAL=0]="LINEAR_VERTICAL",vb[vb.LINEAR_HORIZONTAL=1]="LINEAR_HORIZONTAL";// disabling eslint for now, going to rewrite this in v5
var oG={align:"left",breakWords:!1,dropShadow:!1,dropShadowAlpha:1,dropShadowAngle:Math.PI/6,dropShadowBlur:0,dropShadowColor:"black",dropShadowDistance:5,fill:"black",fillGradientType:bx.LINEAR_VERTICAL,fillGradientStops:[],fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",letterSpacing:0,lineHeight:0,lineJoin:"miter",miterLimit:10,padding:0,stroke:"black",strokeThickness:0,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100,leading:0},ok=["serif","sans-serif","monospace","cursive","fantasy","system-ui"],oH=/** @class */function(){/**
     * @param {object} [style] - The style parameters
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
     *  does not affect single line text
     * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
     *  needs wordWrap to be set to true
     * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
     * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
     * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
     * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
     * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
     * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
     *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
     *  eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
     *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
     * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
     * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     * @param {string|string[]} [style.fontFamily='Arial'] - The font family
     * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
     *  equivalents are '26px','20pt','160%' or '1.6em')
     * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
     * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
     * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
     *  '200', '300', '400', '500', '600', '700', '800' or '900')
     * @param {number} [style.leading=0] - The space between lines
     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
     * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
     * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Possible values "miter" (creates a sharp corner), "round" (creates a round corner) or "bevel"
     *      (creates a squared corner).
     * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
     *     happening by adding padding to all sides of the text.
     * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
     *  e.g 'blue', '#FCFF00'
     * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
     *  Default is 0 (no stroke)
     * @param {boolean} [style.trim=false] - Trim transparent borders
     * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
     * @param {string} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved "normal"
     *      (collapse, collapse), "pre" (preserve, preserve) | "pre-line" (preserve, collapse). It needs wordWrap to be set to true
     * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
     * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
     */function t(t){this.styleID=0,this.reset(),oV(this,t,t)}return(/**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */t.prototype.clone=function(){var e={};return oV(e,this,oG),new t(e)},/**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */t.prototype.reset=function(){oV(this,oG,oG)},Object.defineProperty(t.prototype,"align",{/**
         * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
         *
         * @member {string}
         */get:function(){return this._align},set:function(t){this._align!==t&&(this._align=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"breakWords",{/**
         * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
         *
         * @member {boolean}
         */get:function(){return this._breakWords},set:function(t){this._breakWords!==t&&(this._breakWords=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadow",{/**
         * Set a drop shadow for the text
         *
         * @member {boolean}
         */get:function(){return this._dropShadow},set:function(t){this._dropShadow!==t&&(this._dropShadow=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadowAlpha",{/**
         * Set alpha for the drop shadow
         *
         * @member {number}
         */get:function(){return this._dropShadowAlpha},set:function(t){this._dropShadowAlpha!==t&&(this._dropShadowAlpha=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadowAngle",{/**
         * Set a angle of the drop shadow
         *
         * @member {number}
         */get:function(){return this._dropShadowAngle},set:function(t){this._dropShadowAngle!==t&&(this._dropShadowAngle=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadowBlur",{/**
         * Set a shadow blur radius
         *
         * @member {number}
         */get:function(){return this._dropShadowBlur},set:function(t){this._dropShadowBlur!==t&&(this._dropShadowBlur=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadowColor",{/**
         * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
         *
         * @member {string|number}
         */get:function(){return this._dropShadowColor},set:function(t){var e=oj(t);this._dropShadowColor!==e&&(this._dropShadowColor=e,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dropShadowDistance",{/**
         * Set a distance of the drop shadow
         *
         * @member {number}
         */get:function(){return this._dropShadowDistance},set:function(t){this._dropShadowDistance!==t&&(this._dropShadowDistance=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fill",{/**
         * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
         * Can be an array to create a gradient eg ['#000000','#FFFFFF']
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
         *
         * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */get:function(){return this._fill},set:function(t){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
//       the setter converts to string. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
// TODO: Not sure if getColor works properly with CanvasGradient and/or CanvasPattern, can't pass in
//       without casting here.
var e=oj(t);this._fill!==e&&(this._fill=e,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fillGradientType",{/**
         * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
         * See {@link PIXI.TEXT_GRADIENT}
         *
         * @member {number}
         */get:function(){return this._fillGradientType},set:function(t){this._fillGradientType!==t&&(this._fillGradientType=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fillGradientStops",{/**
         * If fill is an array of colours to create a gradient, this array can set the stop points
         * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
         *
         * @member {number[]}
         */get:function(){return this._fillGradientStops},set:function(t){!/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 * @private
 * @param {Array} array1 - First array to compare
 * @param {Array} array2 - Second array to compare
 * @return {boolean} Do the arrays contain the same values in the same order
 */function(t,e){if(!Array.isArray(t)||!Array.isArray(e)||t.length!==e.length)return!1;for(var i=0;i<t.length;++i)if(t[i]!==e[i])return!1;return!0}(this._fillGradientStops,t)&&(this._fillGradientStops=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fontFamily",{/**
         * The font family
         *
         * @member {string|string[]}
         */get:function(){return this._fontFamily},set:function(t){this.fontFamily!==t&&(this._fontFamily=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fontSize",{/**
         * The font size
         * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
         *
         * @member {number|string}
         */get:function(){return this._fontSize},set:function(t){this._fontSize!==t&&(this._fontSize=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fontStyle",{/**
         * The font style
         * ('normal', 'italic' or 'oblique')
         *
         * @member {string}
         */get:function(){return this._fontStyle},set:function(t){this._fontStyle!==t&&(this._fontStyle=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fontVariant",{/**
         * The font variant
         * ('normal' or 'small-caps')
         *
         * @member {string}
         */get:function(){return this._fontVariant},set:function(t){this._fontVariant!==t&&(this._fontVariant=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"fontWeight",{/**
         * The font weight
         * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
         *
         * @member {string}
         */get:function(){return this._fontWeight},set:function(t){this._fontWeight!==t&&(this._fontWeight=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"letterSpacing",{/**
         * The amount of spacing between letters, default is 0
         *
         * @member {number}
         */get:function(){return this._letterSpacing},set:function(t){this._letterSpacing!==t&&(this._letterSpacing=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"lineHeight",{/**
         * The line height, a number that represents the vertical space that a letter uses
         *
         * @member {number}
         */get:function(){return this._lineHeight},set:function(t){this._lineHeight!==t&&(this._lineHeight=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"leading",{/**
         * The space between lines
         *
         * @member {number}
         */get:function(){return this._leading},set:function(t){this._leading!==t&&(this._leading=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"lineJoin",{/**
         * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
         * Default is 'miter' (creates a sharp corner).
         *
         * @member {string}
         */get:function(){return this._lineJoin},set:function(t){this._lineJoin!==t&&(this._lineJoin=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"miterLimit",{/**
         * The miter limit to use when using the 'miter' lineJoin mode
         * This can reduce or increase the spikiness of rendered text.
         *
         * @member {number}
         */get:function(){return this._miterLimit},set:function(t){this._miterLimit!==t&&(this._miterLimit=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"padding",{/**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         *
         * @member {number}
         */get:function(){return this._padding},set:function(t){this._padding!==t&&(this._padding=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"stroke",{/**
         * A canvas fillstyle that will be used on the text stroke
         * e.g 'blue', '#FCFF00'
         *
         * @member {string|number}
         */get:function(){return this._stroke},set:function(t){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
//       the setter converts to string. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
var e=oj(t);this._stroke!==e&&(this._stroke=e,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"strokeThickness",{/**
         * A number that represents the thickness of the stroke.
         * Default is 0 (no stroke)
         *
         * @member {number}
         */get:function(){return this._strokeThickness},set:function(t){this._strokeThickness!==t&&(this._strokeThickness=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"textBaseline",{/**
         * The baseline of the text that is rendered.
         *
         * @member {string}
         */get:function(){return this._textBaseline},set:function(t){this._textBaseline!==t&&(this._textBaseline=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"trim",{/**
         * Trim transparent borders
         *
         * @member {boolean}
         */get:function(){return this._trim},set:function(t){this._trim!==t&&(this._trim=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"whiteSpace",{/**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         *
         * @member {string}
         */get:function(){return this._whiteSpace},set:function(t){this._whiteSpace!==t&&(this._whiteSpace=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"wordWrap",{/**
         * Indicates if word wrap should be used
         *
         * @member {boolean}
         */get:function(){return this._wordWrap},set:function(t){this._wordWrap!==t&&(this._wordWrap=t,this.styleID++)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"wordWrapWidth",{/**
         * The width at which text will wrap, it needs wordWrap to be set to true
         *
         * @member {number}
         */get:function(){return this._wordWrapWidth},set:function(t){this._wordWrapWidth!==t&&(this._wordWrapWidth=t,this.styleID++)},enumerable:!1,configurable:!0}),/**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */t.prototype.toFontString=function(){// build canvas api font setting from individual components. Convert a numeric this.fontSize to px
var t="number"==typeof this.fontSize?this.fontSize+"px":this.fontSize,e=this.fontFamily;Array.isArray(this.fontFamily)||(e=this.fontFamily.split(","));for(var i=e.length-1;i>=0;i--){// Trim any extra white-space
var r=e[i].trim();!/([\"\'])[^\'\"]+\1/.test(r)&&0>ok.indexOf(r)&&(r='"'+r+'"'),e[i]=r}return this.fontStyle+" "+this.fontVariant+" "+this.fontWeight+" "+t+" "+e.join(",")},t)}();/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * @private
 * @param {string|number} color
 * @return {string} The color as a string.
 */function oz(t){return"number"==typeof t?e7(t):("string"==typeof t&&0===t.indexOf("0x")&&(t=t.replace("0x","#")),t)}function oj(t){if(!Array.isArray(t))return oz(t);for(var e=0;e<t.length;++e)t[e]=oz(t[e]);return t}/**
 * Utility function to ensure that object properties are copied by value, and not by reference
 * @private
 * @param {Object} target - Target object to copy properties into
 * @param {Object} source - Source object for the properties to copy
 * @param {string} propertyObj - Object containing properties names we want to loop over
 */function oV(t,e,i){for(var r in i)Array.isArray(e[r])?t[r]=e[r].slice():t[r]=e[r]}/**
 * The TextMetrics object represents the measurement of a block of text with a specified style.
 *
 * ```js
 * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})
 * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)
 * ```
 *
 * @class
 * @memberof PIXI
 */var oX=/** @class */function(){/**
     * @param {string} text - the text that was measured
     * @param {PIXI.TextStyle} style - the style that was measured
     * @param {number} width - the measured width of the text
     * @param {number} height - the measured height of the text
     * @param {string[]} lines - an array of the lines of text broken by new lines and wrapping if specified in style
     * @param {number[]} lineWidths - an array of the line widths for each line matched to `lines`
     * @param {number} lineHeight - the measured line height for this style
     * @param {number} maxLineWidth - the maximum line width for all measured lines
     * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont
     */function t(t,e,i,r,n,s,o,a,h){/**
         * The text that was measured
         *
         * @member {string}
         */this.text=t,/**
         * The style that was measured
         *
         * @member {PIXI.TextStyle}
         */this.style=e,/**
         * The measured width of the text
         *
         * @member {number}
         */this.width=i,/**
         * The measured height of the text
         *
         * @member {number}
         */this.height=r,/**
         * An array of lines of the text broken by new lines and wrapping is specified in style
         *
         * @member {string[]}
         */this.lines=n,/**
         * An array of the line widths for each line matched to `lines`
         *
         * @member {number[]}
         */this.lineWidths=s,/**
         * The measured line height for this style
         *
         * @member {number}
         */this.lineHeight=o,/**
         * The maximum line width for all measured lines
         *
         * @member {number}
         */this.maxLineWidth=a,/**
         * The font properties object from TextMetrics.measureFont
         *
         * @member {PIXI.IFontMetrics}
         */this.fontProperties=h}return(/**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */t.measureText=function(e,i,r,n){void 0===n&&(n=t._canvas),r=null==r?i.wordWrap:r;var s=i.toFontString(),o=t.measureFont(s);0===o.fontSize&&(o.fontSize=i.fontSize,o.ascent=i.fontSize);var a=n.getContext("2d");a.font=s;for(var h=(r?t.wordWrap(e,i,n):e).split(/(?:\r\n|\r|\n)/),l=Array(h.length),u=0,c=0;c<h.length;c++){var d=a.measureText(h[c]).width+(h[c].length-1)*i.letterSpacing;l[c]=d,u=Math.max(u,d)}var p=u+i.strokeThickness;i.dropShadow&&(p+=i.dropShadowDistance);var f=i.lineHeight||o.fontSize+i.strokeThickness,m=Math.max(f,o.fontSize+i.strokeThickness)+(h.length-1)*(f+i.leading);return i.dropShadow&&(m+=i.dropShadowDistance),new t(e,i,p,m,h,l,f+i.leading,u,o)},/**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */t.wordWrap=function(e,i,r){void 0===r&&(r=t._canvas);for(var n=r.getContext("2d"),s=0,o="",a="",h=Object.create(null),l=i.letterSpacing,u=i.whiteSpace,c=t.collapseSpaces(u),d=t.collapseNewlines(u),p=!c,f=i.wordWrapWidth+l,m=t.tokenize(e),g=0;g<m.length;g++){// get the word, space or newlineChar
var y=m[g];// if word is a new line
if(t.isNewline(y)){// keep the new line
if(!d){a+=t.addLine(o),p=!c,o="",s=0;continue}// if we should collapse new lines
// we simply convert it into a space
y=" "}// if we should collapse repeated whitespaces
if(c){// check both this and the last tokens for spaces
var _=t.isBreakingSpace(y),v=t.isBreakingSpace(o[o.length-1]);if(_&&v)continue}// get word width from cache if possible
var x=t.getFromCache(y,l,h,n);// word is longer than desired bounds
if(x>f){// break large word over multiple lines
if(""!==o&&(// start newlines for overflow words
a+=t.addLine(o),o="",s=0),t.canBreakWords(y,i.breakWords))// loop the characters
for(var b=t.wordWrapSplit(y),E=0;E<b.length;E++){// we are not at the end of the token
for(var T=b[E],w=1;b[E+w];){var S=b[E+w],M=T[T.length-1];// should not split chars
if(t.canBreakChars(M,S,y,E,i.breakWords))break;T+=S,w++}E+=T.length-1;var A=t.getFromCache(T,l,h,n);A+s>f&&(a+=t.addLine(o),p=!1,o="",s=0),o+=T,s+=A}else{o.length>0&&(a+=t.addLine(o),o="",s=0);var R=g===m.length-1;// give it its own line if it's not the end
a+=t.addLine(y,!R),p=!1,o="",s=0}}else x+s>f&&(// if its a space we don't want it
p=!1,// add a new line
a+=t.addLine(o),// start a new line
o="",s=0),(o.length>0||!t.isBreakingSpace(y)||p)&&(// add the word to the current line
o+=y,// update width counter
s+=x)}return a+t.addLine(o,!1)},/**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line        - The line of text to add
     * @param  {boolean}  newLine     - Add new line character to end
     * @return {string}  A formatted line
     */t.addLine=function(e,i){return void 0===i&&(i=!0),e=t.trimRight(e),e=i?e+"\n":e},/**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                    key            - The key
     * @param  {number}                    letterSpacing  - The letter spacing
     * @param  {object}                    cache          - The cache
     * @param  {CanvasRenderingContext2D}  context        - The canvas context
     * @return {number}                    The from cache.
     */t.getFromCache=function(t,e,i,r){var n=i[t];if("number"!=typeof n){var s=t.length*e;n=r.measureText(t).width+s,i[t]=n}return n},/**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace - The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */t.collapseSpaces=function(t){return"normal"===t||"pre-line"===t},/**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace - The white space
     * @return {boolean}  should collapse
     */t.collapseNewlines=function(t){return"normal"===t},/**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text - The text
     * @return {string}  trimmed string
     */t.trimRight=function(e){if("string"!=typeof e)return"";for(var i=e.length-1;i>=0;i--){var r=e[i];if(!t.isBreakingSpace(r))break;e=e.slice(0,-1)}return e},/**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char - The character
     * @return {boolean}  True if newline, False otherwise.
     */t.isNewline=function(e){return"string"==typeof e&&t._newlines.indexOf(e.charCodeAt(0))>=0},/**
     * Determines if char is a breaking whitespace.
     *
     * It allows one to determine whether char should be a breaking whitespace
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @param  {string}  char     - The character
     * @param  {string}  [nextChar] - The next character
     * @return {boolean}  True if whitespace, False otherwise.
     */t.isBreakingSpace=function(e,i){return"string"==typeof e&&t._breakingSpaces.indexOf(e.charCodeAt(0))>=0},/**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text - The text
     * @return {string[]}  A tokenized array
     */t.tokenize=function(e){var i=[],r="";if("string"!=typeof e)return i;for(var n=0;n<e.length;n++){var s=e[n],o=e[n+1];if(t.isBreakingSpace(s,o)||t.isNewline(s)){""!==r&&(i.push(r),r=""),i.push(s);continue}r+=s}return""!==r&&i.push(r),i},/**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @param  {string}  token       - The token
     * @param  {boolean}  breakWords - The style attr break words
     * @return {boolean} whether to break word or not
     */t.canBreakWords=function(t,e){return e},/**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @param  {string}  char        - The character
     * @param  {string}  nextChar    - The next character
     * @param  {string}  token       - The token/word the characters are from
     * @param  {number}  index       - The index in the token of the char
     * @param  {boolean}  breakWords - The style attr break words
     * @return {boolean} whether to break word or not
     */t.canBreakChars=function(t,e,i,r,n){return!0},/**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It is called when a token (usually a word) has to be split into separate pieces
     * in order to determine the point to break a word.
     * It must return an array of characters.
     *
     * @example
     * // Correctly splits emojis, eg "" will result in two element array, each with one emoji.
     * TextMetrics.wordWrapSplit = (token) => [...token];
     *
     * @param  {string}  token - The token to split
     * @return {string[]} The characters of the token
     */t.wordWrapSplit=function(t){return t.split("")},/**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.IFontMetrics} Font properties object
     */t.measureFont=function(e){// as this method is used for preparing assets, don't recalculate things if we don't need to
if(t._fonts[e])return t._fonts[e];var i={ascent:0,descent:0,fontSize:0},r=t._canvas,n=t._context;n.font=e;var s=t.METRICS_STRING+t.BASELINE_SYMBOL,o=Math.ceil(n.measureText(s).width),a=Math.ceil(n.measureText(t.BASELINE_SYMBOL).width),h=Math.ceil(t.HEIGHT_MULTIPLIER*a);a=a*t.BASELINE_MULTIPLIER|0,r.width=o,r.height=h,n.fillStyle="#f00",n.fillRect(0,0,o,h),n.font=e,n.textBaseline="alphabetic",n.fillStyle="#000",n.fillText(s,0,a);var l=n.getImageData(0,0,o,h).data,u=l.length,c=4*o,d=0,p=0,f=!1;// ascent. scan from top to bottom until we find a non red pixel
for(d=0;d<a;++d){for(var m=0;m<c;m+=4)if(255!==l[p+m]){f=!0;break}if(f)break;p+=c}// descent. scan from bottom to top until we find a non red pixel
for(i.ascent=a-d,p=u-c,f=!1,d=h;d>a;--d){for(var m=0;m<c;m+=4)if(255!==l[p+m]){f=!0;break}if(f)break;p-=c}return i.descent=d-a,i.fontSize=i.ascent+i.descent,t._fonts[e]=i,i},/**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */t.clearMetrics=function(e){void 0===e&&(e=""),e?delete t._fonts[e]:t._fonts={}},t)}(),oW=function(){try{// OffscreenCanvas2D measureText can be up to 40% faster.
var t=new OffscreenCanvas(0,0),e=t.getContext("2d");if(e&&e.measureText)return t;return document.createElement("canvas")}catch(t){return document.createElement("canvas")}}();oW.width=oW.height=10,/**
 * Cached canvas element for measuring text
 *
 * @memberof PIXI.TextMetrics
 * @type {HTMLCanvasElement}
 * @private
 */oX._canvas=oW,/**
 * Cache for context to use.
 *
 * @memberof PIXI.TextMetrics
 * @type {CanvasRenderingContext2D}
 * @private
 */oX._context=oW.getContext("2d"),/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 *
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */oX._fonts={},/**
 * String used for calculate font metrics.
 * These characters are all tall to help calculate the height required for text.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |q
 */oX.METRICS_STRING="|\xc9q\xc5",/**
 * Baseline symbol for calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */oX.BASELINE_SYMBOL="M",/**
 * Baseline multiplier for calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */oX.BASELINE_MULTIPLIER=1.4,/**
 * Height multiplier for setting height of canvas to calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name HEIGHT_MULTIPLIER
 * @type {number}
 * @default 2.00
 */oX.HEIGHT_MULTIPLIER=2,/**
 * Cache of new line chars.
 *
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */oX._newlines=[10,13],/**
 * Cache of breaking spaces.
 *
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */oX._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];/**
 * A number, or a string containing a number.
 *
 * @memberof PIXI
 * @typedef {object} IFontMetrics
 * @property {number} ascent - Font ascent
 * @property {number} descent - Font descent
 * @property {number} fontSize - Font size
 */var oY={texture:!0,children:!1,baseTexture:!0},oq=/** @class */function(t){/**
     * @param {string} text - The string that you would like the text to display
     * @param {object|PIXI.TextStyle} [style] - The style parameters
     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text
     */function e(e,i,r){var n=this,s=!1;r||(r=document.createElement("canvas"),s=!0),r.width=3,r.height=3;var o=rH.from(r);return o.orig=new iU,o.trim=new iU,/**
         * Keep track if this Text object created it's own canvas
         * element (`true`) or uses the constructor argument (`false`).
         * Used to workaround a GC issues with Safari < 13 when
         * destroying Text. See `destroy` for more info.
         *
         * @member {boolean}
         * @private
         */(n=t.call(this,o)||this)._ownCanvas=s,/**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */n.canvas=r,/**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */n.context=n.canvas.getContext("2d"),/**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */n._resolution=ec.RESOLUTION,n._autoResolution=!0,/**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */n._text=null,/**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */n._style=null,/**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */n._styleListener=null,/**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */n._font="",n.text=e,n.style=i,n.localStyleID=-1,n}return!function(t,e){function i(){this.constructor=t}oU(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Renders text to its canvas, and updates its texture.
     * By default this is used internally to ensure the texture is correct before rendering,
     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
     * and then shared across multiple Sprites.
     *
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */e.prototype.updateText=function(t){var i,r,n=this._style;if(this.localStyleID!==n.styleID&&(this.dirty=!0,this.localStyleID=n.styleID),this.dirty||!t){this._font=this._style.toFontString();var s=this.context,o=oX.measureText(this._text||" ",this._style,this._style.wordWrap,this.canvas),a=o.width,h=o.height,l=o.lines,u=o.lineHeight,c=o.lineWidths,d=o.maxLineWidth,p=o.fontProperties;this.canvas.width=Math.ceil(Math.ceil(Math.max(1,a)+2*n.padding)*this._resolution),this.canvas.height=Math.ceil(Math.ceil(Math.max(1,h)+2*n.padding)*this._resolution),s.scale(this._resolution,this._resolution),s.clearRect(0,0,this.canvas.width,this.canvas.height),s.font=this._font,s.lineWidth=n.strokeThickness,s.textBaseline=n.textBaseline,s.lineJoin=n.lineJoin,s.miterLimit=n.miterLimit;// For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,
// but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.
//
// For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more
// visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill
// and the stroke; and fill drop shadows would appear over the top of the stroke.
//
// For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal
// text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the
// drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow
// beneath the text, whilst also having the proper text shadow styling.
for(var f=n.dropShadow?2:1,m=0;m<f;++m){var g=n.dropShadow&&0===m,y=g?Math.ceil(Math.max(1,h)+2*n.padding):0,_=y*this._resolution;if(g){// On Safari, text with gradient and drop shadows together do not position correctly
// if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689
// Therefore we'll set the styles to be a plain black whilst generating this drop shadow
s.fillStyle="black",s.strokeStyle="black";var v=n.dropShadowColor,x=e8("number"==typeof v?v:e9(v));s.shadowColor="rgba("+255*x[0]+","+255*x[1]+","+255*x[2]+","+n.dropShadowAlpha+")",s.shadowBlur=n.dropShadowBlur,s.shadowOffsetX=Math.cos(n.dropShadowAngle)*n.dropShadowDistance,s.shadowOffsetY=Math.sin(n.dropShadowAngle)*n.dropShadowDistance+_}else // set canvas text styles
s.fillStyle=this._generateFillStyle(n,l,o),// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
//       the setter converts to string. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
s.strokeStyle=n.stroke,s.shadowColor="black",s.shadowBlur=0,s.shadowOffsetX=0,s.shadowOffsetY=0;var b=(u-p.fontSize)/2;(!e.nextLineHeightBehavior||u-p.fontSize<0)&&(b=0);// draw lines line by line
for(var E=0;E<l.length;E++)i=n.strokeThickness/2,r=n.strokeThickness/2+E*u+p.ascent+b,"right"===n.align?i+=d-c[E]:"center"===n.align&&(i+=(d-c[E])/2),n.stroke&&n.strokeThickness&&this.drawLetterSpacing(l[E],i+n.padding,r+n.padding-y,!0),n.fill&&this.drawLetterSpacing(l[E],i+n.padding,r+n.padding-y)}this.updateTexture()}},/**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */e.prototype.drawLetterSpacing=function(t,e,i,r){void 0===r&&(r=!1);// letterSpacing of 0 means normal
var n=this._style.letterSpacing;if(0===n){r?this.context.strokeText(t,e,i):this.context.fillText(t,e,i);return}for(var s=e,o=Array.from?Array.from(t):t.split(""),a=this.context.measureText(t).width,h=0,l=0;l<o.length;++l){var u=o[l];r?this.context.strokeText(u,s,i):this.context.fillText(u,s,i),s+=a-(h=this.context.measureText(t.substring(l+1)).width)+n,a=h}},/**
     * Updates texture size based on canvas size
     *
     * @private
     */e.prototype.updateTexture=function(){var t=this.canvas;if(this._style.trim){var e=iA(t);e.data&&(t.width=e.width,t.height=e.height,this.context.putImageData(e.data,0,0))}var i=this._texture,r=this._style,n=r.trim?0:r.padding,s=i.baseTexture;i.trim.width=i._frame.width=t.width/this._resolution,i.trim.height=i._frame.height=t.height/this._resolution,i.trim.x=-n,i.trim.y=-n,i.orig.width=i._frame.width-2*n,i.orig.height=i._frame.height-2*n,// call sprite onTextureUpdate to update scale if _width or _height were set
this._onTextureUpdate(),s.setRealSize(t.width,t.height,this._resolution),i.updateUvs(),// Recursively updates transform of all objects from the root to this one
this._recursivePostUpdateTransform(),this.dirty=!1},/**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._render=function(e){this._autoResolution&&this._resolution!==e.resolution&&(this._resolution=e.resolution,this.dirty=!0),this.updateText(!0),t.prototype._render.call(this,e)},/**
     * Gets the local bounds of the text object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */e.prototype.getLocalBounds=function(e){return this.updateText(!0),t.prototype.getLocalBounds.call(this,e)},/**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     * @protected
     */e.prototype._calculateBounds=function(){this.updateText(!0),this.calculateVertices(),// if we have already done this on THIS frame.
this._bounds.addQuad(this.vertexData)},/**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */e.prototype._generateFillStyle=function(t,e,i){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
//       the setter converts to string. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
var r,n=t.fill;if(!Array.isArray(n))return n;if(1===n.length)return n[0];// a dropshadow will enlarge the canvas and result in the gradient being
// generated with the incorrect dimensions
var s=t.dropShadow?t.dropShadowDistance:0,o=t.padding||0,a=this.canvas.width/this._resolution-s-2*o,h=this.canvas.height/this._resolution-s-2*o,l=n.slice(),u=t.fillGradientStops.slice();// wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
if(!u.length)for(var c=l.length+1,d=1;d<c;++d)u.push(d/c);if(// stop the bleeding of the last gradient on the line above to the top gradient of the this line
// by hard defining the first gradient colour at point 0, and last gradient colour at point 1
l.unshift(n[0]),u.unshift(0),l.push(n[n.length-1]),u.push(1),t.fillGradientType===bx.LINEAR_VERTICAL){// start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
r=this.context.createLinearGradient(a/2,o,a/2,h+o);for(var p=i.fontProperties.fontSize+t.strokeThickness,d=0;d<e.length;d++){var f=i.lineHeight*(d-1)+p,m=i.lineHeight*d,g=m;// Handle case where last & this line overlap
d>0&&f>m&&(g=(m+f)/2);var y=m+p,_=i.lineHeight*(d+1),v=y;// Handle case where this & next line overlap
d+1<e.length&&_<y&&(v=(y+_)/2);for(var x=(v-g)/h,b=0;b<l.length;b++){// 0-1 stop point for the current line, multiplied to global space afterwards
var E=Math.min(1,Math.max(0,g/h+("number"==typeof u[b]?u[b]:b/l.length)*x));// There's potential for floating point precision issues at the seams between gradient repeats.
E=Number(E.toFixed(5)),r.addColorStop(E,l[b])}}}else{// start the gradient at the center left of the canvas, and end at the center right of the canvas
r=this.context.createLinearGradient(o,h/2,a+o,h/2);for(var T=l.length+1,w=1,d=0;d<l.length;d++){var S=void 0;S="number"==typeof u[d]?u[d]:w/T,r.addColorStop(S,l[d]),w++}}return r},/**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */e.prototype.destroy=function(e){"boolean"==typeof e&&(e={children:e}),e=Object.assign({},oY,e),t.prototype.destroy.call(this,e),this._ownCanvas&&(this.canvas.height=this.canvas.width=0),// make sure to reset the the context and canvas.. dont want this hanging around in memory!
this.context=null,this.canvas=null,this._style=null},Object.defineProperty(e.prototype,"width",{/**
         * The width of the Text, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this.updateText(!0),Math.abs(this.scale.x)*this._texture.orig.width},set:function(t){this.updateText(!0);var e=ig(this.scale.x)||1;this.scale.x=e*t/this._texture.orig.width,this._width=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the Text, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this.updateText(!0),Math.abs(this.scale.y)*this._texture.orig.height},set:function(t){this.updateText(!0);var e=ig(this.scale.y)||1;this.scale.y=e*t/this._texture.orig.height,this._height=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"style",{/**
         * Set the style of the text. Set up an event listener to listen for changes on the style
         * object and mark the text as dirty.
         *
         * @member {object|PIXI.TextStyle}
         */get:function(){// TODO: Can't have different types for getter and setter. The getter shouldn't have the ITextStyle
//       since the setter creates the TextStyle. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
return this._style},set:function(t){(t=t||{})instanceof oH?this._style=t:this._style=new oH(t),this.localStyleID=-1,this.dirty=!0},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"text",{/**
         * Set the copy for the text object. To split a line you can use '\n'.
         *
         * @member {string}
         */get:function(){return this._text},set:function(t){t=String(null==t?"":t),this._text!==t&&(this._text=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"resolution",{/**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default 1
         */get:function(){return this._resolution},set:function(t){this._autoResolution=!1,this._resolution!==t&&(this._resolution=t,this.dirty=!0)},enumerable:!1,configurable:!0}),/**
     * New behavior for `lineHeight` that's meant to mimic HTML text. A value of `true` will
     * make sure the first baseline is offset by the `lineHeight` value if it is greater than `fontSize`.
     * A value of `false` will use the legacy behavior and not change the baseline of the first line.
     * In the next major release, we'll enable this by default.
     *
     * @static
     * @memberof PIXI.Text
     * @member {boolean} nextLineHeightBehavior
     * @default false
     */e.nextLineHeightBehavior=!1,e}(oB);ec.UPLOADS_PER_FRAME=4;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var oK=function(t,e){return(oK=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},oJ=/** @class */function(){/**
     * @param {number} maxItemsPerFrame - The maximum number of items that can be prepared each frame.
     */function t(t){/**
         * The maximum number of items that can be prepared each frame.
         * @type {number}
         * @private
         */this.maxItemsPerFrame=t,/**
         * The number of items that can be prepared in the current frame.
         * @type {number}
         * @private
         */this.itemsLeft=0}return(/**
     * Resets any counting properties to start fresh on a new frame.
     */t.prototype.beginFrame=function(){this.itemsLeft=this.maxItemsPerFrame},/**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */t.prototype.allowedToUpload=function(){return this.itemsLeft-- >0},t)}();/**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */function oZ(t,e){var i=!1;// Objects with multiple textures
if(t&&t._textures&&t._textures.length){for(var r=0;r<t._textures.length;r++)if(t._textures[r]instanceof rH){var n=t._textures[r].baseTexture;-1===e.indexOf(n)&&(e.push(n),i=!0)}}return i}/**
 * Built-in hook to find BaseTextures from Texture.
 *
 * @private
 * @param {PIXI.Texture} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */function o$(t,e){if(t.baseTexture instanceof rS){var i=t.baseTexture;return -1===e.indexOf(i)&&e.push(i),!0}return!1}/**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */function oQ(t,e){if(t._texture&&t._texture instanceof rH){var i=t._texture.baseTexture;return -1===e.indexOf(i)&&e.push(i),!0}return!1}/**
 * Built-in hook to draw PIXI.Text to its texture.
 *
 * @private
 * @param {PIXI.AbstractRenderer|PIXI.BasePrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */function o0(t,e){return e instanceof oq&&(// updating text will return early if it is not dirty
e.updateText(!0),!0)}/**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.AbstractRenderer|PIXI.BasePrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */function o1(t,e){if(e instanceof oH){var i=e.toFontString();return oX.measureFont(i),!0}return!1}/**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */function o2(t,e){if(t instanceof oq){-1===e.indexOf(t.style)&&e.push(t.style),-1===e.indexOf(t)&&e.push(t);// also push the Text's texture for upload to GPU
var i=t._texture.baseTexture;return -1===e.indexOf(i)&&e.push(i),!0}return!1}/**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */function o3(t,e){return t instanceof oH&&(-1===e.indexOf(t)&&e.push(t),!0)}/**
 * The prepare manager provides functionality to upload content to the GPU.
 *
 * BasePrepare handles basic queuing functionality and is extended by
 * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}
 * to provide preparation capabilities specific to their respective renderers.
 *
 * @example
 * // Create a sprite
 * const sprite = PIXI.Sprite.from('something.png');
 *
 * // Load object into GPU
 * app.renderer.plugins.prepare.upload(sprite, () => {
 *
 *     //Texture(s) has been uploaded to GPU
 *     app.stage.addChild(sprite);
 *
 * })
 *
 * @abstract
 * @class
 * @memberof PIXI
 */var o5=/** @class */function(){/**
     * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer
     */function t(t){var e=this;/**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.CountLimiter|PIXI.TimeLimiter}
         */this.limiter=new oJ(ec.UPLOADS_PER_FRAME),/**
         * Reference to the renderer.
         * @type {PIXI.AbstractRenderer}
         * @protected
         */this.renderer=t,/**
         * The only real difference between CanvasPrepare and Prepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {object}
         * @protected
         */this.uploadHookHelper=null,/**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */this.queue=[],/**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */this.addHooks=[],/**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */this.uploadHooks=[],/**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */this.completes=[],/**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */this.ticking=!1,/**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */this.delayedTick=function(){// unlikely, but in case we were destroyed between tick() and delayedTick()
e.queue&&e.prepareItems()},// hooks to find the correct texture
this.registerFindHook(o2),this.registerFindHook(o3),this.registerFindHook(oZ),this.registerFindHook(o$),this.registerFindHook(oQ),// upload hooks
this.registerUploadHook(o0),this.registerUploadHook(o1)}return(/**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *        Either the container or display object to search for items to upload, the items to upload themselves,
     *        or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */t.prototype.upload=function(t,e){"function"==typeof t&&(e=t,t=null),t&&this.add(t),this.queue.length?(e&&this.completes.push(e),this.ticking||(this.ticking=!0,rr.system.addOnce(this.tick,this,bs.UTILITY))):e&&e()},/**
     * Handle tick update
     *
     * @private
     */t.prototype.tick=function(){setTimeout(this.delayedTick,0)},/**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */t.prototype.prepareItems=function(){// Upload the graphics
for(this.limiter.beginFrame();this.queue.length&&this.limiter.allowedToUpload();){var t=this.queue[0],e=!1;if(t&&!t._destroyed){for(var i=0,r=this.uploadHooks.length;i<r;i++)if(this.uploadHooks[i](this.uploadHookHelper,t)){this.queue.shift(),e=!0;break}}e||this.queue.shift()}// We're finished
if(this.queue.length)rr.system.addOnce(this.tick,this,bs.UTILITY);else{this.ticking=!1;var n=this.completes.slice(0);this.completes.length=0;for(var i=0,r=n.length;i<r;i++)n[i]()}},/**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *          function must return `true` if it was able to add item to the queue.
     * @return {this} Instance of plugin for chaining.
     */t.prototype.registerFindHook=function(t){return t&&this.addHooks.push(t),this},/**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *          function must return `true` if it was able to handle upload of item.
     * @return {this} Instance of plugin for chaining.
     */t.prototype.registerUploadHook=function(t){return t&&this.uploadHooks.push(t),this},/**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *        add to the queue
     * @return {this} Instance of plugin for chaining.
     */t.prototype.add=function(t){// Add additional hooks for finding elements on special
// types of objects that
for(var e=0,i=this.addHooks.length;e<i&&!this.addHooks[e](t,this.queue);e++);// Get children recursively
if(t instanceof i8)for(var e=t.children.length-1;e>=0;e--)this.add(t.children[e]);return this},/**
     * Destroys the plugin, don't use after this.
     *
     */t.prototype.destroy=function(){this.ticking&&rr.system.remove(this.tick,this),this.ticking=!1,this.addHooks=null,this.uploadHooks=null,this.renderer=null,this.completes=null,this.queue=null,this.limiter=null,this.uploadHookHelper=null},t)}();/**
 * Built-in hook to upload PIXI.Texture objects to the GPU.
 *
 * @private
 * @param {PIXI.Renderer} renderer - instance of the webgl renderer
 * @param {PIXI.BaseTexture} item - Item to check
 * @return {boolean} If item was uploaded.
 */function o4(t,e){return e instanceof rS&&(e._glTextures[t.CONTEXT_UID]||t.texture.bind(e),!0)}/**
 * Built-in hook to upload PIXI.Graphics to the GPU.
 *
 * @private
 * @param {PIXI.Renderer} renderer - instance of the webgl renderer
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */function o6(t,e){if(!(e instanceof oP))return!1;var i=e.geometry;// update dirty graphics to get batches
e.finishPoly(),i.updateBatches();// upload all textures found in styles
for(var r=i.batches,n=0;n<r.length;n++){var s=r[n].style.texture;s&&o4(t,s.baseTexture)}return i.batchable||t.geometry.bind(i,e._resolveDirectShader(t)),!0}/**
 * Built-in hook to find graphics.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Graphics object was found.
 */function o8(t,e){return t instanceof oP&&(e.push(t),!0)}/**
 * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for
 * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.
 *
 * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.
 * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.
 * @example
 * // Create a new application
 * const app = new PIXI.Application();
 * document.body.appendChild(app.view);
 *
 * // Don't start rendering right away
 * app.stop();
 *
 * // create a display object
 * const rect = new PIXI.Graphics()
 *     .beginFill(0x00ff00)
 *     .drawRect(40, 40, 200, 200);
 *
 * // Add to the stage
 * app.stage.addChild(rect);
 *
 * // Don't start rendering until the graphic is uploaded to the GPU
 * app.renderer.plugins.prepare.upload(app.stage, () => {
 *     app.start();
 * });
 *
 * @class
 * @extends PIXI.BasePrepare
 * @memberof PIXI
 */var o7=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - A reference to the current renderer
     */function e(e){var i=t.call(this,e)||this;return i.uploadHookHelper=i.renderer,// Add textures and graphics to upload
i.registerFindHook(o8),i.registerUploadHook(o4),i.registerUploadHook(o6),i}return!function(t,e){function i(){this.constructor=t}oK(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),e}(o5),o9=/** @class */function(){/**
     * @param {number} maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame.
     */function t(t){/**
         * The maximum milliseconds that can be spent preparing items each frame.
         * @type {number}
         * @private
         */this.maxMilliseconds=t,/**
         * The start time of the current frame.
         * @type {number}
         * @private
         */this.frameStart=0}return(/**
     * Resets any counting properties to start fresh on a new frame.
     */t.prototype.beginFrame=function(){this.frameStart=Date.now()},/**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */t.prototype.allowedToUpload=function(){return Date.now()-this.frameStart<this.maxMilliseconds},t)}(),at={};tC(at,"Spritesheet",()=>ae),tC(at,"SpritesheetLoader",()=>ai);/*!
 * @pixi/spritesheet - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * Utility class for maintaining reference to a collection
 * of Textures on a single Spritesheet.
 *
 * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:
 *
 * ```js
 * PIXI.Loader.shared.add("images/spritesheet.json").load(setup);
 *
 * function setup() {
 *   let sheet = PIXI.Loader.shared.resources["images/spritesheet.json"].spritesheet;
 *   ...
 * }
 * ```
 * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.
 *
 * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},
 * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.
 * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only
 * supported by TexturePacker.
 *
 * @class
 * @memberof PIXI
 */var ae=/** @class */function(){/**
     * @param {PIXI.BaseTexture|PIXI.Texture} baseTexture - Reference to the source BaseTexture object.
     * @param {Object} data - Spritesheet image data.
     * @param {string} [resolutionFilename] - The filename to consider when determining
     *        the resolution of the spritesheet. If not provided, the imageUrl will
     *        be used on the BaseTexture.
     */function t(t,e,i){void 0===i&&(i=null),/**
         * Reference to original source image from the Loader. This reference is retained so we
         * can destroy the Texture later on. It is never used internally.
         * @type {PIXI.Texture}
         * @private
         */this._texture=t instanceof rH?t:null,/**
         * Reference to ths source texture.
         * @type {PIXI.BaseTexture}
         */this.baseTexture=t instanceof rS?t:this._texture.baseTexture,/**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */this.textures={},/**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */this.animations={},/**
         * Reference to the original JSON data.
         * @type {Object}
         */this.data=e;var r=this.baseTexture.resource;/**
         * The resolution of the spritesheet.
         * @type {number}
         */this.resolution=this._updateResolution(i||(r?r.url:null)),/**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */this._frames=this.data.frames,/**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */this._frameKeys=Object.keys(this._frames),/**
         * Current batch index being processed.
         * @type {number}
         * @private
         */this._batchIndex=0,/**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */this._callback=null}return(/**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *        the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */t.prototype._updateResolution=function(t){void 0===t&&(t=null);var e=this.data.meta.scale,i=iI(t,null);return null===i&&(i=void 0!==e?parseFloat(e):1),1!==i&&this.baseTexture.setResolution(i),i},/**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *        a map of the Textures for this spritesheet.
     */t.prototype.parse=function(e){this._batchIndex=0,this._callback=e,this._frameKeys.length<=t.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()},/**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */t.prototype._processFrames=function(e){for(var i=e,r=t.BATCH_SIZE;i-e<r&&i<this._frameKeys.length;){var n=this._frameKeys[i],s=this._frames[n],o=s.frame;if(o){var a=null,h=null,l=!1!==s.trimmed&&s.sourceSize?s.sourceSize:s.frame,u=new iU(0,0,Math.floor(l.w)/this.resolution,Math.floor(l.h)/this.resolution);a=s.rotated?new iU(Math.floor(o.x)/this.resolution,Math.floor(o.y)/this.resolution,Math.floor(o.h)/this.resolution,Math.floor(o.w)/this.resolution):new iU(Math.floor(o.x)/this.resolution,Math.floor(o.y)/this.resolution,Math.floor(o.w)/this.resolution,Math.floor(o.h)/this.resolution),!1!==s.trimmed&&s.spriteSourceSize&&(h=new iU(Math.floor(s.spriteSourceSize.x)/this.resolution,Math.floor(s.spriteSourceSize.y)/this.resolution,Math.floor(o.w)/this.resolution,Math.floor(o.h)/this.resolution)),this.textures[n]=new rH(this.baseTexture,a,u,h,s.rotated?2:0,s.anchor),rH.addToCache(this.textures[n],n)}i++}},/**
     * Parse animations config
     *
     * @private
     */t.prototype._processAnimations=function(){var t=this.data.animations||{};for(var e in t){this.animations[e]=[];for(var i=0;i<t[e].length;i++){var r=t[e][i];this.animations[e].push(this.textures[r])}}},/**
     * The parse has completed.
     *
     * @private
     */t.prototype._parseComplete=function(){var t=this._callback;this._callback=null,this._batchIndex=0,t.call(this,this.textures)},/**
     * Begin the next batch of textures.
     *
     * @private
     */t.prototype._nextBatch=function(){var e=this;this._processFrames(this._batchIndex*t.BATCH_SIZE),this._batchIndex++,setTimeout(function(){e._batchIndex*t.BATCH_SIZE<e._frameKeys.length?e._nextBatch():(e._processAnimations(),e._parseComplete())},0)},/**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
     */t.prototype.destroy=function(t){var e;for(var i in void 0===t&&(t=!1),this.textures)this.textures[i].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,t&&(null===(e=this._texture)||void 0===e||e.destroy(),this.baseTexture.destroy()),this._texture=null,this.baseTexture=null},/**
     * The maximum number of Textures to build per process.
     *
     * @type {number}
     * @default 1000
     */t.BATCH_SIZE=1e3,t)}(),ai=/** @class */function(){function t(){}return(/**
     * Called after a resource is loaded.
     * @see PIXI.Loader.loaderMiddleware
     * @param {PIXI.LoaderResource} resource
     * @param {function} next
     */t.use=function(e,i){// because this is middleware, it execute in loader context. `this` = loader
var r,n,s=this,o=e.name+"_image";// skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
if(!e.data||e.type!==sO.TYPE.JSON||!e.data.frames||s.resources[o]){i();return}// Check and add the multi atlas
// Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js
// eslint-disable-next-line camelcase
var a=null===(n=null===(r=e.data)||void 0===r?void 0:r.meta)||void 0===n?void 0:n.related_multi_packs;if(Array.isArray(a))for(var h=0;h<a.length;h++)!function(t){if("string"==typeof t){var i=t.replace(".json",""),r=e0.resolve(e.url.replace(s.baseUrl,""),t);// Check if the file wasn't already added as multipacks are redundant
if(!(s.resources[i]||Object.values(s.resources).some(function(t){return e0.format(e0.parse(t.url))===r}))){var n={crossOrigin:e.crossOrigin,loadType:sO.LOAD_TYPE.XHR,xhrType:sO.XHR_RESPONSE_TYPE.JSON,parentResource:e};s.add(i,r,n)}}}(a[h]);var l={crossOrigin:e.crossOrigin,metadata:e.metadata.imageMetadata,parentResource:e},u=t.getResourcePath(e,s.baseUrl);// load the image for this sheet
s.add(o,u,l,function(t){if(t.error){i(t.error);return}var r=new ae(t.texture,e.data,e.url);r.parse(function(){e.spritesheet=r,e.textures=r.textures,i()})})},/**
     * Get the spritesheets root path
     * @param {PIXI.LoaderResource} resource - Resource to check path
     * @param {string} baseUrl - Base root url
     */t.getResourcePath=function(t,e){return(// Prepend url path unless the resource image is a data url
t.isDataUrl?t.data.meta.image:e0.resolve(t.url.replace(e,""),t.data.meta.image))},t)}(),ar={};tC(ar,"TilingSprite",()=>aa),tC(ar,"TilingSpriteRenderer",()=>au);/*!
 * @pixi/sprite-tiling - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var an=function(t,e){return(an=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function as(t,e){function i(){this.constructor=t}an(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var ao=new ij,aa=/** @class */function(t){/**
     * @param {PIXI.Texture} texture - the texture of the tiling sprite
     * @param {number} [width=100] - the width of the tiling sprite
     * @param {number} [height=100] - the height of the tiling sprite
     */function e(e,i,r){void 0===i&&(i=100),void 0===r&&(r=100);var n=t.call(this,e)||this;return(/**
         * Tile transform
         *
         * @member {PIXI.Transform}
         */n.tileTransform=new i0,/**
         * The with of the tiling sprite
         *
         * @member {number}
         * @private
         */n._width=i,/**
         * The height of the tiling sprite
         *
         * @member {number}
         * @private
         */n._height=r,/**
         * matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space
         *
         * @member {PIXI.TextureMatrix}
         */n.uvMatrix=n.texture.uvMatrix||new nP(e),/**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' method.
         *
         * @member {string}
         * @default 'tilingSprite'
         */n.pluginName="tilingSprite",/**
         * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
         * local space.
         *
         * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
         * this, the top-left corner always gets the (0, 0) texture coordinate.
         *
         * @member {boolean}
         * @default false
         */n.uvRespectAnchor=!1,n)}return as(e,t),Object.defineProperty(e.prototype,"clampMargin",{/**
         * Changes frame clamping in corresponding textureTransform, shortcut
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */get:function(){return this.uvMatrix.clampMargin},set:function(t){this.uvMatrix.clampMargin=t,this.uvMatrix.update(!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tileScale",{/**
         * The scaling of the image that is being tiled
         *
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.tileTransform.scale},set:function(t){this.tileTransform.scale.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tilePosition",{/**
         * The offset of the image that is being tiled
         *
         * @member {PIXI.ObservablePoint}
         */get:function(){return this.tileTransform.position},set:function(t){this.tileTransform.position.copyFrom(t)},enumerable:!1,configurable:!0}),/**
     * @protected
     */e.prototype._onTextureUpdate=function(){this.uvMatrix&&(this.uvMatrix.texture=this._texture),this._cachedTint=16777215},/**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */e.prototype._render=function(t){// tweak our texture temporarily..
var e=this._texture;e&&e.valid&&(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))},/**
     * Updates the bounds of the tiling sprite.
     *
     * @protected
     */e.prototype._calculateBounds=function(){var t=-(this._width*this._anchor._x),e=-(this._height*this._anchor._y),i=this._width*(1-this._anchor._x),r=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,t,e,i,r)},/**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */e.prototype.getLocalBounds=function(e){return(// we can do a fast local bounds if the sprite has no children!
0===this.children.length?(this._bounds.minX=-(this._width*this._anchor._x),this._bounds.minY=-(this._height*this._anchor._y),this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._y),e||(this._localBoundsRect||(this._localBoundsRect=new iU),e=this._localBoundsRect),this._bounds.getRectangle(e)):t.prototype.getLocalBounds.call(this,e))},/**
     * Checks if a point is inside this tiling sprite.
     *
     * @param {PIXI.IPointData} point - the point to check
     * @return {boolean} Whether or not the sprite contains the point.
     */e.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,ao);var e=this._width,i=this._height,r=-e*this.anchor._x;if(ao.x>=r&&ao.x<r+e){var n=-i*this.anchor._y;if(ao.y>=n&&ao.y<n+i)return!0}return!1},/**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */e.prototype.destroy=function(e){t.prototype.destroy.call(this,e),this.tileTransform=null,this.uvMatrix=null},/**
     * Helper function that creates a new tiling sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
     * @param {Object} options - See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {number} options.width - required width of the tiling sprite
     * @param {number} options.height - required height of the tiling sprite
     * @return {PIXI.TilingSprite} The newly created texture
     */e.from=function(t,i){var r=t instanceof rH?t:rH.from(t,i);return new e(r,i.width,i.height)},Object.defineProperty(e.prototype,"width",{/**
         * The width of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this._width},set:function(t){this._width=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */get:function(){return this._height},set:function(t){this._height=t},enumerable:!1,configurable:!0}),e}(oB),ah="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",al=new iX,au=/** @class */function(t){/**
     * constructor for renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.
     */function e(e){var i=t.call(this,e)||this,r={globals:i.renderer.globalUniforms};return i.shader=nM.from(ah,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n",r),i.simpleShader=nM.from(ah,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n",r),i.quad=new r0,/**
         * The WebGL state in which this renderer will work.
         *
         * @member {PIXI.State}
         * @readonly
         */i.state=nA.for2d(),i}return as(e,t),/**
     *
     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered
     */e.prototype.render=function(t){var e=this.renderer,i=this.quad,r=i.vertices;r[0]=r[6]=-(t._width*t.anchor.x),r[1]=r[3]=-(t._height*t.anchor.y),r[2]=r[4]=t._width*(1-t.anchor.x),r[5]=r[7]=t._height*(1-t.anchor.y);var n=t.uvRespectAnchor?t.anchor.x:0,s=t.uvRespectAnchor?t.anchor.y:0;(r=i.uvs)[0]=r[6]=-n,r[1]=r[3]=-s,r[2]=r[4]=1-n,r[5]=r[7]=1-s,i.invalidate();var o=t._texture,a=o.baseTexture,h=t.tileTransform.localTransform,l=t.uvMatrix,u=a.isPowerOfTwo&&o.frame.width===a.width&&o.frame.height===a.height;u&&(a._glTextures[e.CONTEXT_UID]?u=a.wrapMode!==x3.CLAMP:a.wrapMode===x3.CLAMP&&(a.wrapMode=x3.REPEAT));var c=u?this.simpleShader:this.shader,d=o.width,p=o.height,f=t._width,m=t._height;al.set(h.a*d/f,h.b*d/m,h.c*p/f,h.d*p/m,h.tx/f,h.ty/m),// that part is the same as above:
// tempMat.identity();
// tempMat.scale(tex.width, tex.height);
// tempMat.prepend(lt);
// tempMat.scale(1.0 / ts._width, 1.0 / ts._height);
al.invert(),u?al.prepend(l.mapCoord):(c.uniforms.uMapCoord=l.mapCoord.toArray(!0),c.uniforms.uClampFrame=l.uClampFrame,c.uniforms.uClampOffset=l.uClampOffset),c.uniforms.uTransform=al.toArray(!0),c.uniforms.uColor=io(t.tint,t.worldAlpha,c.uniforms.uColor,a.alphaMode),c.uniforms.translationMatrix=t.transform.worldTransform.toArray(!0),c.uniforms.uSampler=o,e.shader.bind(c),e.geometry.bind(i),this.state.blendMode=ii(t.blendMode,a.alphaMode),e.state.set(this.state),e.geometry.draw(this.renderer.gl.TRIANGLES,6,0)},e}(r8),ac={};tC(ac,"BitmapFontData",()=>aE),tC(ac,"BitmapFont",()=>aR),tC(ac,"BitmapText",()=>aI),tC(ac,"BitmapFontLoader",()=>aO);/*!
 * @pixi/text-bitmap - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var ad={};tC(ad,"MeshBatchUvs",()=>am),tC(ad,"Mesh",()=>a_),tC(ad,"MeshMaterial",()=>av),tC(ad,"MeshGeometry",()=>ax);/*!
 * @pixi/mesh - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var ap=function(t,e){return(ap=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function af(t,e){function i(){this.constructor=t}ap(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.
 *
 * @class
 * @memberof PIXI
 */var am=/** @class */function(){/**
     * @param {PIXI.Buffer} uvBuffer - Buffer with normalized uv's
     * @param {PIXI.TextureMatrix} uvMatrix - Material UV matrix
     */function t(t,e){/**
         * Buffer with normalized UV's
         * @member {PIXI.Buffer}
         */this.uvBuffer=t,/**
         * Material UV matrix
         * @member {PIXI.TextureMatrix}
         */this.uvMatrix=e,/**
         * UV Buffer data
         * @member {Float32Array}
         * @readonly
         */this.data=null,this._bufferUpdateId=-1,this._textureUpdateId=-1,this._updateID=0}return(/**
     * updates
     *
     * @param {boolean} [forceUpdate] - force the update
     */t.prototype.update=function(t){if(t||this._bufferUpdateId!==this.uvBuffer._updateID||this._textureUpdateId!==this.uvMatrix._updateID){this._bufferUpdateId=this.uvBuffer._updateID,this._textureUpdateId=this.uvMatrix._updateID;var e=this.uvBuffer.data;this.data&&this.data.length===e.length||(this.data=new Float32Array(e.length)),this.uvMatrix.multiplyUvs(e,this.data),this._updateID++}},t)}(),ag=new ij,ay=new iH,a_=/** @class */function(t){/**
     * @param {PIXI.Geometry} geometry - the geometry the mesh will use
     * @param {PIXI.MeshMaterial} shader - the shader the mesh will use
     * @param {PIXI.State} [state] - the state that the WebGL context is required to be in to render the mesh
     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.
     * @param {number} [drawMode=PIXI.DRAW_MODES.TRIANGLES] - the drawMode, can be any of the PIXI.DRAW_MODES consts
     */function e(e,i,r,n){void 0===n&&(n=xZ.TRIANGLES);var s=t.call(this)||this;return(/**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */s.geometry=e,e.refCount++,/**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */s.shader=i,/**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */s.state=r||nA.for2d(),/**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */s.drawMode=n,/**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */s.start=0,/**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */s.size=0,/**
         * these are used as easy access for batching
         * @member {Float32Array}
         * @private
         */s.uvs=null,/**
         * these are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */s.indices=null,/**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */s.vertexData=new Float32Array(1),/**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */s.vertexDirty=-1,s._transformID=-1,/**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */s._roundPixels=ec.ROUND_PIXELS,/**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */s.batchUvs=null,s)}return af(e,t),Object.defineProperty(e.prototype,"uvBuffer",{/**
         * To change mesh uv's, change its uvBuffer data and increment its _updateID.
         * @member {PIXI.Buffer}
         * @readonly
         */get:function(){return this.geometry.buffers[1]},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"verticesBuffer",{/**
         * To change mesh vertices, change its uvBuffer data and increment its _updateID.
         * Incrementing _updateID is optional because most of Mesh objects do it anyway.
         * @member {PIXI.Buffer}
         * @readonly
         */get:function(){return this.geometry.buffers[0]},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"material",{get:function(){return this.shader},/**
         * Alias for {@link PIXI.Mesh#shader}.
         * @member {PIXI.MeshMaterial}
         */set:function(t){this.shader=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"blendMode",{get:function(){return this.state.blendMode},/**
         * The blend mode to be applied to the Mesh. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL;
         * @see PIXI.BLEND_MODES
         */set:function(t){this.state.blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"roundPixels",{get:function(){return this._roundPixels},/**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
         *
         * @member {boolean}
         * @default false
         */set:function(t){this._roundPixels!==t&&(this._transformID=-1),this._roundPixels=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tint",{/**
         * The multiply tint applied to the Mesh. This is a hex value. A value of
         * `0xFFFFFF` will remove any tint effect.
         *
         * Null for non-MeshMaterial shaders
         * @member {number}
         * @default 0xFFFFFF
         */get:function(){return"tint"in this.shader?this.shader.tint:null},set:function(t){this.shader.tint=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"texture",{/**
         * The texture that the Mesh uses.
         *
         * Null for non-MeshMaterial shaders
         * @member {PIXI.Texture}
         */get:function(){return"texture"in this.shader?this.shader.texture:null},set:function(t){this.shader.texture=t},enumerable:!1,configurable:!0}),/**
     * Standard renderer draw.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */e.prototype._render=function(t){// set properties for batching..
// TODO could use a different way to grab verts?
var i=this.geometry.buffers[0].data;// TODO benchmark check for attribute size..
this.shader.batchable&&this.drawMode===xZ.TRIANGLES&&i.length<2*e.BATCHABLE_SIZE?this._renderToBatch(t):this._renderDefault(t)},/**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */e.prototype._renderDefault=function(t){var e=this.shader;e.alpha=this.worldAlpha,e.update&&e.update(),t.batch.flush(),// bind and sync uniforms..
e.uniforms.translationMatrix=this.transform.worldTransform.toArray(!0),t.shader.bind(e),// set state..
t.state.set(this.state),// bind the geometry...
t.geometry.bind(this.geometry,e),// then render it
t.geometry.draw(this.drawMode,this.size,this.start,this.geometry.instanceCount)},/**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */e.prototype._renderToBatch=function(t){var e=this.geometry,i=this.shader;i.uvMatrix&&(i.uvMatrix.update(),this.calculateUvs()),// set properties for batching..
this.calculateVertices(),this.indices=e.indexBuffer.data,this._tintRGB=i._tintRGB,this._texture=i.texture;var r=this.material.pluginName;t.batch.setObjectRenderer(t.plugins[r]),t.plugins[r].render(this)},/**
     * Updates vertexData field based on transform and vertices
     */e.prototype.calculateVertices=function(){var t=this.geometry.buffers[0],e=t.data,i=t._updateID;if(i!==this.vertexDirty||this._transformID!==this.transform._worldID){this._transformID=this.transform._worldID,this.vertexData.length!==e.length&&(this.vertexData=new Float32Array(e.length));for(var r=this.transform.worldTransform,n=r.a,s=r.b,o=r.c,a=r.d,h=r.tx,l=r.ty,u=this.vertexData,c=0;c<u.length/2;c++){var d=e[2*c],p=e[2*c+1];u[2*c]=n*d+o*p+h,u[2*c+1]=s*d+a*p+l}if(this._roundPixels)for(var f=ec.RESOLUTION,c=0;c<u.length;++c)u[c]=Math.round((u[c]*f|0)/f);this.vertexDirty=i}},/**
     * Updates uv field based on from geometry uv's or batchUvs
     */e.prototype.calculateUvs=function(){var t=this.geometry.buffers[1],e=this.shader;e.uvMatrix.isSimple?this.uvs=t.data:(this.batchUvs||(this.batchUvs=new am(t,e.uvMatrix)),this.batchUvs.update(),this.uvs=this.batchUvs.data)},/**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */e.prototype._calculateBounds=function(){this.calculateVertices(),this._bounds.addVertexData(this.vertexData,0,this.vertexData.length)},/**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.IPointData} point - the point to test
     * @return {boolean} the result of the test
     */e.prototype.containsPoint=function(t){if(!this.getBounds().contains(t.x,t.y))return!1;this.worldTransform.applyInverse(t,ag);for(var e=this.geometry.getBuffer("aVertexPosition").data,i=ay.points,r=this.geometry.getIndex().data,n=r.length,s=4===this.drawMode?3:1,o=0;o+2<n;o+=s){var a=2*r[o],h=2*r[o+1],l=2*r[o+2];if(i[0]=e[a],i[1]=e[a+1],i[2]=e[h],i[3]=e[h+1],i[4]=e[l],i[5]=e[l+1],ay.contains(ag.x,ag.y))return!0}return!1},/**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */e.prototype.destroy=function(e){t.prototype.destroy.call(this,e),this.geometry.refCount--,0===this.geometry.refCount&&this.geometry.dispose(),this._cachedTexture&&(this._cachedTexture.destroy(),this._cachedTexture=null),this.geometry=null,this.shader=null,this.state=null,this.uvs=null,this.indices=null,this.vertexData=null},/**
     * The maximum number of vertices to consider batchable. Generally, the complexity
     * of the geometry.
     * @memberof PIXI.Mesh
     * @static
     * @member {number} BATCHABLE_SIZE
     */e.BATCHABLE_SIZE=100,e}(i8),av=/** @class */function(t){/**
     * @param {PIXI.Texture} uSampler - Texture that material uses to render.
     * @param {object} [options] - Additional options
     * @param {number} [options.alpha=1] - Default alpha.
     * @param {number} [options.tint=0xFFFFFF] - Default tint.
     * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.
     * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.
     * @param {object} [options.uniforms] - Custom uniforms.
     */function e(e,i){var r=this,n={uSampler:e,alpha:1,uTextureMatrix:iX.IDENTITY,uColor:new Float32Array([1,1,1,1])};return(// Set defaults
(i=Object.assign({tint:16777215,alpha:1,pluginName:"batch"},i)).uniforms&&Object.assign(n,i.uniforms),/**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */(r=t.call(this,i.program||nS.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"),n)||this)._colorDirty=!1,/**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */r.uvMatrix=new nP(e),/**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */r.batchable=void 0===i.program,/**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */r.pluginName=i.pluginName,r.tint=i.tint,r.alpha=i.alpha,r)}return af(e,t),Object.defineProperty(e.prototype,"texture",{/**
         * Reference to the texture being rendered.
         * @member {PIXI.Texture}
         */get:function(){return this.uniforms.uSampler},set:function(t){this.uniforms.uSampler!==t&&(this.uniforms.uSampler=t,this.uvMatrix.texture=t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"alpha",{get:function(){return this._alpha},/**
         * This gets automatically set by the object using this.
         *
         * @default 1
         * @member {number}
         */set:function(t){t!==this._alpha&&(this._alpha=t,this._colorDirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"tint",{get:function(){return this._tint},/**
         * Multiply tint for the material.
         * @member {number}
         * @default 0xFFFFFF
         */set:function(t){t!==this._tint&&(this._tint=t,this._tintRGB=(t>>16)+(65280&t)+((255&t)<<16),this._colorDirty=!0)},enumerable:!1,configurable:!0}),/**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */e.prototype.update=function(){if(this._colorDirty){this._colorDirty=!1;var t=this.texture.baseTexture;io(this._tint,this._alpha,this.uniforms.uColor,t.alphaMode)}this.uvMatrix.update()&&(this.uniforms.uTextureMatrix=this.uvMatrix.mapCoord)},e}(nM),ax=/** @class */function(t){/**
     * @param {Float32Array|number[]} [vertices] - Positional data on geometry.
     * @param {Float32Array|number[]} [uvs] - Texture UVs.
     * @param {Uint16Array|number[]} [index] - IndexBuffer
     */function e(e,i,r){var n=t.call(this)||this,s=new rY(e),o=new rY(i,!0),a=new rY(r,!0,!0);return n.addAttribute("aVertexPosition",s,2,!1,x0.FLOAT).addAttribute("aTextureCoord",o,2,!1,x0.FLOAT).addIndex(a),/**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */n._updateId=-1,n}return af(e,t),Object.defineProperty(e.prototype,"vertexDirtyId",{/**
         * If the vertex position is updated.
         * @member {number}
         * @readonly
         * @private
         */get:function(){return this.buffers[0]._updateID},enumerable:!1,configurable:!0}),e}(r$),ab=function(t,e){return(ab=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aE=function(){/**
         * @member {PIXI.IBitmapFontDataInfo[]}
         * @readOnly
         */this.info=[],/**
         * @member {PIXI.IBitmapFontDataCommon[]}
         * @readOnly
         */this.common=[],/**
         * @member {PIXI.IBitmapFontDataPage[]}
         * @readOnly
         */this.page=[],/**
         * @member {PIXI.IBitmapFontDataChar[]}
         * @readOnly
         */this.char=[],/**
         * @member {PIXI.IBitmapFontDataKerning[]}
         * @readOnly
         */this.kerning=[]},aT=/** @class */function(){function t(){}return(/**
     * Check if resource refers to txt font data.
     *
     * @static
     * @private
     * @param {any} data
     * @return {boolean} True if resource could be treated as font data, false otherwise.
     */t.test=function(t){return"string"==typeof t&&0===t.indexOf("info face=")},/**
     * Convert text font data to a javascript object.
     *
     * @static
     * @private
     * @param {string} txt - Raw string data to be converted
     * @return {PIXI.BitmapFontData} Parsed font data
     */t.parse=function(t){// Retrieve data item
var e=t.match(/^[a-z]+\s+.+$/gm),i={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[]};for(var r in e){// Extract item name
var n=e[r].match(/^[a-z]+/gm)[0],s=e[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),o={};for(var a in s){// Split key-value pairs
var h=s[a].split("="),l=h[0],u=h[1].replace(/"/gm,""),c=parseFloat(u),d=isNaN(c)?u:c;o[l]=d}// Push current item to the resulting data
i[n].push(o)}var p=new aE;return i.info.forEach(function(t){return p.info.push({face:t.face,size:parseInt(t.size,10)})}),i.common.forEach(function(t){return p.common.push({lineHeight:parseInt(t.lineHeight,10)})}),i.page.forEach(function(t){return p.page.push({id:parseInt(t.id,10),file:t.file})}),i.char.forEach(function(t){return p.char.push({id:parseInt(t.id,10),page:parseInt(t.page,10),x:parseInt(t.x,10),y:parseInt(t.y,10),width:parseInt(t.width,10),height:parseInt(t.height,10),xoffset:parseInt(t.xoffset,10),yoffset:parseInt(t.yoffset,10),xadvance:parseInt(t.xadvance,10)})}),i.kerning.forEach(function(t){return p.kerning.push({first:parseInt(t.first,10),second:parseInt(t.second,10),amount:parseInt(t.amount,10)})}),p},t)}(),aw=/** @class */function(){function t(){}return(/**
     * Check if resource refers to xml font data.
     *
     * @static
     * @private
     * @param {any} data
     * @return {boolean} True if resource could be treated as font data, false otherwise.
     */t.test=function(t){return t instanceof XMLDocument&&t.getElementsByTagName("page").length&&null!==t.getElementsByTagName("info")[0].getAttribute("face")},/**
     * Convert the XML into BitmapFontData that we can use.
     *
     * @static
     * @private
     * @param {XMLDocument} xml
     * @return {BitmapFontData} Data to use for BitmapFont
     */t.parse=function(t){for(var e=new aE,i=t.getElementsByTagName("info"),r=t.getElementsByTagName("common"),n=t.getElementsByTagName("page"),s=t.getElementsByTagName("char"),o=t.getElementsByTagName("kerning"),a=0;a<i.length;a++)e.info.push({face:i[a].getAttribute("face"),size:parseInt(i[a].getAttribute("size"),10)});for(var a=0;a<r.length;a++)e.common.push({lineHeight:parseInt(r[a].getAttribute("lineHeight"),10)});for(var a=0;a<n.length;a++)e.page.push({id:parseInt(n[a].getAttribute("id"),10)||0,file:n[a].getAttribute("file")});for(var a=0;a<s.length;a++){var h=s[a];e.char.push({id:parseInt(h.getAttribute("id"),10),page:parseInt(h.getAttribute("page"),10)||0,x:parseInt(h.getAttribute("x"),10),y:parseInt(h.getAttribute("y"),10),width:parseInt(h.getAttribute("width"),10),height:parseInt(h.getAttribute("height"),10),xoffset:parseInt(h.getAttribute("xoffset"),10),yoffset:parseInt(h.getAttribute("yoffset"),10),xadvance:parseInt(h.getAttribute("xadvance"),10)})}for(var a=0;a<o.length;a++)e.kerning.push({first:parseInt(o[a].getAttribute("first"),10),second:parseInt(o[a].getAttribute("second"),10),amount:parseInt(o[a].getAttribute("amount"),10)});return e},t)}(),aS=/** @class */function(){function t(){}return(/**
     * Check if resource refers to text xml font data.
     *
     * @static
     * @private
     * @param {any} data
     * @return {boolean} True if resource could be treated as font data, false otherwise.
     */t.test=function(t){if("string"==typeof t&&t.indexOf("<font>")>-1){var e=new self.DOMParser().parseFromString(t,"text/xml");return aw.test(e)}return!1},/**
     * Convert the text XML into BitmapFontData that we can use.
     *
     * @static
     * @private
     * @param {string} xmlTxt
     * @return {BitmapFontData} Data to use for BitmapFont
     */t.parse=function(t){var e=new self.DOMParser().parseFromString(t,"text/xml");return aw.parse(e)},t)}(),aM=[aT,aw,aS];/**
 * Auto-detect BitmapFont parsing format based on data.
 * @private
 * @param {any} data - Data to detect format
 * @return {any} Format or null
 */function aA(t){for(var e=0;e<aM.length;e++)if(aM[e].test(t))return aM[e];return null}/**
 * BitmapFont represents a typeface available for use with the BitmapText class. Use the `install`
 * method for adding a font to be used.
 *
 * @class
 * @memberof PIXI
 */var aR=/** @class */function(){/**
     * @param {PIXI.BitmapFontData} data
     * @param {PIXI.Texture[]|Object.<string, PIXI.Texture>} textures
     * @param {boolean} ownsTextures - Setting to `true` will destroy page textures
     *        when the font is uninstalled.
     */function t(t,e,i){var r=t.info[0],n=t.common[0],s=iI(t.page[0].file),o={};this._ownsTextures=i,/**
         * The name of the font face.
         *
         * @member {string}
         * @readonly
         */this.font=r.face,/**
         * The size of the font face in pixels.
         *
         * @member {number}
         * @readonly
         */this.size=r.size,/**
         * The line-height of the font face in pixels.
         *
         * @member {number}
         * @readonly
         */this.lineHeight=n.lineHeight/s,/**
         * The map of characters by character code.
         *
         * @member {object}
         * @readonly
         */this.chars={},/**
         * The map of base page textures (i.e., sheets of glyphs).
         *
         * @member {object}
         * @readonly
         * @private
         */this.pageTextures=o;// Convert the input Texture, Textures or object
// into a page Texture lookup by "id"
for(var a=0;a<t.page.length;a++){var h=t.page[a],l=h.id,u=h.file;o[l]=e instanceof Array?e[a]:e[u]}// parse letters
for(var a=0;a<t.char.length;a++){var c=t.char[a],l=c.id,d=c.page,p=t.char[a],f=p.x,m=p.y,g=p.width,y=p.height,_=p.xoffset,v=p.yoffset,x=p.xadvance;f/=s,m/=s,g/=s,y/=s,_/=s,v/=s,x/=s;var b=new iU(f+o[d].frame.x/s,m+o[d].frame.y/s,g,y);this.chars[l]={xOffset:_,yOffset:v,xAdvance:x,kerning:{},texture:new rH(o[d].baseTexture,b),page:d}}// parse kernings
for(var a=0;a<t.kerning.length;a++){var E=t.kerning[a],T=E.first,w=E.second,S=E.amount;T/=s,w/=s,S/=s,this.chars[w]&&(this.chars[w].kerning[T]=S)}}return(/**
     * Remove references to created glyph textures.
     */t.prototype.destroy=function(){for(var t in this.chars)this.chars[t].texture.destroy(),this.chars[t].texture=null;for(var t in this.pageTextures)this._ownsTextures&&this.pageTextures[t].destroy(!0),this.pageTextures[t]=null;// Set readonly null.
this.chars=null,this.pageTextures=null},/**
     * Register a new bitmap font.
     *
     * @static
     * @param {XMLDocument|string|PIXI.BitmapFontData} data - The
     *        characters map that could be provided as xml or raw string.
     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]}
     *        textures - List of textures for each page.
     * @param managedTexture - Set to `true` to destroy page textures
     *        when the font is uninstalled. By default fonts created with
     *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.
     * @return {PIXI.BitmapFont} Result font object with font, size, lineHeight
     *         and char fields.
     */t.install=function(e,i,r){if(e instanceof aE)n=e;else{var n,s=aA(e);if(!s)throw Error("Unrecognized data format for font.");n=s.parse(e)}i instanceof rH&&(i=[i]);var o=new t(n,i,r);return t.available[o.font]=o,o},/**
     * Remove bitmap font by name.
     *
     * @static
     * @param name - Name of the font to uninstall.
     */t.uninstall=function(e){var i=t.available[e];if(!i)throw Error("No font found named '"+e+"'");i.destroy(),delete t.available[e]},/**
     * Generates a bitmap-font for the given style and character set. This does not support
     * kernings yet. With `style` properties, only the following non-layout properties are used:
     *
     * - {@link PIXI.TextStyle#dropShadow|dropShadow}
     * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}
     * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}
     * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}
     * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}
     * - {@link PIXI.TextStyle#fill|fill}
     * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}
     * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}
     * - {@link PIXI.TextStyle#fontFamily|fontFamily}
     * - {@link PIXI.TextStyle#fontSize|fontSize}
     * - {@link PIXI.TextStyle#fontVariant|fontVariant}
     * - {@link PIXI.TextStyle#fontWeight|fontWeight}
     * - {@link PIXI.TextStyle#lineJoin|lineJoin}
     * - {@link PIXI.TextStyle#miterLimit|miterLimit}
     * - {@link PIXI.TextStyle#stroke|stroke}
     * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}
     * - {@link PIXI.TextStyle#textBaseline|textBaseline}
     *
     * @param {string} name - The name of the custom font to use with BitmapText.
     * @param {object|PIXI.TextStyle} [style] - Style options to render with BitmapFont.
     * @param {PIXI.IBitmapFontOptions} [options] - Setup options for font or name of the font.
     * @param {string|string[]|string[][]} [options.chars=PIXI.BitmapFont.ALPHANUMERIC] - characters included
     *      in the font set. You can also use ranges. For example, `[['a', 'z'], ['A', 'Z'], "!@#$%^&*()~{}[] "]`.
     *      Don't forget to include spaces ' ' in your character set!
     * @param {number} [options.resolution=1] - Render resolution for glyphs.
     * @param {number} [options.textureWidth=512] - Optional width of atlas, smaller values to reduce memory.
     * @param {number} [options.textureHeight=512] - Optional height of atlas, smaller values to reduce memory.
     * @param {number} [options.padding=4] - Padding between glyphs on texture atlas.
     * @return {PIXI.BitmapFont} Font generated by style options.
     * @static
     * @example
     * PIXI.BitmapFont.from("TitleFont", {
     *     fontFamily: "Arial",
     *     fontSize: 12,
     *     strokeThickness: 2,
     *     fill: "purple"
     * });
     *
     * const title = new PIXI.BitmapText("This is the title", { fontName: "TitleFont" });
     */t.from=function(e,i,r){if(!e)throw Error("[BitmapFont] Property `name` is required.");var n,s,o,a=Object.assign({},t.defaultOptions,r),h=a.chars,l=a.padding,u=a.resolution,c=a.textureWidth,d=a.textureHeight,p=/**
 * Processes the passed character set data and returns a flattened array of all the characters.
 *
 * Ignored because not directly exposed.
 *
 * @ignore
 * @param {string | string[] | string[][] } chars
 * @returns {string[]}
 */function(t){// Split the chars string into individual characters
"string"==typeof t&&(t=[t]);for(var e=[],i=0,r=t.length;i<r;i++){var n=t[i];// Handle range delimited by start/end chars
if(Array.isArray(n)){if(2!==n.length)throw Error("[BitmapFont]: Invalid character range length, expecting 2 got "+n.length+".");var s=n[0].charCodeAt(0),o=n[1].charCodeAt(0);if(o<s)throw Error("[BitmapFont]: Invalid character range.");for(var a=s;a<=o;a++)e.push(String.fromCharCode(a))}else e.push.apply(e,n.split(""))}if(0===e.length)throw Error("[BitmapFont]: Empty set when resolving characters.");return e}(h),f=i instanceof oH?i:new oH(i),m=new aE;m.info[0]={face:f.fontFamily,size:f.fontSize},m.common[0]={lineHeight:f.fontSize};for(var g=0,y=0,_=0,v=[],x=0;x<p.length;x++){n||((n=document.createElement("canvas")).width=c,n.height=d,s=n.getContext("2d"),o=new rS(n,{resolution:u}),v.push(new rH(o)),m.page.push({id:v.length-1,file:""}));// Measure glyph dimensions
var b=oX.measureText(p[x],f,!1,n),E=b.width,T=Math.ceil(b.height),w=Math.ceil(("italic"===f.fontStyle?2:1)*E);// Can't fit char anymore: next canvas please!
if(y>=d-T*u){if(0===y)throw Error("[BitmapFont] textureHeight "+d+"px is too small for "+f.fontSize+"px fonts");--x,// Create new atlas once current has filled up
n=null,s=null,o=null,y=0,g=0,_=0;continue}// Wrap line once full row has been rendered
if(_=Math.max(T+b.fontProperties.descent,_),w*u+g>=c){--x,y+=_*u,y=Math.ceil(y),g=0,_=0;continue}!// TODO: Prevent code duplication b/w drawGlyph & Text#updateText
/**
 * Draws the glyph `metrics.text` on the given canvas.
 *
 * Ignored because not directly exposed.
 *
 * @ignore
 * @param {HTMLCanvasElement} canvas
 * @param {CanvasRenderingContext2D} context
 * @param {TextMetrics} metrics
 * @param {number} x
 * @param {number} y
 * @param {number} resolution
 * @param {TextStyle} style
 */function(t,e,i,r,n,s,o){var a=i.text,h=i.fontProperties;e.translate(r,n),e.scale(s,s);var l=o.strokeThickness/2,u=-(o.strokeThickness/2);e.font=o.toFontString(),e.lineWidth=o.strokeThickness,e.textBaseline=o.textBaseline,e.lineJoin=o.lineJoin,e.miterLimit=o.miterLimit,// set canvas text styles
e.fillStyle=// TODO: Prevent code duplication b/w generateFillStyle & Text#generateFillStyle
/**
 * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
 *
 * @private
 * @param {object} style - The style.
 * @param {string[]} lines - The lines of text.
 * @return {string|number|CanvasGradient} The fill style
 */function(t,e,i,r,n,s){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
//       the setter converts to string. See this thread for more details:
//       https://github.com/microsoft/TypeScript/issues/2521
var o,a=i.fill;if(!Array.isArray(a))return a;if(1===a.length)return a[0];// a dropshadow will enlarge the canvas and result in the gradient being
// generated with the incorrect dimensions
var h=i.dropShadow?i.dropShadowDistance:0,l=i.padding||0,u=t.width/r-h-2*l,c=t.height/r-h-2*l,d=a.slice(),p=i.fillGradientStops.slice();// wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
if(!p.length)for(var f=d.length+1,m=1;m<f;++m)p.push(m/f);if(// stop the bleeding of the last gradient on the line above to the top gradient of the this line
// by hard defining the first gradient colour at point 0, and last gradient colour at point 1
d.unshift(a[0]),p.unshift(0),d.push(a[a.length-1]),p.push(1),i.fillGradientType===bx.LINEAR_VERTICAL){// start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
o=e.createLinearGradient(u/2,l,u/2,c+l);for(var g=0,y=(s.fontProperties.fontSize+i.strokeThickness)/c,m=0;m<n.length;m++)for(var _=s.lineHeight*m,v=0;v<d.length;v++){// 0-1 stop point for the current line, multiplied to global space afterwards
var x=Math.max(g,_/c+("number"==typeof p[v]?p[v]:v/d.length)*y);x=Math.min(x,1),o.addColorStop(x,d[v]),g=x}}else{// start the gradient at the center left of the canvas, and end at the center right of the canvas
o=e.createLinearGradient(l,c/2,u+l,c/2);for(var b=d.length+1,E=1,m=0;m<d.length;m++){var T=void 0;T="number"==typeof p[m]?p[m]:E/b,o.addColorStop(T,d[m]),E++}}return o}(t,e,o,s,[a],i),e.strokeStyle=o.stroke;var c=o.dropShadowColor,d=e8("number"==typeof c?c:e9(c));o.dropShadow?(e.shadowColor="rgba("+255*d[0]+","+255*d[1]+","+255*d[2]+","+o.dropShadowAlpha+")",e.shadowBlur=o.dropShadowBlur,e.shadowOffsetX=Math.cos(o.dropShadowAngle)*o.dropShadowDistance,e.shadowOffsetY=Math.sin(o.dropShadowAngle)*o.dropShadowDistance):(e.shadowColor="black",e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0),o.stroke&&o.strokeThickness&&e.strokeText(a,l,u+i.lineHeight-h.descent),o.fill&&e.fillText(a,l,u+i.lineHeight-h.descent),e.setTransform(1,0,0,1,0,0),e.fillStyle="rgba(0, 0, 0, 0)"}(n,s,b,g,y,u,f);// Unique (numeric) ID mapping to this glyph
var S=b.text.charCodeAt(0);// Create a texture holding just the glyph
m.char.push({id:S,page:v.length-1,x:g/u,y:y/u,width:w,height:T,xoffset:0,yoffset:0,xadvance:Math.ceil(E-(f.dropShadow?f.dropShadowDistance:0)-(f.stroke?f.strokeThickness:0))}),g+=(w+2*l)*u,g=Math.ceil(g)}// Brute-force kerning info, this can be expensive b/c it's an O(n),
// but we're using measureText which is native and fast.
for(var x=0,M=p.length;x<M;x++)for(var A=p[x],R=0;R<M;R++){var C=p[R],P=s.measureText(A).width,I=s.measureText(C).width,O=s.measureText(A+C).width-(P+I);O&&m.kerning.push({first:A.charCodeAt(0),second:C.charCodeAt(0),amount:O})}var L=new t(m,v,!0);return void 0!==t.available[e]&&t.uninstall(e),t.available[e]=L,L},/**
     * This character set includes all the letters in the alphabet (both lower- and upper- case).
     * @readonly
     * @static
     * @member {string[][]}
     * @example
     * BitmapFont.from("ExampleFont", style, { chars: BitmapFont.ALPHA })
     */t.ALPHA=[["a","z"],["A","Z"]," "],/**
     * This character set includes all decimal digits (from 0 to 9).
     * @readonly
     * @static
     * @member {string[][]}
     * @example
     * BitmapFont.from("ExampleFont", style, { chars: BitmapFont.NUMERIC })
     */t.NUMERIC=[["0","9"]],/**
     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.
     * @readonly
     * @static
     * @member {string[][]}
     */t.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],/**
     * This character set consists of all the ASCII table.
     * @readonly
     * @static
     * @member {string[][]}
     * @see http://www.asciitable.com/
     */t.ASCII=[[" ","~"]],/**
     * Collection of default options when using `BitmapFont.from`.
     *
     * @readonly
     * @static
     * @member {PIXI.IBitmapFontOptions}
     * @property {number} resolution=1
     * @property {number} textureWidth=512
     * @property {number} textureHeight=512
     * @property {number} padding=4
     * @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC
     */t.defaultOptions={resolution:1,textureWidth:512,textureHeight:512,padding:4,chars:t.ALPHANUMERIC},/**
     * Collection of available/installed fonts.
     *
     * @readonly
     * @static
     * @member {Object.<string, PIXI.BitmapFont>}
     */t.available={},t)}(),aC=[],aP=[],aI=/** @class */function(t){/**
     * @param {string} text - A string that you would like the text to display.
     * @param {object} style - The style parameters.
     * @param {string} style.fontName - The installed BitmapFont name.
     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,
     *.     this will default to the BitmapFont size.
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),
     *      does not affect single line text.
     * @param {number} [style.tint=0xFFFFFF] - The tint color.
     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.
     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.
     */function e(i,r){void 0===r&&(r={});var n=t.call(this)||this;n._tint=16777215;// Apply the defaults
var s=Object.assign({},e.styleDefaults,r),o=s.align,a=s.tint,h=s.maxWidth,l=s.letterSpacing,u=s.fontName,c=s.fontSize;if(!aR.available[u])throw Error('Missing BitmapFont "'+u+'"');return(/**
         * Collection of page mesh data.
         *
         * @member {object}
         * @private
         */n._activePagesMeshData=[],/**
         * Private tracker for the width of the overall text
         *
         * @member {number}
         * @private
         */n._textWidth=0,/**
         * Private tracker for the height of the overall text
         *
         * @member {number}
         * @private
         */n._textHeight=0,/**
         * Private tracker for the current text align.
         *
         * @member {string}
         * @private
         */n._align=o,/**
         * Private tracker for the current tint.
         *
         * @member {number}
         * @private
         */n._tint=a,/**
         * Private tracker for the current font name.
         *
         * @member {string}
         * @private
         */n._fontName=u,/**
         * Private tracker for the current font size.
         *
         * @member {number}
         * @private
         */n._fontSize=c||aR.available[u].size,/**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */n._text=i,/**
         * The max width of this bitmap text in pixels. If the text provided is longer than the
         * value provided, line breaks will be automatically inserted in the last whitespace.
         * Disable by setting value to 0
         *
         * @member {number}
         * @private
         */n._maxWidth=h,/**
         * The max line height. This is useful when trying to use the total height of the Text,
         * ie: when trying to vertically align. (Internally used)
         *
         * @member {number}
         * @private
         */n._maxLineHeight=0,/**
         * Letter spacing. This is useful for setting the space between characters.
         * @member {number}
         * @private
         */n._letterSpacing=l,/**
         * Text anchor. read-only
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */n._anchor=new iV(function(){n.dirty=!0},n,0,0),/**
         * If true PixiJS will Math.floor() x/y values when rendering
         *
         * @member {boolean}
         * @default PIXI.settings.ROUND_PIXELS
         */n._roundPixels=ec.ROUND_PIXELS,/**
         * Set to `true` if the BitmapText needs to be redrawn.
         *
         * @member {boolean}
         */n.dirty=!0,/**
         * Cached char texture is destroyed when BitmapText is destroyed
         * @member {Record<number, Texture>}
         * @private
         */n._textureCache={},n)}return!function(t,e){function i(){this.constructor=t}ab(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Renders text and updates it when needed. This should only be called
     * if the BitmapFont is regenerated.
     */e.prototype.updateText=function(){for(var t,e=aR.available[this._fontName],i=this._fontSize/e.size,r=new ij,n=[],s=[],o=[],a=this._text.replace(/(?:\r\n|\r)/g,"\n")||" ",h=a.length,l=this._maxWidth*e.size/this._fontSize,u=null,c=0,d=0,p=0,f=-1,m=0,g=0,y=0,_=0,v=0;v<h;v++){var x=a.charCodeAt(v),b=a.charAt(v);if(/(?:\s)/.test(b)&&(f=v,m=c,_++),"\r"===b||"\n"===b){s.push(c),o.push(-1),d=Math.max(d,c),++p,++g,r.x=0,r.y+=e.lineHeight,u=null,_=0;continue}var E=e.chars[x];if(E){u&&E.kerning[u]&&(r.x+=E.kerning[u]);var T=aP.pop()||{texture:rH.EMPTY,line:0,charCode:0,prevSpaces:0,position:new ij};T.texture=E.texture,T.line=p,T.charCode=x,T.position.x=r.x+E.xOffset+this._letterSpacing/2,T.position.y=r.y+E.yOffset,T.prevSpaces=_,n.push(T),c=T.position.x+E.texture.orig.width,r.x+=E.xAdvance+this._letterSpacing,y=Math.max(y,E.yOffset+E.texture.height),u=x,-1!==f&&l>0&&r.x>l&&(im(n,1+f-++g,1+v-f),v=f,f=-1,s.push(m),o.push(n.length>0?n[n.length-1].prevSpaces:0),d=Math.max(d,m),p++,r.x=0,r.y+=e.lineHeight,u=null,_=0)}}var w=a.charAt(a.length-1);"\r"!==w&&"\n"!==w&&(/(?:\s)/.test(w)&&(c=m),s.push(c),d=Math.max(d,c),o.push(-1));for(var S=[],v=0;v<=p;v++){var M=0;"right"===this._align?M=d-s[v]:"center"===this._align?M=(d-s[v])/2:"justify"===this._align&&(M=o[v]<0?0:(d-s[v])/o[v]),S.push(M)}for(var A=n.length,R={},C=[],P=this._activePagesMeshData,v=0;v<P.length;v++)aC.push(P[v]);for(var v=0;v<A;v++){var I=n[v].texture,O=I.baseTexture.uid;if(!R[O]){var L=aC.pop();if(!L){var N=new ax,D=new av(rH.EMPTY);L={index:0,indexCount:0,vertexCount:0,uvsCount:0,total:0,mesh:new a_(N,D),vertices:null,uvs:null,indices:null}}// reset data..
L.index=0,L.indexCount=0,L.vertexCount=0,L.uvsCount=0,L.total=0;// TODO need to get page texture here somehow..
var F=this._textureCache;F[O]=F[O]||new rH(I.baseTexture),L.mesh.texture=F[O],L.mesh.tint=this._tint,C.push(L),R[O]=L}R[O].total++}// lets find any previously active pageMeshDatas that are no longer required for
// the updated text (if any), removed and return them to the pool.
for(var v=0;v<P.length;v++)-1===C.indexOf(P[v])&&this.removeChild(P[v].mesh);// next lets add any new meshes, that have not yet been added to this BitmapText
// we only add if its not already a child of this BitmapObject
for(var v=0;v<C.length;v++)C[v].mesh.parent!==this&&this.addChild(C[v].mesh);for(var v in // active page mesh datas are set to be the new pages added.
this._activePagesMeshData=C,R){var L=R[v],B=L.total;// lets only allocate new buffers if we can fit the new text in the current ones..
// unless that is, we will be batching. Currently batching dose not respect the size property of mesh
if(!((null===(t=L.indices)||void 0===t?void 0:t.length)>6*B)||L.vertices.length<2*a_.BATCHABLE_SIZE)L.vertices=new Float32Array(8*B),L.uvs=new Float32Array(8*B),L.indices=new Uint16Array(6*B);else // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.
for(var U=L.total,G=L.vertices,k=8*U;k<G.length;k++)G[k]=0;// as a buffer maybe bigger than the current word, we set the size of the meshMaterial
// to match the number of letters needed
L.mesh.size=6*B}for(var v=0;v<A;v++){var b=n[v],H=b.position.x+S[b.line]*("justify"===this._align?b.prevSpaces:1);this._roundPixels&&(H=Math.round(H));var z=H*i,j=b.position.y*i,I=b.texture,V=R[I.baseTexture.uid],X=I.frame,W=I._uvs,Y=V.index++;V.indices[6*Y+0]=0+4*Y,V.indices[6*Y+1]=1+4*Y,V.indices[6*Y+2]=2+4*Y,V.indices[6*Y+3]=0+4*Y,V.indices[6*Y+4]=2+4*Y,V.indices[6*Y+5]=3+4*Y,V.vertices[8*Y+0]=z,V.vertices[8*Y+1]=j,V.vertices[8*Y+2]=z+X.width*i,V.vertices[8*Y+3]=j,V.vertices[8*Y+4]=z+X.width*i,V.vertices[8*Y+5]=j+X.height*i,V.vertices[8*Y+6]=z,V.vertices[8*Y+7]=j+X.height*i,V.uvs[8*Y+0]=W.x0,V.uvs[8*Y+1]=W.y0,V.uvs[8*Y+2]=W.x1,V.uvs[8*Y+3]=W.y1,V.uvs[8*Y+4]=W.x2,V.uvs[8*Y+5]=W.y2,V.uvs[8*Y+6]=W.x3,V.uvs[8*Y+7]=W.y3}for(var v in this._textWidth=d*i,this._textHeight=(r.y+e.lineHeight)*i,R){var L=R[v];// apply anchor
if(0!==this.anchor.x||0!==this.anchor.y)for(var q=0,K=this._textWidth*this.anchor.x,J=this._textHeight*this.anchor.y,Z=0;Z<L.total;Z++)L.vertices[q++]-=K,L.vertices[q++]-=J,L.vertices[q++]-=K,L.vertices[q++]-=J,L.vertices[q++]-=K,L.vertices[q++]-=J,L.vertices[q++]-=K,L.vertices[q++]-=J;this._maxLineHeight=y*i;var $=L.mesh.geometry.getBuffer("aVertexPosition"),Q=L.mesh.geometry.getBuffer("aTextureCoord"),tt=L.mesh.geometry.getIndex();$.data=L.vertices,Q.data=L.uvs,tt.data=L.indices,$.update(),Q.update(),tt.update()}for(var v=0;v<n.length;v++)aP.push(n[v])},/**
     * Updates the transform of this object
     *
     * @private
     */e.prototype.updateTransform=function(){this.validate(),this.containerUpdateTransform()},/**
     * Validates text before calling parent's getLocalBounds
     *
     * @return {PIXI.Rectangle} The rectangular bounding area
     */e.prototype.getLocalBounds=function(){return this.validate(),t.prototype.getLocalBounds.call(this)},/**
     * Updates text when needed
     *
     * @private
     */e.prototype.validate=function(){this.dirty&&(this.updateText(),this.dirty=!1)},Object.defineProperty(e.prototype,"tint",{/**
         * The tint of the BitmapText object.
         *
         * @member {number}
         * @default 0xffffff
         */get:function(){return this._tint},set:function(t){if(this._tint!==t){this._tint=t;for(var e=0;e<this._activePagesMeshData.length;e++)this._activePagesMeshData[e].mesh.tint=t}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"align",{/**
         * The alignment of the BitmapText object.
         *
         * @member {string}
         * @default 'left'
         */get:function(){return this._align},set:function(t){this._align!==t&&(this._align=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"fontName",{/**
         * The name of the BitmapFont.
         *
         * @member {string}
         */get:function(){return this._fontName},set:function(t){if(!aR.available[t])throw Error('Missing BitmapFont "'+t+'"');this._fontName!==t&&(this._fontName=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"fontSize",{/**
         * The size of the font to display.
         *
         * @member {number}
         */get:function(){return this._fontSize},set:function(t){this._fontSize!==t&&(this._fontSize=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"anchor",{/**
         * The anchor sets the origin point of the text.
         *
         * The default is `(0,0)`, this means the text's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
         *
         * @member {PIXI.Point | number}
         */get:function(){return this._anchor},set:function(t){"number"==typeof t?this._anchor.set(t):this._anchor.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"text",{/**
         * The text of the BitmapText object.
         *
         * @member {string}
         */get:function(){return this._text},set:function(t){t=String(null==t?"":t),this._text!==t&&(this._text=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"maxWidth",{/**
         * The max width of this bitmap text in pixels. If the text provided is longer than the
         * value provided, line breaks will be automatically inserted in the last whitespace.
         * Disable by setting the value to 0.
         *
         * @member {number}
         */get:function(){return this._maxWidth},set:function(t){this._maxWidth!==t&&(this._maxWidth=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"maxLineHeight",{/**
         * The max line height. This is useful when trying to use the total height of the Text,
         * i.e. when trying to vertically align.
         *
         * @member {number}
         * @readonly
         */get:function(){return this.validate(),this._maxLineHeight},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"textWidth",{/**
         * The width of the overall text, different from fontSize,
         * which is defined in the style object.
         *
         * @member {number}
         * @readonly
         */get:function(){return this.validate(),this._textWidth},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"letterSpacing",{/**
         * Additional space between characters.
         *
         * @member {number}
         */get:function(){return this._letterSpacing},set:function(t){this._letterSpacing!==t&&(this._letterSpacing=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"roundPixels",{/**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
         *
         * @member {boolean}
         * @default PIXI.settings.ROUND_PIXELS
         */get:function(){return this._roundPixels},set:function(t){t!==this._roundPixels&&(this._roundPixels=t,this.dirty=!0)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"textHeight",{/**
         * The height of the overall text, different from fontSize,
         * which is defined in the style object.
         *
         * @member {number}
         * @readonly
         */get:function(){return this.validate(),this._textHeight},enumerable:!1,configurable:!0}),e.prototype.destroy=function(e){var i=this._textureCache;for(var r in i)i[r].destroy(),delete i[r];this._textureCache=null,t.prototype.destroy.call(this,e)},e.styleDefaults={align:"left",tint:16777215,maxWidth:0,letterSpacing:0},e}(i8),aO=/** @class */function(){function t(){}return(/**
     * Called when the plugin is installed.
     *
     * @see PIXI.Loader.registerPlugin
     */t.add=function(){sO.setExtensionXhrType("fnt",sO.XHR_RESPONSE_TYPE.TEXT)},/**
     * Called after a resource is loaded.
     * @see PIXI.Loader.loaderMiddleware
     * @param {PIXI.LoaderResource} resource
     * @param {function} next
     */t.use=function(e,i){var r=aA(e.data);// Resource was not recognised as any of the expected font data format
if(!r){i();return}for(var n=t.getBaseUrl(this,e),s=r.parse(e.data),o={},a=function(t){o[t.metadata.pageFile]=t.texture,Object.keys(o).length===s.page.length&&(e.bitmapFont=aR.install(s,o,!0),i())},h=0;h<s.page.length;++h){var l=s.page[h].file,u=n+l,c=!1;// incase the image is loaded outside
// using the same loader, resource will be available
for(var d in this.resources){var p=this.resources[d];if(p.url===u){p.metadata.pageFile=l,p.texture?a(p):p.onAfterMiddleware.add(a),c=!0;break}}// texture is not loaded, we'll attempt to add
// it to the load and add the texture to the list
if(!c){// Standard loading options for images
var f={crossOrigin:e.crossOrigin,loadType:sO.LOAD_TYPE.IMAGE,metadata:Object.assign({pageFile:l},e.metadata.imageMetadata),parentResource:e};this.add(u,f,a)}}},/**
     * Get folder path from a resource
     * @private
     * @param {PIXI.Loader} loader
     * @param {PIXI.LoaderResource} resource
     * @return {string}
     */t.getBaseUrl=function(e,i){var r=i.isDataUrl?"":t.dirname(i.url);return i.isDataUrl&&("."===r&&(r=""),e.baseUrl&&r&&"/"===e.baseUrl.charAt(e.baseUrl.length-1)&&(r+="/")),// remove baseUrl from resUrl
(r=r.replace(e.baseUrl,""))&&"/"!==r.charAt(r.length-1)&&(r+="/"),r},/**
     * Replacement for NodeJS's path.dirname
     * @private
     * @param {string} url - Path to get directory for
     */t.dirname=function(t){var e=t.replace(/\\/g,"/")// convert windows notation to UNIX notation, URL-safe because it's a forbidden character
.replace(/\/$/,"")// replace trailing slash
.replace(/\/[^\/]*$/,"");// remove everything after the last
return(// File request is relative, use current directory
e===t?".":""===e?"/":e)},t)}(),aL=function(t,e){return(aL=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aN=/** @class */function(t){/**
     * @param {number} [alpha=1] - Amount of alpha from 0 to 1, where 0 is transparent
     */function e(e){void 0===e&&(e=1);var i=t.call(this,n9,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n",{uAlpha:1})||this;return i.alpha=e,i}return!function(t,e){function i(){this.constructor=t}aL(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),Object.defineProperty(e.prototype,"alpha",{/**
         * Coefficient for alpha multiplication
         *
         * @member {number}
         * @default 1
         */get:function(){return this.uniforms.uAlpha},set:function(t){this.uniforms.uAlpha=t},enumerable:!1,configurable:!0}),e}(nR),aD=function(t,e){return(aD=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function aF(t,e){function i(){this.constructor=t}aD(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var aB={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]};(vE=bb||(bb={}))[vE.WEBGL_LEGACY=0]="WEBGL_LEGACY",vE[vE.WEBGL=1]="WEBGL",vE[vE.WEBGL2=2]="WEBGL2",(vT=bE||(bE={}))[vT.UNKNOWN=0]="UNKNOWN",vT[vT.WEBGL=1]="WEBGL",vT[vT.CANVAS=2]="CANVAS",(vw=bT||(bT={}))[vw.COLOR=16384]="COLOR",vw[vw.DEPTH=256]="DEPTH",vw[vw.STENCIL=1024]="STENCIL",(vS=bw||(bw={}))[vS.NORMAL=0]="NORMAL",vS[vS.ADD=1]="ADD",vS[vS.MULTIPLY=2]="MULTIPLY",vS[vS.SCREEN=3]="SCREEN",vS[vS.OVERLAY=4]="OVERLAY",vS[vS.DARKEN=5]="DARKEN",vS[vS.LIGHTEN=6]="LIGHTEN",vS[vS.COLOR_DODGE=7]="COLOR_DODGE",vS[vS.COLOR_BURN=8]="COLOR_BURN",vS[vS.HARD_LIGHT=9]="HARD_LIGHT",vS[vS.SOFT_LIGHT=10]="SOFT_LIGHT",vS[vS.DIFFERENCE=11]="DIFFERENCE",vS[vS.EXCLUSION=12]="EXCLUSION",vS[vS.HUE=13]="HUE",vS[vS.SATURATION=14]="SATURATION",vS[vS.COLOR=15]="COLOR",vS[vS.LUMINOSITY=16]="LUMINOSITY",vS[vS.NORMAL_NPM=17]="NORMAL_NPM",vS[vS.ADD_NPM=18]="ADD_NPM",vS[vS.SCREEN_NPM=19]="SCREEN_NPM",vS[vS.NONE=20]="NONE",vS[vS.SRC_OVER=0]="SRC_OVER",vS[vS.SRC_IN=21]="SRC_IN",vS[vS.SRC_OUT=22]="SRC_OUT",vS[vS.SRC_ATOP=23]="SRC_ATOP",vS[vS.DST_OVER=24]="DST_OVER",vS[vS.DST_IN=25]="DST_IN",vS[vS.DST_OUT=26]="DST_OUT",vS[vS.DST_ATOP=27]="DST_ATOP",vS[vS.ERASE=26]="ERASE",vS[vS.SUBTRACT=28]="SUBTRACT",vS[vS.XOR=29]="XOR",(vM=bS||(bS={}))[vM.POINTS=0]="POINTS",vM[vM.LINES=1]="LINES",vM[vM.LINE_LOOP=2]="LINE_LOOP",vM[vM.LINE_STRIP=3]="LINE_STRIP",vM[vM.TRIANGLES=4]="TRIANGLES",vM[vM.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",vM[vM.TRIANGLE_FAN=6]="TRIANGLE_FAN",(vA=bM||(bM={}))[vA.RGBA=6408]="RGBA",vA[vA.RGB=6407]="RGB",vA[vA.RG=33319]="RG",vA[vA.RED=6403]="RED",vA[vA.RGBA_INTEGER=36249]="RGBA_INTEGER",vA[vA.RGB_INTEGER=36248]="RGB_INTEGER",vA[vA.RG_INTEGER=33320]="RG_INTEGER",vA[vA.RED_INTEGER=36244]="RED_INTEGER",vA[vA.ALPHA=6406]="ALPHA",vA[vA.LUMINANCE=6409]="LUMINANCE",vA[vA.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",vA[vA.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",vA[vA.DEPTH_STENCIL=34041]="DEPTH_STENCIL",(vR=bA||(bA={}))[vR.TEXTURE_2D=3553]="TEXTURE_2D",vR[vR.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",vR[vR.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",vR[vR.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",vR[vR.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",vR[vR.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",vR[vR.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",vR[vR.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",vR[vR.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",(vC=bR||(bR={}))[vC.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",vC[vC.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",vC[vC.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",vC[vC.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",vC[vC.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",vC[vC.UNSIGNED_INT=5125]="UNSIGNED_INT",vC[vC.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",vC[vC.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",vC[vC.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",vC[vC.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",vC[vC.BYTE=5120]="BYTE",vC[vC.SHORT=5122]="SHORT",vC[vC.INT=5124]="INT",vC[vC.FLOAT=5126]="FLOAT",vC[vC.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",vC[vC.HALF_FLOAT=36193]="HALF_FLOAT",(vP=bC||(bC={}))[vP.FLOAT=0]="FLOAT",vP[vP.INT=1]="INT",vP[vP.UINT=2]="UINT",(vI=bP||(bP={}))[vI.NEAREST=0]="NEAREST",vI[vI.LINEAR=1]="LINEAR",(vO=bI||(bI={}))[vO.CLAMP=33071]="CLAMP",vO[vO.REPEAT=10497]="REPEAT",vO[vO.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",(vL=bO||(bO={}))[vL.OFF=0]="OFF",vL[vL.POW2=1]="POW2",vL[vL.ON=2]="ON",vL[vL.ON_MANUAL=3]="ON_MANUAL",(vN=bL||(bL={}))[vN.NPM=0]="NPM",vN[vN.UNPACK=1]="UNPACK",vN[vN.PMA=2]="PMA",vN[vN.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",vN[vN.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",vN[vN.PREMULTIPLY_ALPHA=2]="PREMULTIPLY_ALPHA",(vD=bN||(bN={}))[vD.NO=0]="NO",vD[vD.YES=1]="YES",vD[vD.AUTO=2]="AUTO",vD[vD.BLEND=0]="BLEND",vD[vD.CLEAR=1]="CLEAR",vD[vD.BLIT=2]="BLIT",(vF=bD||(bD={}))[vF.AUTO=0]="AUTO",vF[vF.MANUAL=1]="MANUAL",(vB=bF||(bF={})).LOW="lowp",vB.MEDIUM="mediump",vB.HIGH="highp",(vU=bB||(bB={}))[vU.NONE=0]="NONE",vU[vU.SCISSOR=1]="SCISSOR",vU[vU.STENCIL=2]="STENCIL",vU[vU.SPRITE=3]="SPRITE",(vG=bU||(bU={}))[vG.NONE=0]="NONE",vG[vG.LOW=2]="LOW",vG[vG.MEDIUM=4]="MEDIUM",vG[vG.HIGH=8]="HIGH",(vk=bG||(bG={}))[vk.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",vk[vk.ARRAY_BUFFER=34962]="ARRAY_BUFFER",// NOT YET SUPPORTED
vk[vk.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER";/**
 * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 */var aU=/** @class */function(t){/**
     * @param {boolean} horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
     * @param {number} [strength=8] - The strength of the blur filter.
     * @param {number} [quality=4] - The quality of the blur filter.
     * @param {number} [resolution=PIXI.settings.FILTER_RESOLUTION] - The resolution of the blur filter.
     * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */function e(e,i,r,n,s){void 0===i&&(i=8),void 0===r&&(r=4),void 0===n&&(n=ec.FILTER_RESOLUTION),void 0===s&&(s=5);var o=this,a=function(t,e){var i,r=Math.ceil(t/2),n="\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",s="";i=e?"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);":"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";for(var o=0;o<t;o++){var a=i.replace("%index%",o.toString());s+=(a=a.replace("%sampleIndex%",o-(r-1)+".0"))+"\n"}return(n=n.replace("%blur%",s)).replace("%size%",t.toString())}(s,e),h=function(t){for(var e,i=aB[t],r=i.length,n="varying vec2 vBlurTexCoords[%size%];\nuniform sampler2D uSampler;\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n    %blur%\n}",s="",o=0;o<t;o++){var a="gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%",o.toString());e=o,o>=r&&(e=t-o-1),s+=(a=a.replace("%value%",i[e].toString()))+"\n"}return(n=n.replace("%blur%",s)).replace("%size%",t.toString())}(s);return(o=t.call(this,a,h)||this).horizontal=e,o.resolution=n,o._quality=0,o.quality=r,o.blur=i,o}return aF(e,t),/**
     * Applies the filter.
     *
     * @param {PIXI.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     * @param {PIXI.CLEAR_MODES} clearMode - How to clear
     */e.prototype.apply=function(t,e,i,r){if(i?this.horizontal?this.uniforms.strength=1/i.width*(i.width/e.width):this.uniforms.strength=1/i.height*(i.height/e.height):this.horizontal?this.uniforms.strength=1/t.renderer.width*(t.renderer.width/e.width):this.uniforms.strength=1/t.renderer.height*(t.renderer.height/e.height),// screen space!
this.uniforms.strength*=this.strength,this.uniforms.strength/=this.passes,1===this.passes)t.applyFilter(this,e,i,r);else{var n=t.getFilterTexture(),s=t.renderer,o=e,a=n;this.state.blend=!1,t.applyFilter(this,o,a,bN.CLEAR);for(var h=1;h<this.passes-1;h++){t.bindAndClear(o,bN.BLIT),this.uniforms.uSampler=a;var l=a;a=o,o=l,s.shader.bind(this),s.geometry.draw(5)}this.state.blend=!0,t.applyFilter(this,a,i,r),t.returnFilterTexture(n)}},Object.defineProperty(e.prototype,"blur",{/**
         * Sets the strength of both the blur.
         *
         * @member {number}
         * @default 16
         */get:function(){return this.strength},set:function(t){this.padding=1+2*Math.abs(t),this.strength=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"quality",{/**
         * Sets the quality of the blur by modifying the number of passes. More passes means higher
         * quality bluring but the lower the performance.
         *
         * @member {number}
         * @default 4
         */get:function(){return this._quality},set:function(t){this._quality=t,this.passes=t},enumerable:!1,configurable:!0}),e}(nR),aG=/** @class */function(t){/**
     * @param {number} [strength=8] - The strength of the blur filter.
     * @param {number} [quality=4] - The quality of the blur filter.
     * @param {number} [resolution=PIXI.settings.FILTER_RESOLUTION] - The resolution of the blur filter.
     * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
     */function e(e,i,r,n){void 0===e&&(e=8),void 0===i&&(i=4),void 0===r&&(r=ec.FILTER_RESOLUTION),void 0===n&&(n=5);var s=t.call(this)||this;return s.blurXFilter=new aU(!0,e,i,r,n),s.blurYFilter=new aU(!1,e,i,r,n),s.resolution=r,s.quality=i,s.blur=e,s.repeatEdgePixels=!1,s}return aF(e,t),/**
     * Applies the filter.
     *
     * @param {PIXI.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     * @param {PIXI.CLEAR_MODES} clearMode - How to clear
     */e.prototype.apply=function(t,e,i,r){var n=Math.abs(this.blurXFilter.strength),s=Math.abs(this.blurYFilter.strength);if(n&&s){var o=t.getFilterTexture();this.blurXFilter.apply(t,e,o,bN.CLEAR),this.blurYFilter.apply(t,o,i,r),t.returnFilterTexture(o)}else s?this.blurYFilter.apply(t,e,i,r):this.blurXFilter.apply(t,e,i,r)},e.prototype.updatePadding=function(){this._repeatEdgePixels?this.padding=0:this.padding=2*Math.max(Math.abs(this.blurXFilter.strength),Math.abs(this.blurYFilter.strength))},Object.defineProperty(e.prototype,"blur",{/**
         * Sets the strength of both the blurX and blurY properties simultaneously
         *
         * @member {number}
         * @default 2
         */get:function(){return this.blurXFilter.blur},set:function(t){this.blurXFilter.blur=this.blurYFilter.blur=t,this.updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"quality",{/**
         * Sets the number of passes for blur. More passes means higher quality bluring.
         *
         * @member {number}
         * @default 1
         */get:function(){return this.blurXFilter.quality},set:function(t){this.blurXFilter.quality=this.blurYFilter.quality=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"blurX",{/**
         * Sets the strength of the blurX property
         *
         * @member {number}
         * @default 2
         */get:function(){return this.blurXFilter.blur},set:function(t){this.blurXFilter.blur=t,this.updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"blurY",{/**
         * Sets the strength of the blurY property
         *
         * @member {number}
         * @default 2
         */get:function(){return this.blurYFilter.blur},set:function(t){this.blurYFilter.blur=t,this.updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"blendMode",{/**
         * Sets the blendmode of the filter
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         */get:function(){return this.blurYFilter.blendMode},set:function(t){this.blurYFilter.blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"repeatEdgePixels",{/**
         * If set to true the edge of the target will be clamped
         *
         * @member {boolean}
         * @default false
         */get:function(){return this._repeatEdgePixels},set:function(t){this._repeatEdgePixels=t,this.updatePadding()},enumerable:!1,configurable:!0}),e}(nR),ak=function(t,e){return(ak=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aH=/** @class */function(t){function e(){var e=this,i={m:new Float32Array([1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0]),uAlpha:1};return(e=t.call(this,st,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n",i)||this).alpha=1,e}return!function(t,e){function i(){this.constructor=t}ak(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype._loadMatrix=function(t,e){void 0===e&&(e=!1);var i=t;e&&(this._multiply(i,this.uniforms.m,t),i=this._colorMatrix(i)),// set the new matrix
this.uniforms.m=i},/**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */e.prototype._multiply=function(t,e,i){return(// Red Channel
t[0]=e[0]*i[0]+e[1]*i[5]+e[2]*i[10]+e[3]*i[15],t[1]=e[0]*i[1]+e[1]*i[6]+e[2]*i[11]+e[3]*i[16],t[2]=e[0]*i[2]+e[1]*i[7]+e[2]*i[12]+e[3]*i[17],t[3]=e[0]*i[3]+e[1]*i[8]+e[2]*i[13]+e[3]*i[18],t[4]=e[0]*i[4]+e[1]*i[9]+e[2]*i[14]+e[3]*i[19]+e[4],// Green Channel
t[5]=e[5]*i[0]+e[6]*i[5]+e[7]*i[10]+e[8]*i[15],t[6]=e[5]*i[1]+e[6]*i[6]+e[7]*i[11]+e[8]*i[16],t[7]=e[5]*i[2]+e[6]*i[7]+e[7]*i[12]+e[8]*i[17],t[8]=e[5]*i[3]+e[6]*i[8]+e[7]*i[13]+e[8]*i[18],t[9]=e[5]*i[4]+e[6]*i[9]+e[7]*i[14]+e[8]*i[19]+e[9],// Blue Channel
t[10]=e[10]*i[0]+e[11]*i[5]+e[12]*i[10]+e[13]*i[15],t[11]=e[10]*i[1]+e[11]*i[6]+e[12]*i[11]+e[13]*i[16],t[12]=e[10]*i[2]+e[11]*i[7]+e[12]*i[12]+e[13]*i[17],t[13]=e[10]*i[3]+e[11]*i[8]+e[12]*i[13]+e[13]*i[18],t[14]=e[10]*i[4]+e[11]*i[9]+e[12]*i[14]+e[13]*i[19]+e[14],// Alpha Channel
t[15]=e[15]*i[0]+e[16]*i[5]+e[17]*i[10]+e[18]*i[15],t[16]=e[15]*i[1]+e[16]*i[6]+e[17]*i[11]+e[18]*i[16],t[17]=e[15]*i[2]+e[16]*i[7]+e[17]*i[12]+e[18]*i[17],t[18]=e[15]*i[3]+e[16]*i[8]+e[17]*i[13]+e[18]*i[18],t[19]=e[15]*i[4]+e[16]*i[9]+e[17]*i[14]+e[18]*i[19]+e[19],t)},/**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */e.prototype._colorMatrix=function(t){// Create a Float32 Array and normalize the offset component to 0-1
var e=new Float32Array(t);return e[4]/=255,e[9]/=255,e[14]/=255,e[19]/=255,e},/**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.brightness=function(t,e){var i=[t,0,0,0,0,0,t,0,0,0,0,0,t,0,0,0,0,0,1,0];this._loadMatrix(i,e)},/**
     * Sets each channel on the diagonal of the color matrix.
     * This can be used to achieve a tinting effect on Containers similar to the tint field of some
     * display objects like Sprite, Text, Graphics, and Mesh.
     *
     * @param {number} color - Color of the tint. This is a hex value.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.tint=function(t,e){this._loadMatrix([(t>>16&255)/255,0,0,0,0,0,(t>>8&255)/255,0,0,0,0,0,(255&t)/255,0,0,0,0,0,1,0],e)},/**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.greyscale=function(t,e){var i=[t,t,t,0,0,t,t,t,0,0,t,t,t,0,0,0,0,0,1,0];this._loadMatrix(i,e)},/**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.blackAndWhite=function(t){this._loadMatrix([.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0],t)},/**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.hue=function(t,e){var i=Math.cos(t=(t||0)/180*Math.PI),r=Math.sin(t),n=1/3,s=(0,Math.sqrt)(1/3);this._loadMatrix([i+(1-i)*n,n*(1-i)-s*r,n*(1-i)+s*r,0,0,n*(1-i)+s*r,i+n*(1-i),n*(1-i)-s*r,0,0,n*(1-i)-s*r,n*(1-i)+s*r,i+n*(1-i),0,0,0,0,0,1,0],e)},/**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.contrast=function(t,e){var i=(t||0)+1,r=-.5*(i-1),n=[i,0,0,0,r,0,i,0,0,r,0,0,i,0,r,0,0,0,1,0];this._loadMatrix(n,e)},/**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} [multiply] - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.saturate=function(t,e){void 0===t&&(t=0);var i=2*t/3+1,r=-((i-1)*.5),n=[i,r,r,0,0,r,i,r,0,0,r,r,i,0,0,0,0,0,1,0];this._loadMatrix(n,e)},/**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */e.prototype.desaturate=function(){this.saturate(-1)},/**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.negative=function(t){this._loadMatrix([-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0],t)},/**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.sepia=function(t){this._loadMatrix([.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0],t)},/**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.technicolor=function(t){this._loadMatrix([1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0],t)},/**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.polaroid=function(t){this._loadMatrix([1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0],t)},/**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.toBGR=function(t){this._loadMatrix([0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0],t)},/**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.kodachrome=function(t){this._loadMatrix([1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0],t)},/**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.browni=function(t){this._loadMatrix([.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0],t)},/**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.vintage=function(t){this._loadMatrix([.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0],t)},/**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {number} lightColor - Tone values, example: `0xFFE580`
     * @param {number} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.colorTone=function(t,e,i,r,n){var s=((i=i||16770432)>>16&255)/255,o=(i>>8&255)/255,a=(255&i)/255,h=((r=r||3375104)>>16&255)/255,l=(r>>8&255)/255,u=(255&r)/255,c=[.3,.59,.11,0,0,s,o,a,t=t||.2,0,h,l,u,e=e||.15,0,s-h,o-l,a-u,0,0];this._loadMatrix(c,n)},/**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.night=function(t,e){var i=[-2*(t=t||.1),-t,0,0,0,-t,0,t,0,0,0,t,2*t,0,0,0,0,0,1,0];this._loadMatrix(i,e)},/**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.predator=function(t,e){this._loadMatrix([// row 1
11.224130630493164*t,-4.794486999511719*t,-2.8746118545532227*t,0*t,.40342438220977783*t,// row 2
-3.6330697536468506*t,9.193157196044922*t,-2.951810836791992*t,0*t,-1.316135048866272*t,// row 3
-3.2184197902679443*t,-4.2375030517578125*t,7.476448059082031*t,0*t,.8044459223747253*t,// row 4
0,0,0,1,0],e)},/**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */e.prototype.lsd=function(t){this._loadMatrix([2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0],t)},/**
     * Erase the current matrix by setting the default one
     *
     */e.prototype.reset=function(){this._loadMatrix([1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],!1)},Object.defineProperty(e.prototype,"matrix",{/**
         * The matrix of the color matrix filter
         *
         * @member {number[]}
         * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
         */get:function(){return this.uniforms.m},set:function(t){this.uniforms.m=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"alpha",{/**
         * The opacity value to use when mixing the original and resultant colors.
         *
         * When the value is 0, the original color is used without modification.
         * When the value is 1, the result color is used.
         * When in the range (0, 1) the color is interpolated between the original and result by this amount.
         *
         * @member {number}
         * @default 1
         */get:function(){return this.uniforms.uAlpha},set:function(t){this.uniforms.uAlpha=t},enumerable:!1,configurable:!0}),e}(nR);// Americanized alias
aH.prototype.grayscale=aH.prototype.greyscale;/*!
 * @pixi/filter-displacement - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var az=function(t,e){return(az=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aj=/** @class */function(t){/**
     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)
     * @param {number} [scale] - The scale of the displacement
     */function e(e,i){var r=this,n=new iX;return e.renderable=!1,(r=t.call(this,"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n","varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n",{mapSampler:e._texture,filterMatrix:n,scale:{x:1,y:1},rotation:new Float32Array([1,0,0,1])})||this).maskSprite=e,r.maskMatrix=n,null==i&&(i=20),/**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */r.scale=new ij(i,i),r}return!function(t,e){function i(){this.constructor=t}az(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Applies the filter.
     *
     * @param {PIXI.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     * @param {PIXI.CLEAR_MODES} clearMode - clearMode.
     */e.prototype.apply=function(t,e,i,r){// fill maskMatrix with _normalized sprite texture coords_
this.uniforms.filterMatrix=t.calculateSpriteMatrix(this.maskMatrix,this.maskSprite),this.uniforms.scale.x=this.scale.x,this.uniforms.scale.y=this.scale.y;// Extract rotation from world transform
var n=this.maskSprite.worldTransform,s=Math.sqrt(n.a*n.a+n.b*n.b),o=Math.sqrt(n.c*n.c+n.d*n.d);0!==s&&0!==o&&(this.uniforms.rotation[0]=n.a/s,this.uniforms.rotation[1]=n.b/s,this.uniforms.rotation[2]=n.c/o,this.uniforms.rotation[3]=n.d/o),// draw the filter...
t.applyFilter(this,e,i,r)},Object.defineProperty(e.prototype,"map",{/**
         * The texture used for the displacement map. Must be power of 2 sized texture.
         *
         * @member {PIXI.Texture}
         */get:function(){return this.uniforms.mapSampler},set:function(t){this.uniforms.mapSampler=t},enumerable:!1,configurable:!0}),e}(nR),aV=function(t,e){return(aV=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aX=/** @class */function(t){function e(){// TODO - needs work
return t.call(this,"\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n')||this}return!function(t,e){function i(){this.constructor=t}aV(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),e}(nR),aW=function(t,e){return(aW=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},aY=/** @class */function(t){/**
     * @param {number} [noise=0.5] - The noise intensity, should be a normalized value in the range [0, 1].
     * @param {number} [seed] - A random seed for the noise generation. Default is `Math.random()`.
     */function e(e,i){void 0===e&&(e=.5),void 0===i&&(i=Math.random());var r=t.call(this,st,"precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n",{uNoise:0,uSeed:0})||this;return r.noise=e,r.seed=i,r}return!function(t,e){function i(){this.constructor=t}aW(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),Object.defineProperty(e.prototype,"noise",{/**
         * The amount of noise to apply, this value should be in the range (0, 1].
         *
         * @member {number}
         * @default 0.5
         */get:function(){return this.uniforms.uNoise},set:function(t){this.uniforms.uNoise=t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"seed",{/**
         * A seed value to apply to the random noise generation. `Math.random()` is a good value to use.
         *
         * @member {number}
         */get:function(){return this.uniforms.uSeed},set:function(t){this.uniforms.uSeed=t},enumerable:!1,configurable:!0}),e}(nR);(vH=bk||(bk={}))[vH.WEBGL_LEGACY=0]="WEBGL_LEGACY",vH[vH.WEBGL=1]="WEBGL",vH[vH.WEBGL2=2]="WEBGL2",(vz=bH||(bH={}))[vz.UNKNOWN=0]="UNKNOWN",vz[vz.WEBGL=1]="WEBGL",vz[vz.CANVAS=2]="CANVAS",(vj=bz||(bz={}))[vj.COLOR=16384]="COLOR",vj[vj.DEPTH=256]="DEPTH",vj[vj.STENCIL=1024]="STENCIL",(vV=bj||(bj={}))[vV.NORMAL=0]="NORMAL",vV[vV.ADD=1]="ADD",vV[vV.MULTIPLY=2]="MULTIPLY",vV[vV.SCREEN=3]="SCREEN",vV[vV.OVERLAY=4]="OVERLAY",vV[vV.DARKEN=5]="DARKEN",vV[vV.LIGHTEN=6]="LIGHTEN",vV[vV.COLOR_DODGE=7]="COLOR_DODGE",vV[vV.COLOR_BURN=8]="COLOR_BURN",vV[vV.HARD_LIGHT=9]="HARD_LIGHT",vV[vV.SOFT_LIGHT=10]="SOFT_LIGHT",vV[vV.DIFFERENCE=11]="DIFFERENCE",vV[vV.EXCLUSION=12]="EXCLUSION",vV[vV.HUE=13]="HUE",vV[vV.SATURATION=14]="SATURATION",vV[vV.COLOR=15]="COLOR",vV[vV.LUMINOSITY=16]="LUMINOSITY",vV[vV.NORMAL_NPM=17]="NORMAL_NPM",vV[vV.ADD_NPM=18]="ADD_NPM",vV[vV.SCREEN_NPM=19]="SCREEN_NPM",vV[vV.NONE=20]="NONE",vV[vV.SRC_OVER=0]="SRC_OVER",vV[vV.SRC_IN=21]="SRC_IN",vV[vV.SRC_OUT=22]="SRC_OUT",vV[vV.SRC_ATOP=23]="SRC_ATOP",vV[vV.DST_OVER=24]="DST_OVER",vV[vV.DST_IN=25]="DST_IN",vV[vV.DST_OUT=26]="DST_OUT",vV[vV.DST_ATOP=27]="DST_ATOP",vV[vV.ERASE=26]="ERASE",vV[vV.SUBTRACT=28]="SUBTRACT",vV[vV.XOR=29]="XOR",(vX=bV||(bV={}))[vX.POINTS=0]="POINTS",vX[vX.LINES=1]="LINES",vX[vX.LINE_LOOP=2]="LINE_LOOP",vX[vX.LINE_STRIP=3]="LINE_STRIP",vX[vX.TRIANGLES=4]="TRIANGLES",vX[vX.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",vX[vX.TRIANGLE_FAN=6]="TRIANGLE_FAN",(vW=bX||(bX={}))[vW.RGBA=6408]="RGBA",vW[vW.RGB=6407]="RGB",vW[vW.RG=33319]="RG",vW[vW.RED=6403]="RED",vW[vW.RGBA_INTEGER=36249]="RGBA_INTEGER",vW[vW.RGB_INTEGER=36248]="RGB_INTEGER",vW[vW.RG_INTEGER=33320]="RG_INTEGER",vW[vW.RED_INTEGER=36244]="RED_INTEGER",vW[vW.ALPHA=6406]="ALPHA",vW[vW.LUMINANCE=6409]="LUMINANCE",vW[vW.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",vW[vW.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",vW[vW.DEPTH_STENCIL=34041]="DEPTH_STENCIL",(vY=bW||(bW={}))[vY.TEXTURE_2D=3553]="TEXTURE_2D",vY[vY.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",vY[vY.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",vY[vY.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",vY[vY.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",vY[vY.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",vY[vY.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",vY[vY.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",vY[vY.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",(vq=bY||(bY={}))[vq.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",vq[vq.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",vq[vq.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",vq[vq.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",vq[vq.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",vq[vq.UNSIGNED_INT=5125]="UNSIGNED_INT",vq[vq.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",vq[vq.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",vq[vq.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",vq[vq.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",vq[vq.BYTE=5120]="BYTE",vq[vq.SHORT=5122]="SHORT",vq[vq.INT=5124]="INT",vq[vq.FLOAT=5126]="FLOAT",vq[vq.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",vq[vq.HALF_FLOAT=36193]="HALF_FLOAT",(vK=bq||(bq={}))[vK.FLOAT=0]="FLOAT",vK[vK.INT=1]="INT",vK[vK.UINT=2]="UINT",(vJ=bK||(bK={}))[vJ.NEAREST=0]="NEAREST",vJ[vJ.LINEAR=1]="LINEAR",(vZ=bJ||(bJ={}))[vZ.CLAMP=33071]="CLAMP",vZ[vZ.REPEAT=10497]="REPEAT",vZ[vZ.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",(v$=bZ||(bZ={}))[v$.OFF=0]="OFF",v$[v$.POW2=1]="POW2",v$[v$.ON=2]="ON",v$[v$.ON_MANUAL=3]="ON_MANUAL",(vQ=b$||(b$={}))[vQ.NPM=0]="NPM",vQ[vQ.UNPACK=1]="UNPACK",vQ[vQ.PMA=2]="PMA",vQ[vQ.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",vQ[vQ.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",vQ[vQ.PREMULTIPLY_ALPHA=2]="PREMULTIPLY_ALPHA",(v0=bQ||(bQ={}))[v0.NO=0]="NO",v0[v0.YES=1]="YES",v0[v0.AUTO=2]="AUTO",v0[v0.BLEND=0]="BLEND",v0[v0.CLEAR=1]="CLEAR",v0[v0.BLIT=2]="BLIT",(v1=b0||(b0={}))[v1.AUTO=0]="AUTO",v1[v1.MANUAL=1]="MANUAL",(v2=b1||(b1={})).LOW="lowp",v2.MEDIUM="mediump",v2.HIGH="highp",(v3=b2||(b2={}))[v3.NONE=0]="NONE",v3[v3.SCISSOR=1]="SCISSOR",v3[v3.STENCIL=2]="STENCIL",v3[v3.SPRITE=3]="SPRITE",(v5=b3||(b3={}))[v5.NONE=0]="NONE",v5[v5.LOW=2]="LOW",v5[v5.MEDIUM=4]="MEDIUM",v5[v5.HIGH=8]="HIGH",(v4=b5||(b5={}))[v4.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",v4[v4.ARRAY_BUFFER=34962]="ARRAY_BUFFER",// NOT YET SUPPORTED
v4[v4.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER";var aq=new iX;i5.prototype._cacheAsBitmap=!1,i5.prototype._cacheData=null,i5.prototype._cacheAsBitmapResolution=null,i5.prototype._cacheAsBitmapMultisample=b3.NONE;// figured there's no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 * @private
 */var aK=function(){this.textureCacheId=null,this.originalRender=null,this.originalRenderCanvas=null,this.originalCalculateBounds=null,this.originalGetLocalBounds=null,this.originalUpdateTransform=null,this.originalDestroy=null,this.originalMask=null,this.originalFilterArea=null,this.originalContainsPoint=null,this.sprite=null};Object.defineProperties(i5.prototype,{/**
     * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
     * but can be overriden for performance. Lower values will reduce memory usage at the expense
     * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
     * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
     *
     * @member {number} cacheAsBitmapResolution
     * @memberof PIXI.DisplayObject#
     * @default null
     */cacheAsBitmapResolution:{get:function(){return this._cacheAsBitmapResolution},set:function(t){t!==this._cacheAsBitmapResolution&&(this._cacheAsBitmapResolution=t,this.cacheAsBitmap&&(// Toggle to re-render at the new resolution
this.cacheAsBitmap=!1,this.cacheAsBitmap=!0))}},/**
     * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
     * sample count is used.
     * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
     *
     * @member {number} cacheAsBitmapMultisample
     * @memberof PIXI.DisplayObject#
     * @default PIXI.MSAA_QUALITY.NONE
     */cacheAsBitmapMultisample:{get:function(){return this._cacheAsBitmapMultisample},set:function(t){t!==this._cacheAsBitmapMultisample&&(this._cacheAsBitmapMultisample=t,this.cacheAsBitmap&&(// Toggle to re-render with new multisample
this.cacheAsBitmap=!1,this.cacheAsBitmap=!0))}},/**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can
     * provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to `false`
     *
     * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
     *
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */cacheAsBitmap:{get:function(){return this._cacheAsBitmap},set:function(t){var e;this._cacheAsBitmap!==t&&(this._cacheAsBitmap=t,t?(this._cacheData||(this._cacheData=new aK),(e=this._cacheData).originalRender=this.render,e.originalRenderCanvas=this.renderCanvas,e.originalUpdateTransform=this.updateTransform,e.originalCalculateBounds=this.calculateBounds,e.originalGetLocalBounds=this.getLocalBounds,e.originalDestroy=this.destroy,e.originalContainsPoint=this.containsPoint,e.originalMask=this._mask,e.originalFilterArea=this.filterArea,this.render=this._renderCached,this.renderCanvas=this._renderCachedCanvas,this.destroy=this._cacheAsBitmapDestroy):((e=this._cacheData).sprite&&this._destroyCachedDisplayObject(),this.render=e.originalRender,this.renderCanvas=e.originalRenderCanvas,this.calculateBounds=e.originalCalculateBounds,this.getLocalBounds=e.originalGetLocalBounds,this.destroy=e.originalDestroy,this.updateTransform=e.originalUpdateTransform,this.containsPoint=e.originalContainsPoint,this._mask=e.originalMask,this.filterArea=e.originalFilterArea))}}}),i5.prototype._renderCached=function(t){this.visible&&!(this.worldAlpha<=0)&&this.renderable&&(this._initCachedDisplayObject(t),this._cacheData.sprite.transform._worldID=this.transform._worldID,this._cacheData.sprite.worldAlpha=this.worldAlpha,this._cacheData.sprite._render(t))},i5.prototype._initCachedDisplayObject=function(t){if(!this._cacheData||!this._cacheData.sprite){// make sure alpha is set to 1 otherwise it will get rendered as invisible!
var e,i=this.alpha;this.alpha=1,// first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
t.batch.flush();// this.filters= [];
// next we find the dimensions of the untransformed object
// this function also calls updatetransform on all its children as part of the measuring.
// This means we don't need to update the transform again in this function
// TODO pass an object to clone too? saves having to create a new one each time!
var r=this.getLocalBounds(null,!0).clone();// add some padding!
if(this.filters){var n=this.filters[0].padding;r.pad(n)}r.ceil(ec.RESOLUTION);// for now we cache the current renderTarget that the WebGL renderer is currently using.
// this could be more elegant..
var s=t.renderTexture.current,o=t.renderTexture.sourceFrame.clone(),a=t.renderTexture.destinationFrame.clone(),h=t.projection.transform,l=rj.create({width:r.width,height:r.height,resolution:this.cacheAsBitmapResolution||t.resolution,multisample:null!==(e=this.cacheAsBitmapMultisample)&&void 0!==e?e:t.multisample}),u="cacheAsBitmap_"+i_();this._cacheData.textureCacheId=u,rS.addToCache(l.baseTexture,u),rH.addToCache(l,u);// need to set //
var c=this.transform.localTransform.copyTo(aq).invert().translate(-r.x,-r.y);// set all properties to there original so we can render to a texture
this.render=this._cacheData.originalRender,t.render(this,{renderTexture:l,clear:!0,transform:c,skipUpdateTransform:!1}),t.framebuffer.blit(),// now restore the state be setting the new properties
t.projection.transform=h,t.renderTexture.bind(s,o,a),// renderer.filterManager.filterStack = stack;
this.render=this._renderCached,// the rest is the same as for Canvas
this.updateTransform=this.displayObjectUpdateTransform,this.calculateBounds=this._calculateCachedBounds,this.getLocalBounds=this._getCachedLocalBounds,this._mask=null,this.filterArea=null,this.alpha=i;// create our cached sprite
var d=new oB(l);d.transform.worldTransform=this.transform.worldTransform,d.anchor.x=-(r.x/r.width),d.anchor.y=-(r.y/r.height),d.alpha=i,d._bounds=this._bounds,this._cacheData.sprite=d,this.transform._parentID=-1,this.parent?this.updateTransform():(this.enableTempParent(),this.updateTransform(),this.disableTempParent(null)),// map the hit test..
this.containsPoint=d.containsPoint.bind(d)}},i5.prototype._renderCachedCanvas=function(t){this.visible&&!(this.worldAlpha<=0)&&this.renderable&&(this._initCachedDisplayObjectCanvas(t),this._cacheData.sprite.worldAlpha=this.worldAlpha,this._cacheData.sprite._renderCanvas(t))},i5.prototype._initCachedDisplayObjectCanvas=function(t){if(!this._cacheData||!this._cacheData.sprite){// get bounds actually transforms the object for us already!
var e=this.getLocalBounds(null,!0),i=this.alpha;this.alpha=1;var r=t.context,n=t._projTransform;e.ceil(ec.RESOLUTION);var s=rj.create({width:e.width,height:e.height}),o="cacheAsBitmap_"+i_();this._cacheData.textureCacheId=o,rS.addToCache(s.baseTexture,o),rH.addToCache(s,o),this.transform.localTransform.copyTo(aq),aq.invert(),aq.tx-=e.x,aq.ty-=e.y,// m.append(this.transform.worldTransform.)
// set all properties to there original so we can render to a texture
this.renderCanvas=this._cacheData.originalRenderCanvas,t.render(this,{renderTexture:s,clear:!0,transform:aq,skipUpdateTransform:!1}),// now restore the state be setting the new properties
t.context=r,t._projTransform=n,this.renderCanvas=this._renderCachedCanvas,// the rest is the same as for WebGL
this.updateTransform=this.displayObjectUpdateTransform,this.calculateBounds=this._calculateCachedBounds,this.getLocalBounds=this._getCachedLocalBounds,this._mask=null,this.filterArea=null,this.alpha=i;// create our cached sprite
var a=new oB(s);a.transform.worldTransform=this.transform.worldTransform,a.anchor.x=-(e.x/e.width),a.anchor.y=-(e.y/e.height),a.alpha=i,a._bounds=this._bounds,this._cacheData.sprite=a,this.transform._parentID=-1,this.parent?this.updateTransform():(this.parent=t._tempDisplayObjectParent,this.updateTransform(),this.parent=null),// map the hit test..
this.containsPoint=a.containsPoint.bind(a)}},i5.prototype._calculateCachedBounds=function(){this._bounds.clear(),this._cacheData.sprite.transform._worldID=this.transform._worldID,this._cacheData.sprite._calculateBounds(),this._bounds.updateID=this._boundsID},i5.prototype._getCachedLocalBounds=function(){return this._cacheData.sprite.getLocalBounds(null)},i5.prototype._destroyCachedDisplayObject=function(){this._cacheData.sprite._texture.destroy(!0),this._cacheData.sprite=null,rS.removeFromCache(this._cacheData.textureCacheId),rH.removeFromCache(this._cacheData.textureCacheId),this._cacheData.textureCacheId=null},i5.prototype._cacheAsBitmapDestroy=function(t){this.cacheAsBitmap=!1,this.destroy(t)},i5.prototype.name=null,i8.prototype.getChildByName=function(t,e){for(var i=0,r=this.children.length;i<r;i++)if(this.children[i].name===t)return this.children[i];if(e){for(var i=0,r=this.children.length;i<r;i++)if(this.children[i].getChildByName){var n=this.children[i].getChildByName(t,!0);if(n)return n}}return null},i5.prototype.getGlobalPosition=function(t,e){return void 0===t&&(t=new ij),void 0===e&&(e=!1),this.parent?this.parent.toGlobal(this.position,t,e):(t.x=this.position.x,t.y=this.position.y),t};var aJ={};tC(aJ,"PlaneGeometry",()=>aQ),tC(aJ,"RopeGeometry",()=>a0),tC(aJ,"SimpleRope",()=>a1),tC(aJ,"SimplePlane",()=>a2),tC(aJ,"SimpleMesh",()=>a3),tC(aJ,"NineSlicePlane",()=>a5);/*!
 * @pixi/mesh-extras - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var aZ=function(t,e){return(aZ=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function a$(t,e){function i(){this.constructor=t}aZ(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * @memberof PIXI
 */var aQ=/** @class */function(t){/**
     * @param width - The width of the plane.
     * @param height - The height of the plane.
     * @param segWidth - Number of horizontal segments.
     * @param segHeight - Number of vertical segments.
     */function e(e,i,r,n){void 0===e&&(e=100),void 0===i&&(i=100),void 0===r&&(r=10),void 0===n&&(n=10);var s=t.call(this)||this;return s.segWidth=r,s.segHeight=n,s.width=e,s.height=i,s.build(),s}return a$(e,t),/**
     * Refreshes plane coordinates
     * @private
     */e.prototype.build=function(){for(var t=this.segWidth*this.segHeight,e=[],i=[],r=[],n=this.segWidth-1,s=this.segHeight-1,o=this.width/n,a=this.height/s,h=0;h<t;h++){var l=h%this.segWidth,u=h/this.segWidth|0;e.push(l*o,u*a),i.push(l/n,u/s)}for(var c=n*s,h=0;h<c;h++){var d=h%n,p=h/n|0,f=p*this.segWidth+d,m=p*this.segWidth+d+1,g=(p+1)*this.segWidth+d,y=(p+1)*this.segWidth+d+1;r.push(f,m,g,m,y,g)}this.buffers[0].data=new Float32Array(e),this.buffers[1].data=new Float32Array(i),this.indexBuffer.data=new Uint16Array(r),// ensure that the changes are uploaded
this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()},e}(ax),a0=/** @class */function(t){/**
     * @param {number} [width=200] - The width (i.e., thickness) of the rope.
     * @param {PIXI.Point[]} [points] - An array of {@link PIXI.Point} objects to construct this rope.
     * @param {number} [textureScale=0] - By default the rope texture will be stretched to match
     *     rope length. If textureScale is positive this value will be treated as a scaling
     *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope
     *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,
     *     then set textureScale=1 to keep the original texture pixel size.
     *     In order to reduce alpha channel artifacts provide a larger texture and downsample -
     *     i.e. set textureScale=0.5 to scale it down twice.
     */function e(e,i,r){void 0===e&&(e=200),void 0===r&&(r=0);var n=t.call(this,new Float32Array(4*i.length),new Float32Array(4*i.length),new Uint16Array((i.length-1)*6))||this;return(/**
         * An array of points that determine the rope
         * @member {PIXI.Point[]}
         */n.points=i,/**
         * The width (i.e., thickness) of the rope.
         * @member {number}
         * @readOnly
         */n._width=e,/**
         * Rope texture scale, if zero then the rope texture is stretched.
         * @member {number}
         * @readOnly
         */n.textureScale=r,n.build(),n)}return a$(e,t),Object.defineProperty(e.prototype,"width",{/**
         * The width (i.e., thickness) of the rope.
         * @member {number}
         * @readOnly
         */get:function(){return this._width},enumerable:!1,configurable:!0}),/**
     * Refreshes Rope indices and uvs
     * @private
     */e.prototype.build=function(){var t=this.points;if(t){var e=this.getBuffer("aVertexPosition"),i=this.getBuffer("aTextureCoord"),r=this.getIndex();// if too little points, or texture hasn't got UVs set yet just move on.
if(!(t.length<1)){e.data.length/4!==t.length&&(e.data=new Float32Array(4*t.length),i.data=new Float32Array(4*t.length),r.data=new Uint16Array((t.length-1)*6));var n=i.data,s=r.data;n[0]=0,n[1]=0,n[2]=0,n[3]=1;for(var o=0,a=t[0],h=this._width*this.textureScale,l=t.length,u=0;u<l;u++){// time to do some smart drawing!
var c=4*u;if(this.textureScale>0){// calculate pixel distance from previous point
var d=a.x-t[u].x,p=a.y-t[u].y,f=Math.sqrt(d*d+p*p);a=t[u],o+=f/h}else o=u/(l-1);n[c]=o,n[c+1]=0,n[c+2]=o,n[c+3]=1}for(var m=0,u=0;u<l-1;u++){var c=2*u;s[m++]=c,s[m++]=c+1,s[m++]=c+2,s[m++]=c+2,s[m++]=c+1,s[m++]=c+3}// ensure that the changes are uploaded
i.update(),r.update(),this.updateVertices()}}},/**
     * refreshes vertices of Rope mesh
     */e.prototype.updateVertices=function(){var t,e=this.points;if(!(e.length<1)){for(var i=e[0],r=0,n=0,s=this.buffers[0].data,o=e.length,a=0;a<o;a++){var h=e[a],l=4*a;n=-((t=a<e.length-1?e[a+1]:h).x-i.x);var u=Math.sqrt((r=t.y-i.y)*r+n*n),c=this.textureScale>0?this.textureScale*this._width/2:this._width/2;r/=u,n/=u,r*=c,n*=c,s[l]=h.x+r,s[l+1]=h.y+n,s[l+2]=h.x-r,s[l+3]=h.y-n,i=h}this.buffers[0].update()}},e.prototype.update=function(){this.textureScale>0?this.build():this.updateVertices()},e}(ax),a1=/** @class */function(t){/**
     * @param {PIXI.Texture} texture - The texture to use on the rope.
     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.
     * @param {number} [textureScale=0] - Optional. Positive values scale rope texture
     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
     * and downsampling here. If set to zero, texture will be stretched instead.
     */function e(e,i,r){void 0===r&&(r=0);var n=this,s=new a0(e.height,i,r),o=new av(e);return r>0&&(e.baseTexture.wrapMode=x3.REPEAT),/**
         * re-calculate vertices by rope points each frame
         *
         * @member {boolean}
         */(n=t.call(this,s,o)||this).autoUpdate=!0,n}return a$(e,t),e.prototype._render=function(e){var i=this.geometry;(this.autoUpdate||i._width!==this.shader.texture.height)&&(i._width=this.shader.texture.height,i.update()),t.prototype._render.call(this,e)},e}(a_),a2=/** @class */function(t){/**
     * @param {PIXI.Texture} texture - The texture to use on the SimplePlane.
     * @param {number} verticesX - The number of vertices in the x-axis
     * @param {number} verticesY - The number of vertices in the y-axis
     */function e(e,i,r){var n=this,s=new aQ(e.width,e.height,i,r),o=new av(rH.WHITE);return(// lets call the setter to ensure all necessary updates are performed
(n=t.call(this,s,o)||this).texture=e,n.autoResize=!0,n)}return a$(e,t),/**
     * Method used for overrides, to do something in case texture frame was changed.
     * Meshes based on plane can override it and change more details based on texture.
     */e.prototype.textureUpdated=function(){this._textureID=this.shader.texture._updateID;var t=this.geometry,e=this.shader.texture,i=e.width,r=e.height;this.autoResize&&(t.width!==i||t.height!==r)&&(t.width=this.shader.texture.width,t.height=this.shader.texture.height,t.build())},Object.defineProperty(e.prototype,"texture",{get:function(){return this.shader.texture},set:function(t){// Track texture same way sprite does.
// For generated meshes like NineSlicePlane it can change the geometry.
// Unfortunately, this method might not work if you directly change texture in material.
this.shader.texture!==t&&(this.shader.texture=t,this._textureID=-1,t.baseTexture.valid?this.textureUpdated():t.once("update",this.textureUpdated,this))},enumerable:!1,configurable:!0}),e.prototype._render=function(e){this._textureID!==this.shader.texture._updateID&&this.textureUpdated(),t.prototype._render.call(this,e)},e.prototype.destroy=function(e){this.shader.texture.off("update",this.textureUpdated,this),t.prototype.destroy.call(this,e)},e}(a_),a3=/** @class */function(t){/**
     * @param {PIXI.Texture} [texture=Texture.EMPTY] - The texture to use
     * @param {Float32Array} [vertices] - if you want to specify the vertices
     * @param {Float32Array} [uvs] - if you want to specify the uvs
     * @param {Uint16Array} [indices] - if you want to specify the indices
     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts
     */function e(e,i,r,n,s){void 0===e&&(e=rH.EMPTY);var o=this,a=new ax(i,r,n);a.getBuffer("aVertexPosition").static=!1;var h=new av(e);return(/**
         * upload vertices buffer each frame
         * @member {boolean}
         */(o=t.call(this,a,h,null,s)||this).autoUpdate=!0,o)}return a$(e,t),Object.defineProperty(e.prototype,"vertices",{/**
         * Collection of vertices data.
         * @member {Float32Array}
         */get:function(){return this.geometry.getBuffer("aVertexPosition").data},set:function(t){this.geometry.getBuffer("aVertexPosition").data=t},enumerable:!1,configurable:!0}),e.prototype._render=function(e){this.autoUpdate&&this.geometry.getBuffer("aVertexPosition").update(),t.prototype._render.call(this,e)},e}(a_),a5=/** @class */function(t){/**
     * @param {PIXI.Texture} texture - The texture to use on the NineSlicePlane.
     * @param {number} [leftWidth=10] - size of the left vertical bar (A)
     * @param {number} [topHeight=10] - size of the top horizontal bar (C)
     * @param {number} [rightWidth=10] - size of the right vertical bar (B)
     * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)
     */function e(e,i,r,n,s){void 0===i&&(i=10),void 0===r&&(r=10),void 0===n&&(n=10),void 0===s&&(s=10);var o=t.call(this,rH.WHITE,4,4)||this;return o._origWidth=e.orig.width,o._origHeight=e.orig.height,/**
         * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @override
         */o._width=o._origWidth,/**
         * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         * @override
         */o._height=o._origHeight,/**
         * The width of the left column (a)
         *
         * @member {number}
         * @private
         */o._leftWidth=i,/**
         * The width of the right column (b)
         *
         * @member {number}
         * @private
         */o._rightWidth=n,/**
         * The height of the top row (c)
         *
         * @member {number}
         * @private
         */o._topHeight=r,/**
         * The height of the bottom row (d)
         *
         * @member {number}
         * @private
         */o._bottomHeight=s,// lets call the setter to ensure all necessary updates are performed
o.texture=e,o}return a$(e,t),e.prototype.textureUpdated=function(){this._textureID=this.shader.texture._updateID,this._refresh()},Object.defineProperty(e.prototype,"vertices",{get:function(){return this.geometry.getBuffer("aVertexPosition").data},set:function(t){this.geometry.getBuffer("aVertexPosition").data=t},enumerable:!1,configurable:!0}),/**
     * Updates the horizontal vertices.
     *
     */e.prototype.updateHorizontalVertices=function(){var t=this.vertices,e=this._getMinScale();t[9]=t[11]=t[13]=t[15]=this._topHeight*e,t[17]=t[19]=t[21]=t[23]=this._height-this._bottomHeight*e,t[25]=t[27]=t[29]=t[31]=this._height},/**
     * Updates the vertical vertices.
     *
     */e.prototype.updateVerticalVertices=function(){var t=this.vertices,e=this._getMinScale();t[2]=t[10]=t[18]=t[26]=this._leftWidth*e,t[4]=t[12]=t[20]=t[28]=this._width-this._rightWidth*e,t[6]=t[14]=t[22]=t[30]=this._width},/**
     * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.
     *
     * @return {number} Smaller number of vertical and horizontal scale.
     * @private
     */e.prototype._getMinScale=function(){var t=this._leftWidth+this._rightWidth,e=this._width>t?1:this._width/t,i=this._topHeight+this._bottomHeight;return Math.min(e,this._height>i?1:this._height/i)},Object.defineProperty(e.prototype,"width",{/**
         * The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         */get:function(){return this._width},set:function(t){this._width=t,this._refresh()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane
         *
         * @member {number}
         */get:function(){return this._height},set:function(t){this._height=t,this._refresh()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"leftWidth",{/**
         * The width of the left column
         *
         * @member {number}
         */get:function(){return this._leftWidth},set:function(t){this._leftWidth=t,this._refresh()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"rightWidth",{/**
         * The width of the right column
         *
         * @member {number}
         */get:function(){return this._rightWidth},set:function(t){this._rightWidth=t,this._refresh()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"topHeight",{/**
         * The height of the top row
         *
         * @member {number}
         */get:function(){return this._topHeight},set:function(t){this._topHeight=t,this._refresh()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"bottomHeight",{/**
         * The height of the bottom row
         *
         * @member {number}
         */get:function(){return this._bottomHeight},set:function(t){this._bottomHeight=t,this._refresh()},enumerable:!1,configurable:!0}),/**
     * Refreshes NineSlicePlane coords. All of them.
     */e.prototype._refresh=function(){var t=this.texture,e=this.geometry.buffers[1].data;this._origWidth=t.orig.width,this._origHeight=t.orig.height;var i=1/this._origWidth,r=1/this._origHeight;e[0]=e[8]=e[16]=e[24]=0,e[1]=e[3]=e[5]=e[7]=0,e[6]=e[14]=e[22]=e[30]=1,e[25]=e[27]=e[29]=e[31]=1,e[2]=e[10]=e[18]=e[26]=i*this._leftWidth,e[4]=e[12]=e[20]=e[28]=1-i*this._rightWidth,e[9]=e[11]=e[13]=e[15]=r*this._topHeight,e[17]=e[19]=e[21]=e[23]=1-r*this._bottomHeight,this.updateHorizontalVertices(),this.updateVerticalVertices(),this.geometry.buffers[0].update(),this.geometry.buffers[1].update()},e}(a2),a4={};tC(a4,"AnimatedSprite",()=>a8);/*!
 * @pixi/sprite-animated - v6.1.2
 * Compiled Thu, 12 Aug 2021 17:11:19 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var a6=function(t,e){return(a6=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},a8=/** @class */function(t){/**
     * @param {PIXI.Texture[]|PIXI.AnimatedSprite.FrameObject[]} textures - An array of {@link PIXI.Texture} or frame
     *  objects that make up the animation.
     * @param {boolean} [autoUpdate=true] - Whether to use PIXI.Ticker.shared to auto update animation time.
     */function e(e,i){void 0===i&&(i=!0);var r=t.call(this,e[0]instanceof rH?e[0]:e[0].texture)||this;return(/**
         * @type {PIXI.Texture[]}
         * @private
         */r._textures=null,/**
         * @type {number[]}
         * @private
         */r._durations=null,/**
         * `true` uses PIXI.Ticker.shared to auto update animation time.
         *
         * @type {boolean}
         * @default true
         * @private
         */r._autoUpdate=i,/**
         * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time.
         *
         * @type {boolean}
         * @default false
         * @private
         */r._isConnectedToTicker=!1,/**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.
         *
         * @member {number}
         * @default 1
         */r.animationSpeed=1,/**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */r.loop=!0,/**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */r.updateAnchor=!1,/**
         * User-assigned function to call when an AnimatedSprite finishes playing.
         *
         * @example
         * animation.onComplete = function () {
         *   // finished!
         * };
         * @member {Function}
         */r.onComplete=null,/**
         * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.
         *
         * @example
         * animation.onFrameChange = function () {
         *   // updated!
         * };
         * @member {Function}
         */r.onFrameChange=null,/**
         * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and
         * loops around to start again.
         *
         * @example
         * animation.onLoop = function () {
         *   // looped!
         * };
         * @member {Function}
         */r.onLoop=null,/**
         * Elapsed time since animation has been started, used internally to display current texture.
         *
         * @member {number}
         * @private
         */r._currentTime=0,r._playing=!1,/**
         * The texture index that was displayed last time
         *
         * @member {number}
         * @private
         */r._previousFrame=null,r.textures=e,r)}return!function(t,e){function i(){this.constructor=t}a6(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Stops the AnimatedSprite.
     *
     */e.prototype.stop=function(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(rr.shared.remove(this.update,this),this._isConnectedToTicker=!1))},/**
     * Plays the AnimatedSprite.
     *
     */e.prototype.play=function(){this._playing||(this._playing=!0,!this._autoUpdate||this._isConnectedToTicker||(rr.shared.add(this.update,this,bs.HIGH),this._isConnectedToTicker=!0))},/**
     * Stops the AnimatedSprite and goes to a specific frame.
     *
     * @param {number} frameNumber - Frame index to stop at.
     */e.prototype.gotoAndStop=function(t){this.stop();var e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this.updateTexture()},/**
     * Goes to a specific frame and begins playing the AnimatedSprite.
     *
     * @param {number} frameNumber - Frame index to start at.
     */e.prototype.gotoAndPlay=function(t){var e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this.updateTexture(),this.play()},/**
     * Updates the object transform for rendering.
     *
     * @param {number} deltaTime - Time since last tick.
     */e.prototype.update=function(t){if(this._playing){var e=this.animationSpeed*t,i=this.currentFrame;if(null!==this._durations){var r=this._currentTime%1*this._durations[this.currentFrame];for(r+=e/60*1e3;r<0;)this._currentTime--,r+=this._durations[this.currentFrame];var n=Math.sign(this.animationSpeed*t);for(this._currentTime=Math.floor(this._currentTime);r>=this._durations[this.currentFrame];)r-=this._durations[this.currentFrame]*n,this._currentTime+=n;this._currentTime+=r/this._durations[this.currentFrame]}else this._currentTime+=e;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):i!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<i?this.onLoop():this.animationSpeed<0&&this.currentFrame>i&&this.onLoop()),this.updateTexture())}},/**
     * Updates the displayed texture to match the current frame index.
     *
     * @private
     */e.prototype.updateTexture=function(){var t=this.currentFrame;this._previousFrame!==t&&(this._previousFrame=t,this._texture=this._textures[t],this._textureID=-1,this._textureTrimmedID=-1,this._cachedTint=16777215,this.uvs=this._texture._uvs.uvsFloat32,this.updateAnchor&&this._anchor.copyFrom(this._texture.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))},/**
     * Stops the AnimatedSprite and destroys it.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
     */e.prototype.destroy=function(e){this.stop(),t.prototype.destroy.call(this,e),this.onComplete=null,this.onFrameChange=null,this.onLoop=null},/**
     * A short hand way of creating an AnimatedSprite from an array of frame ids.
     *
     * @static
     * @param {string[]} frames - The array of frames ids the AnimatedSprite will use as its texture frames.
     * @return {PIXI.AnimatedSprite} The new animated sprite with the specified frames.
     */e.fromFrames=function(t){for(var i=[],r=0;r<t.length;++r)i.push(rH.from(t[r]));return new e(i)},/**
     * A short hand way of creating an AnimatedSprite from an array of image ids.
     *
     * @static
     * @param {string[]} images - The array of image urls the AnimatedSprite will use as its texture frames.
     * @return {PIXI.AnimatedSprite} The new animate sprite with the specified images as frames.
     */e.fromImages=function(t){for(var i=[],r=0;r<t.length;++r)i.push(rH.from(t[r]));return new e(i)},Object.defineProperty(e.prototype,"totalFrames",{/**
         * The total number of frames in the AnimatedSprite. This is the same as number of textures
         * assigned to the AnimatedSprite.
         *
         * @readonly
         * @member {number}
         * @default 0
         */get:function(){return this._textures.length},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"textures",{/**
         * The array of textures used for this AnimatedSprite.
         *
         * @member {PIXI.Texture[]}
         */get:function(){return this._textures},set:function(t){if(t[0]instanceof rH)this._textures=t,this._durations=null;else{this._textures=[],this._durations=[];for(var e=0;e<t.length;e++)this._textures.push(t[e].texture),this._durations.push(t[e].time)}this._previousFrame=null,this.gotoAndStop(0),this.updateTexture()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"currentFrame",{/**
        * The AnimatedSprites current frame index.
        *
        * @member {number}
        * @readonly
        */get:function(){var t=Math.floor(this._currentTime)%this._textures.length;return t<0&&(t+=this._textures.length),t},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"playing",{/**
         * Indicates if the AnimatedSprite is currently playing.
         *
         * @member {boolean}
         * @readonly
         */get:function(){return this._playing},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"autoUpdate",{/**
         * Whether to use PIXI.Ticker.shared to auto update animation time
         *
         * @member {boolean}
         */get:function(){return this._autoUpdate},set:function(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(rr.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(rr.shared.add(this.update,this),this._isConnectedToTicker=!0))},enumerable:!1,configurable:!0}),e}(oB);n8.registerPlugin("accessibility",i9),n8.registerPlugin("extract",sb),n8.registerPlugin("interaction",rd),n8.registerPlugin("particle",oe),n8.registerPlugin("prepare",o7),n8.registerPlugin("batch",sc),n8.registerPlugin("tilingSprite",au),sB.registerPlugin(aO),sB.registerPlugin(sY),sB.registerPlugin(sQ),sB.registerPlugin(s4),sB.registerPlugin(ai),sy.registerPlugin(rn),sy.registerPlugin(sU);/**
 * String of the current PIXI version.
 *
 * @static
 * @constant
 * @memberof PIXI
 * @name VERSION
 * @type {string}
 */var a7="6.1.2",a9={AlphaFilter:aN,BlurFilter:aG,BlurFilterPass:aU,ColorMatrixFilter:aH,DisplacementFilter:aj,FXAAFilter:aX,NoiseFilter:aY};tR(tN,iO),tR(tN,rt),tR(tN,rp),tR(tN,rf),tR(tN,sv),tR(tN,sE),tR(tN,sH),tR(tN,s6),tR(tN,oi),tR(tN,at),tR(tN,ar),tR(tN,ac),tR(tN,re),tR(tN,eQ),tR(tN,iL),tR(tN,or),tR(tN,iN),tR(tN,ad),tR(tN,aJ),tR(tN,rm),tR(tN,oL),tR(tN,a4),tR(tN,oO),tR(tN,t2);class ht{/**
	 * Gets data of the first response
	 */getData(){return this.responses&&this.responses.length>0?this.responses[0].data:null}isProcessed(){return 0!==this.responses.length}isSuccess(){return!this.isError()}isError(){return!!this.responses.filter(t=>null!=t.error).length}constructor(){this.responses=[]}}class he{constructor(t,e,i,r){/**
	 * Data payload
	 */this.data=null,/*
	 * If any handler sets this flag to true, the message will not be sent further
	 */this.expired=!1,/**
	 * Action type identifier
	 */this._action=null,/**
	 * Component that sent this message
	 */this._component=null,/**
	 * GameObject attached to this message
	 */this._gameObject=null,this._action=t,this._component=e,this._gameObject=i,this.data=r,this.responses=new ht}get action(){return this._action}get component(){return this._component}get gameObject(){return this._gameObject}}(v6=b4||(b4={})).ANY="ANY",v6.OBJECT_ADDED="OBJECT_ADDED",v6.OBJECT_REMOVED="OBJECT_REMOVED",v6.COMPONENT_ADDED="COMPONENT_ADDED",v6.COMPONENT_DETACHED="COMPONENT_DETACHED",v6.COMPONENT_REMOVED="COMPONENT_REMOVED",v6.ATTRIBUTE_ADDED="ATTRIBUTE_ADDED",v6.ATTRIBUTE_CHANGED="ATTRIBUTE_CHANGED",v6.ATTRIBUTE_REMOVED="ATTRIBUTE_REMOVED",v6.STATE_CHANGED="STATE_CHANGED",v6.FLAG_CHANGED="FLAG_CHANGED",v6.TAG_ADDED="TAG_ADDED",v6.TAG_REMOVED="TAG_REMOVED",v6.SCENE_CLEAR="SCENE_CLEAR",(v8=b6||(b6={}))[v8.NEW=0]="NEW",v8[v8.INITIALIZED=1]="INITIALIZED",v8[v8.RUNNING=2]="RUNNING",v8[v8.DETACHED=3]="DETACHED",v8[v8.FINISHED=4]="FINISHED",v8[v8.REMOVED=5]="REMOVED";class hi{static #t=(()=>{this.idCounter=0})();constructor(t){// owner object of this component
this.owner=null,// link to scene
this.scene=null,// component state
this._cmpState=b6.NEW,// auto-incremented id
this._id=0,this._id=hi.idCounter++,this._lastFixedUpdate=0,this.props=t}get id(){return this._id}get name(){return this._name||this.constructor.name}get cmpState(){return this._cmpState}get isCompleted(){return this._cmpState===b6.FINISHED||this._cmpState===b6.REMOVED}/**
	 * Called when the component is being added to a new object FOR THE FIRST TIME
	 */onInit(){// override
}/**
	 * Called when the component is being added to the scene
	 */onAttach(){// override
}/**
	 * Handles incoming message
	 */onMessage(t){// override
}/**
	 * Handles fixed update loop
	 * Called ONLY if fixedFrequency is set
	 */onFixedUpdate(t,e){// override
}/**
	 * Handles update loop
	 */onUpdate(t,e){// override
}/**
	 * Called before the owner object gets detached from the scene
	 */onDetach(){// override
}/**
	 * Called before the component gets removed from its owner object
	 */onRemove(){// override
}/**
	 * Called after finish()
	 */onFinish(){// override
}/**
	 * Subscribes itself as a listener for an action of a given key
	 */subscribe(...t){for(let e of t)this.scene._subscribeComponent(e,this)}/**
	 * Unsubscribes itself from given action (or a set of actions)
	 */unsubscribe(...t){for(let e of t)this.scene._unsubscribeComponent(e,this)}/**
	 * Sends a message to all subscribers
	 */sendMessage(t,e,i){let r=new he(t,this,this.owner,e);return this.scene.sendMessage(r,i),r}/**
	 * Aborts the component and immediately removes it from its object
	 * Will call onFinish(), onDetach() and onRemove()
	 */finish(){this.owner&&this._cmpState===b6.RUNNING&&(this.onFinish(),this._cmpState=b6.FINISHED,this.owner.removeComponent(this))}}/**
 * Slightly optimized bit array for flags
 */class hr{/**
	 * Returns true, if given flag is set
	 */hasFlag(t){if(t<1||t>128)throw Error("Only flag values between 1-128 are supported");let e=this.getFlagIndex(t),i=1<<this.getFlagOffset(t);if(e<=3)switch(e){case 0:return(this.flags[0]&i)===i;case 1:return(this.flags[1]&i)===i;case 2:return(this.flags[2]&i)===i;case 3:return(this.flags[3]&i)===i}else throw Error("Flag at unsupported index");return!1}/**
	 * Inverts given flag
	 */invertFlag(t){this.hasFlag(t)?this.resetFlag(t):this.setFlag(t)}/**
	 * Will switch two flags
	 */switchFlag(t,e){let i=this.hasFlag(e);this.hasFlag(t)?this.setFlag(e):this.resetFlag(e),i?this.setFlag(t):this.resetFlag(t)}/**
	 * Sets given flag to true
	 */setFlag(t){this.changeFlag(!0,t)}/**
	 * Sets given flag to false
	 */resetFlag(t){this.changeFlag(!1,t)}/**
	 * Gets set of all flags in numeric values (1-128)
	 */getAllFlags(){let t=new Set,e=0;for(let i=0;i<this.flags.length;i++){let r=this.flags[i];if(e++,0!==r)for(let i=1;i<=32;i++){let n=1<<i-1;(r&n)===n&&t.add(i+(e-1)*32)}// skip unassigned flags
}return t}getFlagIndex(t){return Math.floor((t-1)/32);// sizeof 64bit int
}getFlagOffset(t){return(t-1)%32;// sizeof 64bit int
}changeFlag(t,e){if(e<1||e>128)throw Error("Flag at unsupported index");let i=this.getFlagIndex(e),r=1<<this.getFlagOffset(e);if(i<=3)switch(i){case 0:t?this.flags[0]|=r:this.flags[0]&=~r;break;case 1:t?this.flags[1]|=r:this.flags[1]&=~r;break;case 2:t?this.flags[2]|=r:this.flags[2]&=~r;break;case 3:t?this.flags[3]|=r:this.flags[3]&=~r}else throw Error("Flag at unsupported index")}constructor(){// flag array 1-128
this.flags=new Uint32Array(4)}}(v7=b8||(b8={}))[v7.NEW=0]="NEW",v7[v7.ATTACHED=1]="ATTACHED",v7[v7.DETACHED=2]="DETACHED",v7[v7.DESTROYED=3]="DESTROYED";class hn{static #t=(()=>{this.idCounter=0})();constructor(t,e){// auto-incremented identifier
this._id=0,// state of this object
this._stateId=0,// game object this proxy is attached to
this._pixiObj=null,// link to scene
this._scene=null,// collection of tags
this._tags=new Set,// bit-array of flags
this.flags=new hr,// set of all components, mapped by their id
this.components=new Map,// generic attributse
this.attributes=new Map,// list of components that will be added at the end of update loop
this.componentsToAdd=[],this._internalState=b8.NEW,// last value of the game time
this.lastAbsolute=0,this._id=hn.idCounter++,this._pixiObj=e,this._pixiObj.name=t}get id(){return this._id}get pixiObj(){return this._pixiObj}get scene(){return this._scene}set scene(t){this._scene=t}get rawAttributes(){return this.attributes}get rawComponents(){return this.components}get tags(){return new Set(this._tags)}get isOnScene(){return null!==this.scene}get internalState(){return this._internalState}getAllFlags(){return this.flags.getAllFlags()}/**
	 * Returns true if this object is still waiting for
	 * an update within the scope of the current tick
	 */get waitingForUpdate(){return this.lastAbsolute<this.scene.currentAbsolute}/**
	 * Adds a new component
	 */addComponent(t,e=!1){if(e){if(!this.isOnScene)throw Error("This object hasn't been added to the scene yet");if(this._internalState===b8.DETACHED)throw Error("Can't run a component upon a detached object!");this.initNewComponent(t),this.waitingForUpdate||t.onUpdate(this.scene.currentDelta,this.scene.currentAbsolute)}else this.componentsToAdd.push(t)}/**
	 * Removes an existing component
	 */removeComponent(t){t._cmpState===b6.RUNNING&&(t.onFinish(),t._cmpState=b6.FINISHED),t.onDetach(),t._cmpState=b6.DETACHED,t.onRemove(),t._cmpState=b6.REMOVED,t._lastFixedUpdate=0,t.owner=null,this.components.delete(t.id),this.isOnScene&&// if this object is still attached to the scene
this.scene._onComponentRemoved(t,this)}/**
	 * Removes all components
	 */removeAllComponents(){for(let[,t]of this.components)this.removeComponent(t)}/**
	 * Tries to find a component by given class name
	 * Keep in mind that if the name of a component is not specified as an attribute,
	 * this method may not work for minified/obfuscated code
	 */findComponentByName(t){for(let[,e]of this.components)if(e.name===t)return e;return null}/**
	 * Inserts a new attribute or modifies an existing one
	 */assignAttribute(t,e){if(this.attributes.has(t)){// replacing existing attribute
let i=this.attributes.get(t);this.attributes.set(t,e),this.isOnScene&&this.scene._onAttributeChanged(t,i,e,this)}else // new attribute
this.attributes.set(t,e),this.isOnScene&&this.scene._onAttributeAdded(t,e,this)}/**
	 * Gets an attribute by its key
	 */getAttribute(t){return this.attributes.get(t)}/**
	 * Removes an existing attribute
	 */removeAttribute(t){if(this.attributes.has(t)){let e=this.attributes.get(t);return this.attributes.delete(t),this.isOnScene&&this.scene._onAttributeRemoved(t,e,this),!0}return!1}/**
	 * Add a new tag
	 */addTag(t){this._tags.add(t),this.isOnScene&&this.scene._onTagAdded(t,this)}/**
	 * Removes tag
	 */removeTag(t){this._tags.has(t)&&(this._tags.delete(t),this.isOnScene&&this.scene._onTagRemoved(t,this))}/**
	 * Returns true if a given tag is set
	 */hasTag(t){return this._tags.has(t)}/**
	 * Sets flag at a given index
	 */setFlag(t){this.flags.setFlag(t),this.isOnScene&&this.scene._onFlagChanged(t,!0,this)}/**
	 * Resets flag at a given index
	 */resetFlag(t){this.flags.resetFlag(t),this.isOnScene&&this.scene._onFlagChanged(t,!1,this)}/**
	 * Returns true, if a flag at a given index is set
	 */hasFlag(t){return this.flags.hasFlag(t)}/**
	 * Inverts a flag at a given index
	 */invertFlag(t){this.flags.invertFlag(t),this.isOnScene&&this.scene._onFlagChanged(t,this.flags.hasFlag(t),this)}/**
	 * Gets a numeric state of this object
	 */get stateId(){return this._stateId}/**
	 * Sets a numeric state of this object
	 */set stateId(t){let e=this.stateId;this._stateId=t,this.isOnScene&&this.scene._onStateChanged(e,t,this)}/**
	 * Processes a new child
	 * The child will initialize all components just here
	 */onChildAdded(t){if(t.internalState===b8.ATTACHED)throw Error(`This object has already been added to the scene: ${t.pixiObj.name}`);t.scene=this.scene,t.attach()}/**
	 * Processes a removed child
	 * The child will detach all components just here
	 */onChildDetached(t){t.detach()}/**
	 * Processes a destroyed child
	 * The child will remove all components and destroys the PIXI object
	 */onChildDestroyed(t){t.destroy()}update(t,e){// update all components
for(let[,i]of(// initialize all components from the previous loop
this.initNewComponents(),this.components))if(i._cmpState===b6.RUNNING&&(i.onUpdate(t,e),i.fixedFrequency&&e-i._lastFixedUpdate>=1e3/i.fixedFrequency)){let t=0===i._lastFixedUpdate?1e3/i.fixedFrequency:e-i._lastFixedUpdate;i.onFixedUpdate(t,e),i._lastFixedUpdate=e}// update all children recursively and their components
for(let i of this.pixiObj.children)i&&i._proxy&&i._proxy.update(t,e);this.lastAbsolute=e}initNewComponent(t){if(!this.isOnScene)throw Error("The object must be on the scene before its components are initialized");if(null!==t.owner)throw Error(`The component ${t.name}:${t.id} seems to already have a game object assigned!`);t.owner=this.pixiObj,this.components.set(t.id,t),this.scene._onComponentAdded(t,this),t.onInit(),t._cmpState=b6.INITIALIZED,t.onAttach(),t._cmpState=b6.RUNNING}initNewComponents(){if(0!==this.componentsToAdd.length){// create a copy because someone else can add new components in the meantime
let t=[...this.componentsToAdd];this.componentsToAdd=[],t.forEach(t=>{// at first, add it to the set so it can be looked up
this.components.set(t.id,t),this.initNewComponent(t)})}}attach(){for(let t of(this._internalState=b8.ATTACHED,this.scene._onObjectAdded(this),this.initNewComponents(),// re-attach detached components
this.components.forEach(t=>{t.cmpState===b6.DETACHED&&(this.scene._onComponentAdded(t,this),t.onAttach(),t._cmpState=b6.RUNNING)}),this.pixiObj.children))t&&t._proxy&&t._proxy.attach()}detach(){for(let t of(this._internalState=b8.DETACHED,// detach all components
this.components.forEach(t=>{t._cmpState!==b6.DETACHED&&(this.scene._onComponentDetached(t),t.onDetach(),t._cmpState=b6.DETACHED)}),this.scene._onObjectRemoved(this),this.pixiObj.children))t&&t._proxy&&t._proxy.detach()}destroy(){for(let t of(this._internalState=b8.DESTROYED,this.removeAllComponents(),this.scene._onObjectRemoved(this),this.pixiObj.children))t&&t._proxy&&t._proxy.destroy()}}class hs extends i8{constructor(t=""){super(),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class ho{insert(t,e){return this.items.has(t)||this.items.set(t,new Map),!this.items.get(t).has(e.id)&&(this.items.get(t).set(e.id,e),this.itemKeys.has(e.id)||this.itemKeys.set(e.id,new Set),this.itemKeys.get(e.id).add(t),!0)// already is in the collection
}remove(t,e){return this.itemKeys.delete(e.id),!!this.items.has(t)&&(this.items.get(t).delete(e.id),0===this.items.get(t).size&&this.items.delete(t),!0)}removeItem(t){if(this.itemKeys.has(t.id)){for(let e of this.itemKeys.get(t.id))this.remove(e,t);this.itemKeys.delete(t.id)}}findFirst(t){return this.items.has(t)?this.items.get(t).values().next().value:null}findAll(t){return this.items.has(t)?[...this.items.get(t).values()]:[]}clear(){this.items.clear(),this.itemKeys.clear()}constructor(){this.items=new Map,this.itemKeys=new Map// helper for faster inverted search
}}(v9=b7||(b7={}))[v9.KEY_LEFT=37]="KEY_LEFT",v9[v9.KEY_UP=38]="KEY_UP",v9[v9.KEY_RIGHT=39]="KEY_RIGHT",v9[v9.KEY_DOWN=40]="KEY_DOWN",v9[v9.KEY_CTRL=17]="KEY_CTRL",v9[v9.KEY_ALT=18]="KEY_ALT",v9[v9.KEY_SPACE=32]="KEY_SPACE",v9[v9.KEY_SHIFT=16]="KEY_SHIFT",v9[v9.KEY_ENTER=13]="KEY_ENTER",v9[v9.KEY_A=65]="KEY_A",v9[v9.KEY_B=66]="KEY_B",v9[v9.KEY_C=67]="KEY_C",v9[v9.KEY_D=68]="KEY_D",v9[v9.KEY_E=69]="KEY_E",v9[v9.KEY_F=70]="KEY_F",v9[v9.KEY_G=71]="KEY_G",v9[v9.KEY_H=72]="KEY_H",v9[v9.KEY_I=73]="KEY_I",v9[v9.KEY_J=74]="KEY_J",v9[v9.KEY_K=75]="KEY_K",v9[v9.KEY_L=76]="KEY_L",v9[v9.KEY_M=77]="KEY_M",v9[v9.KEY_N=78]="KEY_N",v9[v9.KEY_O=79]="KEY_O",v9[v9.KEY_P=80]="KEY_P",v9[v9.KEY_Q=81]="KEY_Q",v9[v9.KEY_R=82]="KEY_R",v9[v9.KEY_S=83]="KEY_S",v9[v9.KEY_T=84]="KEY_T",v9[v9.KEY_U=85]="KEY_U",v9[v9.KEY_V=86]="KEY_V",v9[v9.KEY_W=87]="KEY_W",v9[v9.KEY_X=88]="KEY_X",v9[v9.KEY_Y=89]="KEY_Y",v9[v9.KEY_Z=90]="KEY_Z";class ha extends hi{constructor(){super(),this.keys=new Set,this.handledKeys=new Set,this.onKeyDown=t=>{this.pressKey(t.keyCode)},this.onKeyUp=t=>{this.releaseKey(t.keyCode)},this._name=ha.name}onAttach(){document.addEventListener("keyup",this.onKeyUp,!1),document.addEventListener("keydown",this.onKeyDown,!1)}onDetach(){document.removeEventListener("keyup",this.onKeyUp),document.removeEventListener("keydown",this.onKeyDown)}/**
	 * Returns true if given key is pressed
	 * @param keyCode code of the key. You can use enum Keys to get the code your need
	 * @param includeHandled if true, it will check for already handled keys as well
	 */isKeyPressed(t,e=!1){return this.keys.has(t)||e&&this.handledKeys.has(t)}/**
	 * Marks given key as handled
	 */handleKey(t){this.keys.delete(t),this.handledKeys.add(t)}pressKey(t){this.handledKeys.has(t)||this.keys.add(t)}releaseKey(t){this.handledKeys.delete(t),this.keys.delete(t)}}class hh extends hi{onInit(){this.initDebugWindow(),// subscribe to all messages
this.subscribe(b4.ANY)}onMessage(t){// discared messages from the log
if(-1===this.discaredMessages.indexOf(t.action)){let e=document.createElement("tr"),i=document.createElement("td"),r=document.createElement("td"),n=document.createElement("td"),s=document.createElement("td");i.style.color="#CDCDCD",r.style.color="#ff7e7e",n.style.color="#7e8bff",s.style.color="#7eff80",i.innerText=(this.scene.currentAbsolute/1e3).toFixed(2),r.innerText=t.action,n.innerText=t.component?t.component.name:"n/a",s.innerText=t.gameObject?t.gameObject.name:"n/a",e.appendChild(i),e.appendChild(r),e.appendChild(n),e.appendChild(s),this.msgElement.insertBefore(e,this.msgElement.childNodes[0]),this.msgElement.scrollTo(0,0)}if(t.action===b4.OBJECT_ADDED)this.addGameObject(t.gameObject);else if(t.action===b4.COMPONENT_ADDED)this.addComponent(t.component,t.gameObject);else if(t.action===b4.COMPONENT_REMOVED)this.removeComponent(t.component);else if(t.action===b4.OBJECT_REMOVED){let e=document.getElementById(this.getObjectId(t.gameObject));e&&e.remove()}else t.action===b4.SCENE_CLEAR&&(this.debugElement.innerHTML="")}addGameObject(t){let e=this.getObjectId(t),i=document.getElementById(e);if(i)return;if(null!==t.pixiObj.parent){// add under the parent
let e=document.createElement("ul");i=document.createElement("li"),e.appendChild(i),i.id=this.getObjectId(t);let r=document.getElementById(this.getObjectId(t.pixiObj.parent));null==r&&(// parent hasn't been created yet -> create it accordingly
this.addGameObject(t.parentGameObject),r=document.getElementById(this.getObjectId(t.pixiObj.parent))),r.appendChild(e)}else(i=document.createElement("li")).id=this.getObjectId(t),this.debugElement.childNodes[0].appendChild(i);let r=document.createElement("span");for(let e of(r.style.color="#ff7e7e",r.innerText=t.id+":"+t.name,i.appendChild(r),["components"])){let r=document.createElement("ul");r.id=this.getObjectId(t)+"_"+e,i.appendChild(r)}for(let[,e]of t._proxy.rawComponents)this.addComponent(e,t)}removeGameObject(t){let e=document.getElementById(this.getObjectId(t)),i=e.parentElement;e.remove(),0===i.childElementCount&&i.remove()}addComponent(t,e){if(null===document.getElementById(this.getObjectId(e))&&this.addGameObject(e),null!==document.getElementById(this.getComponentId(t)))return;let i=document.getElementById(this.getComponentSectionId(e)),r=document.createElement("li"),n=document.createElement("span");if(n.style.color="#7e8bff",r.id=this.getComponentId(t),i.appendChild(r),r.appendChild(n),n.innerText=t.id+":"+t.name,t.props&&this.displayProps)try{let e=JSON.stringify(t.props),i=document.createElement("ul"),n=document.createElement("li"),s=document.createElement("span");s.style.color="#7eff80",s.innerHTML=e,r.appendChild(i),i.appendChild(n),n.appendChild(s)}catch(t){// cyclic item value err
}}removeComponent(t){let e=document.getElementById(this.getComponentId(t));e&&e.remove()}getObjectId(t){return`node_${t.id}`}getObjectInfoSectionId(t){return"node_"+t.id+"_info"}getComponentSectionId(t){return"node_"+t.id+"_components"}getComponentId(t){return"cmp_"+t.id}initDebugWindow(){let t=document.getElementById("debugContainer");t||((t=document.createElement("div")).id="debugContainer",t.style.width="800px",t.style.display="inline",document.getElementsByTagName("body")[0].appendChild(t)),// prevent key down as we don't want to scroll while playing the game
document.onkeydown=t=>{-1!==[b7.KEY_LEFT,b7.KEY_RIGHT,b7.KEY_UP,b7.KEY_DOWN].indexOf(t.keyCode)&&t.preventDefault()};let e=document.getElementById("debug");e||((e=document.createElement("div")).id="debug",e.style.width="400px",e.style.height="100vh",e.style.overflow="scroll",e.style.cssFloat="left",e.style.backgroundColor="#000",e.style.fontFamily="'Courier New', monospace",e.style.fontSize="15px",t.appendChild(e)),e.innerHTML="";let i=document.createElement("ul");e.appendChild(i);let r=document.getElementById("debug_msg");if(!r){(r=document.createElement("div")).id="debug_msg",r.style.width="400px",r.style.height="100vh",r.style.overflow="scroll",r.style.cssFloat="left",r.style.backgroundColor="#000",r.style.fontFamily="'Courier New', monospace",r.style.fontSize="15px";let e=document.createElement("table");r.appendChild(e),t.appendChild(r)}this.debugElement=e,this.msgElement=r.children[0]}constructor(...t){super(...t),// messages that will be ignored
this.discaredMessages=[b4.COMPONENT_ADDED,b4.COMPONENT_REMOVED,b4.OBJECT_ADDED,b4.OBJECT_REMOVED,b4.STATE_CHANGED,b4.ATTRIBUTE_CHANGED,b4.ATTRIBUTE_REMOVED],// if true, will also render properties
this.displayProps=!0,this.debugElement=null,this.msgElement=null}}const hl=(t,e)=>!!t&&!!((void 0===e.ownerId||t.id===e.ownerId)&&(void 0===e.ownerName||t.name===e.ownerName)&&(void 0===e.ownerTag||t.hasTag(e.ownerTag))&&(void 0===e.ownerState||t.stateId===e.ownerState)&&(void 0===e.ownerFlag||t.hasFlag(e.ownerFlag))),hu={flagsSearchEnabled:!1,statesSearchEnabled:!1,tagsSearchEnabled:!0,namesSearchEnabled:!0,notifyAttributeChanges:!1,notifyStateChanges:!1,notifyFlagChanges:!1,notifyTagChanges:!1,debugEnabled:!1};class hc{constructor(t,e,i){// PIXI stage object
this.stage=null,this.name=t,this.subscribers=new ho,this.gameObjects=new Map,this.initConfig(i),this.app=e,this.resolution=this.app.renderer.resolution,this.width=this.app.renderer.width/this.resolution,this.height=this.app.renderer.height/this.resolution,this.clearScene()}get config(){return this._config}get currentDelta(){return this._currentDelta}get currentAbsolute(){return this._currentAbsolute}/**
	 * Adds a new function that will be invoked after a given amount of time
	 * @param delay delay in miliseconds. If 0, it will be invoked IN THE END OF THE UPDATE LOOP
	 * @param action function pointer with no arguments
	 */callWithDelay(t,e){this.pendingInvocations.push({delay:t,time:0,action:e})}/**
	 * Adds a component to the stage object (global component)
	 */addGlobalComponent(t){this.stage.addComponent(t)}/**
	 * Adds a component to the stage object and invokes it immediately (global component)
	 */addGlobalComponentAndRun(t){this.stage.addComponentAndRun(t)}/**
	 * Tries to find a global component by its class
	 */findGlobalComponentByName(t){return this.stage.findComponentByName(t)}/**
	 * Removes a component from a stage object
	 */removeGlobalComponent(t){this.stage.removeComponent(t)}/**
	 * Inserts a global attribute
	 */assignGlobalAttribute(t,e){this.stage.assignAttribute(t,e)}/**
	 * Gets a global attribute by its id
	 */getGlobalAttribute(t){return this.stage.getAttribute(t)}/**
	 * Removes a global attribute by its key
	 */removeGlobalAttribute(t){return this.stage.removeAttribute(t)}/**
	 * Gets object by its id
	 */findObjectById(t){return this.gameObjects.has(t)?this.gameObjects.get(t):null}/**
	 * Finds all objects that meet specific condition
	 */findObjectsByQuery(t){let e=[];// linear complexity
for(let[,i]of this.gameObjects)hl(i,t)&&e.push(i);return e}/**
	 * Finds all game objects by their name
	 */findObjectsByName(t){if(!this.config.namesSearchEnabled)throw Error("Searching by name is not enabled. See SceneConfig");return this.gameObjectNames.findAll(t)}/**
	 * Finds a first object of a given name
	 */findObjectByName(t){if(!this.config.namesSearchEnabled)throw Error("Searching by name is not enabled. See SceneConfig");return this.gameObjectNames.findFirst(t)}/**
	 * Finds all game objects by their tag
	 */findObjectsByTag(t){if(!this.config.tagsSearchEnabled)throw Error("Searching by tag is not enabled. See SceneConfig");return this.gameObjectTags.findAll(t)}/**
	 * Finds a first object with a given tag
	 */findObjectByTag(t){if(!this.config.tagsSearchEnabled)throw Error("Searching by tag is not enabled. See SceneConfig");return this.gameObjectTags.findFirst(t)}/**
	 * Finds all game objects by their flag
	 */findObjectsByFlag(t){if(!this.config.flagsSearchEnabled)throw Error("Searching by flags is not enabled. See SceneConfig");return this.gameObjectFlags.findAll(t)}/**
	 * Finds a first object with a given flag
	 */findObjectByFlag(t){if(!this.config.flagsSearchEnabled)throw Error("Searching by flags is not enabled. See SceneConfig");return this.gameObjectFlags.findFirst(t)}/**
	 * Finds all game objects by their state
	 */findObjectsByState(t){if(!this.config.statesSearchEnabled)throw Error("Searching by states is not enabled. See SceneConfig");return this.gameObjectStates.findAll(t)}/**
	 * Finds a first object of a given state
	 */findObjectByState(t){if(!this.config.statesSearchEnabled)throw Error("Searching by states is not enabled. See SceneConfig");return this.gameObjectStates.findFirst(t)}/**
	 * Sends message to all subscribers
	 */sendMessage(t,e){let i=[];this.subscribers.findAll(t.action).forEach(r=>{// don't send expired messages
// don't send message to its own sender
if(!t.expired&&(null==t.component||t.component.id!==r.id)&&(!e||e.find(t=>r.owner.hasTag(t)))){// collect responses
let e=r.onMessage(t);e&&i.push({componentId:r.id,data:e})}}),t.responses.responses=i,// check global subscribers that are interested in all messages (usually for debugging)
this.subscribers.findAll(b4.ANY).forEach(e=>e.onMessage(t)),this.config.debugEnabled&&console.log(`MSG: ${t.action}; ${t.responses.isProcessed()?"PROCESSED":"IGNORED"} ${t.responses.isError()?"ERROR":"SUCCESS"}`)}/**
	 * Removes all objects from scene at the end of current update loop
	 */clearSceneAsync(t){this.callWithDelay(0,()=>this.clearScene(t))}/**
	 * Removes all objects from the scene
	 */clearScene(t){if(this.isUpdating)throw Error("Scene can't be cleared during update loop. Use clearSceneAsync() instead!");this.sendMessage(new he(b4.SCENE_CLEAR,null,null,this.name)),t&&this.initConfig(t),// reinitialize everything
this.subscribers.clear(),this.config.namesSearchEnabled&&(this.gameObjectNames?this.gameObjectNames.clear():this.gameObjectNames=new ho),this.config.statesSearchEnabled&&(this.gameObjectStates?this.gameObjectStates.clear():this.gameObjectStates=new ho),this.config.tagsSearchEnabled&&(this.gameObjectTags?this.gameObjectTags.clear():this.gameObjectTags=new ho),this.config.flagsSearchEnabled&&(this.gameObjectFlags?this.gameObjectFlags.clear():this.gameObjectFlags=new ho),this.sceneCleared=!0,this.gameObjects.clear(),this.pendingInvocations=[],this._currentDelta=this._currentAbsolute=0;let e=new hs("stage");// stage doesn't have any parents, we need to remove its children recursively
for(let t of this.app.stage.children)t.destroy();this.app.stage.destroy(),this.app.stage=e,e._proxy.scene=this,this.stage=e,this.config.debugEnabled&&this.addGlobalComponentAndRun(new hh),this._onObjectAdded(e._proxy)}// ===============================================================================
// methods that are supposed to be invoked only from within this library
// ===============================================================================
// executes the update cycle
_update(t,e){this.sceneCleared&&(this.sceneCleared=!1),this._currentDelta=t,this._currentAbsolute=e,this.isUpdating=!0,// update root object and all other objects recursively
this.stage._proxy.update(t,e),this.isUpdating=!1;// execute pending invocations
let i=this.pendingInvocations.length;for(;i--;){let e=this.pendingInvocations[i];if(e.time+=t,e.time>=e.delay&&(// call the function and remove it from the collection
this.pendingInvocations.splice(i,1),e.action(),this.sceneCleared))break}}// subscribes given component for messaging system
_subscribeComponent(t,e){this.subscribers.insert(t,e)}// unsubscribes given component
_unsubscribeComponent(t,e){this.subscribers.remove(t,e)}_onObjectAdded(t){let e=t.pixiObj;this.config.namesSearchEnabled&&this.gameObjectNames.insert(e.name,e),this.config.flagsSearchEnabled&&t.getAllFlags().forEach(t=>this.gameObjectFlags.insert(t,e)),this.config.tagsSearchEnabled&&t.tags.forEach(t=>this.gameObjectTags.insert(t,e)),this.config.statesSearchEnabled&&this.gameObjectStates.insert(e.stateId,e),this.gameObjects.set(t.id,t.pixiObj),this.sendMessage(new he(b4.OBJECT_ADDED,null,t.pixiObj))}_onObjectRemoved(t){let e=t.pixiObj;this.config.namesSearchEnabled&&this.gameObjectNames.remove(e.name,e),this.config.flagsSearchEnabled&&this.gameObjectFlags.removeItem(e),this.config.statesSearchEnabled&&this.gameObjectStates.removeItem(e),this.config.tagsSearchEnabled&&this.gameObjectTags.removeItem(e),this.gameObjects.delete(t.id),// notify listeners
this.sendMessage(new he(b4.OBJECT_REMOVED,null,e))}_onComponentAdded(t,e){t.scene=this,this.sendMessage(new he(b4.COMPONENT_ADDED,t,e.pixiObj))}_onComponentDetached(t){this.subscribers.removeItem(t),this.sendMessage(new he(b4.COMPONENT_DETACHED,t,t.owner))}_onComponentRemoved(t,e){this.subscribers.removeItem(t),this.sendMessage(new he(b4.COMPONENT_REMOVED,t,e.pixiObj))}_onStateChanged(t,e,i){this.config.statesSearchEnabled&&(this.gameObjectStates.remove(t,i.pixiObj),this.gameObjectStates.insert(e,i.pixiObj)),this.config.notifyStateChanges&&this.sendMessage(new he(b4.STATE_CHANGED,null,i.pixiObj,{previous:t,current:e}))}_onAttributeAdded(t,e,i){if(this.config.notifyAttributeChanges){let r={key:t,type:b4.ATTRIBUTE_ADDED,previousValue:null,currentValue:e};this.sendMessage(new he(b4.ATTRIBUTE_ADDED,null,i.pixiObj,r))}}_onAttributeChanged(t,e,i,r){if(this.config.notifyAttributeChanges){let n={key:t,type:b4.ATTRIBUTE_CHANGED,previousValue:e,currentValue:i};this.sendMessage(new he(b4.ATTRIBUTE_CHANGED,null,r.pixiObj,n))}}_onAttributeRemoved(t,e,i){if(this.config.notifyAttributeChanges){let r={key:t,type:b4.ATTRIBUTE_REMOVED,previousValue:e,currentValue:null};this.sendMessage(new he(b4.ATTRIBUTE_REMOVED,null,i.pixiObj,r))}}_onFlagChanged(t,e,i){this.config.flagsSearchEnabled&&(e?this.gameObjectFlags.insert(t,i.pixiObj):this.gameObjectFlags.remove(t,i.pixiObj)),this.config.notifyFlagChanges&&this.sendMessage(new he(b4.FLAG_CHANGED,null,i.pixiObj,{flag:t,isSet:e}))}_onTagAdded(t,e){if(this.config.tagsSearchEnabled&&this.gameObjectTags.insert(t,e.pixiObj),this.config.notifyTagChanges){let i={tag:t,type:b4.TAG_ADDED};this.sendMessage(new he(b4.TAG_ADDED,null,e.pixiObj,i))}}_onTagRemoved(t,e){if(this.config.tagsSearchEnabled&&this.gameObjectTags.remove(t,e.pixiObj),this.config.notifyTagChanges){let i={tag:t,type:b4.TAG_REMOVED};this.sendMessage(new he(b4.TAG_REMOVED,null,e.pixiObj,i))}}initConfig(t){this._config={...hu,...t}}}const hd=()=>/(iphone|ipod|ipad|android)/gi.test(navigator.userAgent),hp=(t,e,i)=>{let r;let n=!1;window.innerWidth/window.innerHeight>e/i?r=window.innerHeight/i:(r=window.innerWidth/e,n=!0);// On some mobile devices '100vh' is taller than the visible
// viewport which leads to part of the presentation being
let s=()=>setTimeout(()=>{window.scrollTo(0,1)},10);hd()&&(document.documentElement.style.setProperty("--vh",.01*window.innerHeight+"px"),// Events that should trigger the address bar to hide
window.addEventListener("load",s,!1),window.addEventListener("orientationchange",s,!1));let o=`scale(${r})`,a=n?window.innerHeight/2-i/2:(r-1)*i/2;t.style.setProperty("position","absolute"),t.style.setProperty("MozTransform",o),t.style.setProperty("transform",o),t.style.setProperty("WebkitTransform",o),t.style.setProperty("top",a+"px"),t.style.setProperty("left",(r-1)*e/2+(window.innerWidth-e*r)/2+"px")};window.PIXI=tN,(xt=b9||(b9={})).FIXED="FIXED",xt.VARIABLE="VARIABLE";const hf={...hu,resizeToScreen:!1,transparent:!1,backgroundColor:0,antialias:!0,resolution:1,gameLoopThreshold:300,gameLoopFixedTick:16,speed:1,gameLoopType:b9.VARIABLE};class hm{init(t,e){// merge config
this.config={...hf,...e},// enable debug if the query string contains ?debug
this.config.debugEnabled=this.config.debugEnabled||/[?&]debug/.test(location.search),// do not resize to screen if debug window is on
this.config.resizeToScreen=(this.config.resizeToScreen||/[?&]responsive/.test(location.search))&&!this.config.debugEnabled,this.virtualWidth=this.config.width||t.width,this.virtualHeight=this.config.height||t.height,this.app=new tN.Application({width:this.virtualWidth/this.config.resolution,height:this.virtualHeight/this.config.resolution,view:t,resolution:this.config.resolution,transparent:this.config.transparent,antialias:this.config.antialias,backgroundColor:this.config.backgroundColor}),this.scene=new hc("default",this.app,this.config),this.config.resizeToScreen&&this.initResizeHandler(),this.ticker=this.app.ticker,// stop the shared ticket and update it manually
this.ticker.autoStart=!1,this.ticker.stop(),this._running=!0,this.loop(performance.now())}get running(){return this._running}destroy(){this.app.destroy(!1),this._running=!1,this.config.resizeToScreen&&window.removeEventListener("resize",this.resizeHandler)}loop(t){let e=Math.min(t-this.lastFrameTime,this.config.gameLoopThreshold)*this.config.speed;this.lastFrameTime=t,this.config.gameLoopType===b9.FIXED?(// fixed game loop
this.gameTime+=this.config.gameLoopFixedTick*this.config.speed,this.scene._update(this.config.gameLoopFixedTick*this.config.speed,this.gameTime)):(// variable game loop
this.gameTime+=e,this.scene._update(e,this.gameTime)),this._running&&(this.ticker.update(this.gameTime),requestAnimationFrame(t=>this.loop(t)))}initResizeHandler(){hp(this.app.view,this.virtualWidth,this.virtualHeight),window.addEventListener("resize",this.resizeHandler)}constructor(){this.app=null,this.lastFrameTime=0,this.gameTime=0,this.scene=null,this.ticker=null,this.resizeHandler=()=>hp(this.app.view,this.virtualWidth,this.virtualHeight)}}class hg extends aI{constructor(t="",e="",i,r,n=16777215){super(e,{fontName:i,fontSize:r,tint:n}),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){return this}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hy extends oP{constructor(t=""){super(),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){return this}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class h_ extends a_{constructor(t="",e,i,r,n){super(e,i,r,n),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){return this}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hv extends a5{constructor(t="",e,i,r,n,s){super(e,i,r,n,s),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){return this}asNineSlicePlane(){return this}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){return this}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hx extends s9{constructor(t="",e,i){super(e,i),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){return this}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hb extends oB{constructor(t="",e){super(e),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){return this}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hE extends oq{constructor(t="",e=""){super(e),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){return this}asText(){return this}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hT extends aa{constructor(t="",e,i,r){super(e,i,r),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){return this}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){return this}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hw extends a8{constructor(t="",e,i){super(e,i),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){return this}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){throw Error("Can't cast to this object!")}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){return this}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0,texture:!0,baseTexture:!1})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hS extends a3{constructor(t="",e,i,r,n,s){super(e,i,r,n,s),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){return this}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){return this}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hM extends a2{constructor(t="",e,i,r){super(e,i,r),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){return this}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){return this}asSimpleRope(){throw Error("Can't cast to this object!")}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0})}destroyChildren(){for(let t of[...this.children])t.destroy()}}class hA extends a1{constructor(t="",e,i,r){super(e,i,r),this._proxy=new hn(t,this)}get id(){return this._proxy.id}get pixiObj(){return this}get scene(){return this._proxy.scene}get parentGameObject(){return this.parent}asAnimatedSprite(){throw Error("Can't cast to this object!")}asBitmapText(){throw Error("Can't cast to this object!")}asContainer(){return this}asGraphics(){throw Error("Can't cast to this object!")}asMesh(){return this}asNineSlicePlane(){throw Error("Can't cast to this object!")}asParticleContainer(){throw Error("Can't cast to this object!")}asSimpleMesh(){throw Error("Can't cast to this object!")}asSimplePlane(){throw Error("Can't cast to this object!")}asSimpleRope(){return this}asSprite(){throw Error("Can't cast to this object!")}asText(){throw Error("Can't cast to this object!")}asTilingSprite(){throw Error("Can't cast to this object!")}// overrides pixijs function
addChild(...t){let e=super.addChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildAdded(e._proxy);return e}// overrides pixijs function
addChildAt(t,e){let i=super.addChildAt(t,e);return i&&i._proxy&&this._proxy.onChildAdded(i._proxy),i}// overrides pixijs function
removeChild(...t){let e=super.removeChild(...t);for(let e of t)e&&e._proxy&&this._proxy.onChildDetached(e._proxy);return e}// overrides pixijs function
removeChildAt(t){let e=super.removeChildAt(t);return e&&e._proxy&&this._proxy.onChildDetached(e._proxy),e}// overrides pixijs function
removeChildren(t,e){let i=super.removeChildren(t,e);for(let t of i)t&&t._proxy&&this._proxy.onChildDetached(t._proxy);return i}destroyChild(...t){let e=super.removeChild(...t);return e&&e._proxy&&this._proxy.onChildDestroyed(e._proxy),e}addComponent(t){this._proxy.addComponent(t,!1)}addComponentAndRun(t){this._proxy.addComponent(t,!0)}findComponentByName(t){return this._proxy.findComponentByName(t)}removeComponent(t){this._proxy.removeComponent(t)}assignAttribute(t,e){this._proxy.assignAttribute(t,e)}getAttribute(t){return this._proxy.getAttribute(t)}removeAttribute(t){return this._proxy.removeAttribute(t)}addTag(t){this._proxy.addTag(t)}removeTag(t){this._proxy.removeTag(t)}hasTag(t){return this._proxy.hasTag(t)}get tags(){return this._proxy.tags}setFlag(t){this._proxy.setFlag(t)}resetFlag(t){this._proxy.resetFlag(t)}hasFlag(t){return this._proxy.hasFlag(t)}invertFlag(t){this._proxy.invertFlag(t)}get stateId(){return this._proxy.stateId}set stateId(t){this._proxy.stateId=t}detach(){this.parent.removeChild(this)}destroy(){this.parentGameObject&&this.parentGameObject.destroyChild(this),super.destroy({children:!0})}destroyChildren(){for(let t of[...this.children])t.destroy()}}(xe=Et||(Et={}))[xe.AnimatedSprite=0]="AnimatedSprite",xe[xe.BitmapText=1]="BitmapText",xe[xe.Container=2]="Container",xe[xe.Graphics=3]="Graphics",xe[xe.Mesh=4]="Mesh",xe[xe.NineSlicePlane=5]="NineSlicePlane",xe[xe.ParticleContainer=6]="ParticleContainer",xe[xe.SimpleMesh=7]="SimpleMesh",xe[xe.SimplePlane=8]="SimplePlane",xe[xe.SimpleRope=9]="SimpleRope",xe[xe.Sprite=10]="Sprite",xe[xe.Text=11]="Text",xe[xe.TilingSprite=12]="TilingSprite";class hR{constructor(t){this.scene=t,this.clear()}/**
	 * Sets an anchor
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */anchor(t,e){return"number"==typeof t?(this.props.anchorX=t,null!=e?this.props.anchorY=e:this.props.anchorY=this.props.anchorX):(this.props.anchorX=t.x,this.props.anchorY=t.y),this}/**
	 * Sets a virtual anchor (it aligns the position but doesn't change the real pivot nor anchor)
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */virtualAnchor(t,e){return"number"==typeof t?(this.props.virtAnchorX=t,null!=e?this.props.virtAnchorY=e:this.props.virtAnchorY=this.props.virtAnchorX):(this.props.virtAnchorX=t.x,this.props.virtAnchorY=t.y),this}/**
	 * Sets position relative to the screen ([0,0] for topleft corner, [1,1] for bottomright corner)
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */relativePos(t,e){return"number"==typeof t?(this.props.relPosX=t,null!=e?this.props.relPosY=e:this.props.relPosY=this.props.relPosX):(this.props.relPosX=t.x,this.props.relPosY=t.y),this}/**
	 * Sets local position
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */localPos(t,e){return"number"==typeof t?(this.props.locPosX=t,null!=e?this.props.locPosY=e:this.props.locPosY=this.props.locPosX):(this.props.locPosX=t.x,this.props.locPosY=t.y),this}/**
	 * Sets global position
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */globalPos(t,e){return"number"==typeof t?(this.props.absPosX=t,null!=e?this.props.absPosY=e:this.props.absPosY=this.props.absPosX):(this.props.absPosX=t.x,this.props.absPosY=t.y),this}/**
	 * Sets local scale
	 * If you pass 'x' as a number and no 'y', it will have the same value as 'x'
	 */scale(t,e){return"number"==typeof t?(this.props.scaleX=t,null!=e?this.props.scaleY=e:this.props.scaleY=this.props.scaleX):(this.props.scaleX=t.x,this.props.scaleY=t.y),this}/**
	 * Adds an attribute to the object
	 */withAttribute(t,e){return this.props.attributes.set(t,e),this}/**
	 * Adds either a component or an arrow function that returns this component (can be used as a factory)
	 * Use arrow function if you want to use this builder for the same object more than once.
	 */withComponent(t){return t instanceof hi?this.props.components.push(t):this.props.componentBuilders.push(t),this}withComponents(t){return t.forEach(t=>this.withComponent(t)),this}withFlag(t){return this.props.flags.push(t),this}withState(t){return this.props.state=t,this}withTag(t){return this.props.tags.add(t),this}withParent(t){return this.props.parent=t,this}withChild(t){return this.children.push(t),this}withName(t){return this.props.name=t,this}asContainer(){return this.objectProps={type:Et.Container},this}asAnimatedSprite(t){return this.objectProps={type:Et.AnimatedSprite,textures:t},this}asBitmapText(t="",e,i,r){return this.objectProps={text:t,fontName:e,fontSize:i,fontColor:r,type:Et.BitmapText},this}asGraphics(){return this.objectProps={type:Et.Graphics},this}asMesh(t,e){return this.objectProps={geometry:t,shader:e,type:Et.Mesh},this}asNineSlicePlane(t,e,i,r,n){return this.objectProps={type:Et.NineSlicePlane,texture:t,leftWidth:e,topHeight:i,rightWidth:r,bottomHeight:n},this}asParticleContainer(){return this.objectProps={type:Et.ParticleContainer},this}asSimpleMesh(t,e){return this.objectProps={type:Et.SimpleMesh,texture:t,vertices:e},this}asSimplePlane(t,e,i){return this.objectProps={type:Et.SimplePlane,texture:t,verticesX:e,verticesY:i},this}asSimpleRope(t,e){return this.objectProps={type:Et.SimpleRope,texture:t,points:e},this}asSprite(t){return this.objectProps={texture:t,type:Et.Sprite},this}asTilingSprite(t,e,i){return this.objectProps={texture:t,width:e,height:i,type:Et.TilingSprite},this}asText(t="",e){return this.objectProps={text:t,fontStyle:e,type:Et.Text},this}/**
	 * Copies the attributes and properties to already existing object.
	 * All properties will be removed from the builder
	 */buildInto(t){return this.objectToBuild=t,this.process(!0)}/**
	 * Copies the attributes and properties to already existing object
	 * Properties will be kept in the builder for later use
	 */buildIntoAndKeepData(t){return this.objectToBuild=t,this.process(!1)}/**
	 * Builds a new object and removes all properties from the builder
	 */build(){return this.process(!0)}/**
	 * Builds a new object and keeps stored data
	 */buildAndKeepData(){return this.process(!1)}process(t=!0){let e;if(null!==this.objectToBuild)e=this.objectToBuild;else switch(this.objectProps.type){case Et.Container:e=new hs(this.props.name);break;case Et.AnimatedSprite:e=new hw(this.props.name,this.objectProps.textures);break;case Et.BitmapText:e=new hg(this.props.name,this.objectProps.text,this.objectProps.fontName,this.objectProps.fontSize,this.objectProps.fontColor);break;case Et.Graphics:e=new hy(this.props.name);break;case Et.Mesh:e=new h_(this.props.name,this.objectProps.geometry,this.objectProps.shader);break;case Et.NineSlicePlane:e=new hv(this.props.name,this.objectProps.texture,this.objectProps.leftWidth,this.objectProps.topHeight,this.objectProps.rightWidth,this.objectProps.bottomHeight);break;case Et.ParticleContainer:e=new hx(this.props.name,1e4,{});break;case Et.SimpleMesh:e=new hS(this.props.name,this.objectProps.texture,this.objectProps.vertices);break;case Et.SimplePlane:e=new hM(this.props.name,this.objectProps.texture,this.objectProps.verticesX,this.objectProps.verticesY);break;case Et.SimpleRope:e=new hA(this.props.name,this.objectProps.texture,this.objectProps.points);break;case Et.Sprite:e=new hb(this.props.name,this.objectProps.texture.clone());break;case Et.Text:(e=new hE(this.props.name,this.objectProps.text)).style=this.objectProps.fontStyle;break;case Et.TilingSprite:e=new hT(this.props.name,this.objectProps.texture.clone(),this.objectProps.width,this.objectProps.height)}// add all components and attributes before the object is added to the scene
// this means that we won't get any notification that attributes/components have been added
for(let t of this.props.components)e.addComponent(t);// consider also component builders
// this is very useful if this builder is used more than once
for(let t of(// for safety -> we can't use the same components for more than one object
this.props.components=[],this.props.componentBuilders))e.addComponent(t());for(let[t,i]of this.props.attributes)e.assignAttribute(t,i);for(let t of this.props.flags)e.setFlag(t);null!=this.props.state&&(e.stateId=this.props.state),0!==this.props.tags.size&&this.props.tags.forEach(t=>e.addTag(t));let i=e.pixiObj;if(null!=this.props.scaleX&&(i.scale.x=this.props.scaleX),null!=this.props.scaleY&&(i.scale.y=this.props.scaleY),null!=this.props.relPosX){let t=new ij;t.x=this.props.relPosX*this.scene.width/this.scene.stage.scale.x,i.position.x=i.toLocal(t).x,null!=this.props.scaleX&&(i.position.x*=this.props.scaleX)}if(null!=this.props.relPosY){let t=new ij;t.y=this.props.relPosY*this.scene.height/this.scene.stage.scale.y,i.position.y=i.toLocal(t).y,null!=this.props.scaleY&&(i.position.y*=this.props.scaleY)}if(null!=this.props.locPosX&&(null!=this.props.relPosX?i.position.x+=this.props.locPosX:i.position.x=this.props.locPosX),null!=this.props.locPosY&&(null!=this.props.relPosY?i.position.y+=this.props.locPosY:i.position.y=this.props.locPosY),null!=this.props.absPosX){let t=new ij;t.x=this.props.absPosX,i.position.x=i.toLocal(t,this.scene.stage.pixiObj).x,null!=this.props.scaleX&&(i.position.x*=this.props.scaleX)}if(null!=this.props.absPosY){let t=new ij;t.y=this.props.absPosY,i.position.y=i.toLocal(t,this.scene.stage.pixiObj).y,null!=this.props.scaleY&&(i.position.y*=this.props.scaleY)}if(null!=this.props.anchorX&&(i instanceof hb||i instanceof hE?i.anchor.x=this.props.anchorX:i.pivot.x=this.props.anchorX*i.width),null!=this.props.anchorY&&(i instanceof hb||i instanceof hE?i.anchor.y=this.props.anchorY:i.pivot.y=this.props.anchorY*i.height),null!=this.props.virtAnchorX){let t=this.props.virtAnchorX-(null==this.props.anchorX?0:this.props.anchorX);i.position.x-=t*i.width}if(null!=this.props.virtAnchorY){let t=this.props.virtAnchorY-(null==this.props.anchorY?0:this.props.anchorY);i.position.y-=t*i.height}// now, when this object is already assigned to its parent, we can build children
for(let i of(null!=this.props.parent&&this.props.parent.pixiObj.addChild(e.pixiObj),this.children))i.withParent(e).process(t);return t&&this.clear(),e}clear(){return this.props={name:"",components:[],componentBuilders:[],attributes:new Map,flags:[],tags:new Set},this.objectProps={type:Et.Container},this.objectToBuild=null,this.children=[],this}}class hC{constructor(){this.topNode=null,this.size=0,this.topNode=null,this.size=0}/**
	 * Pushes a new node onto the stack
	 */push(t){this.topNode=t,this.size+=1}/**
	 * Pops the current node from the stack
	 */pop(){let t=this.topNode;return this.topNode=this.topNode.previous,this.size-=1,t}/**
	 * Returns the node on the top
	 */top(){return this.topNode}}/**
 * A generic node for chain of commands
 * Stores two parameters
 */class hP{constructor(t,e=null,i=null){this.key=0,// custom parameters
this.param1=null,this.param2=null,// cached custom parameters
this.param1C=null,this.param2C=null,// if true, params are already cached
this.cached=!1,// link to previous and next node
this.next=null,this.previous=null,this.key=t,this.param1=e,this.param2=i,this.param1C=null,this.param2C=null}/**
	 * Caches params or their results (if a corresponding parameter is a function) into param<num>Cached variables
	 */cacheParams(){this.cached||(null!=this.param1&&(this.param1C="function"==typeof this.param1?this.param1():this.param1),null!=this.param2&&(this.param2C="function"==typeof this.param2?this.param2():this.param2),this.cached=!0)}getParam1(){return this.cached||this.cacheParams(),this.param1C}setParam1(t){this.param1=t,this.param1C=t}getParam2(){return this.cached||this.cacheParams(),this.param2C}setParam2(t){this.param2=t,this.param2C=t}resetCache(){this.param1C=this.param2C=null,this.cached=!1}}class hI extends hi{constructor(t="Chain"){super(),// stack of current scope
this.scopeStack=new hC,// current node
this.current=null,// linked list
this.head=null,this.tail=null,// helping parameters used for processing the current node
this.tmpParam=null,this.tmpParam2=null,this.abortIfChecks=[],this._name=t}/**
	 * Merges this component with another component.
	 * Puts the other component to the beginning of this one
	 */mergeAtBeginning(t){if(t.cmpState===b6.RUNNING)throw Error("Can't merge running component!");return this.head?(t.tail.next=this.head,this.head=t.head):(this.head=t.head,this.tail=t.tail),this.current=this.head,t.head=t.tail=null,this}/**
	 * Merges this component with another component
	 * Puts the other component to the end of this one
	 *
	 */mergeWith(t){if(t.cmpState===b6.RUNNING)throw Error("Can't merge running component!");return this.tail?(this.tail.next=t.head,this.tail=t.tail):(this.tail=t.tail,this.head=t.head),t.head=t.tail=null,this}/**
	 * Repeats the following part of the chain until endRepeat()
	 * @param num number of repetitions (0 for infinite loop); or a function that returns that number
	 */beginRepeat(t){return this.enqueue(1,t,0===t),this}/**
	 * Enclosing element for beginRepeat() command
	 */endRepeat(){return this.enqueue(2),this}/**
	 * Executes a closure
	 * @param {action} func function to execute
	 */call(t){return this.enqueue(3,t),this}/**
	 * Attaches itself to a game object and executes the chain
	 */executeUpon(t){return t.addComponentAndRun(this),this}/**
	 * Repeats the following part of the chain down to the endWhile() block
	 * till the func() returns true
	 * @param func function that returns either true or false
	 */beginWhile(t){return this.enqueue(4,t),this}/**
	 * Enclosing command for beginWhile()
	 */endWhile(){return this.enqueue(5),this}/**
	 * Starts an infinite loop that will repeat every num second
	 * @param num number of seconds to wait or function that returns that number
	 */beginInterval(t){return this.enqueue(6,t),this}/**
	 * Enclosing command for beginInterval()
	 */endInterval(){return this.enqueue(7),this}/**
	 * Checks an IF condition returned by 'func' and jumps to the next element,
	 * behind the 'else' element or behind the 'endIf' element, if the condition is not met
	 * @param func function that returns either true or false
	 */beginIf(t){return this.enqueue(8,t),this}/**
	 * Defines a set of commands that are to be executed if the condition
	 * of the current beginIf() command is not met
	 */else(){return this.enqueue(9),this}/**
	 * Enclosing command for beginIf()
	 */endIf(){return this.enqueue(10),this}/**
	 * Adds a new component to a given game object (or to the owner of this component if none specified)
	 * @param component component or function that returns a component
	 * @param gameObj game object or function that returns a game object
	 */addComponent(t,e=null){return this.enqueue(12,t,e),this}/**
	 * Waits until a given component has finished
	 * If provided component doesn't have an owner, it will be attached to the owner of this chain-component
	 * @param component or function that returns this component
	 */waitFor(t){return this.enqueue(14,t),this}/**
	 * Waits until first component has finished. The others are interrupted
	 * @param components or a function that returns a set of components
	 */waitForFirst(t){return this.enqueue(15,t),this}/**
	 * Waits till a given function returns true
	 * @param func
	 */waitUntil(t){return this.enqueue(16,t),this}/**
	 * Waits for a given number of iterations of the update loop
	 * @param num number of frames
	 */waitFrames(t){return this.enqueue(17,t),this}/**
	 * Waits for a given amount of miliseconds
	 * @param time number of miliseconds to wait; or function that returns this number
	 */waitTime(t){return this.enqueue(11,t),this}/**
	 * Waits until a message of a given key is captured
	 * @param msg message key
	 */waitForMessage(t){return this.enqueue(18,t),this}/**
	 * Waits until a message of a given key, meeting a specific condition is captured
	 */waitForMessageConditional(t,e){return this.enqueue(19,t,e),this}/**
	 * Removes component from given object (or the owner if null)
	 * @param cmp name of the component or the component itself
	 * @param gameObj object from which the component should be removed
	 */removeComponent(t,e=null){return this.enqueue(20,t,e),this}/**
	 * Detaches game objects that meet given condition
	 */detachGameObjectsByQuery(t){return this.enqueue(21,t),this}/**
	 * Destroys game objects that meet given condition
	 */destroyGameObjectsByQuery(t){return this.enqueue(22,t),this}/**
	 * Detaches given game object
	 */detachGameObject(t){return this.enqueue(23,t),this}/**
	 * Destroys given game object
	 */destroyGameObject(t){return this.enqueue(23,t),this}/**
	 * Interrupts this component as soon as the function argument returns true
	 * The condition is checked every loop
	 * @param obj
	 */addAbortCondition(t){return this.abortIfChecks.push(t),this}onMessage(t){this.current&&(18===this.current.key&&this.current.param1===t.action||19===this.current.key&&this.current.param1===t.action&&hl(t.gameObject,this.current.param2))&&// it will be processed during the next loop
(this.tmpParam2=!0)}onUpdate(t,e){if(null!==this.owner){if(0!==this.abortIfChecks.length)// always check for conditions for interrupt
{for(let t of this.abortIfChecks)if(t()){this.finish();return}}if(null==this.current&&(this.current=this.dequeue()),null==this.current){// no more items -> finish
this.finish();return}switch(this.current.key){case 1:// push context and go to the next item
this.current.cacheParams(),this.scopeStack.push(this.current),this.gotoNextImmediately(t,e);break;case 2:// pop context and jump
let i=this.scopeStack.pop();i.setParam1(i.getParam1()-1),!0===i.getParam2()||// infinite loop check
i.getParam1()>0?(// jump to the beginning
this.current=i,this.onUpdate(t,e)):(// reset values to their original state
i.resetCache(),this.gotoNextImmediately(t,e));break;case 3:// execute a function and go to the next item
this.current.param1(this),this.gotoNextImmediately(t,e);break;case 4:// push context and go to the next item
this.scopeStack.push(this.current),this.gotoNextImmediately(t,e);break;case 5:// pop contex and check condition
let r=this.scopeStack.pop();r.param1()?(// condition is true -> jump to the beginning
this.current=r,this.onUpdate(t,e)):this.gotoNextImmediately(t,e);break;case 6:this.current.cached||this.current.cacheParams(),null==this.tmpParam?this.tmpParam=e:e-this.tmpParam>=this.current.getParam1()&&(// push context and go to the next ite
this.tmpParam=null,this.current.resetCache(),this.scopeStack.push(this.current),this.gotoNextImmediately(t,e));break;case 7:// pop context and jump to the beginning
this.current=this.scopeStack.pop(),this.onUpdate(t,e);break;case 8:if(this.current.param1()){// condition met -> go to then ext item
this.gotoNextImmediately(t,e);break}// condition not met -> we need to jump to the next ELSE or END-IF node
let n=1;for(;;)// we need to find the next ELSE of END of the current scope
// thus, we have to skip all inner IF-ELSE branches
if(// search for the next node we might jump into
this.current=this.dequeue(),8===this.current.key&&n++,10===this.current.key&&n--,1===n&&9===this.current.key||0===n&&10===this.current.key){this.gotoNext();break}this.onUpdate(t,e);break;case 9:// jump to the first END_IF block of the current branch
let s=1;for(;;)if(this.current=this.dequeue(),8===this.current.key&&s++,10===this.current.key&&s--,0===s&&10===this.current.key){this.gotoNext();break}this.onUpdate(t,e);break;case 10:// nothing to do here, just go to the next item
this.gotoNextImmediately(t,e);break;case 11:this.current.cacheParams(),null==this.tmpParam&&(this.tmpParam=e),e-this.tmpParam>this.current.getParam1()&&(// it is time to go to the next item
this.tmpParam=null,this.current.resetCache(),this.gotoNextImmediately(t,e));break;case 12:(null!=this.current.getParam2()?this.current.getParam2():this.owner).addComponent(this.current.getParam1()),this.gotoNextImmediately(t,e);break;case 14:// wait until isFinished is true
let o=!this.current.cached;this.current.cached||this.current.cacheParams();let a=this.current.getParam1(),h=Array.isArray(a);o&&(h||a.cmpState!==b6.NEW?h&&a.filter(t=>t.cmpState===b6.NEW).forEach(t=>this.owner.addComponentAndRun(t)):this.owner.addComponentAndRun(a)),(!h&&a.isCompleted||h&&0===a.filter(t=>t._cmpState===b6.RUNNING).length)&&(this.current.resetCache(),this.gotoNextImmediately(t,e));break;case 15:// wait until isFinished is true for at least one case
let l=!this.current.cached;this.current.cached||this.current.cacheParams();let u=this.current.getParam1();l&&u.filter(t=>t._cmpState===b6.NEW).forEach(t=>this.owner.addComponentAndRun(t)),0!==u.filter(t=>t.isCompleted).length&&(this.current.resetCache(),// finish the other ones
u.forEach(t=>t.finish()),this.gotoNextImmediately(t,e));break;case 16:this.current.param1()||this.gotoNextImmediately(t,e);break;case 17:null==this.tmpParam&&(this.tmpParam=0),++this.tmpParam>this.current.param1&&(this.tmpParam=null,this.gotoNextImmediately(t,e));break;case 18:case 19:// tmpParam indicates that this component has already subscribed the message
!0===this.tmpParam?!0===this.tmpParam2&&(// got message -> unsubscribe and proceed
this.unsubscribe(this.current.param1),this.tmpParam=this.tmpParam2=null,this.gotoNextImmediately(t,e)):(// just subscribe and wait
this.tmpParam=!0,this.tmpParam2=!1,this.subscribe(this.current.param1));break;case 20:// pop the object, the name of the component, remove it and go to the next item
let c=null!=this.current.param2?this.current.param2:this.owner;c.removeComponent(c.findComponentByName(this.current.param1)),this.gotoNextImmediately(t,e);break;case 21:for(let t of this.scene.findObjectsByQuery(this.current.param1))t.detach();this.gotoNextImmediately(t,e);break;case 22:for(let t of this.scene.findObjectsByQuery(this.current.param1))t.detach();this.gotoNextImmediately(t,e);break;case 23:this.current.param1.detach(),this.gotoNextImmediately(t,e);break;case 23:this.current.param1.destroy(),this.gotoNextImmediately(t,e)}}}enqueue(t,e=null,i=null){let r=new hP(t,e,i);null==this.head?this.head=this.tail=r:(this.tail.next=r,r.previous=this.tail,this.tail=r),null==this.current&&(this.current=this.head)}// dequeues a next node
dequeue(){return null==this.current||null==this.current.next?null:(this.current=this.current.next,this.current)}// goes to the next node
gotoNext(){this.current=this.current.next}// goes to the next node and re-executes the update loop
gotoNextImmediately(t,e){this.current=this.current.next,this.onUpdate(t,e)}}class hO extends hi{/**
	 * Creates a new functional component
	 * @param name name that will be used instead of class name within the scene
	 */constructor(t,e){super(e),this.duration=0,this.firstRun=0,this.onInitFunc=null,this.onAttachFunc=null,this.onMessageHandlers=new Map,this.onMessageConditionalHandlers=new Map,this.onUpdateFunc=null,this.onFixedUpdateFunc=null,this.onDetachFunc=null,this.onRemoveFunc=null,this.onFinishFunc=null,this._name=t}get name(){return this._name}/**
	 * Registers a function that will be invoked for onInit()
	 */doOnInit(t){return this.onInitFunc=t,this}/**
	 * Registers a function that will be invoked for onAttach()
	 */doOnAttach(t){return this.onAttachFunc=t,this}/**
	 * Registers a function that will be invoked when a specific message arrives
	 */doOnMessage(t,e){return this.onMessageHandlers.set(t,{handler:e,onlyOnce:!1}),this}/**
	 * Registers a function that will be invoked when a specific message arrives, but only once
	 */doOnMessageOnce(t,e){return this.onMessageHandlers.set(t,{handler:e,onlyOnce:!0}),this}/**
	 * Registers a function that will be invoked when a specific message arrives and given conditions are met
	 * Can be used to listen only for a group of objects
	 */doOnMessageConditional(t,e,i){return this.onMessageConditionalHandlers.has(t)||this.onMessageConditionalHandlers.set(t,new Set),this.onMessageConditionalHandlers.get(t).add({onlyOnce:!1,handler:i,condition:e}),this}/**
	 * Registers a function that will be invoked for onFixedUpdate
	 */doOnFixedUpdate(t){return this.onFixedUpdateFunc=t,this}/**
	 * Registers a function that will be invoked for onUpdate
	 */doOnUpdate(t){return this.onUpdateFunc=t,this}/**
	 * Registers a function that will be invoked for onDetach()
	 */doOnDetach(t){return this.onDetachFunc=t,this}/**
	 * Registers a function that will be invoked for onRemove()
	 */doOnRemove(t){return this.onRemoveFunc=t,this}/**
	 * Registers a function that will be invoked for onFinish()
	 */doOnFinish(t){return this.onFinishFunc=t,this}/**
	 * Sets frequency for the fixed loop
	 */setFixedFrequency(t){return this.fixedFrequency=t,this}/**
	 * Sets a duration for how long this component should run
	 */setDuration(t){return this.duration=t,this}onInit(){null!=this.onInitFunc&&this.onInitFunc(this)}onAttach(){// register all messages
for(let[t]of(null!=this.onAttachFunc&&this.onAttachFunc(this),this.onMessageHandlers))this.subscribe(t);for(let[t]of this.onMessageConditionalHandlers)this.subscribe(t)}onMessage(t){if(this.onMessageHandlers.has(t.action)){let e=this.onMessageHandlers.get(t.action);e.handler(this,t),e.onlyOnce&&(this.onMessageHandlers.delete(t.action),this.unsubscribe(t.action))}if(this.onMessageConditionalHandlers.has(t.action))for(let e of this.onMessageConditionalHandlers.get(t.action))t.gameObject&&hl(t.gameObject,e.condition)&&e.handler(this,t)}onFixedUpdate(t,e){null!=this.onFixedUpdateFunc&&this.onFixedUpdateFunc(this,t,e)}onUpdate(t,e){if(0===this.firstRun&&(this.firstRun=e),0!==this.duration&&e-this.firstRun>=this.duration){this.finish();return}null!=this.onUpdateFunc&&this.onUpdateFunc(this,t,e)}onDetach(){null!=this.onDetachFunc&&this.onDetachFunc(this)}onRemove(){null!=this.onRemoveFunc&&this.onRemoveFunc(this)}onFinish(){this.firstRun=0,null!=this.onFinishFunc&&this.onFinishFunc(this)}}(xi=Ee||(Ee={}))[xi.UP=0]="UP",xi[xi.DOWN=1]="DOWN",xi[xi.RIGHT=2]="RIGHT",xi[xi.LEFT=3]="LEFT",xi[xi.X=4]="X",xi[xi.Y=5]="Y",xi[xi.A=6]="A",xi[xi.B=7]="B";class hL extends ha{constructor(t){super(),this.pressedButtons=new Map,this.renderRequired=!1,this.pointerDown=t=>{let e=t.data.identifier,i=this.getPressedButton(this.getPos(t.data.originalEvent));null!=i&&(this.pressedButtons.set(e,i),this.renderRequired=!0,this.simulateKeyEvent(i,!0))},this.pointerUp=t=>{let e=t.data.identifier,i=this.pressedButtons.get(e);this.pressedButtons.delete(e),this.renderRequired=!0,this.simulateKeyEvent(i,!1)},this.pointerMove=t=>{let e=t.data.identifier,i=this.getPressedButton(this.getPos(t.data.originalEvent));if(null!==i)this.pressedButtons.set(e,i),this.renderRequired=!0,this.simulateKeyEvent(i,!0);else{let t=this.pressedButtons.get(e);this.pressedButtons.delete(e),this.renderRequired=!0,this.simulateKeyEvent(t,!1)}},this.keyMapper=t,this._name=ha.name}onAttach(){this.gamePadRenderer=new hy("gamepad"),this.renderButtons()}renderButtons(){this.gamePadRenderer.clear();let t=this.scene.app.screen.width,e=this.scene.app.screen.height,i=.17*t,r=.82*t,n=.75*e,s=.24*e,o=s/1.8;if(!this.buttons){this.buttons=[new iU(i-o/2,n-o/2-o,o,o),new iU(i-o/2,n-o/2+o,o,o),new iU(i-o/2-o,n-o/2,o,o),new iU(i-o/2+o,n-o/2,o,o),new iU(r-o/2,n-o/2-o,o,o),new iU(r-o/2,n-o/2+o,o,o),new iU(r-o/2-o,n-o/2,o,o),new iU(r-o/2+o,n-o/2,o,o)];// cover slightly larger area
let t=1.3*o;this.buttonHitRects=[new iU(i-t/2,n-t/2-t,t,t),new iU(i-t/2,n-t/2+t,t,t),new iU(i-t/2-t,n-t/2,t,t),new iU(i-t/2+t,n-t/2,t,t),new iU(r-t/2,n-t/2-t,t,t),new iU(r-t/2,n-t/2+t,t,t),new iU(r-t/2-t,n-t/2,t,t),new iU(r-t/2+t,n-t/2,t,t)]}// create a new object and inject it into the scene
this.gamePadRenderer.beginFill(4473924,.5),// draw the first joystick
// pressed buttons are brighter
this.gamePadRenderer.drawCircle(i,n,s),this.gamePadRenderer.drawRect(i-o/2,n-o/2,o,o),this.gamePadRenderer.beginFill(11184810,this.keys.has(this.keyMapper.KEY_UP)?.8:.5),this.gamePadRenderer.drawRect(this.buttons[0].x,this.buttons[0].y,this.buttons[0].width,this.buttons[0].height),this.gamePadRenderer.beginFill(11184810,this.keys.has(this.keyMapper.KEY_DOWN)?.8:.5),this.gamePadRenderer.drawRect(this.buttons[1].x,this.buttons[1].y,this.buttons[1].width,this.buttons[1].height),this.gamePadRenderer.beginFill(11184810,this.keys.has(this.keyMapper.KEY_LEFT)?.8:.5),this.gamePadRenderer.drawRect(this.buttons[2].x,this.buttons[2].y,this.buttons[2].width,this.buttons[2].height),this.gamePadRenderer.beginFill(11184810,this.keys.has(this.keyMapper.KEY_RIGHT)?.8:.5),this.gamePadRenderer.drawRect(this.buttons[3].x,this.buttons[3].y,this.buttons[3].width,this.buttons[3].height),this.gamePadRenderer.beginFill(11184810,.5),this.gamePadRenderer.drawPolygon([i,n-1.3*o,i+o/3,n-o/1.5,i-o/3,n-o/1.5]),this.gamePadRenderer.drawPolygon([i,n+1.3*o,i+o/3,n+o/1.5,i-o/3,n+o/1.5]),this.gamePadRenderer.drawPolygon([i+1.3*o,n,i+o/1.5,n-o/3,i+o/1.5,n+o/3]),this.gamePadRenderer.drawPolygon([i-1.3*o,n,i-o/1.5,n-o/3,i-o/1.5,n+o/3]),// draw the second joystick
this.gamePadRenderer.beginFill(4473924,.5),this.gamePadRenderer.drawCircle(r,n,s),this.gamePadRenderer.beginFill(this.keyMapper.KEY_B?15328623:4473924,this.keys.has(this.keyMapper.KEY_B)?1:.6),this.gamePadRenderer.drawCircle(r,n-o,o/1.8),this.gamePadRenderer.beginFill(this.keyMapper.KEY_Y?15298415:4473924,this.keys.has(this.keyMapper.KEY_Y)?1:.6),this.gamePadRenderer.drawCircle(r,n+o,o/1.8),this.gamePadRenderer.beginFill(this.keyMapper.KEY_A?7334278:4473924,this.keys.has(this.keyMapper.KEY_A)?1:.6),this.gamePadRenderer.drawCircle(r-o,n,o/1.8),this.gamePadRenderer.beginFill(this.keyMapper.KEY_X?7303657:4473924,this.keys.has(this.keyMapper.KEY_X)?1:.6),this.gamePadRenderer.drawCircle(r+o,n,o/1.8),this.gamePadRenderer.endFill(),this.gamePadRenderer.on("touchstart",this.pointerDown),this.gamePadRenderer.on("touchend",this.pointerUp),this.gamePadRenderer.on("touchendoutside",this.pointerUp),this.gamePadRenderer.on("touchcancel",this.pointerUp),this.gamePadRenderer.on("touchmove",this.pointerMove),this.gamePadRenderer.interactive=!0,this.owner.asContainer().sortableChildren=!0,this.gamePadRenderer.zIndex=1e3,this.owner.asContainer().addChild(this.gamePadRenderer)}onDetach(){this.gamePadRenderer.removeListener("touchstart",this.pointerDown),this.gamePadRenderer.removeListener("touchend",this.pointerUp),this.gamePadRenderer.removeListener("touchendoutside",this.pointerUp),this.gamePadRenderer.removeListener("touchcancel",this.pointerUp),this.gamePadRenderer.removeListener("touchmove",this.pointerMove)}onUpdate(){this.renderRequired&&(this.renderButtons(),this.renderRequired=!1)}getPos(t){let e=this.scene.app.view.getBoundingClientRect(),i=this.scene.app.renderer.resolution,r=t.changedTouches?t.changedTouches[0].clientX:t.clientX,n=t.changedTouches?t.changedTouches[0].clientY:t.clientY;return{posX:Math.round((r-e.left)/(e.right-e.left)*this.scene.app.view.width/i),posY:Math.round((n-e.top)/(e.bottom-e.top)*this.scene.app.view.height/i)}}getPressedButton(t){return this.buttonHitRects[0].contains(t.posX,t.posY)?Ee.UP:this.buttonHitRects[1].contains(t.posX,t.posY)?Ee.DOWN:this.buttonHitRects[2].contains(t.posX,t.posY)?Ee.LEFT:this.buttonHitRects[3].contains(t.posX,t.posY)?Ee.RIGHT:this.buttonHitRects[4].contains(t.posX,t.posY)?Ee.B:this.buttonHitRects[5].contains(t.posX,t.posY)?Ee.Y:this.buttonHitRects[6].contains(t.posX,t.posY)?Ee.A:this.buttonHitRects[7].contains(t.posX,t.posY)?Ee.X:null}simulateKeyEvent(t,e){let i=null;t===Ee.UP&&this.keyMapper.KEY_UP&&(i=this.keyMapper.KEY_UP),t===Ee.DOWN&&this.keyMapper.KEY_DOWN&&(i=this.keyMapper.KEY_DOWN),t===Ee.LEFT&&this.keyMapper.KEY_LEFT&&(i=this.keyMapper.KEY_LEFT),t===Ee.RIGHT&&this.keyMapper.KEY_RIGHT&&(i=this.keyMapper.KEY_RIGHT),t===Ee.X&&this.keyMapper.KEY_X&&(i=this.keyMapper.KEY_X),t===Ee.Y&&this.keyMapper.KEY_Y&&(i=this.keyMapper.KEY_Y),t===Ee.A&&this.keyMapper.KEY_A&&(i=this.keyMapper.KEY_A),t===Ee.B&&this.keyMapper.KEY_B&&(i=this.keyMapper.KEY_B),null!==i&&(e?this.pressKey(i):this.releaseKey(i))}}(xr=Ei||(Ei={})).POINTER_TAP="pointer-tap",xr.POINTER_DOWN="pointer-down",xr.POINTER_OVER="pointer-over",xr.POINTER_RELEASE="pointer-release";class hN extends hi{constructor(t){super({handleClick:!0,handlePointerDown:!1,handlePointerOver:!1,handlePointerRelease:!1,...t}),this.lastTouch=null,this.handleStart=t=>{t.preventDefault();let e=window.TouchEvent&&t instanceof TouchEvent;e&&1===t.changedTouches.length?this.lastTouch=t.changedTouches[0]:this.lastTouch=t,this.props.handlePointerDown&&this.sendMessage(Ei.POINTER_DOWN,{mousePos:this.getMousePos(this.scene.app.view,t,e),isTouch:e})},this.handleMove=t=>{t.preventDefault();let e=void 0!==t.changedTouches;this.sendMessage(Ei.POINTER_OVER,{mousePos:this.getMousePos(this.scene.app.view,t,e),isTouch:e})},this.handleEnd=t=>{let e,i;t.preventDefault();let r=window.TouchEvent&&t instanceof TouchEvent;null!=this.lastTouch&&(r&&1===t.changedTouches.length?(e=t.changedTouches[0].pageX,i=t.changedTouches[0].pageY):(// mouse
e=t.pageX,i=t.pageY),10>Math.abs(this.lastTouch.pageX-e)&&10>Math.abs(this.lastTouch.pageY-i)&&(r||this.props.handleClick)?this.sendMessage(Ei.POINTER_TAP,{mousePos:this.getMousePos(this.scene.app.view,t,r),isTouch:r}):this.sendMessage(Ei.POINTER_RELEASE,{mousePos:this.getMousePos(this.scene.app.view,t,r),isTouch:r}))}}onAttach(){this.lastTouch=null,this.messagesToSend=[];let t=this.scene.app.view;t.addEventListener("touchstart",this.handleStart,!1),t.addEventListener("touchend",this.handleEnd,!1),t.addEventListener("mousedown",this.handleStart,!1),(this.props.handlePointerRelease||this.props.handleClick)&&t.addEventListener("mouseup",this.handleEnd,!1),this.props.handlePointerOver&&(t.addEventListener("mousemove",this.handleMove,!1),t.addEventListener("touchmove",this.handleMove,!1))}onUpdate(){for(let t of this.messagesToSend)this.scene.sendMessage(t);this.messagesToSend=[]}onDetach(){let t=this.scene.app.view;t.removeEventListener("touchstart",this.handleStart),t.removeEventListener("touchend",this.handleEnd),t.removeEventListener("mousedown",this.handleStart),(this.props.handlePointerRelease||this.props.handleClick)&&t.removeEventListener("mouseup",this.handleEnd),this.props.handlePointerOver&&(t.removeEventListener("mousemove",this.handleMove),t.removeEventListener("touchmove",this.handleMove))}sendMessage(t,e=null){return(// wait for next update loop to send all the messages
this.messagesToSend.push(new he(t,this,this.owner,e)),null)}// Get the mouse position
getMousePos(t,e,i){let r=t.getBoundingClientRect(),n=this.scene.app.renderer.resolution,s=i?e.changedTouches[0].clientX:e.clientX,o=i?e.changedTouches[0].clientY:e.clientY;return{posX:Math.round((s-r.left)/(r.right-r.left)*this.scene.app.view.width/n),posY:Math.round((o-r.top)/(r.bottom-r.top)*this.scene.app.view.height/n)}}}/**
 * An object that represents a 2-dimensional vector with standard vector
 * operations. All operations on this class produce a new copy of the vector
 * instead of modifying the vector in place.
 */class hD{/** Construct a new vector with the specified x and y coordinates */constructor(t,e){"number"==typeof t?(this._x=t,this._y=null==e?this._x:e):(// array parameter
this._x=t[0],this._y=t[1])}get x(){return this._x}get y(){return this._y}/**
	 * Returns a new vector that is the result of adding this vector with
	 * another vector.
	 */add(t){return new hD(this.x+t.x,this.y+t.y)}/**
	 * Returns a new vector that is the result of subtracting this vector by
	 * another vector.
	 */subtract(t){return new hD(this.x-t.x,this.y-t.y)}/**
	 * Returns a new vector that is the result of multiplying the elements of
	 * this vector by a scalar.
	 */multiply(t){return new hD(t*this.x,t*this.y)}/**
	 * Returns a new vector that is the result of dividing the elements of this
	 * vector by a scalar.
	 */divide(t){return new hD(this.x/t,this.y/t)}/**
	 * Return Euklidean distance between two vectors(points)
	 */distance(t){return new hD(this.x-t.x,this.y-t.y).magnitude()}/**
	 * Return squared Euklidean distance between two vectors(points)
	 */squareDistance(t){return new hD(this.x-t.x,this.y-t.y).magnitudeSquared()}/**
	 * Return Manhattan distance between two vectors (points)
	 */manhattanDistance(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}/**
	 * Returns the normalized form of this vector as a new vector. A normalized
	 * vector has a length of 1. This operation is potentially costly so it is
	 * best to cache the result when possible.
	 */normalize(){let t=this.magnitude();return new hD(this.x/t,this.y/t)}/**
	 * Returns the squared magnitude of this vector. This is cheaper to
	 * compute than the magnitude, so should be preferred where possible.
	 */magnitudeSquared(){return this.dot(this)}/**
	 * Computes the magnitude (or length) of this vector. This operation is
	 * potentially cost os it is best to cache the result when possible.
	 */magnitude(){return Math.sqrt(this.magnitudeSquared())}/**
	 * Computes and returns the angle of this vector in radians.
	 */angle(){let t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}/**
	 * Calculates and returns the dot product of this vector and another vector.
	 */dot(t){return this.x*t.x+this.y*t.y}/**
	 * Limits the vector size
	 */limit(t){let e=this.magnitudeSquared();return t<e?new hD(this.x/Math.sqrt(e/t),this.y/Math.sqrt(e/t)):this.clone()}equals(t){return this.x===t.x&&this.y===t.y}clone(){return new hD(this.x,this.y)}}const hF="300 es";/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */class hB{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;let i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;let i=this._listeners,r=i[t];if(void 0!==r){let t=r.indexOf(e);-1!==t&&r.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;let e=this._listeners,i=e[t.type];if(void 0!==i){t.target=this;// Make a copy, in case listeners are removed while iterating.
let e=i.slice(0);for(let i=0,r=e.length;i<r;i++)e[i].call(this,t);t.target=null}}}const hU=[];for(let t=0;t<256;t++)hU[t]=(t<16?"0":"")+t.toString(16);const hG=Math.PI/180,hk=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function hH(){let t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,r=4294967295*Math.random()|0,n=hU[255&t]+hU[t>>8&255]+hU[t>>16&255]+hU[t>>24&255]+"-"+hU[255&e]+hU[e>>8&255]+"-"+hU[e>>16&15|64]+hU[e>>24&255]+"-"+hU[63&i|128]+hU[i>>8&255]+"-"+hU[i>>16&255]+hU[i>>24&255]+hU[255&r]+hU[r>>8&255]+hU[r>>16&255]+hU[r>>24&255];// .toUpperCase() here flattens concatenated strings to save heap memory space.
return n.toUpperCase()}function hz(t,e,i){return Math.max(e,Math.min(i,t))}function hj(t){return(t&t-1)==0&&0!==t}function hV(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}class hX{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){let e=this.x,i=this.y,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6],this.y=r[1]*e+r[4]*i+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return(// assumes min < max, componentwise
this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this)}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){// computes the angle in radians with respect to the positive x-axis
let t=Math.atan2(-this.y,-this.x)+Math.PI;return t}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){let i=Math.cos(e),r=Math.sin(e),n=this.x-t.x,s=this.y-t.y;return this.x=n*i-s*r+t.x,this.y=n*r+s*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}hX.prototype.isVector2=!0;class hW{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,r,n,s,o,a,h){let l=this.elements;return l[0]=t,l[1]=r,l[2]=o,l[3]=e,l[4]=n,l[5]=a,l[6]=i,l[7]=s,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){let e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){let e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){let i=t.elements,r=e.elements,n=this.elements,s=i[0],o=i[3],a=i[6],h=i[1],l=i[4],u=i[7],c=i[2],d=i[5],p=i[8],f=r[0],m=r[3],g=r[6],y=r[1],_=r[4],v=r[7],x=r[2],b=r[5],E=r[8];return n[0]=s*f+o*y+a*x,n[3]=s*m+o*_+a*b,n[6]=s*g+o*v+a*E,n[1]=h*f+l*y+u*x,n[4]=h*m+l*_+u*b,n[7]=h*g+l*v+u*E,n[2]=c*f+d*y+p*x,n[5]=c*m+d*_+p*b,n[8]=c*g+d*v+p*E,this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){let t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],o=t[5],a=t[6],h=t[7],l=t[8];return e*s*l-e*o*h-i*n*l+i*o*a+r*n*h-r*s*a}invert(){let t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=l*s-o*h,c=o*a-l*n,d=h*n-s*a,p=e*u+i*c+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);let f=1/p;return t[0]=u*f,t[1]=(r*h-l*i)*f,t[2]=(o*i-r*s)*f,t[3]=c*f,t[4]=(l*e-r*a)*f,t[5]=(r*n-o*e)*f,t[6]=d*f,t[7]=(i*a-h*e)*f,t[8]=(s*e-i*n)*f,this}transpose(){let t;let e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){let e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,r,n,s,o){let a=Math.cos(n),h=Math.sin(n);return this.set(i*a,i*h,-i*(a*s+h*o)+s+t,-r*h,r*a,-r*(-h*s+a*o)+o+e,0,0,1),this}scale(t,e){let i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){let e=Math.cos(t),i=Math.sin(t),r=this.elements,n=r[0],s=r[3],o=r[6],a=r[1],h=r[4],l=r[7];return r[0]=e*n+i*a,r[3]=e*s+i*h,r[6]=e*o+i*l,r[1]=-i*n+e*a,r[4]=-i*s+e*h,r[7]=-i*o+e*l,this}translate(t,e){let i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){let e=this.elements,i=t.elements;for(let t=0;t<9;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){let i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}hW.prototype.isMatrix3=!0;class hY{static getDataURL(e){let i;if(/^data:/i.test(e.src)||"undefined"==typeof HTMLCanvasElement)return e.src;if(e instanceof HTMLCanvasElement)i=e;else{void 0===t&&(t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),t.width=e.width,t.height=e.height;let r=t.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),i=t}return i.width>2048||i.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),i.toDataURL("image/jpeg",.6)):i.toDataURL("image/png")}}let hq=0;class hK extends hB{constructor(t=hK.DEFAULT_IMAGE,e=hK.DEFAULT_MAPPING,i=1001,r=1001,n=1006,s=1008,o=1023,a=1009,h=1,l=3e3){super(),Object.defineProperty(this,"id",{value:hq++}),this.uuid=hH(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=r,this.magFilter=n,this.minFilter=s,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=a,this.offset=new hX(0,0),this.repeat=new hX(1,1),this.center=new hX(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new hW,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=l,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){let e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];let i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){// TODO: Move to THREE.Image
let r=this.image;if(void 0===r.uuid&&(r.uuid=hH()),!e&&void 0===t.images[r.uuid]){let e;if(Array.isArray(r)){// process array of images e.g. CubeTexture
e=[];for(let t=0,i=r.length;t<i;t++)r[t].isDataTexture?e.push(hJ(r[t].image)):e.push(hJ(r[t]))}else e=hJ(r);t.images[r.uuid]={uuid:r.uuid,url:e}}i.image=r.uuid}return e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&this.version++}}function hJ(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?hY.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}hK.DEFAULT_IMAGE=void 0,hK.DEFAULT_MAPPING=300,hK.prototype.isTexture=!0;class hZ{constructor(t=0,e=0,i=0,r=1){this.x=t,this.y=e,this.z=i,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,r){return this.x=t,this.y=e,this.z=i,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){let e=this.x,i=this.y,r=this.z,n=this.w,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*r+s[12]*n,this.y=s[1]*e+s[5]*i+s[9]*r+s[13]*n,this.z=s[2]*e+s[6]*i+s[10]*r+s[14]*n,this.w=s[3]*e+s[7]*i+s[11]*r+s[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(t.w);let e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,r,n;let s=t.elements,o=s[0],a=s[4],h=s[8],l=s[1],u=s[5],c=s[9],d=s[2],p=s[6],f=s[10];if(.01>Math.abs(a-l)&&.01>Math.abs(h-d)&&.01>Math.abs(c-p)){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(.1>Math.abs(a+l)&&.1>Math.abs(h+d)&&.1>Math.abs(c+p)&&.1>Math.abs(o+u+f-3))return(// this singularity is identity matrix so angle = 0
this.set(1,0,0,0),this);// zero angle, arbitrary axis
// otherwise this singularity is angle = 180
e=Math.PI;let t=(o+1)/2,s=(u+1)/2,m=(f+1)/2,g=(a+l)/4,y=(h+d)/4,_=(c+p)/4;return t>s&&t>m?t<.01?(i=0,r=.707106781,n=.707106781):(r=g/(i=Math.sqrt(t)),n=y/i):s>m?s<.01?(i=.707106781,r=0,n=.707106781):(i=g/(r=Math.sqrt(s)),n=_/r):m<.01?(i=.707106781,r=.707106781,n=0):(i=y/(n=Math.sqrt(m)),r=_/n),this.set(i,r,n,e),this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
let m=Math.sqrt((p-c)*(p-c)+(h-d)*(h-d)+(l-a)*(l-a));// used to normalize
return .001>Math.abs(m)&&(m=1),// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(p-c)/m,this.y=(h-d)/m,this.z=(l-a)/m,this.w=Math.acos((o+u+f-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return(// assumes min < max, componentwise
this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this)}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}hZ.prototype.isVector4=!0;/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/class h$ extends hB{constructor(t,e,i={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new hZ(0,0,t,e),this.scissorTest=!1,this.viewport=new hZ(0,0,t,e),this.texture=new hK(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,this.texture.minFilter=void 0!==i.minFilter?i.minFilter:1006,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,i=1){(this.width!==t||this.height!==e||this.depth!==i)&&(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}h$.prototype.isWebGLRenderTarget=!0,(class extends h${constructor(t,e,i){super(t,e);let r=this.texture;this.texture=[];for(let t=0;t<i;t++)this.texture[t]=r.clone()}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let r=0,n=this.texture.length;r<n;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=i;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,i=t.texture.length;e<i;e++)this.texture[e]=t.texture[e].clone();return this}}).prototype.isWebGLMultipleRenderTargets=!0;class hQ extends h${constructor(t,e,i){super(t,e,i),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}hQ.prototype.isWebGLMultisampleRenderTarget=!0;class h0{constructor(t=0,e=0,i=0,r=1){this._x=t,this._y=e,this._z=i,this._w=r}static slerp(t,e,i,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,r)}static slerpFlat(t,e,i,r,n,s,o){// fuzz-free, array-based Quaternion SLERP operation
let a=i[r+0],h=i[r+1],l=i[r+2],u=i[r+3],c=n[s+0],d=n[s+1],p=n[s+2],f=n[s+3];if(0===o){t[e+0]=a,t[e+1]=h,t[e+2]=l,t[e+3]=u;return}if(1===o){t[e+0]=c,t[e+1]=d,t[e+2]=p,t[e+3]=f;return}if(u!==f||a!==c||h!==d||l!==p){let t=1-o,e=a*c+h*d+l*p+u*f,i=e>=0?1:-1,r=1-e*e;// Skip the Slerp for tiny steps to avoid numeric problems:
if(r>Number.EPSILON){let n=Math.sqrt(r),s=Math.atan2(n,e*i);t=Math.sin(t*s)/n,o=Math.sin(o*s)/n}let n=o*i;// Normalize in case we just did a lerp:
if(a=a*t+c*n,h=h*t+d*n,l=l*t+p*n,u=u*t+f*n,t===1-o){let t=1/Math.sqrt(a*a+h*h+l*l+u*u);a*=t,h*=t,l*=t,u*=t}}t[e]=a,t[e+1]=h,t[e+2]=l,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,r,n,s){let o=i[r],a=i[r+1],h=i[r+2],l=i[r+3],u=n[s],c=n[s+1],d=n[s+2],p=n[s+3];return t[e]=o*p+l*u+a*d-h*c,t[e+1]=a*p+l*c+h*u-o*d,t[e+2]=h*p+l*d+o*c-a*u,t[e+3]=l*p-o*u-a*c-h*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,r){return this._x=t,this._y=e,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");let i=t._x,r=t._y,n=t._z,s=t._order,o=Math.cos,a=Math.sin,h=o(i/2),l=o(r/2),u=o(n/2),c=a(i/2),d=a(r/2),p=a(n/2);switch(s){case"XYZ":this._x=c*l*u+h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u-c*d*p;break;case"YXZ":this._x=c*l*u+h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u+c*d*p;break;case"ZXY":this._x=c*l*u-h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u-c*d*p;break;case"ZYX":this._x=c*l*u-h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u+c*d*p;break;case"YZX":this._x=c*l*u+h*d*p,this._y=h*d*u+c*l*p,this._z=h*l*p-c*d*u,this._w=h*l*u-c*d*p;break;case"XZY":this._x=c*l*u-h*d*p,this._y=h*d*u-c*l*p,this._z=h*l*p+c*d*u,this._w=h*l*u+c*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
let i=e/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let e=t.elements,i=e[0],r=e[4],n=e[8],s=e[1],o=e[5],a=e[9],h=e[2],l=e[6],u=e[10],c=i+o+u;if(c>0){let t=.5/Math.sqrt(c+1);this._w=.25/t,this._x=(l-a)*t,this._y=(n-h)*t,this._z=(s-r)*t}else if(i>o&&i>u){let t=2*Math.sqrt(1+i-o-u);this._w=(l-a)/t,this._x=.25*t,this._y=(r+s)/t,this._z=(n+h)/t}else if(o>u){let t=2*Math.sqrt(1+o-i-u);this._w=(n-h)/t,this._x=(r+s)/t,this._y=.25*t,this._z=(a+l)/t}else{let t=2*Math.sqrt(1+u-i-o);this._w=(s-r)/t,this._x=(n+h)/t,this._y=(a+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){// assumes direction vectors vFrom and vTo are normalized
let i=t.dot(e)+1;return i<Number.EPSILON?(// vFrom and vTo point in opposite directions
i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0):(this._x=0,this._y=-t.z,this._z=t.y)):(// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x),this._w=i,this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(hz(this.dot(t),-1,1)))}rotateTowards(t,e){let i=this.angleTo(t);if(0===i)return this;let r=Math.min(1,e/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){// quaternion is assumed to have unit length
return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
let i=t._x,r=t._y,n=t._z,s=t._w,o=e._x,a=e._y,h=e._z,l=e._w;return this._x=i*l+s*o+r*h-n*a,this._y=r*l+s*a+n*o-i*h,this._z=n*l+s*h+i*a-r*o,this._w=s*l-i*o-r*a-n*h,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);let i=this._x,r=this._y,n=this._z,s=this._w,o=s*t._w+i*t._x+r*t._y+n*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=i,this._y=r,this._z=n,this;let a=1-o*o;if(a<=Number.EPSILON){let t=1-e;return this._w=t*s+e*this._w,this._x=t*i+e*this._x,this._y=t*r+e*this._y,this._z=t*n+e*this._z,this.normalize(),this._onChangeCallback(),this}let h=Math.sqrt(a),l=Math.atan2(h,o),u=Math.sin((1-e)*l)/h,c=Math.sin(e*l)/h;return this._w=s*u+this._w*c,this._x=i*u+this._x*c,this._y=r*u+this._y*c,this._z=n*u+this._z*c,this._onChangeCallback(),this}slerpQuaternions(t,e,i){this.copy(t).slerp(e,i)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}h0.prototype.isQuaternion=!0;class h1{constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(h3.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(h3.setFromAxisAngle(t,e))}applyMatrix3(t){let e=this.x,i=this.y,r=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*r,this.y=n[1]*e+n[4]*i+n[7]*r,this.z=n[2]*e+n[5]*i+n[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){let e=this.x,i=this.y,r=this.z,n=t.elements,s=1/(n[3]*e+n[7]*i+n[11]*r+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*r+n[12])*s,this.y=(n[1]*e+n[5]*i+n[9]*r+n[13])*s,this.z=(n[2]*e+n[6]*i+n[10]*r+n[14])*s,this}applyQuaternion(t){let e=this.x,i=this.y,r=this.z,n=t.x,s=t.y,o=t.z,a=t.w,h=a*e+s*r-o*i,l=a*i+o*e-n*r,u=a*r+n*i-s*e,c=-n*e-s*i-o*r;return(// calculate result * inverse quat
this.x=h*a+-(c*n)+-(l*o)- -(u*s),this.y=l*a+-(c*s)+-(u*n)- -(h*o),this.z=u*a+-(c*o)+-(h*s)- -(l*n),this)}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
let e=this.x,i=this.y,r=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*r,this.y=n[1]*e+n[5]*i+n[9]*r,this.z=n[2]*e+n[6]*i+n[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return(// assumes min < max, componentwise
this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this)}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}// TODO lengthSquared?
lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){let i=t.x,r=t.y,n=t.z,s=e.x,o=e.y,a=e.z;return this.x=r*a-n*o,this.y=n*s-i*a,this.z=i*o-r*s,this}projectOnVector(t){let e=t.lengthSq();if(0===e)return this.set(0,0,0);let i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return h2.copy(this).projectOnVector(t),this.sub(h2)}reflect(t){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
return this.sub(h2.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){let e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;let i=this.dot(t)/e;// clamp, to handle numerical problems
return Math.acos(hz(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){let e=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return e*e+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){let r=Math.sin(e)*t;return this.x=r*Math.sin(i),this.y=Math.cos(e)*t,this.z=r*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){let e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){let e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}h1.prototype.isVector3=!0;const h2=/*@__PURE__*/new h1,h3=/*@__PURE__*/new h0;class h5{constructor(t=new h1(1/0,1/0,1/0),e=new h1(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,r=1/0,n=-1/0,s=-1/0,o=-1/0;for(let a=0,h=t.length;a<h;a+=3){let h=t[a],l=t[a+1],u=t[a+2];h<e&&(e=h),l<i&&(i=l),u<r&&(r=u),h>n&&(n=h),l>s&&(s=l),u>o&&(o=u)}return this.min.set(e,i,r),this.max.set(n,s,o),this}setFromBufferAttribute(t){let e=1/0,i=1/0,r=1/0,n=-1/0,s=-1/0,o=-1/0;for(let a=0,h=t.count;a<h;a++){let h=t.getX(a),l=t.getY(a),u=t.getZ(a);h<e&&(e=h),l<i&&(i=l),u<r&&(r=u),h>n&&(n=h),l>s&&(s=l),u>o&&(o=u)}return this.min.set(e,i,r),this.max.set(n,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){let i=h6.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
t.updateWorldMatrix(!1,!1);let e=t.geometry;void 0!==e&&(null===e.boundingBox&&e.computeBoundingBox(),h8.copy(e.boundingBox),h8.applyMatrix4(t.matrixWorld),this.union(h8));let i=t.children;for(let t=0,e=i.length;t<e;t++)this.expandByObject(i[t]);return this}containsPoint(t){return!(t.x<this.min.x)&&!(t.x>this.max.x)&&!(t.y<this.min.y)&&!(t.y>this.max.y)&&!(t.z<this.min.z)&&!(t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){// using 6 splitting planes to rule out intersections.
return!(t.max.x<this.min.x)&&!(t.min.x>this.max.x)&&!(t.max.y<this.min.y)&&!(t.min.y>this.max.y)&&!(t.max.z<this.min.z)&&!(t.min.z>this.max.z)}intersectsSphere(t){// If that point is inside the sphere, the AABB and sphere intersect.
return(// Find the point on the AABB closest to the sphere center.
this.clampPoint(t.center,h6),h6.distanceToSquared(t.center)<=t.radius*t.radius)}intersectsPlane(t){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;// compute box center and extents
this.getCenter(ln),ls.subVectors(this.max,ln),// translate triangle to aabb origin
h7.subVectors(t.a,ln),h9.subVectors(t.b,ln),lt.subVectors(t.c,ln),// compute edge vectors for triangle
le.subVectors(h9,h7),li.subVectors(lt,h9),lr.subVectors(h7,lt);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
let e=[0,-le.z,le.y,0,-li.z,li.y,0,-lr.z,lr.y,le.z,0,-le.x,li.z,0,-li.x,lr.z,0,-lr.x,-le.y,le.x,0,-li.y,li.x,0,-lr.y,lr.x,0];return!!(lh(e,h7,h9,lt,ls)&&lh(// test 3 face normals from the aabb
e=[1,0,0,0,1,0,0,0,1],h7,h9,lt,ls))&&(// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
lo.crossVectors(le,li),lh(e=[lo.x,lo.y,lo.z],h7,h9,lt,ls))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){let e=h6.copy(t).clamp(this.min,this.max);return e.sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(h6).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(// NOTE: I am using a binary pattern to specify all 2^3 combinations below
h4[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),h4[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),h4[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),h4[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),h4[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),h4[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),h4[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),h4[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(h4)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}h5.prototype.isBox3=!0;const h4=[/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1,/*@__PURE__*/new h1],h6=/*@__PURE__*/new h1,h8=/*@__PURE__*/new h5,h7=/*@__PURE__*/new h1,h9=/*@__PURE__*/new h1,lt=/*@__PURE__*/new h1,le=/*@__PURE__*/new h1,li=/*@__PURE__*/new h1,lr=/*@__PURE__*/new h1,ln=/*@__PURE__*/new h1,ls=/*@__PURE__*/new h1,lo=/*@__PURE__*/new h1,la=/*@__PURE__*/new h1;function lh(t,e,i,r,n){for(let s=0,o=t.length-3;s<=o;s+=3){la.fromArray(t,s);// project the aabb onto the seperating axis
let o=n.x*Math.abs(la.x)+n.y*Math.abs(la.y)+n.z*Math.abs(la.z),a=e.dot(la),h=i.dot(la),l=r.dot(la);// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(a,h,l),Math.min(a,h,l))>o)// the axis is seperating and we can exit
return!1}return!0}const ll=/*@__PURE__*/new h5,lu=/*@__PURE__*/new h1,lc=/*@__PURE__*/new h1,ld=/*@__PURE__*/new h1;class lp{constructor(t=new h1,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){let i=this.center;void 0!==e?i.copy(e):ll.setFromPoints(t).getCenter(i);let r=0;for(let e=0,n=t.length;e<n;e++)r=Math.max(r,i.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){let e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){let i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?// Empty sphere produces empty bounding box
t.makeEmpty():(t.set(this.center,this.center),t.expandByScalar(this.radius)),t}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
ld.subVectors(t,this.center);let e=ld.lengthSq();if(e>this.radius*this.radius){let t=Math.sqrt(e),i=(t-this.radius)*.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
// and the other half to position. This gives a tighter enclosure, instead of if
// the whole missing distance were just added to radius.
this.center.add(ld.multiplyScalar(i/t)),this.radius+=i}return this}union(t){return(// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
// To enclose another sphere into this sphere, we only need to enclose two points:
// 1) Enclose the farthest point on the other sphere into this sphere.
// 2) Enclose the opposite point of the farthest point into this sphere.
lc.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(lu.copy(t.center).add(lc)),this.expandByPoint(lu.copy(t.center).sub(lc)),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const lf=/*@__PURE__*/new h1,lm=/*@__PURE__*/new h1,lg=/*@__PURE__*/new h1,ly=/*@__PURE__*/new h1,l_=/*@__PURE__*/new h1,lv=/*@__PURE__*/new h1,lx=/*@__PURE__*/new h1;class lb{constructor(t=new h1,e=new h1(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,lf)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);let i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){let e=lf.subVectors(t,this.origin).dot(this.direction);return(// point behind the ray
e<0?this.origin.distanceToSquared(t):(lf.copy(this.direction).multiplyScalar(e).add(this.origin),lf.distanceToSquared(t)))}distanceSqToSegment(t,e,i,r){let n,s,o,a;// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
lm.copy(t).add(e).multiplyScalar(.5),lg.copy(e).sub(t).normalize(),ly.copy(this.origin).sub(lm);let h=.5*t.distanceTo(e),l=-this.direction.dot(lg),u=ly.dot(this.direction),c=-ly.dot(lg),d=ly.lengthSq(),p=Math.abs(1-l*l);if(p>0){if(// The ray and segment are not parallel.
n=l*c-u,s=l*u-c,a=h*p,n>=0){if(s>=-a){if(s<=a){// region 0
// Minimum at interior points of ray and segment.
let t=1/p;n*=t,s*=t,o=n*(n+l*s+2*u)+s*(l*n+s+2*c)+d}else o=-(n=Math.max(0,-(l*// region 1
(s=h)+u)))*n+s*(s+2*c)+d}else o=-(n=Math.max(0,-(l*// region 5
(s=-h)+u)))*n+s*(s+2*c)+d}else s<=-a?(s=// region 4
(n=Math.max(0,-(-l*h+u)))>0?-h:Math.min(Math.max(-h,-c),h),o=-n*n+s*(s+2*c)+d):s<=a?(// region 3
n=0,o=(s=Math.min(Math.max(-h,-c),h))*(s+2*c)+d):(s=// region 2
(n=Math.max(0,-(l*h+u)))>0?h:Math.min(Math.max(-h,-c),h),o=-n*n+s*(s+2*c)+d)}else // Ray and segment are parallel.
s=l>0?-h:h,o=-(n=Math.max(0,-(l*s+u)))*n+s*(s+2*c)+d;return i&&i.copy(this.direction).multiplyScalar(n).add(this.origin),r&&r.copy(lg).multiplyScalar(s).add(lm),o}intersectSphere(t,e){lf.subVectors(t.center,this.origin);let i=lf.dot(this.direction),r=lf.dot(lf)-i*i,n=t.radius*t.radius;if(r>n)return null;let s=Math.sqrt(n-r),o=i-s,a=i+s;return(// test to see if both t0 and t1 are behind the ray - if so, return null
o<0&&a<0?null:o<0?this.at(a,e):this.at(o,e))}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){let e=t.normal.dot(this.direction);if(0===e)return(// line is coplanar, return origin
0===t.distanceToPoint(this.origin)?0:null);let i=-(this.origin.dot(t.normal)+t.constant)/e;// Return if the ray never intersects the plane
return i>=0?i:null}intersectPlane(t,e){let i=this.distanceToPlane(t);return null===i?null:this.at(i,e)}intersectsPlane(t){// check if the ray lies on the plane first
let e=t.distanceToPoint(this.origin);if(0===e)return!0;let i=t.normal.dot(this.direction);return i*e<0}intersectBox(t,e){let i,r,n,s,o,a;let h=1/this.direction.x,l=1/this.direction.y,u=1/this.direction.z,c=this.origin;return(h>=0?(i=(t.min.x-c.x)*h,r=(t.max.x-c.x)*h):(i=(t.max.x-c.x)*h,r=(t.min.x-c.x)*h),l>=0?(n=(t.min.y-c.y)*l,s=(t.max.y-c.y)*l):(n=(t.max.y-c.y)*l,s=(t.min.y-c.y)*l),i>s||n>r)?null:((n>i||i!=i)&&(i=n),(s<r||r!=r)&&(r=s),u>=0?(o=(t.min.z-c.z)*u,a=(t.max.z-c.z)*u):(o=(t.max.z-c.z)*u,a=(t.min.z-c.z)*u),i>a||o>r)?null:((o>i||i!=i)&&(i=o),(a<r||r!=r)&&(r=a),r<0)?null:this.at(i>=0?i:r,e)}intersectsBox(t){return null!==this.intersectBox(t,lf)}intersectTriangle(t,e,i,r,n){let s;// Compute the offset origin, edges, and normal.
// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
l_.subVectors(e,t),lv.subVectors(i,t),lx.crossVectors(l_,lv);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
let o=this.direction.dot(lx);if(o>0){if(r)return null;s=1}else{if(!(o<0))return null;s=-1,o=-o}ly.subVectors(this.origin,t);let a=s*this.direction.dot(lv.crossVectors(ly,lv));// b1 < 0, no intersection
if(a<0)return null;let h=s*this.direction.dot(l_.cross(ly));// b2 < 0, no intersection
if(h<0||a+h>o)return null;// Line intersects triangle, check if ray does.
let l=-s*ly.dot(lx);return(// t < 0, no intersection
l<0?null:this.at(l/o,n))}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class lE{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,r,n,s,o,a,h,l,u,c,d,p,f,m){let g=this.elements;return g[0]=t,g[4]=e,g[8]=i,g[12]=r,g[1]=n,g[5]=s,g[9]=o,g[13]=a,g[2]=h,g[6]=l,g[10]=u,g[14]=c,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new lE().fromArray(this.elements)}copy(t){let e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){let e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){let e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){// this method does not support reflection matrices
let e=this.elements,i=t.elements,r=1/lT.setFromMatrixColumn(t,0).length(),n=1/lT.setFromMatrixColumn(t,1).length(),s=1/lT.setFromMatrixColumn(t,2).length();return e[0]=i[0]*r,e[1]=i[1]*r,e[2]=i[2]*r,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*s,e[9]=i[9]*s,e[10]=i[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");let e=this.elements,i=t.x,r=t.y,n=t.z,s=Math.cos(i),o=Math.sin(i),a=Math.cos(r),h=Math.sin(r),l=Math.cos(n),u=Math.sin(n);if("XYZ"===t.order){let t=s*l,i=s*u,r=o*l,n=o*u;e[0]=a*l,e[4]=-a*u,e[8]=h,e[1]=i+r*h,e[5]=t-n*h,e[9]=-o*a,e[2]=n-t*h,e[6]=r+i*h,e[10]=s*a}else if("YXZ"===t.order){let t=a*l,i=a*u,r=h*l,n=h*u;e[0]=t+n*o,e[4]=r*o-i,e[8]=s*h,e[1]=s*u,e[5]=s*l,e[9]=-o,e[2]=i*o-r,e[6]=n+t*o,e[10]=s*a}else if("ZXY"===t.order){let t=a*l,i=a*u,r=h*l,n=h*u;e[0]=t-n*o,e[4]=-s*u,e[8]=r+i*o,e[1]=i+r*o,e[5]=s*l,e[9]=n-t*o,e[2]=-s*h,e[6]=o,e[10]=s*a}else if("ZYX"===t.order){let t=s*l,i=s*u,r=o*l,n=o*u;e[0]=a*l,e[4]=r*h-i,e[8]=t*h+n,e[1]=a*u,e[5]=n*h+t,e[9]=i*h-r,e[2]=-h,e[6]=o*a,e[10]=s*a}else if("YZX"===t.order){let t=s*a,i=s*h,r=o*a,n=o*h;e[0]=a*l,e[4]=n-t*u,e[8]=r*u+i,e[1]=u,e[5]=s*l,e[9]=-o*l,e[2]=-h*l,e[6]=i*u+r,e[10]=t-n*u}else if("XZY"===t.order){let t=s*a,i=s*h,r=o*a,n=o*h;e[0]=a*l,e[4]=-u,e[8]=h*l,e[1]=t*u+n,e[5]=s*l,e[9]=i*u-r,e[2]=r*u-i,e[6]=o*l,e[10]=n*u+t}return(// bottom row
e[3]=0,e[7]=0,e[11]=0,// last column
e[12]=0,e[13]=0,e[14]=0,e[15]=1,this)}makeRotationFromQuaternion(t){return this.compose(lS,t,lM)}lookAt(t,e,i){let r=this.elements;return lC.subVectors(t,e),0===lC.lengthSq()&&(lC.z=1),lC.normalize(),lA.crossVectors(i,lC),0===lA.lengthSq()&&(1===Math.abs(i.z)?lC.x+=1e-4:lC.z+=1e-4,lC.normalize(),lA.crossVectors(i,lC)),lA.normalize(),lR.crossVectors(lC,lA),r[0]=lA.x,r[4]=lR.x,r[8]=lC.x,r[1]=lA.y,r[5]=lR.y,r[9]=lC.y,r[2]=lA.z,r[6]=lR.z,r[10]=lC.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){let i=t.elements,r=e.elements,n=this.elements,s=i[0],o=i[4],a=i[8],h=i[12],l=i[1],u=i[5],c=i[9],d=i[13],p=i[2],f=i[6],m=i[10],g=i[14],y=i[3],_=i[7],v=i[11],x=i[15],b=r[0],E=r[4],T=r[8],w=r[12],S=r[1],M=r[5],A=r[9],R=r[13],C=r[2],P=r[6],I=r[10],O=r[14],L=r[3],N=r[7],D=r[11],F=r[15];return n[0]=s*b+o*S+a*C+h*L,n[4]=s*E+o*M+a*P+h*N,n[8]=s*T+o*A+a*I+h*D,n[12]=s*w+o*R+a*O+h*F,n[1]=l*b+u*S+c*C+d*L,n[5]=l*E+u*M+c*P+d*N,n[9]=l*T+u*A+c*I+d*D,n[13]=l*w+u*R+c*O+d*F,n[2]=p*b+f*S+m*C+g*L,n[6]=p*E+f*M+m*P+g*N,n[10]=p*T+f*A+m*I+g*D,n[14]=p*w+f*R+m*O+g*F,n[3]=y*b+_*S+v*C+x*L,n[7]=y*E+_*M+v*P+x*N,n[11]=y*T+_*A+v*I+x*D,n[15]=y*w+_*R+v*O+x*F,this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){let t=this.elements,e=t[0],i=t[4],r=t[8],n=t[12],s=t[1],o=t[5],a=t[9],h=t[13],l=t[2],u=t[6],c=t[10],d=t[14],p=t[3],f=t[7],m=t[11],g=t[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return p*(+n*a*u-r*h*u-n*o*c+i*h*c+r*o*d-i*a*d)+f*(+e*a*d-e*h*c+n*s*c-r*s*d+r*h*l-n*a*l)+m*(+e*h*u-e*o*d-n*s*u+i*s*d+n*o*l-i*h*l)+g*(-r*o*l-e*a*u+e*o*c+r*s*u-i*s*c+i*a*l)}transpose(){let t;let e=this.elements;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(t,e,i){let r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=i),this}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
let t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],o=t[5],a=t[6],h=t[7],l=t[8],u=t[9],c=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],y=u*m*h-f*c*h+f*a*d-o*m*d-u*a*g+o*c*g,_=p*c*h-l*m*h-p*a*d+s*m*d+l*a*g-s*c*g,v=l*f*h-p*u*h+p*o*d-s*f*d-l*o*g+s*u*g,x=p*u*a-l*f*a-p*o*c+s*f*c+l*o*m-s*u*m,b=e*y+i*_+r*v+n*x;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let E=1/b;return t[0]=y*E,t[1]=(f*c*n-u*m*n-f*r*d+i*m*d+u*r*g-i*c*g)*E,t[2]=(o*m*n-f*a*n+f*r*h-i*m*h-o*r*g+i*a*g)*E,t[3]=(u*a*n-o*c*n-u*r*h+i*c*h+o*r*d-i*a*d)*E,t[4]=_*E,t[5]=(l*m*n-p*c*n+p*r*d-e*m*d-l*r*g+e*c*g)*E,t[6]=(p*a*n-s*m*n-p*r*h+e*m*h+s*r*g-e*a*g)*E,t[7]=(s*c*n-l*a*n+l*r*h-e*c*h-s*r*d+e*a*d)*E,t[8]=v*E,t[9]=(p*u*n-l*f*n-p*i*d+e*f*d+l*i*g-e*u*g)*E,t[10]=(s*f*n-p*o*n+p*i*h-e*f*h-s*i*g+e*o*g)*E,t[11]=(l*o*n-s*u*n-l*i*h+e*u*h+s*i*d-e*o*d)*E,t[12]=x*E,t[13]=(l*f*r-p*u*r+p*i*c-e*f*c-l*i*m+e*u*m)*E,t[14]=(p*o*r-s*f*r-p*i*a+e*f*a+s*i*m-e*o*m)*E,t[15]=(s*u*r-l*o*r+l*i*a-e*u*a-s*i*c+e*o*c)*E,this}scale(t){let e=this.elements,i=t.x,r=t.y,n=t.z;return e[0]*=i,e[4]*=r,e[8]*=n,e[1]*=i,e[5]*=r,e[9]*=n,e[2]*=i,e[6]*=r,e[10]*=n,e[3]*=i,e[7]*=r,e[11]*=n,this}getMaxScaleOnAxis(){let t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,r))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){let e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){let e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){let e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){// Based on http://www.gamedev.net/reference/articles/article1199.asp
let i=Math.cos(e),r=Math.sin(e),n=1-i,s=t.x,o=t.y,a=t.z,h=n*s,l=n*o;return this.set(h*s+i,h*o-r*a,h*a+r*o,0,h*o+r*a,l*o+i,l*a-r*s,0,h*a-r*o,l*a+r*s,n*a*a+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,r,n,s){return this.set(1,i,n,0,t,1,s,0,e,r,1,0,0,0,0,1),this}compose(t,e,i){let r=this.elements,n=e._x,s=e._y,o=e._z,a=e._w,h=n+n,l=s+s,u=o+o,c=n*h,d=n*l,p=n*u,f=s*l,m=s*u,g=o*u,y=a*h,_=a*l,v=a*u,x=i.x,b=i.y,E=i.z;return r[0]=(1-(f+g))*x,r[1]=(d+v)*x,r[2]=(p-_)*x,r[3]=0,r[4]=(d-v)*b,r[5]=(1-(c+g))*b,r[6]=(m+y)*b,r[7]=0,r[8]=(p+_)*E,r[9]=(m-y)*E,r[10]=(1-(c+f))*E,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,i){let r=this.elements,n=lT.set(r[0],r[1],r[2]).length(),s=lT.set(r[4],r[5],r[6]).length(),o=lT.set(r[8],r[9],r[10]).length(),a=this.determinant();a<0&&(n=-n),t.x=r[12],t.y=r[13],t.z=r[14],// scale the rotation part
lw.copy(this);let h=1/n,l=1/s,u=1/o;return lw.elements[0]*=h,lw.elements[1]*=h,lw.elements[2]*=h,lw.elements[4]*=l,lw.elements[5]*=l,lw.elements[6]*=l,lw.elements[8]*=u,lw.elements[9]*=u,lw.elements[10]*=u,e.setFromRotationMatrix(lw),i.x=n,i.y=s,i.z=o,this}makePerspective(t,e,i,r,n,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");let o=this.elements;return o[0]=2*n/(e-t),o[4]=0,o[8]=(e+t)/(e-t),o[12]=0,o[1]=0,o[5]=2*n/(i-r),o[9]=(i+r)/(i-r),o[13]=0,o[2]=0,o[6]=0,o[10]=-(s+n)/(s-n),o[14]=-2*s*n/(s-n),o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,r,n,s){let o=this.elements,a=1/(e-t),h=1/(i-r),l=1/(s-n);return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-((e+t)*a),o[1]=0,o[5]=2*h,o[9]=0,o[13]=-((i+r)*h),o[2]=0,o[6]=0,o[10]=-2*l,o[14]=-((s+n)*l),o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){let e=this.elements,i=t.elements;for(let t=0;t<16;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){let i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}lE.prototype.isMatrix4=!0;const lT=/*@__PURE__*/new h1,lw=/*@__PURE__*/new lE,lS=/*@__PURE__*/new h1(0,0,0),lM=/*@__PURE__*/new h1(1,1,1),lA=/*@__PURE__*/new h1,lR=/*@__PURE__*/new h1,lC=/*@__PURE__*/new h1,lP=/*@__PURE__*/new lE,lI=/*@__PURE__*/new h0;class lO{constructor(t=0,e=0,i=0,r=lO.DefaultOrder){this._x=t,this._y=e,this._z=i,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,r=this._order){return this._x=t,this._y=e,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let r=t.elements,n=r[0],s=r[4],o=r[8],a=r[1],h=r[5],l=r[9],u=r[2],c=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(hz(o,-1,1)),.9999999>Math.abs(o)?(this._x=Math.atan2(-l,d),this._z=Math.atan2(-s,n)):(this._x=Math.atan2(c,h),this._z=0);break;case"YXZ":this._x=Math.asin(-hz(l,-1,1)),.9999999>Math.abs(l)?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,h)):(this._y=Math.atan2(-u,n),this._z=0);break;case"ZXY":this._x=Math.asin(hz(c,-1,1)),.9999999>Math.abs(c)?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,h)):(this._y=0,this._z=Math.atan2(a,n));break;case"ZYX":this._y=Math.asin(-hz(u,-1,1)),.9999999>Math.abs(u)?(this._x=Math.atan2(c,d),this._z=Math.atan2(a,n)):(this._x=0,this._z=Math.atan2(-s,h));break;case"YZX":this._z=Math.asin(hz(a,-1,1)),.9999999>Math.abs(a)?(this._x=Math.atan2(-l,h),this._y=Math.atan2(-u,n)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-hz(s,-1,1)),.9999999>Math.abs(s)?(this._x=Math.atan2(c,h),this._y=Math.atan2(o,n)):(this._x=Math.atan2(-l,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return lP.makeRotationFromQuaternion(t),this.setFromRotationMatrix(lP,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return(// WARNING: this discards revolution information -bhouston
lI.setFromEuler(this),this.setFromQuaternion(lI,t))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new h1(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}lO.prototype.isEuler=!0,lO.DefaultOrder="XYZ",lO.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class lL{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let lN=0;const lD=/*@__PURE__*/new h1,lF=/*@__PURE__*/new h0,lB=/*@__PURE__*/new lE,lU=/*@__PURE__*/new h1,lG=/*@__PURE__*/new h1,lk=/*@__PURE__*/new h1,lH=/*@__PURE__*/new h0,lz=/*@__PURE__*/new h1(1,0,0),lj=/*@__PURE__*/new h1(0,1,0),lV=/*@__PURE__*/new h1(0,0,1),lX={type:"added"},lW={type:"removed"};class lY extends hB{constructor(){super(),Object.defineProperty(this,"id",{value:lN++}),this.uuid=hH(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=lY.DefaultUp.clone();let t=new h1,e=new lO,i=new h0,r=new h1(1,1,1);e._onChange(function(){i.setFromEuler(e,!1)}),i._onChange(function(){e.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new lE},normalMatrix:{value:new hW}}),this.matrix=new lE,this.matrixWorld=new lE,this.matrixAutoUpdate=lY.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new lL,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){// assumes axis is normalized
this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){// assumes q is normalized
this.quaternion.copy(t)}rotateOnAxis(t,e){return(// rotate object on axis in object space
// axis is assumed to be normalized
lF.setFromAxisAngle(t,e),this.quaternion.multiply(lF),this)}rotateOnWorldAxis(t,e){return(// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
lF.setFromAxisAngle(t,e),this.quaternion.premultiply(lF),this)}rotateX(t){return this.rotateOnAxis(lz,t)}rotateY(t){return this.rotateOnAxis(lj,t)}rotateZ(t){return this.rotateOnAxis(lV,t)}translateOnAxis(t,e){return(// translate object by distance along axis in object space
// axis is assumed to be normalized
lD.copy(t).applyQuaternion(this.quaternion),this.position.add(lD.multiplyScalar(e)),this)}translateX(t){return this.translateOnAxis(lz,t)}translateY(t){return this.translateOnAxis(lj,t)}translateZ(t){return this.translateOnAxis(lV,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(lB.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?lU.copy(t):lU.set(t,e,i);let r=this.parent;this.updateWorldMatrix(!0,!1),lG.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?lB.lookAt(lG,lU,this.up):lB.lookAt(lU,lG,this.up),this.quaternion.setFromRotationMatrix(lB),r&&(lB.extractRotation(r.matrixWorld),lF.setFromRotationMatrix(lB),this.quaternion.premultiply(lF.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",t):t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(lX)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}let e=this.children.indexOf(t);return -1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(lW)),this}removeFromParent(){let t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){let e=this.children[t];e.parent=null,e.dispatchEvent(lW)}return this.children.length=0,this}attach(t){return(// adds object as a child of this, while maintaining the object's world transform
this.updateWorldMatrix(!0,!1),lB.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),lB.multiply(t.parent.matrixWorld)),t.applyMatrix4(lB),this.add(t),t.updateWorldMatrix(!1,!0),this)}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,r=this.children.length;i<r;i++){let r=this.children[i],n=r.getObjectByProperty(t,e);if(void 0!==n)return n}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(lG,t,lk),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(lG,lH,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);let e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);let e=this.children;for(let i=0,r=e.length;i<r;i++)e[i].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);let e=this.children;for(let i=0,r=e.length;i<r;i++)e[i].traverseVisible(t)}traverseAncestors(t){let e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);// update children
let e=this.children;for(let i=0,r=e.length;i<r;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){let i=this.parent;// update children
if(!0===t&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){let t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){// meta is a string when called from JSON.stringify
let e=void 0===t||"string"==typeof t,i={};e&&(// initialize meta obj
t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});// standard Object3D serialization
let r={};//
function n(e,i){return void 0===e[i.uuid]&&(e[i.uuid]=i.toJSON(t)),i.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=n(t.geometries,this.geometry);let e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){let i=e.shapes;if(Array.isArray(i))for(let e=0,r=i.length;e<r;e++){let r=i[e];n(t.shapes,r)}else n(t.shapes,i)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(n(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material){if(Array.isArray(this.material)){let e=[];for(let i=0,r=this.material.length;i<r;i++)e.push(n(t.materials,this.material[i]));r.material=e}else r.material=n(t.materials,this.material)}//
if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}//
if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++){let i=this.animations[e];r.animations.push(n(t.animations,i))}}if(e){let e=s(t.geometries),r=s(t.materials),n=s(t.textures),o=s(t.images),a=s(t.shapes),h=s(t.skeletons),l=s(t.animations);e.length>0&&(i.geometries=e),r.length>0&&(i.materials=r),n.length>0&&(i.textures=n),o.length>0&&(i.images=o),a.length>0&&(i.shapes=a),h.length>0&&(i.skeletons=h),l.length>0&&(i.animations=l)}return i.object=r,i;// extract data from the cache hash
// remove metadata on each item
// and return as array
function s(t){let e=[];for(let i in t){let r=t[i];delete r.metadata,e.push(r)}return e}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){let i=t.children[e];this.add(i.clone())}return this}}lY.DefaultUp=new h1(0,1,0),lY.DefaultMatrixAutoUpdate=!0,lY.prototype.isObject3D=!0;const lq=/*@__PURE__*/new h1,lK=/*@__PURE__*/new h1,lJ=/*@__PURE__*/new h1,lZ=/*@__PURE__*/new h1,l$=/*@__PURE__*/new h1,lQ=/*@__PURE__*/new h1,l0=/*@__PURE__*/new h1,l1=/*@__PURE__*/new h1,l2=/*@__PURE__*/new h1,l3=/*@__PURE__*/new h1;class l5{constructor(t=new h1,e=new h1,i=new h1){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,r){r.subVectors(i,e),lq.subVectors(t,e),r.cross(lq);let n=r.lengthSq();return n>0?r.multiplyScalar(1/Math.sqrt(n)):r.set(0,0,0)}// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
static getBarycoord(t,e,i,r,n){lq.subVectors(r,e),lK.subVectors(i,e),lJ.subVectors(t,e);let s=lq.dot(lq),o=lq.dot(lK),a=lq.dot(lJ),h=lK.dot(lK),l=lK.dot(lJ),u=s*h-o*o;// collinear or singular triangle
if(0===u)// not sure if this is the best idea, maybe should be returning undefined
return n.set(-2,-1,-1);let c=1/u,d=(h*a-o*l)*c,p=(s*l-o*a)*c;// barycentric coordinates must always sum to 1
return n.set(1-d-p,p,d)}static containsPoint(t,e,i,r){return this.getBarycoord(t,e,i,r,lZ),lZ.x>=0&&lZ.y>=0&&lZ.x+lZ.y<=1}static getUV(t,e,i,r,n,s,o,a){return this.getBarycoord(t,e,i,r,lZ),a.set(0,0),a.addScaledVector(n,lZ.x),a.addScaledVector(s,lZ.y),a.addScaledVector(o,lZ.z),a}static isFrontFacing(t,e,i,r){// strictly front facing
return lq.subVectors(i,e),lK.subVectors(t,e),0>lq.cross(lK).dot(r)}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,r){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[r]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return lq.subVectors(this.c,this.b),lK.subVectors(this.a,this.b),.5*lq.cross(lK).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return l5.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return l5.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,r,n){return l5.getUV(t,this.a,this.b,this.c,e,i,r,n)}containsPoint(t){return l5.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return l5.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){let i,r;let n=this.a,s=this.b,o=this.c;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.
l$.subVectors(s,n),lQ.subVectors(o,n),l1.subVectors(t,n);let a=l$.dot(l1),h=lQ.dot(l1);if(a<=0&&h<=0)return e.copy(n);l2.subVectors(t,s);let l=l$.dot(l2),u=lQ.dot(l2);if(l>=0&&u<=l)return e.copy(s);let c=a*u-l*h;if(c<=0&&a>=0&&l<=0)// edge region of AB; barycentric coords (1-v, v, 0)
return i=a/(a-l),e.copy(n).addScaledVector(l$,i);l3.subVectors(t,o);let d=l$.dot(l3),p=lQ.dot(l3);if(p>=0&&d<=p)return e.copy(o);let f=d*h-a*p;if(f<=0&&h>=0&&p<=0)// edge region of AC; barycentric coords (1-w, 0, w)
return r=h/(h-p),e.copy(n).addScaledVector(lQ,r);let m=l*p-d*u;if(m<=0&&u-l>=0&&d-p>=0)// edge region of BC; barycentric coords (0, 1-w, w)
return l0.subVectors(o,s),r=(u-l)/(u-l+(d-p)),e.copy(s).addScaledVector(l0,r);// edge region of BC
// face region
let g=1/(m+f+c);return(// u = va * denom
i=f*g,r=c*g,e.copy(n).addScaledVector(l$,i).addScaledVector(lQ,r))}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let l4=0;class l6 extends hB{constructor(){super(),Object.defineProperty(this,"id",{value:l4++}),this.uuid=hH(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}onBuild(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(let e in t){let i=t[e];if(void 0===i){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}// for backward compatability if shading is set in the constructor
if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===i;continue}let r=this[e];if(void 0===r){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[e]=i}}toJSON(t){let e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});let i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};// TODO: Copied from Object3D.toJSON
function r(t){let e=[];for(let i in t){let r=t[i];delete r.metadata,e.push(r)}return e}if(// standard Material serialization
i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(i.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(i.specularTint=this.specularTint.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(i.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationTint&&(i.attenuationTint=this.attenuationTint.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(i.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=this.flatShading),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),e){let e=r(t.textures),n=r(t.images);e.length>0&&(i.textures=e),n.length>0&&(i.images=n)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;let e=t.clippingPlanes,i=null;if(null!==e){let t=e.length;i=Array(t);for(let r=0;r!==t;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}l6.prototype.isMaterial=!0;const l8={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},l7={h:0,s:0,l:0},l9={h:0,s:0,l:0};function ut(t,e,i){return(i<0&&(i+=1),i>1&&(i-=1),i<1/6)?t+(e-t)*6*i:i<.5?e:i<2/3?t+(e-t)*6*(2/3-i):t}function ue(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function ui(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class ur{constructor(t,e,i){if(void 0===e&&void 0===i)return this.set(t);return this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}setHSL(t,e,i){if(// h,s,l ranges are in 0.0 - 1.0
t=(t%1+1)%1,e=hz(e,0,1),i=hz(i,0,1),0===e)this.r=this.g=this.b=i;else{let r=i<=.5?i*(1+e):i+e-i*e,n=2*i-r;this.r=ut(n,r,t+1/3),this.g=ut(n,r,t),this.b=ut(n,r,t-1/3)}return this}setStyle(t){let e;function i(e){void 0!==e&&1>parseFloat(e)&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}if(e=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;let r=e[1],n=e[2];switch(r){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return(// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,i(t[4]),this);if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return(// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,i(t[4]),this);break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
let e=parseFloat(t[1])/360,r=parseInt(t[2],10)/100,n=parseInt(t[3],10)/100;return i(t[4]),this.setHSL(e,r,n)}}}else if(e=/^\#([A-Fa-f\d]+)$/.exec(t)){// hex color
let t=e[1],i=t.length;if(3===i)return(// #ff0
this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,this);if(6===i)return(// #ff0000
this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,this)}return t&&t.length>0?this.setColorName(t):this}setColorName(t){// color keywords
let e=l8[t.toLowerCase()];return void 0!==e?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){let i=e>0?1/e:1;return this.r=Math.pow(t.r,i),this.g=Math.pow(t.g,i),this.b=Math.pow(t.b,i),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=ue(t.r),this.g=ue(t.g),this.b=ue(t.b),this}copyLinearToSRGB(t){return this.r=ui(t.r),this.g=ui(t.g),this.b=ui(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){let e,i;// h,s,l ranges are in 0.0 - 1.0
let r=this.r,n=this.g,s=this.b,o=Math.max(r,n,s),a=Math.min(r,n,s),h=(a+o)/2;if(a===o)e=0,i=0;else{let t=o-a;switch(i=h<=.5?t/(o+a):t/(2-o-a),o){case r:e=(n-s)/t+(n<s?6:0);break;case n:e=(s-r)/t+2;break;case s:e=(r-n)/t+4}e/=6}return t.h=e,t.s=i,t.l=h,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,i){return this.getHSL(l7),l7.h+=t,l7.s+=e,l7.l+=i,this.setHSL(l7.h,l7.s,l7.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(l7),t.getHSL(l9);let i=(1-e)*l7.h+e*l9.h,r=(1-e)*l7.s+e*l9.s,n=(1-e)*l7.l+e*l9.l;return this.setHSL(i,r,n),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(// assuming Uint8Array
this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}ur.NAMES=l8,ur.prototype.isColor=!0,ur.prototype.r=1,ur.prototype.g=1,ur.prototype.b=1;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 * }
 */class un extends l6{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new ur(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}un.prototype.isMeshBasicMaterial=!0;const us=/*@__PURE__*/new h1,uo=/*@__PURE__*/new hX;class ua{constructor(t,e,i){if(Array.isArray(t))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===i,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let r=0,n=this.itemSize;r<n;r++)this.array[t+r]=e.array[i+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){let e=this.array,i=0;for(let r=0,n=t.length;r<n;r++){let n=t[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),n=new ur),e[i++]=n.r,e[i++]=n.g,e[i++]=n.b}return this}copyVector2sArray(t){let e=this.array,i=0;for(let r=0,n=t.length;r<n;r++){let n=t[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),n=new hX),e[i++]=n.x,e[i++]=n.y}return this}copyVector3sArray(t){let e=this.array,i=0;for(let r=0,n=t.length;r<n;r++){let n=t[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),n=new h1),e[i++]=n.x,e[i++]=n.y,e[i++]=n.z}return this}copyVector4sArray(t){let e=this.array,i=0;for(let r=0,n=t.length;r<n;r++){let n=t[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),n=new hZ),e[i++]=n.x,e[i++]=n.y,e[i++]=n.z,e[i++]=n.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,i=this.count;e<i;e++)uo.fromBufferAttribute(this,e),uo.applyMatrix3(t),this.setXY(e,uo.x,uo.y);else if(3===this.itemSize)for(let e=0,i=this.count;e<i;e++)us.fromBufferAttribute(this,e),us.applyMatrix3(t),this.setXYZ(e,us.x,us.y,us.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)us.x=this.getX(e),us.y=this.getY(e),us.z=this.getZ(e),us.applyMatrix4(t),this.setXYZ(e,us.x,us.y,us.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)us.x=this.getX(e),us.y=this.getY(e),us.z=this.getZ(e),us.applyNormalMatrix(t),this.setXYZ(e,us.x,us.y,us.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)us.x=this.getX(e),us.y=this.getY(e),us.z=this.getZ(e),us.transformDirection(t),this.setXYZ(e,us.x,us.y,us.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=r,this}setXYZW(t,e,i,r,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=r,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),35044!==this.usage&&(t.usage=this.usage),(0!==this.updateRange.offset||-1!==this.updateRange.count)&&(t.updateRange=this.updateRange),t}}ua.prototype.isBufferAttribute=!0;class uh extends ua{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class ul extends ua{constructor(t,e,i){super(new Uint32Array(t),e,i)}}(class extends ua{constructor(t,e,i){super(new Uint16Array(t),e,i)}}).prototype.isFloat16BufferAttribute=!0;class uu extends ua{constructor(t,e,i){super(new Float32Array(t),e,i)}}function uc(t){if(0===t.length)return-1/0;let e=t[0];for(let i=1,r=t.length;i<r;++i)t[i]>e&&(e=t[i]);return e}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;let ud=0;const up=/*@__PURE__*/new lE,uf=/*@__PURE__*/new lY,um=/*@__PURE__*/new h1,ug=/*@__PURE__*/new h5,uy=/*@__PURE__*/new h5,u_=/*@__PURE__*/new h1;class uv extends hB{constructor(){super(),Object.defineProperty(this,"id",{value:ud++}),this.uuid=hH(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(uc(t)>65535?ul:uh)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){let e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);let i=this.attributes.normal;if(void 0!==i){let e=new hW().getNormalMatrix(t);i.applyNormalMatrix(e),i.needsUpdate=!0}let r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return up.makeRotationFromQuaternion(t),this.applyMatrix4(up),this}rotateX(t){return(// rotate geometry around world x-axis
up.makeRotationX(t),this.applyMatrix4(up),this)}rotateY(t){return(// rotate geometry around world y-axis
up.makeRotationY(t),this.applyMatrix4(up),this)}rotateZ(t){return(// rotate geometry around world z-axis
up.makeRotationZ(t),this.applyMatrix4(up),this)}translate(t,e,i){return(// translate geometry
up.makeTranslation(t,e,i),this.applyMatrix4(up),this)}scale(t,e,i){return(// scale geometry
up.makeScale(t,e,i),this.applyMatrix4(up),this)}lookAt(t){return uf.lookAt(t),uf.updateMatrix(),this.applyMatrix4(uf.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(um).negate(),this.translate(um.x,um.y,um.z),this}setFromPoints(t){let e=[];for(let i=0,r=t.length;i<r;i++){let r=t[i];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new uu(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new h5);let t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new h1(-1/0,-1/0,-1/0),new h1(1/0,1/0,1/0));return}if(void 0!==t)// process morph attributes if present
{if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){let i=e[t];ug.setFromBufferAttribute(i),this.morphTargetsRelative?(u_.addVectors(this.boundingBox.min,ug.min),this.boundingBox.expandByPoint(u_),u_.addVectors(this.boundingBox.max,ug.max),this.boundingBox.expandByPoint(u_)):(this.boundingBox.expandByPoint(ug.min),this.boundingBox.expandByPoint(ug.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new lp);let t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new h1,1/0);return}if(t){// first, find the center of the bounding sphere
let i=this.boundingSphere.center;// process morph attributes if present
if(ug.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){let i=e[t];uy.setFromBufferAttribute(i),this.morphTargetsRelative?(u_.addVectors(ug.min,uy.min),ug.expandByPoint(u_),u_.addVectors(ug.max,uy.max),ug.expandByPoint(u_)):(ug.expandByPoint(uy.min),ug.expandByPoint(uy.max))}ug.getCenter(i);// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
let r=0;for(let e=0,n=t.count;e<n;e++)u_.fromBufferAttribute(t,e),r=Math.max(r,i.distanceToSquared(u_));// process morph attributes if present
if(e)for(let n=0,s=e.length;n<s;n++){let s=e[n],o=this.morphTargetsRelative;for(let e=0,n=s.count;e<n;e++)u_.fromBufferAttribute(s,e),o&&(um.fromBufferAttribute(t,e),u_.add(um)),r=Math.max(r,i.distanceToSquared(u_))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){// backwards compatibility
}computeTangents(){let t=this.index,e=this.attributes;// based on http://www.terathon.com/code/tangent.html
// (per vertex tangents)
if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let i=t.array,r=e.position.array,n=e.normal.array,s=e.uv.array,o=r.length/3;void 0===e.tangent&&this.setAttribute("tangent",new ua(new Float32Array(4*o),4));let a=e.tangent.array,h=[],l=[];for(let t=0;t<o;t++)h[t]=new h1,l[t]=new h1;let u=new h1,c=new h1,d=new h1,p=new hX,f=new hX,m=new hX,g=new h1,y=new h1,_=this.groups;0===_.length&&(_=[{start:0,count:i.length}]);for(let t=0,e=_.length;t<e;++t){let e=_[t],n=e.start,o=e.count;for(let t=n,e=n+o;t<e;t+=3)!function(t,e,i){u.fromArray(r,3*t),c.fromArray(r,3*e),d.fromArray(r,3*i),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*i),c.sub(u),d.sub(u),f.sub(p),m.sub(p);let n=1/(f.x*m.y-m.x*f.y);isFinite(n)&&(g.copy(c).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(n),y.copy(d).multiplyScalar(f.x).addScaledVector(c,-m.x).multiplyScalar(n),h[t].add(g),h[e].add(g),h[i].add(g),l[t].add(y),l[e].add(y),l[i].add(y))}(i[t+0],i[t+1],i[t+2])}let v=new h1,x=new h1,b=new h1,E=new h1;function T(t){b.fromArray(n,3*t),E.copy(b);let e=h[t];// Gram-Schmidt orthogonalize
v.copy(e),v.sub(b.multiplyScalar(b.dot(e))).normalize(),// Calculate handedness
x.crossVectors(E,e);let i=x.dot(l[t]);a[4*t]=v.x,a[4*t+1]=v.y,a[4*t+2]=v.z,a[4*t+3]=i<0?-1:1}for(let t=0,e=_.length;t<e;++t){let e=_[t],r=e.start,n=e.count;for(let t=r,e=r+n;t<e;t+=3)T(i[t+0]),T(i[t+1]),T(i[t+2])}}computeVertexNormals(){let t=this.index,e=this.getAttribute("position");if(void 0!==e){let i=this.getAttribute("normal");if(void 0===i)i=new ua(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let t=0,e=i.count;t<e;t++)i.setXYZ(t,0,0,0);let r=new h1,n=new h1,s=new h1,o=new h1,a=new h1,h=new h1,l=new h1,u=new h1;// indexed elements
if(t)for(let c=0,d=t.count;c<d;c+=3){let d=t.getX(c+0),p=t.getX(c+1),f=t.getX(c+2);r.fromBufferAttribute(e,d),n.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),l.subVectors(s,n),u.subVectors(r,n),l.cross(u),o.fromBufferAttribute(i,d),a.fromBufferAttribute(i,p),h.fromBufferAttribute(i,f),o.add(l),a.add(l),h.add(l),i.setXYZ(d,o.x,o.y,o.z),i.setXYZ(p,a.x,a.y,a.z),i.setXYZ(f,h.x,h.y,h.z)}else for(let t=0,o=e.count;t<o;t+=3)r.fromBufferAttribute(e,t+0),n.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),l.subVectors(s,n),u.subVectors(r,n),l.cross(u),i.setXYZ(t+0,l.x,l.y,l.z),i.setXYZ(t+1,l.x,l.y,l.z),i.setXYZ(t+2,l.x,l.y,l.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));let i=this.attributes;for(let r in i){if(void 0===t.attributes[r])continue;let n=i[r],s=n.array,o=t.attributes[r],a=o.array,h=o.itemSize*e,l=Math.min(a.length,s.length-h);for(let t=0,e=h;t<l;t++,e++)s[e]=a[t]}return this}normalizeNormals(){let t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)u_.fromBufferAttribute(t,e),u_.normalize(),t.setXYZ(e,u_.x,u_.y,u_.z)}toNonIndexed(){function t(t,e){let i=t.array,r=t.itemSize,n=t.normalized,s=new i.constructor(e.length*r),o=0,a=0;for(let n=0,h=e.length;n<h;n++){o=t.isInterleavedBufferAttribute?e[n]*t.data.stride+t.offset:e[n]*r;for(let t=0;t<r;t++)s[a++]=i[o++]}return new ua(s,r,n)}//
if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let e=new uv,i=this.index.array,r=this.attributes;// attributes
for(let n in r){let s=r[n],o=t(s,i);e.setAttribute(n,o)}// morph attributes
let n=this.morphAttributes;for(let r in n){let s=[],o=n[r];for(let e=0,r=o.length;e<r;e++){let r=o[e],n=t(r,i);s.push(n)}e.morphAttributes[r]=s}e.morphTargetsRelative=this.morphTargetsRelative;// groups
let s=this.groups;for(let t=0,i=s.length;t<i;t++){let i=s[t];e.addGroup(i.start,i.count,i.materialIndex)}return e}toJSON(){let t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(// standard BufferGeometry serialization
t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){let e=this.parameters;for(let i in e)void 0!==e[i]&&(t[i]=e[i]);return t}// for simplicity the code assumes attributes are not shared across geometries, see #15811
t.data={attributes:{}};let e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});let i=this.attributes;for(let e in i){let r=i[e];t.data.attributes[e]=r.toJSON(t.data)}let r={},n=!1;for(let e in this.morphAttributes){let i=this.morphAttributes[e],s=[];for(let e=0,r=i.length;e<r;e++){let r=i[e];s.push(r.toJSON(t.data))}s.length>0&&(r[e]=s,n=!0)}n&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);let s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));let o=this.boundingSphere;return null!==o&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new uv().copy(this)}copy(t){// reset
this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;// used for storing cloned, shared data
let e={};// name
this.name=t.name;// index
let i=t.index;null!==i&&this.setIndex(i.clone(e));// attributes
let r=t.attributes;for(let t in r){let i=r[t];this.setAttribute(t,i.clone(e))}// morph attributes
let n=t.morphAttributes;for(let t in n){let i=[],r=n[t];for(let t=0,n=r.length;t<n;t++)i.push(r[t].clone(e));this.morphAttributes[t]=i}this.morphTargetsRelative=t.morphTargetsRelative;// groups
let s=t.groups;for(let t=0,e=s.length;t<e;t++){let e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}// bounding box
let o=t.boundingBox;null!==o&&(this.boundingBox=o.clone());// bounding sphere
let a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),// draw range
this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,// user data
this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}uv.prototype.isBufferGeometry=!0;const ux=/*@__PURE__*/new lE,ub=/*@__PURE__*/new lb,uE=/*@__PURE__*/new lp,uT=/*@__PURE__*/new h1,uw=/*@__PURE__*/new h1,uS=/*@__PURE__*/new h1,uM=/*@__PURE__*/new h1,uA=/*@__PURE__*/new h1,uR=/*@__PURE__*/new h1,uC=/*@__PURE__*/new h1,uP=/*@__PURE__*/new h1,uI=/*@__PURE__*/new h1,uO=/*@__PURE__*/new hX,uL=/*@__PURE__*/new hX,uN=/*@__PURE__*/new hX,uD=/*@__PURE__*/new h1,uF=/*@__PURE__*/new h1;class uB extends lY{constructor(t=new uv,e=new un){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){let t=this.geometry;if(t.isBufferGeometry){let e=t.morphAttributes,i=Object.keys(e);if(i.length>0){let t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){let i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{let e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){let i;let r=this.geometry,n=this.material,s=this.matrixWorld;if(void 0!==n&&(null===r.boundingSphere&&r.computeBoundingSphere(),uE.copy(r.boundingSphere),uE.applyMatrix4(s),!1!==t.ray.intersectsSphere(uE))){// Check boundingBox before continuing
if(//
ux.copy(s).invert(),ub.copy(t.ray).applyMatrix4(ux),null!==r.boundingBox&&!1===ub.intersectsBox(r.boundingBox))return;if(r.isBufferGeometry){let s=r.index,o=r.attributes.position,a=r.morphAttributes.position,h=r.morphTargetsRelative,l=r.attributes.uv,u=r.attributes.uv2,c=r.groups,d=r.drawRange;if(null!==s){// indexed buffer geometry
if(Array.isArray(n))for(let r=0,p=c.length;r<p;r++){let p=c[r],f=n[p.materialIndex],m=Math.max(p.start,d.start),g=Math.min(p.start+p.count,d.start+d.count);for(let r=m;r<g;r+=3){let n=s.getX(r),c=s.getX(r+1),d=s.getX(r+2);(i=uU(this,f,t,ub,o,a,h,l,u,n,c,d))&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=p.materialIndex,e.push(i))}}else{let r=Math.max(0,d.start),c=Math.min(s.count,d.start+d.count);for(let d=r;d<c;d+=3){let r=s.getX(d),c=s.getX(d+1),p=s.getX(d+2);(i=uU(this,n,t,ub,o,a,h,l,u,r,c,p))&&(i.faceIndex=Math.floor(d/3),e.push(i))}}}else if(void 0!==o){// non-indexed buffer geometry
if(Array.isArray(n))for(let r=0,s=c.length;r<s;r++){let s=c[r],p=n[s.materialIndex],f=Math.max(s.start,d.start),m=Math.min(s.start+s.count,d.start+d.count);for(let r=f;r<m;r+=3){let n=r,c=r+1,d=r+2;(i=uU(this,p,t,ub,o,a,h,l,u,n,c,d))&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=s.materialIndex,e.push(i))}}else{let r=Math.max(0,d.start),s=Math.min(o.count,d.start+d.count);for(let c=r;c<s;c+=3){let r=c,s=c+1,d=c+2;(i=uU(this,n,t,ub,o,a,h,l,u,r,s,d))&&(i.faceIndex=Math.floor(c/3),e.push(i))}}}}else r.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function uU(t,e,i,r,n,s,o,a,h,l,u,c){uT.fromBufferAttribute(n,l),uw.fromBufferAttribute(n,u),uS.fromBufferAttribute(n,c);let d=t.morphTargetInfluences;if(s&&d){uC.set(0,0,0),uP.set(0,0,0),uI.set(0,0,0);for(let t=0,e=s.length;t<e;t++){let e=d[t],i=s[t];0!==e&&(uM.fromBufferAttribute(i,l),uA.fromBufferAttribute(i,u),uR.fromBufferAttribute(i,c),o?(uC.addScaledVector(uM,e),uP.addScaledVector(uA,e),uI.addScaledVector(uR,e)):(uC.addScaledVector(uM.sub(uT),e),uP.addScaledVector(uA.sub(uw),e),uI.addScaledVector(uR.sub(uS),e)))}uT.add(uC),uw.add(uP),uS.add(uI)}t.isSkinnedMesh&&(t.boneTransform(l,uT),t.boneTransform(u,uw),t.boneTransform(c,uS));let p=function(t,e,i,r,n,s,o,a){if(null===(1===e.side?r.intersectTriangle(o,s,n,!0,a):r.intersectTriangle(n,s,o,2!==e.side,a)))return null;uF.copy(a),uF.applyMatrix4(t.matrixWorld);let h=i.ray.origin.distanceTo(uF);return h<i.near||h>i.far?null:{distance:h,point:uF.clone(),object:t}}(t,e,i,r,uT,uw,uS,uD);if(p){a&&(uO.fromBufferAttribute(a,l),uL.fromBufferAttribute(a,u),uN.fromBufferAttribute(a,c),p.uv=l5.getUV(uD,uT,uw,uS,uO,uL,uN,new hX)),h&&(uO.fromBufferAttribute(h,l),uL.fromBufferAttribute(h,u),uN.fromBufferAttribute(h,c),p.uv2=l5.getUV(uD,uT,uw,uS,uO,uL,uN,new hX));let t={a:l,b:u,c:c,normal:new h1,materialIndex:0};l5.getNormal(uT,uw,uS,t.normal),p.face=t}return p}uB.prototype.isMesh=!0;class uG extends uv{constructor(t=1,e=1,i=1,r=1,n=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:r,heightSegments:n,depthSegments:s};let o=this;// segments
r=Math.floor(r),n=Math.floor(n),s=Math.floor(s);// buffers
let a=[],h=[],l=[],u=[],c=0,d=0;function p(t,e,i,r,n,s,p,f,m,g,y){let _=s/m,v=p/g,x=s/2,b=p/2,E=f/2,T=m+1,w=g+1,S=0,M=0,A=new h1;// generate vertices, normals and uvs
for(let s=0;s<w;s++){let o=s*v-b;for(let a=0;a<T;a++){let c=a*_-x;// set values to correct vector component
A[t]=c*r,A[e]=o*n,A[i]=E,// now apply vector to vertex buffer
h.push(A.x,A.y,A.z),// set values to correct vector component
A[t]=0,A[e]=0,A[i]=f>0?1:-1,// now apply vector to normal buffer
l.push(A.x,A.y,A.z),// uvs
u.push(a/m),u.push(1-s/g),// counters
S+=1}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(let t=0;t<g;t++)for(let e=0;e<m;e++){let i=c+e+T*t,r=c+e+T*(t+1),n=c+(e+1)+T*(t+1),s=c+(e+1)+T*t;// faces
a.push(i,r,s),a.push(r,n,s),// increase counter
M+=6}// add a group to the geometry. this will ensure multi material support
o.addGroup(d,M,y),// calculate new start value for groups
d+=M,// update total number of vertices
c+=S}// build each side of the box geometry
p("z","y","x",-1,-1,i,e,t,s,n,0),p("z","y","x",1,-1,i,e,-t,s,n,1),p("x","z","y",1,1,t,i,e,r,s,2),p("x","z","y",1,-1,t,i,-e,r,s,3),p("x","y","z",1,-1,t,e,i,r,n,4),p("x","y","z",-1,-1,t,e,-i,r,n,5),// build geometry
this.setIndex(a),this.setAttribute("position",new uu(h,3)),this.setAttribute("normal",new uu(l,3)),this.setAttribute("uv",new uu(u,2))}static fromJSON(t){return new uG(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}/**
 * Uniform Utilities
 */function uk(t){let e={};for(let i in t)for(let r in e[i]={},t[i]){let n=t[i][r];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?e[i][r]=n.clone():Array.isArray(n)?e[i][r]=n.slice():e[i][r]=n}return e}function uH(t){let e={};for(let i=0;i<t.length;i++){let r=uk(t[i]);for(let t in r)e[t]=r[t]}return e}// Legacy
const uz={clone:uk,merge:uH};/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>
 * }
 */class uj extends l6{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1// set to use shader texture LOD
},// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=uk(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){let e=super.toJSON(t);for(let i in e.glslVersion=this.glslVersion,e.uniforms={},this.uniforms){let r=this.uniforms[i],n=r.value;n&&n.isTexture?e.uniforms[i]={type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?e.uniforms[i]={type:"c",value:n.getHex()}:n&&n.isVector2?e.uniforms[i]={type:"v2",value:n.toArray()}:n&&n.isVector3?e.uniforms[i]={type:"v3",value:n.toArray()}:n&&n.isVector4?e.uniforms[i]={type:"v4",value:n.toArray()}:n&&n.isMatrix3?e.uniforms[i]={type:"m3",value:n.toArray()}:n&&n.isMatrix4?e.uniforms[i]={type:"m4",value:n.toArray()}:e.uniforms[i]={value:n}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;let i={};for(let t in this.extensions)!0===this.extensions[t]&&(i[t]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}uj.prototype.isShaderMaterial=!0;class uV extends lY{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new lE,this.projectionMatrix=new lE,this.projectionMatrixInverse=new lE}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);let e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}uV.prototype.isCamera=!0;class uX extends uV{constructor(t=50,e=1,i=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength(t){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */let e=.5*this.getFilmHeight()/t;this.fov=2*hk*Math.atan(e),this.updateProjectionMatrix()}/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength(){let t=Math.tan(.5*hG*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*hk*Math.atan(Math.tan(.5*hG*this.fov)/this.zoom)}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1)}/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset(t,e,i,r,n,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=r,this.view.width=n,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let t=this.near,e=t*Math.tan(.5*hG*this.fov)/this.zoom,i=2*e,r=this.aspect*i,n=-.5*r,s=this.view;if(null!==this.view&&this.view.enabled){let t=s.fullWidth,o=s.fullHeight;n+=s.offsetX*r/t,e-=s.offsetY*i/o,r*=s.width/t,i*=s.height/o}let o=this.filmOffset;0!==o&&(n+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+r,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){let e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}uX.prototype.isPerspectiveCamera=!0;class uW extends lY{constructor(t,e,i){if(super(),this.type="CubeCamera",!0!==i.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;let r=new uX(90,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new h1(1,0,0)),this.add(r);let n=new uX(90,1,t,e);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new h1(-1,0,0)),this.add(n);let s=new uX(90,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new h1(0,1,0)),this.add(s);let o=new uX(90,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new h1(0,-1,0)),this.add(o);let a=new uX(90,1,t,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new h1(0,0,1)),this.add(a);let h=new uX(90,1,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new h1(0,0,-1)),this.add(h)}update(t,e){null===this.parent&&this.updateMatrixWorld();let i=this.renderTarget,[r,n,s,o,a,h]=this.children,l=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;let c=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,r),t.setRenderTarget(i,1),t.render(e,n),t.setRenderTarget(i,2),t.render(e,s),t.setRenderTarget(i,3),t.render(e,o),t.setRenderTarget(i,4),t.render(e,a),i.texture.generateMipmaps=c,t.setRenderTarget(i,5),t.render(e,h),t.setRenderTarget(u),t.xr.enabled=l}}class uY extends hK{constructor(t,e,i,r,n,s,o,a,h,l){super(t=void 0!==t?t:[],e=void 0!==e?e:301,i,r,n,s,o=void 0!==o?o:1022,a,h,l),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}uY.prototype.isCubeTexture=!0;class uq extends h${constructor(t,e,i){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=i),super(t,t,e),e=e||{},// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
this.texture=new uY(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=1023,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;let i={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new uG(5,5,5),n=new uj({name:"CubemapFromEquirect",uniforms:uk(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});n.uniforms.tEquirect.value=e;let s=new uB(r,n),o=e.minFilter;1008===e.minFilter&&(e.minFilter=1006);let a=new uW(1,10,this);return a.update(t,s),e.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,i,r){let n=t.getRenderTarget();for(let n=0;n<6;n++)t.setRenderTarget(this,n),t.clear(e,i,r);t.setRenderTarget(n)}}uq.prototype.isWebGLCubeRenderTarget=!0;const uK=/*@__PURE__*/new h1,uJ=/*@__PURE__*/new h1,uZ=/*@__PURE__*/new hW;class u${constructor(t=new h1(1,0,0),e=0){// normal is assumed to be normalized
this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,r){return this.normal.set(t,e,i),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){let r=uK.subVectors(i,e).cross(uJ.subVectors(t,e)).normalize();return(// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(r,t),this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
let t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){let i=t.delta(uK),r=this.normal.dot(i);if(0===r)return(// line is coplanar, return origin
0===this.distanceToPoint(t.start)?e.copy(t.start):null);let n=-(t.start.dot(this.normal)+this.constant)/r;return n<0||n>1?null:e.copy(i).multiplyScalar(n).add(t.start)}intersectsLine(t){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
let e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){let i=e||uZ.getNormalMatrix(t),r=this.coplanarPoint(uK).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}u$.prototype.isPlane=!0;const uQ=/*@__PURE__*/new lp,u0=/*@__PURE__*/new h1;class u1{constructor(t=new u$,e=new u$,i=new u$,r=new u$,n=new u$,s=new u$){this.planes=[t,e,i,r,n,s]}set(t,e,i,r,n,s){let o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(r),o[4].copy(n),o[5].copy(s),this}copy(t){let e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){let e=this.planes,i=t.elements,r=i[0],n=i[1],s=i[2],o=i[3],a=i[4],h=i[5],l=i[6],u=i[7],c=i[8],d=i[9],p=i[10],f=i[11],m=i[12],g=i[13],y=i[14],_=i[15];return e[0].setComponents(o-r,u-a,f-c,_-m).normalize(),e[1].setComponents(o+r,u+a,f+c,_+m).normalize(),e[2].setComponents(o+n,u+h,f+d,_+g).normalize(),e[3].setComponents(o-n,u-h,f-d,_-g).normalize(),e[4].setComponents(o-s,u-l,f-p,_-y).normalize(),e[5].setComponents(o+s,u+l,f+p,_+y).normalize(),this}intersectsObject(t){let e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),uQ.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(uQ)}intersectsSprite(t){return uQ.center.set(0,0,0),uQ.radius=.7071067811865476,uQ.applyMatrix4(t.matrixWorld),this.intersectsSphere(uQ)}intersectsSphere(t){let e=this.planes,i=t.center,r=-t.radius;for(let t=0;t<6;t++){let n=e[t].distanceToPoint(i);if(n<r)return!1}return!0}intersectsBox(t){let e=this.planes;for(let i=0;i<6;i++){let r=e[i];if(// corner at max distance
u0.x=r.normal.x>0?t.max.x:t.min.x,u0.y=r.normal.y>0?t.max.y:t.min.y,u0.z=r.normal.z>0?t.max.z:t.min.z,0>r.distanceToPoint(u0))return!1}return!0}containsPoint(t){let e=this.planes;for(let i=0;i<6;i++)if(0>e[i].distanceToPoint(t))return!1;return!0}clone(){return new this.constructor().copy(this)}}function u2(){let t=null,e=!1,i=null,r=null;function n(e,s){i(e,s),r=t.requestAnimationFrame(n)}return{start:function(){!0!==e&&null!==i&&(r=t.requestAnimationFrame(n),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){i=t},setContext:function(e){t=e}}}function u3(t,e){let i=e.isWebGL2,r=new WeakMap;return{get://
function(t){return t.isInterleavedBufferAttribute&&(t=t.data),r.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);let i=r.get(e);i&&(t.deleteBuffer(i.buffer),r.delete(e))},update:function(e,n){if(e.isGLBufferAttribute){let t=r.get(e);(!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version});return}e.isInterleavedBufferAttribute&&(e=e.data);let s=r.get(e);void 0===s?r.set(e,function(e,r){let n=e.array,s=e.usage,o=t.createBuffer();t.bindBuffer(r,o),t.bufferData(r,n,s),e.onUploadCallback();let a=5126;return n instanceof Float32Array?a=5126:n instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):n instanceof Uint16Array?e.isFloat16BufferAttribute?i?a=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):a=5123:n instanceof Int16Array?a=5122:n instanceof Uint32Array?a=5125:n instanceof Int32Array?a=5124:n instanceof Int8Array?a=5120:n instanceof Uint8Array?a=5121:n instanceof Uint8ClampedArray&&(a=5121),{buffer:o,type:a,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version}}(e,n)):s.version<e.version&&(!function(e,r,n){let s=r.array,o=r.updateRange;t.bindBuffer(n,e),-1===o.count?t.bufferSubData(n,0,s):(i?t.bufferSubData(n,o.offset*s.BYTES_PER_ELEMENT,s,o.offset,o.count):t.bufferSubData(n,o.offset*s.BYTES_PER_ELEMENT,s.subarray(o.offset,o.offset+o.count)),o.count=-1)}(s.buffer,e,n),s.version=e.version)}}}class u5 extends uv{constructor(t=1,e=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:r};let n=t/2,s=e/2,o=Math.floor(i),a=Math.floor(r),h=o+1,l=a+1,u=t/o,c=e/a,d=[],p=[],f=[],m=[];for(let t=0;t<l;t++){let e=t*c-s;for(let i=0;i<h;i++){let r=i*u-n;p.push(r,-e,0),f.push(0,0,1),m.push(i/o),m.push(1-t/a)}}for(let t=0;t<a;t++)for(let e=0;e<o;e++){let i=e+h*t,r=e+h*(t+1),n=e+1+h*(t+1),s=e+1+h*t;d.push(i,r,s),d.push(r,n,s)}this.setIndex(d),this.setAttribute("position",new uu(p,3)),this.setAttribute("normal",new uu(f,3)),this.setAttribute("uv",new uu(m,2))}static fromJSON(t){return new u5(t.width,t.height,t.widthSegments,t.heightSegments)}}const u4={alphamap_fragment:"#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n	varying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	#ifdef SPECULAR\n		vec3 specularIntensityFactor = vec3( specularIntensity );\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n	#else\n		vec3 specularIntensityFactor = vec3( 1.0 );\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularColorF90 = vec3( 1.0 );\n	#endif\n	material.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n	material.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n	vec3 specularColorF90;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",map_fragment:"#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n		#ifdef USE_TANGENT\n			vTangent = normalize( transformedTangent );\n			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n		#endif\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"},u6={common:{diffuse:{value:new ur(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new hW},uv2Transform:{value:new hW},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new hX(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ur(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ur(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new hW}},sprite:{diffuse:{value:new ur(16777215)},opacity:{value:1},center:{value:new hX(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new hW}}},u8={basic:{uniforms:uH([u6.common,u6.specularmap,u6.envmap,u6.aomap,u6.lightmap,u6.fog]),vertexShader:u4.meshbasic_vert,fragmentShader:u4.meshbasic_frag},lambert:{uniforms:uH([u6.common,u6.specularmap,u6.envmap,u6.aomap,u6.lightmap,u6.emissivemap,u6.fog,u6.lights,{emissive:{value:new ur(0)}}]),vertexShader:u4.meshlambert_vert,fragmentShader:u4.meshlambert_frag},phong:{uniforms:uH([u6.common,u6.specularmap,u6.envmap,u6.aomap,u6.lightmap,u6.emissivemap,u6.bumpmap,u6.normalmap,u6.displacementmap,u6.fog,u6.lights,{emissive:{value:new ur(0)},specular:{value:new ur(1118481)},shininess:{value:30}}]),vertexShader:u4.meshphong_vert,fragmentShader:u4.meshphong_frag},standard:{uniforms:uH([u6.common,u6.envmap,u6.aomap,u6.lightmap,u6.emissivemap,u6.bumpmap,u6.normalmap,u6.displacementmap,u6.roughnessmap,u6.metalnessmap,u6.fog,u6.lights,{emissive:{value:new ur(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}// temporary
}]),vertexShader:u4.meshphysical_vert,fragmentShader:u4.meshphysical_frag},toon:{uniforms:uH([u6.common,u6.aomap,u6.lightmap,u6.emissivemap,u6.bumpmap,u6.normalmap,u6.displacementmap,u6.gradientmap,u6.fog,u6.lights,{emissive:{value:new ur(0)}}]),vertexShader:u4.meshtoon_vert,fragmentShader:u4.meshtoon_frag},matcap:{uniforms:uH([u6.common,u6.bumpmap,u6.normalmap,u6.displacementmap,u6.fog,{matcap:{value:null}}]),vertexShader:u4.meshmatcap_vert,fragmentShader:u4.meshmatcap_frag},points:{uniforms:uH([u6.points,u6.fog]),vertexShader:u4.points_vert,fragmentShader:u4.points_frag},dashed:{uniforms:uH([u6.common,u6.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:u4.linedashed_vert,fragmentShader:u4.linedashed_frag},depth:{uniforms:uH([u6.common,u6.displacementmap]),vertexShader:u4.depth_vert,fragmentShader:u4.depth_frag},normal:{uniforms:uH([u6.common,u6.bumpmap,u6.normalmap,u6.displacementmap,{opacity:{value:1}}]),vertexShader:u4.normal_vert,fragmentShader:u4.normal_frag},sprite:{uniforms:uH([u6.sprite,u6.fog]),vertexShader:u4.sprite_vert,fragmentShader:u4.sprite_frag},background:{uniforms:{uvTransform:{value:new hW},t2D:{value:null}},vertexShader:u4.background_vert,fragmentShader:u4.background_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */cube:{uniforms:uH([u6.envmap,{opacity:{value:1}}]),vertexShader:u4.cube_vert,fragmentShader:u4.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:u4.equirect_vert,fragmentShader:u4.equirect_frag},distanceRGBA:{uniforms:uH([u6.common,u6.displacementmap,{referencePosition:{value:new h1},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:u4.distanceRGBA_vert,fragmentShader:u4.distanceRGBA_frag},shadow:{uniforms:uH([u6.lights,u6.fog,{color:{value:new ur(0)},opacity:{value:1}}]),vertexShader:u4.shadow_vert,fragmentShader:u4.shadow_frag}};function u7(t,e,i,r,n){let s,o;let a=new ur(0),h=0,l=null,u=0,c=null;function d(t,e){i.buffers.color.setClear(t.r,t.g,t.b,e,n)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),d(a,h=e)},getClearAlpha:function(){return h},setClearAlpha:function(t){d(a,h=t)},render:function(i,n){let p=!1,f=!0===n.isScene?n.background:null;f&&f.isTexture&&(f=e.get(f));// Ignore background in AR
// TODO: Reconsider this.
let m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?d(a,h):f&&f.isColor&&(d(f,1),p=!0),(t.autoClear||p)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||306===f.mapping)?(void 0===o&&((o=new uB(new uG(1,1,1),new uj({name:"BackgroundCubeMaterial",uniforms:uk(u8.cube.uniforms),vertexShader:u8.cube.vertexShader,fragmentShader:u8.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)},// enable code injection for non-built-in material
Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(o)),o.material.uniforms.envMap.value=f,o.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,(l!==f||u!==f.version||c!==t.toneMapping)&&(o.material.needsUpdate=!0,l=f,u=f.version,c=t.toneMapping),// push to the pre-sorted opaque render list
i.unshift(o,o.geometry,o.material,0,0,null)):f&&f.isTexture&&(void 0===s&&((s=new uB(new u5(2,2),new uj({name:"BackgroundMaterial",uniforms:uk(u8.background.uniforms),vertexShader:u8.background.vertexShader,fragmentShader:u8.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),// enable code injection for non-built-in material
Object.defineProperty(s.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(s)),s.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),s.material.uniforms.uvTransform.value.copy(f.matrix),(l!==f||u!==f.version||c!==t.toneMapping)&&(s.material.needsUpdate=!0,l=f,u=f.version,c=t.toneMapping),// push to the pre-sorted opaque render list
i.unshift(s,s.geometry,s.material,0,0,null))}}}function u9(t,e,i,r){let n=t.getParameter(34921),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||null!==s,a={},h=d(null),l=h;function u(e){return r.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function c(e){return r.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function d(t){let e=[],i=[],r=[];for(let t=0;t<n;t++)e[t]=0,i[t]=0,r[t]=0;return{// for backward compatibility on non-VAO support browser
geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:i,attributeDivisors:r,object:t,attributes:{},index:null}}function p(){let t=l.newAttributes;for(let e=0,i=t.length;e<i;e++)t[e]=0}function f(t){m(t,0)}function m(i,n){let s=l.newAttributes,o=l.enabledAttributes,a=l.attributeDivisors;if(s[i]=1,0===o[i]&&(t.enableVertexAttribArray(i),o[i]=1),a[i]!==n){let s=r.isWebGL2?t:e.get("ANGLE_instanced_arrays");s[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](i,n),a[i]=n}}function g(){let e=l.newAttributes,i=l.enabledAttributes;for(let r=0,n=i.length;r<n;r++)i[r]!==e[r]&&(t.disableVertexAttribArray(r),i[r]=0)}function y(e,i,n,s,o,a){!0===r.isWebGL2&&(5124===n||5125===n)?t.vertexAttribIPointer(e,i,n,o,a):t.vertexAttribPointer(e,i,n,s,o,a)}function _(){v(),l!==h&&u((l=h).object)}// for backward-compatilibity
function v(){h.geometry=null,h.program=null,h.wireframe=!1}return{setup:function(n,h,c,_,v){let x=!1;if(o){let e=function(e,i,n){let o=!0===n.wireframe,h=a[e.id];void 0===h&&(h={},a[e.id]=h);let l=h[i.id];void 0===l&&(l={},h[i.id]=l);let u=l[o];return void 0===u&&(u=d(r.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),l[o]=u),u}(_,c,h);l!==e&&u((l=e).object),(x=function(t,e){let i=l.attributes,r=t.attributes,n=0;for(let t in r){let e=i[t],s=r[t];if(void 0===e||e.attribute!==s||e.data!==s.data)return!0;n++}return l.attributesNum!==n||l.index!==e}(_,v))&&function(t,e){let i={},r=t.attributes,n=0;for(let t in r){let e=r[t],s={};s.attribute=e,e.data&&(s.data=e.data),i[t]=s,n++}l.attributes=i,l.attributesNum=n,l.index=e}(_,v)}else{let t=!0===h.wireframe;(l.geometry!==_.id||l.program!==c.id||l.wireframe!==t)&&(l.geometry=_.id,l.program=c.id,l.wireframe=t,x=!0)}!0===n.isInstancedMesh&&(x=!0),null!==v&&i.update(v,34963),x&&(function(n,s,o,a){if(!1===r.isWebGL2&&(n.isInstancedMesh||a.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;p();let h=a.attributes,l=o.getAttributes(),u=s.defaultAttributeValues;for(let e in l){let r=l[e];if(r>=0){let s=h[e];if(void 0!==s){let e=s.normalized,n=s.itemSize,o=i.get(s);// TODO Attribute may not be available on context restore
if(void 0===o)continue;let h=o.buffer,l=o.type,u=o.bytesPerElement;if(s.isInterleavedBufferAttribute){let i=s.data,o=i.stride,c=s.offset;i&&i.isInstancedInterleavedBuffer?(m(r,i.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=i.meshPerAttribute*i.count)):f(r),t.bindBuffer(34962,h),y(r,n,l,e,o*u,c*u)}else s.isInstancedBufferAttribute?(m(r,s.meshPerAttribute),void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)):f(r),t.bindBuffer(34962,h),y(r,n,l,e,0,0)}else if("instanceMatrix"===e){let e=i.get(n.instanceMatrix);// TODO Attribute may not be available on context restore
if(void 0===e)continue;let s=e.buffer,o=e.type;m(r+0,1),m(r+1,1),m(r+2,1),m(r+3,1),t.bindBuffer(34962,s),t.vertexAttribPointer(r+0,4,o,!1,64,0),t.vertexAttribPointer(r+1,4,o,!1,64,16),t.vertexAttribPointer(r+2,4,o,!1,64,32),t.vertexAttribPointer(r+3,4,o,!1,64,48)}else if("instanceColor"===e){let e=i.get(n.instanceColor);// TODO Attribute may not be available on context restore
if(void 0===e)continue;let s=e.buffer,o=e.type;m(r,1),t.bindBuffer(34962,s),t.vertexAttribPointer(r,3,o,!1,12,0)}else if(void 0!==u){let i=u[e];if(void 0!==i)switch(i.length){case 2:t.vertexAttrib2fv(r,i);break;case 3:t.vertexAttrib3fv(r,i);break;case 4:t.vertexAttrib4fv(r,i);break;default:t.vertexAttrib1fv(r,i)}}}}g()}(n,h,c,_),null!==v&&t.bindBuffer(34963,i.get(v).buffer))},reset:_,resetDefaultState:v,dispose:function(){for(let t in _(),a){let e=a[t];for(let t in e){let i=e[t];for(let t in i)c(i[t].object),delete i[t];delete e[t]}delete a[t]}},releaseStatesOfGeometry:function(t){if(void 0===a[t.id])return;let e=a[t.id];for(let t in e){let i=e[t];for(let t in i)c(i[t].object),delete i[t];delete e[t]}delete a[t.id]},releaseStatesOfProgram:function(t){for(let e in a){let i=a[e];if(void 0===i[t.id])continue;let r=i[t.id];for(let t in r)c(r[t].object),delete r[t];delete i[t.id]}},initAttributes:p,enableAttribute:f,disableUnusedAttributes:g}}function ct(t,e,i,r){let n;let s=r.isWebGL2;//
this.setMode=function(t){n=t},this.render=function(e,r){t.drawArrays(n,e,r),i.update(r,n,1)},this.renderInstances=function(r,o,a){let h,l;if(0!==a){if(s)h=t,l="drawArraysInstanced";else if(h=e.get("ANGLE_instanced_arrays"),l="drawArraysInstancedANGLE",null===h){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}h[l](n,r,o,a),i.update(o,n,a)}}}function ce(t,e,i){let r;function n(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}/* eslint-disable no-undef */let s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext,o=void 0!==i.precision?i.precision:"highp",a=n(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);let h=s||e.has("WEBGL_draw_buffers"),l=!0===i.logarithmicDepthBuffer,u=t.getParameter(34930),c=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),f=t.getParameter(34921),m=t.getParameter(36347),g=t.getParameter(36348),y=t.getParameter(36349),_=c>0,v=s||e.has("OES_texture_float"),x=s?t.getParameter(36183):0;return{isWebGL2:s,drawBuffers:h,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){let i=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:n,precision:o,logarithmicDepthBuffer:l,maxTextures:u,maxVertexTextures:c,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:_,floatFragmentTextures:v,floatVertexTextures:_&&v,maxSamples:x}}function ci(t){let e=this,i=null,r=0,n=!1,s=!1,o=new u$,a=new hW,h={value:null,needsUpdate:!1};function l(){h.value!==i&&(h.value=i,h.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(t,i,r,n){let s=null!==t?t.length:0,l=null;if(0!==s){if(l=h.value,!0!==n||null===l){let e=r+4*s,n=i.matrixWorldInverse;a.getNormalMatrix(n),(null===l||l.length<e)&&(l=new Float32Array(e));for(let e=0,i=r;e!==s;++e,i+=4)o.copy(t[e]).applyMatrix4(n,a),o.normal.toArray(l,i),l[i+3]=o.constant}h.value=l,h.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,l}this.uniform=h,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){let o=0!==t.length||e||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
0!==r||n;return n=e,i=u(t,s,0),r=t.length,o},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,l()},this.setState=function(e,o,a){let c=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(n&&null!==c&&0!==c.length&&(!s||p)){let t=s?0:r,e=4*t,n=f.clippingState||null;h.value=n,n=u(c,o,e,a);for(let t=0;t!==e;++t)n[t]=i[t];f.clippingState=n,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}else // there's no local clipping
s?u(null):l()}}function cr(t){let e=new WeakMap;function i(t,e){return 303===e?t.mapping=301:304===e&&(t.mapping=302),t}function r(t){let i=t.target;i.removeEventListener("dispose",r);let n=e.get(i);void 0!==n&&(e.delete(i),n.dispose())}return{get:function(n){if(n&&n.isTexture&&!1===n.isRenderTargetTexture){let s=n.mapping;if(303===s||304===s){if(e.has(n)){let t=e.get(n).texture;return i(t,n.mapping)}{let s=n.image;if(!s||!(s.height>0))return null;{let o=t.getRenderTarget(),a=new uq(s.height/2);return a.fromEquirectangularTexture(t,n),e.set(n,a),t.setRenderTarget(o),n.addEventListener("dispose",r),i(a.texture,n.mapping)}}}}return n},dispose:function(){e=new WeakMap}}}u8.physical={uniforms:uH([u8.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new hX(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new ur(0)},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new hX},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new ur(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new ur(1,1,1)},specularTintMap:{value:null}}]),vertexShader:u4.meshphysical_vert,fragmentShader:u4.meshphysical_frag};class cn extends uV{constructor(t=-1,e=1,i=1,r=-1,n=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=r,this.near=n,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,i,r,n,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=r,this.view.width=n,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2,n=i-t,s=i+t,o=r+e,a=r-e;if(null!==this.view&&this.view.enabled){let t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=t*this.view.offsetX,s=n+t*this.view.width,o-=e*this.view.offsetY,a=o-e*this.view.height}this.projectionMatrix.makeOrthographic(n,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){let e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}cn.prototype.isOrthographicCamera=!0;class cs extends uj{constructor(t){super(t),this.type="RawShaderMaterial"}}cs.prototype.isRawShaderMaterial=!0;// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const co=[.125,.215,.35,.446,.526,.582],ca=5+co.length,ch={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},cl=new un({side:1,depthWrite:!1,depthTest:!1}),cu=new uB(new uG,cl),cc=/*@__PURE__*/new cn,{_lodPlanes:cd,_sizeLods:cp,_sigmas:cf}=/*@__PURE__*/function(){let t=[],e=[],i=[],r=8;for(let n=0;n<ca;n++){let s=Math.pow(2,r);e.push(s);let o=1/s;n>4?o=co[n-8+4-1]:0==n&&(o=0),i.push(o);let a=1/(s-1),h=-a/2,l=1+a/2,u=[h,h,l,h,l,l,h,h,l,l,h,l],c=new Float32Array(108),d=new Float32Array(72),p=new Float32Array(36);for(let t=0;t<6;t++){let e=t%3*2/3-1,i=t>2?0:-1,r=[e,i,0,e+2/3,i,0,e+2/3,i+1,0,e,i,0,e+2/3,i+1,0,e,i+1,0];c.set(r,18*t),d.set(u,12*t);let n=[t,t,t,t,t,t];p.set(n,6*t)}let f=new uv;f.setAttribute("position",new ua(c,3)),f.setAttribute("uv",new ua(d,2)),f.setAttribute("faceIndex",new ua(p,1)),t.push(f),r>4&&r--}return{_lodPlanes:t,_sizeLods:e,_sigmas:i}}(),cm=/*@__PURE__*/new ur;let cg=null;// Golden Ratio
const cy=(1+Math.sqrt(5))/2,c_=1/cy,cv=[/*@__PURE__*/new h1(1,1,1),/*@__PURE__*/new h1(-1,1,1),/*@__PURE__*/new h1(1,1,-1),/*@__PURE__*/new h1(-1,1,-1),/*@__PURE__*/new h1(0,cy,c_),/*@__PURE__*/new h1(0,cy,-c_),/*@__PURE__*/new h1(c_,0,cy),/*@__PURE__*/new h1(-c_,0,cy),/*@__PURE__*/new h1(cy,c_,0),/*@__PURE__*/new h1(-cy,c_,0)];/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/function cx(t){let e=Math.max(t.r,t.g,t.b),i=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return t.multiplyScalar(Math.pow(2,-i)),(i+128)/255}class cb{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=function(t){let e=new Float32Array(t),i=new h1(0,1,0),r=new cs({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i},inputEncoding:{value:ch[3e3]},outputEncoding:{value:ch[3e3]}},vertexShader:cM(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${cA()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return r}(20),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */fromScene(t,e=0,i=.1,r=100){cg=this._renderer.getRenderTarget();let n=this._allocateTargets();return this._sceneToCubeUV(t,i,r,n),e>0&&this._blur(n,0,0,e),this._applyPMREM(n),this._cleanup(n),n}/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromEquirectangular(t){return this._fromTexture(t)}/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromCubemap(t){return this._fromTexture(t)}/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=cS(),this._compileMaterial(this._cubemapShader))}/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=cw(),this._compileMaterial(this._equirectShader))}/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let t=0;t<cd.length;t++)cd[t].dispose()}// private interface
_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(cg),t.scissorTest=!1,cT(t,0,0,t.width,t.height)}_fromTexture(t){cg=this._renderer.getRenderTarget();let e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){let e={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:void 0!==t&&1009===t.type&&(3e3===t.encoding||3001===t.encoding||3007===t.encoding)?t.encoding:3002,depthBuffer:!1},i=cE(e);return i.depthBuffer=!t,this._pingPongRenderTarget=cE(e),i}_compileMaterial(t){let e=new uB(cd[0],t);this._renderer.compile(e,cc)}_sceneToCubeUV(t,e,i,r){let n=new uX(90,1,e,i),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,h=a.autoClear,l=a.outputEncoding,u=a.toneMapping;a.getClearColor(cm),a.toneMapping=0,a.outputEncoding=3e3,a.autoClear=!1;let c=!1,d=t.background;if(d){if(d.isColor){cl.color.copy(d).convertSRGBToLinear(),t.background=null;let e=cx(cl.color);cl.opacity=e,c=!0}}else{cl.color.copy(cm).convertSRGBToLinear();let t=cx(cl.color);cl.opacity=t,c=!0}for(let e=0;e<6;e++){let i=e%3;0==i?(n.up.set(0,s[e],0),n.lookAt(o[e],0,0)):1==i?(n.up.set(0,0,s[e]),n.lookAt(0,o[e],0)):(n.up.set(0,s[e],0),n.lookAt(0,0,o[e])),cT(r,256*i,e>2?256:0,256,256),a.setRenderTarget(r),c&&a.render(cu,n),a.render(t,n)}a.toneMapping=u,a.outputEncoding=l,a.autoClear=h}_textureToCubeUV(t,e){let i=this._renderer;t.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=cS()):null==this._equirectShader&&(this._equirectShader=cw());let r=t.isCubeTexture?this._cubemapShader:this._equirectShader,n=new uB(cd[0],r),s=r.uniforms;s.envMap.value=t,t.isCubeTexture||s.texelSize.value.set(1/t.image.width,1/t.image.height),s.inputEncoding.value=ch[t.encoding],s.outputEncoding.value=ch[e.texture.encoding],cT(e,0,0,768,512),i.setRenderTarget(e),i.render(n,cc)}_applyPMREM(t){let e=this._renderer,i=e.autoClear;e.autoClear=!1;for(let e=1;e<ca;e++){let i=Math.sqrt(cf[e]*cf[e]-cf[e-1]*cf[e-1]),r=cv[(e-1)%cv.length];this._blur(t,e-1,e,i,r)}e.autoClear=i}/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */_blur(t,e,i,r,n){let s=this._pingPongRenderTarget;this._halfBlur(t,s,e,i,r,"latitudinal",n),this._halfBlur(s,t,i,i,r,"longitudinal",n)}_halfBlur(t,e,i,r,n,s,o){let a=this._renderer,h=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");let l=new uB(cd[r],h),u=h.uniforms,c=cp[i]-1,d=isFinite(n)?Math.PI/(2*c):2*Math.PI/39,p=n/d,f=isFinite(n)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);let m=[],g=0;for(let t=0;t<20;++t){let e=t/p,i=Math.exp(-e*e/2);m.push(i),0==t?g+=i:t<f&&(g+=2*i)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===s,o&&(u.poleAxis.value=o),u.dTheta.value=d,u.mipInt.value=8-i,u.inputEncoding.value=ch[t.texture.encoding],u.outputEncoding.value=ch[t.texture.encoding];let y=cp[r],_=3*Math.max(0,256-2*y),v=(0===r?0:512)+2*y*(r>4?r-8+4:0);cT(e,_,v,3*y,2*y),a.setRenderTarget(e),a.render(l,cc)}}function cE(t){let e=new h$(768,768,t);return e.texture.mapping=306,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function cT(t,e,i,r,n){t.viewport.set(e,i,r,n),t.scissor.set(e,i,r,n)}function cw(){let t=new hX(1,1),e=new cs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:t},inputEncoding:{value:ch[3e3]},outputEncoding:{value:ch[3e3]}},vertexShader:cM(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${cA()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return e}function cS(){let t=new cs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:ch[3e3]},outputEncoding:{value:ch[3e3]}},vertexShader:cM(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${cA()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return t}function cM(){return/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function cA(){return/* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function cR(t){let e=new WeakMap,i=null;function r(t){let i=t.target;i.removeEventListener("dispose",r);let n=e.get(i);void 0!==n&&(n.delete(i),n.dispose())}return{get:function(n){if(n&&n.isTexture&&!1===n.isRenderTargetTexture){let s=n.mapping,o=303===s||304===s,a=301===s||302===s;if(o||a){// equirect/cube map to cubeUV conversion
if(e.has(n))return e.get(n).texture;{let s=n.image;if(!(o&&s&&s.height>0||a&&s&&function(t){let e=0;for(let i=0;i<6;i++)void 0!==t[i]&&e++;return 6===e}(s)))return null;{let s=t.getRenderTarget();null===i&&(i=new cb(t));let a=o?i.fromEquirectangular(n):i.fromCubemap(n);return e.set(n,a),t.setRenderTarget(s),n.addEventListener("dispose",r),a.texture}}}}return n},dispose:function(){e=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function cC(t){let e={};function i(i){let r;if(void 0!==e[i])return e[i];switch(i){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(i)}return e[i]=r,r}return{has:function(t){return null!==i(t)},init:function(t){t.isWebGL2?i("EXT_color_buffer_float"):(i("WEBGL_depth_texture"),i("OES_texture_float"),i("OES_texture_half_float"),i("OES_texture_half_float_linear"),i("OES_standard_derivatives"),i("OES_element_index_uint"),i("OES_vertex_array_object"),i("ANGLE_instanced_arrays")),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float")},get:function(t){let e=i(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function cP(t,e,i,r){let n={},s=new WeakMap;function o(t){let a=t.target;for(let t in null!==a.index&&e.remove(a.index),a.attributes)e.remove(a.attributes[t]);a.removeEventListener("dispose",o),delete n[a.id];let h=s.get(a);h&&(e.remove(h),s.delete(a)),r.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,//
i.memory.geometries--}function a(t){let i=[],r=t.index,n=t.attributes.position,o=0;if(null!==r){let t=r.array;o=r.version;for(let e=0,r=t.length;e<r;e+=3){let r=t[e+0],n=t[e+1],s=t[e+2];i.push(r,n,n,s,s,r)}}else{let t=n.array;o=n.version;for(let e=0,r=t.length/3-1;e<r;e+=3){let t=e+0,r=e+1,n=e+2;i.push(t,r,r,n,n,t)}}let a=new(uc(i)>65535?ul:uh)(i,1);a.version=o;// Updating index buffer in VAO now. See WebGLBindingStates
//
let h=s.get(t);h&&e.remove(h),//
s.set(t,a)}return{get:function(t,e){return!0===n[e.id]||(e.addEventListener("dispose",o),n[e.id]=!0,i.memory.geometries++),e},update:function(t){let i=t.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
for(let t in i)e.update(i[t],34962);// morph targets
let r=t.morphAttributes;for(let t in r){let i=r[t];for(let t=0,r=i.length;t<r;t++)e.update(i[t],34962)}},getWireframeAttribute:function(t){let e=s.get(t);if(e){let i=t.index;null!==i&&e.version<i.version&&a(t)}else a(t);return s.get(t)}}}function cI(t,e,i,r){let n,s,o;let a=r.isWebGL2;//
this.setMode=function(t){n=t},this.setIndex=function(t){s=t.type,o=t.bytesPerElement},this.render=function(e,r){t.drawElements(n,r,s,e*o),i.update(r,n,1)},this.renderInstances=function(r,h,l){let u,c;if(0!==l){if(a)u=t,c="drawElementsInstanced";else if(u=e.get("ANGLE_instanced_arrays"),c="drawElementsInstancedANGLE",null===u){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}u[c](n,h,s,r*o,l),i.update(h,n,l)}}}function cO(t){let e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,i,r){switch(e.calls++,i){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function cL(t,e){return t[0]-e[0]}function cN(t,e){return Math.abs(e[1])-Math.abs(t[1])}function cD(t){let e={},i=new Float32Array(8),r=[];for(let t=0;t<8;t++)r[t]=[t,0];return{update:function(n,s,o,a){let h=n.morphTargetInfluences,l=void 0===h?0:h.length,u=e[s.id];if(void 0===u||u.length!==l){// initialise list
u=[];for(let t=0;t<l;t++)u[t]=[t,0];e[s.id]=u}// Collect influences
for(let t=0;t<l;t++){let e=u[t];e[0]=t,e[1]=h[t]}u.sort(cN);for(let t=0;t<8;t++)t<l&&u[t][1]?(r[t][0]=u[t][0],r[t][1]=u[t][1]):(r[t][0]=Number.MAX_SAFE_INTEGER,r[t][1]=0);r.sort(cL);let c=s.morphAttributes.position,d=s.morphAttributes.normal,p=0;for(let t=0;t<8;t++){let e=r[t],n=e[0],o=e[1];n!==Number.MAX_SAFE_INTEGER&&o?(c&&s.getAttribute("morphTarget"+t)!==c[n]&&s.setAttribute("morphTarget"+t,c[n]),d&&s.getAttribute("morphNormal"+t)!==d[n]&&s.setAttribute("morphNormal"+t,d[n]),i[t]=o,p+=o):(c&&!0===s.hasAttribute("morphTarget"+t)&&s.deleteAttribute("morphTarget"+t),d&&!0===s.hasAttribute("morphNormal"+t)&&s.deleteAttribute("morphNormal"+t),i[t]=0)}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
// This allows us to switch between absolute morphs and relative morphs without changing shader code
// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
let f=s.morphTargetsRelative?1:1-p;a.getUniforms().setValue(t,"morphTargetBaseInfluence",f),a.getUniforms().setValue(t,"morphTargetInfluences",i)}}}function cF(t,e,i,r){let n=new WeakMap;function s(t){let e=t.target;e.removeEventListener("dispose",s),i.remove(e.instanceMatrix),null!==e.instanceColor&&i.remove(e.instanceColor)}return{update:function(t){let o=r.render.frame,a=t.geometry,h=e.get(t,a);return n.get(h)!==o&&(e.update(h),n.set(h,o)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),i.update(t.instanceMatrix,34962),null!==t.instanceColor&&i.update(t.instanceColor,34962)),h},dispose:function(){n=new WeakMap}}}class cB extends hK{constructor(t=null,e=1,i=1,r=1){super(null),this.image={data:t,width:e,height:i,depth:r},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}cB.prototype.isDataTexture2DArray=!0;class cU extends hK{constructor(t=null,e=1,i=1,r=1){// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	const texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839
super(null),this.image={data:t,width:e,height:i,depth:r},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}cU.prototype.isDataTexture3D=!0;/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */const cG=new hK,ck=new cB,cH=new cU,cz=new uY,cj=[],cV=[],cX=new Float32Array(16),cW=new Float32Array(9),cY=new Float32Array(4);// Flattening for arrays of vectors and matrices
function cq(t,e,i){let r=t[0];if(r<=0||r>0)return t;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
let n=e*i,s=cj[n];if(void 0===s&&(s=new Float32Array(n),cj[n]=s),0!==e){r.toArray(s,0);for(let r=1,n=0;r!==e;++r)n+=i,t[r].toArray(s,n)}return s}function cK(t,e){if(t.length!==e.length)return!1;for(let i=0,r=t.length;i<r;i++)if(t[i]!==e[i])return!1;return!0}function cJ(t,e){for(let i=0,r=e.length;i<r;i++)t[i]=e[i]}// Texture unit allocation
function cZ(t,e){let i=cV[e];void 0===i&&(i=new Int32Array(e),cV[e]=i);for(let r=0;r!==e;++r)i[r]=t.allocateTextureUnit();return i}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function c$(t,e){let i=this.cache;i[0]!==e&&(t.uniform1f(this.addr,e),i[0]=e)}// Single float vector (from flat array or THREE.VectorN)
function cQ(t,e){let i=this.cache;if(void 0!==e.x)(i[0]!==e.x||i[1]!==e.y)&&(t.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(cK(i,e))return;t.uniform2fv(this.addr,e),cJ(i,e)}}function c0(t,e){let i=this.cache;if(void 0!==e.x)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z)&&(t.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(void 0!==e.r)(i[0]!==e.r||i[1]!==e.g||i[2]!==e.b)&&(t.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(cK(i,e))return;t.uniform3fv(this.addr,e),cJ(i,e)}}function c1(t,e){let i=this.cache;if(void 0!==e.x)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z||i[3]!==e.w)&&(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(cK(i,e))return;t.uniform4fv(this.addr,e),cJ(i,e)}}// Single matrix (from flat array or THREE.MatrixN)
function c2(t,e){let i=this.cache,r=e.elements;if(void 0===r){if(cK(i,e))return;t.uniformMatrix2fv(this.addr,!1,e),cJ(i,e)}else{if(cK(i,r))return;cY.set(r),t.uniformMatrix2fv(this.addr,!1,cY),cJ(i,r)}}function c3(t,e){let i=this.cache,r=e.elements;if(void 0===r){if(cK(i,e))return;t.uniformMatrix3fv(this.addr,!1,e),cJ(i,e)}else{if(cK(i,r))return;cW.set(r),t.uniformMatrix3fv(this.addr,!1,cW),cJ(i,r)}}function c5(t,e){let i=this.cache,r=e.elements;if(void 0===r){if(cK(i,e))return;t.uniformMatrix4fv(this.addr,!1,e),cJ(i,e)}else{if(cK(i,r))return;cX.set(r),t.uniformMatrix4fv(this.addr,!1,cX),cJ(i,r)}}// Single integer / boolean
function c4(t,e){let i=this.cache;i[0]!==e&&(t.uniform1i(this.addr,e),i[0]=e)}// Single integer / boolean vector (from flat array)
function c6(t,e){let i=this.cache;cK(i,e)||(t.uniform2iv(this.addr,e),cJ(i,e))}function c8(t,e){let i=this.cache;cK(i,e)||(t.uniform3iv(this.addr,e),cJ(i,e))}function c7(t,e){let i=this.cache;cK(i,e)||(t.uniform4iv(this.addr,e),cJ(i,e))}// Single unsigned integer
function c9(t,e){let i=this.cache;i[0]!==e&&(t.uniform1ui(this.addr,e),i[0]=e)}// Single unsigned integer vector (from flat array)
function dt(t,e){let i=this.cache;cK(i,e)||(t.uniform2uiv(this.addr,e),cJ(i,e))}function de(t,e){let i=this.cache;cK(i,e)||(t.uniform3uiv(this.addr,e),cJ(i,e))}function di(t,e){let i=this.cache;cK(i,e)||(t.uniform4uiv(this.addr,e),cJ(i,e))}// Single texture (2D / Cube)
function dr(t,e,i){let r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(t.uniform1i(this.addr,n),r[0]=n),i.safeSetTexture2D(e||cG,n)}function dn(t,e,i){let r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(t.uniform1i(this.addr,n),r[0]=n),i.setTexture3D(e||cH,n)}function ds(t,e,i){let r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(t.uniform1i(this.addr,n),r[0]=n),i.safeSetTextureCube(e||cz,n)}function da(t,e,i){let r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(t.uniform1i(this.addr,n),r[0]=n),i.setTexture2DArray(e||ck,n)}// Array of scalars
function dh(t,e){t.uniform1fv(this.addr,e)}// Array of vectors (from flat array or array of THREE.VectorN)
function dl(t,e){let i=cq(e,this.size,2);t.uniform2fv(this.addr,i)}function du(t,e){let i=cq(e,this.size,3);t.uniform3fv(this.addr,i)}function dc(t,e){let i=cq(e,this.size,4);t.uniform4fv(this.addr,i)}// Array of matrices (from flat array or array of THREE.MatrixN)
function dd(t,e){let i=cq(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,i)}function dp(t,e){let i=cq(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,i)}function df(t,e){let i=cq(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,i)}// Array of integer / boolean
function dm(t,e){t.uniform1iv(this.addr,e)}// Array of integer / boolean vectors (from flat array)
function dg(t,e){t.uniform2iv(this.addr,e)}function dy(t,e){t.uniform3iv(this.addr,e)}function d_(t,e){t.uniform4iv(this.addr,e)}// Array of unsigned integer
function dv(t,e){t.uniform1uiv(this.addr,e)}// Array of unsigned integer vectors (from flat array)
function dx(t,e){t.uniform2uiv(this.addr,e)}function db(t,e){t.uniform3uiv(this.addr,e)}function dE(t,e){t.uniform4uiv(this.addr,e)}// Array of textures (2D / Cube)
function dT(t,e,i){let r=e.length,n=cZ(i,r);t.uniform1iv(this.addr,n);for(let t=0;t!==r;++t)i.safeSetTexture2D(e[t]||cG,n[t])}function dw(t,e,i){let r=e.length,n=cZ(i,r);t.uniform1iv(this.addr,n);for(let t=0;t!==r;++t)i.safeSetTextureCube(e[t]||cz,n[t])}// --- Uniform Classes ---
function dS(t,e,i){this.id=t,this.addr=i,this.cache=[],this.setValue=// Helper to pick the right setter for the singular case
function(t){switch(t){case 5126:return c$;// FLOAT
case 35664:return cQ;// _VEC2
case 35665:return c0;// _VEC3
case 35666:return c1;// _VEC4
case 35674:return c2;// _MAT2
case 35675:return c3;// _MAT3
case 35676:return c5;// _MAT4
case 5124:case 35670:return c4;// INT, BOOL
case 35667:case 35671:return c6;// _VEC2
case 35668:case 35672:return c8;// _VEC3
case 35669:case 35673:return c7;// _VEC4
case 5125:return c9;// UINT
case 36294:return dt;// _VEC2
case 36295:return de;// _VEC3
case 36296:return di;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return dr;case 35679:case 36299:case 36307:return dn;case 35680:case 36300:case 36308:case 36293:return ds;case 36289:case 36303:case 36311:case 36292:return da}}(e.type);// this.path = activeInfo.name; // DEBUG
}function dM(t,e,i){this.id=t,this.addr=i,this.cache=[],this.size=e.size,this.setValue=// Helper to pick the right setter for a pure (bottom-level) array
function(t){switch(t){case 5126:return dh;// FLOAT
case 35664:return dl;// _VEC2
case 35665:return du;// _VEC3
case 35666:return dc;// _VEC4
case 35674:return dd;// _MAT2
case 35675:return dp;// _MAT3
case 35676:return df;// _MAT4
case 5124:case 35670:return dm;// INT, BOOL
case 35667:case 35671:return dg;// _VEC2
case 35668:case 35672:return dy;// _VEC3
case 35669:case 35673:return d_;// _VEC4
case 5125:return dv;// UINT
case 36294:return dx;// _VEC2
case 36295:return db;// _VEC3
case 36296:return dE;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return dT;case 35680:case 36300:case 36308:case 36293:return dw}}(e.type);// this.path = activeInfo.name; // DEBUG
}function dA(t){this.id=t,this.seq=[],this.map={}}dM.prototype.updateCache=function(t){let e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),cJ(e,t)},dA.prototype.setValue=function(t,e,i){let r=this.seq;for(let n=0,s=r.length;n!==s;++n){let s=r[n];s.setValue(t,e[s.id],i)}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
const dR=/(\w+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function dC(t,e){t.seq.push(e),t.map[e.id]=e}// Root Container
function dP(t,e){this.seq=[],this.map={};let i=t.getProgramParameter(e,35718);for(let r=0;r<i;++r){let i=t.getActiveUniform(e,r),n=t.getUniformLocation(e,i.name);!function(t,e,i){let r=t.name,n=r.length;for(// reset RegExp object, because of the early exit of a previous run
dR.lastIndex=0;;){let s=dR.exec(r),o=dR.lastIndex,a=s[1],h="]"===s[2],l=s[3];if(h&&(a|=0),void 0===l||"["===l&&o+2===n){// bare name or "pure" bottom-level array "[0]" suffix
dC(i,void 0===l?new dS(a,t,e):new dM(a,t,e));break}{// step into inner node / create it in case it doesn't exist
let t=i.map,e=t[a];void 0===e&&dC(i,e=new dA(a)),i=e}}}(i,n,this)}}function dI(t,e,i){let r=t.createShader(e);return t.shaderSource(r,i),t.compileShader(r),r}dP.prototype.setValue=function(t,e,i,r){let n=this.map[e];void 0!==n&&n.setValue(t,i,r)},dP.prototype.setOptional=function(t,e,i){let r=e[i];void 0!==r&&this.setValue(t,i,r)},// Static interface
dP.upload=function(t,e,i,r){for(let n=0,s=e.length;n!==s;++n){let s=e[n],o=i[s.id];!1!==o.needsUpdate&&s.setValue(t,o.value,r)}},dP.seqWithValue=function(t,e){let i=[];for(let r=0,n=t.length;r!==n;++r){let n=t[r];n.id in e&&i.push(n)}return i};let dO=0;function dL(t){switch(t){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}function dN(t,e,i){let r=t.getShaderParameter(e,35713),n=t.getShaderInfoLog(e).trim();if(r&&""===n)return"";// --enable-privileged-webgl-extension
// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
let s=t.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+i+"\n"+n+function(t){let e=t.split("\n");for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join("\n")}(s)}function dD(t,e){let i=dL(e);return"vec4 "+t+"( vec4 value ) { return "+i[0]+"ToLinear"+i[1]+"; }"}function dF(t){return""!==t}function dB(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function dU(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}// Resolve Includes
const dG=/^[ \t]*#include +<([\w\d./]+)>/gm;function dk(t){return t.replace(dG,dH)}function dH(t,e){let i=u4[e];if(void 0===i)throw Error("Can not resolve #include <"+e+">");return dk(i)}// Unroll Loops
const dz=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,dj=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function dV(t){return t.replace(dj,dW).replace(dz,dX)}function dX(t,e,i,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),dW(t,e,i,r)}function dW(t,e,i,r){let n="";for(let t=parseInt(e);t<parseInt(i);t++)n+=r.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return n}//
function dY(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function dq(t,e,i,r){let n,s,o,a,h;let l=t.getContext(),u=i.defines,c=i.vertexShader,d=i.fragmentShader,p=(h="SHADOWMAP_TYPE_BASIC",1===i.shadowMapType?h="SHADOWMAP_TYPE_PCF":2===i.shadowMapType?h="SHADOWMAP_TYPE_PCF_SOFT":3===i.shadowMapType&&(h="SHADOWMAP_TYPE_VSM"),h),f=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case 301:case 302:e="ENVMAP_TYPE_CUBE";break;case 306:case 307:e="ENVMAP_TYPE_CUBE_UV"}return e}(i),m=function(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case 302:case 307:e="ENVMAP_MODE_REFRACTION"}return e}(i),g=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(i),y=t.gammaFactor>0?t.gammaFactor:1,_=i.isWebGL2?"":function(t){let e=[t.extensionDerivatives||t.envMapCubeUV||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission>0)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return e.filter(dF).join("\n")}(i),v=function(t){let e=[];for(let i in t){let r=t[i];!1!==r&&e.push("#define "+i+" "+r)}return e.join("\n")}(u),x=l.createProgram(),b=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?((n=[v].filter(dF).join("\n")).length>0&&(n+="\n"),(s=[_,v].filter(dF).join("\n")).length>0&&(s+="\n")):(n=[dY(i),"#define SHADER_NAME "+i.shaderName,v,i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+y,"#define MAX_BONES "+i.maxBones,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+m:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.displacementMap&&i.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularTintMap?"#define USE_SPECULARTINTMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.useVertexTexture?"#define BONE_TEXTURE":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+p:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif","\n"].filter(dF).join("\n"),s=[_,dY(i),"#define SHADER_NAME "+i.shaderName,v,i.alphaTest?"#define ALPHATEST "+i.alphaTest+(i.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+y,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+f:"",i.envMap?"#define "+m:"",i.envMap?"#define "+g:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularTintMap?"#define USE_SPECULARTINTMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.sheen?"#define USE_SHEEN":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+p:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(i.extensionShaderTextureLOD||i.envMap)&&i.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==i.toneMapping?"#define TONE_MAPPING":"",0!==i.toneMapping?u4.tonemapping_pars_fragment:"",0!==i.toneMapping?function(t,e){let i;switch(e){case 1:i="Linear";break;case 2:i="Reinhard";break;case 3:i="OptimizedCineon";break;case 4:i="ACESFilmic";break;case 5:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),i="Linear"}return"vec3 "+t+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",u4.encodings_pars_fragment,i.map?dD("mapTexelToLinear",i.mapEncoding):"",i.matcap?dD("matcapTexelToLinear",i.matcapEncoding):"",i.envMap?dD("envMapTexelToLinear",i.envMapEncoding):"",i.emissiveMap?dD("emissiveMapTexelToLinear",i.emissiveMapEncoding):"",i.specularTintMap?dD("specularTintMapTexelToLinear",i.specularTintMapEncoding):"",i.lightMap?dD("lightMapTexelToLinear",i.lightMapEncoding):"",function(t,e){let i=dL(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+i[0]+i[1]+"; }"}("linearToOutputTexel",i.outputEncoding),i.depthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter(dF).join("\n")),c=dU(c=dB(c=dk(c),i),i),d=dU(d=dB(d=dk(d),i),i),c=dV(c),d=dV(d),i.isWebGL2&&!0!==i.isRawShaderMaterial&&(// GLSL 3.0 conversion for built-in materials and ShaderMaterial
b="#version 300 es\n",n="#define attribute in\n#define varying out\n#define texture2D texture\n"+n,s=["#define varying in",i.glslVersion===hF?"":"out highp vec4 pc_fragColor;",i.glslVersion===hF?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+s);let E=b+n+c,T=b+s+d,w=dI(l,35633,E),S=dI(l,35632,T);// check for link errors
if(l.attachShader(x,w),l.attachShader(x,S),void 0!==i.index0AttributeName?l.bindAttribLocation(x,0,i.index0AttributeName):!0===i.morphTargets&&l.bindAttribLocation(x,0,"position"),l.linkProgram(x),t.debug.checkShaderErrors){let t=l.getProgramInfoLog(x).trim(),e=l.getShaderInfoLog(w).trim(),i=l.getShaderInfoLog(S).trim(),r=!0,o=!0;if(!1===l.getProgramParameter(x,35714)){r=!1;let e=dN(l,w,"vertex"),i=dN(l,S,"fragment");console.error("THREE.WebGLProgram: shader error: ",l.getError(),"35715",l.getProgramParameter(x,35715),"gl.getProgramInfoLog",t,e,i)}else""!==t?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",t):(""===e||""===i)&&(o=!1);o&&(this.diagnostics={runnable:r,programLog:t,vertexShader:{log:e,prefix:n},fragmentShader:{log:i,prefix:s}})}return(// Clean up
// Crashes in iOS9 and iOS10. #18402
// gl.detachShader( program, glVertexShader );
// gl.detachShader( program, glFragmentShader );
l.deleteShader(w),l.deleteShader(S),this.getUniforms=function(){return void 0===o&&(o=new dP(l,x)),o},this.getAttributes=function(){return void 0===a&&(a=function(t,e){let i={},r=t.getProgramParameter(e,35721);for(let n=0;n<r;n++){let r=t.getActiveAttrib(e,n),s=r.name;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
i[s]=t.getAttribLocation(e,s)}return i}(l,x)),a},// free resource
this.destroy=function(){r.releaseStatesOfProgram(this),l.deleteProgram(x),this.program=void 0},//
this.name=i.shaderName,this.id=dO++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=w,this.fragmentShader=S,this)}function dK(t,e,i,r,n,s,o){let a=[],h=n.isWebGL2,l=n.logarithmicDepthBuffer,u=n.floatVertexTextures,c=n.maxVertexUniforms,d=n.vertexTextures,p=n.precision,f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmission","transmissionMap","thicknessMap"];function g(t){let e;return t&&t.isTexture?e=t.encoding:t&&t.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),e=t.texture.encoding):e=3e3,e}return{getParameters:function(s,a,m,y,_){let v,x;let b=y.fog,E=s.isMeshStandardMaterial?y.environment:null,T=(s.isMeshStandardMaterial?i:e).get(s.envMap||E),w=f[s.type],S=_.isSkinnedMesh?function(t){let e=t.skeleton,i=e.bones;if(u)return 1024;{let t=Math.floor((c-20)/4),e=Math.min(t,i.length);return e<i.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+i.length+" bones. This GPU supports "+e+"."),0):e}}(_):0;if(null!==s.precision&&(p=n.getMaxPrecision(s.precision))!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."),w){let t=u8[w];v=t.vertexShader,x=t.fragmentShader}else v=s.vertexShader,x=s.fragmentShader;let M=t.getRenderTarget(),A={isWebGL2:h,shaderID:w,shaderName:s.type,vertexShader:v,fragmentShader:x,defines:s.defines,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===_.isInstancedMesh,instancingColor:!0===_.isInstancedMesh&&null!==_.instanceColor,supportsVertexTextures:d,outputEncoding:null!==M?g(M.texture):t.outputEncoding,map:!!s.map,mapEncoding:g(s.map),matcap:!!s.matcap,matcapEncoding:g(s.matcap),envMap:!!T,envMapMode:T&&T.mapping,envMapEncoding:g(T),envMapCubeUV:!!T&&(306===T.mapping||307===T.mapping),lightMap:!!s.lightMap,lightMapEncoding:g(s.lightMap),aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,emissiveMapEncoding:g(s.emissiveMap),bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,clearcoatMap:!!s.clearcoatMap,clearcoatRoughnessMap:!!s.clearcoatRoughnessMap,clearcoatNormalMap:!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularTintMap:!!s.specularTintMap,specularTintMapEncoding:g(s.specularTintMap),alphaMap:!!s.alphaMap,gradientMap:!!s.gradientMap,sheen:!!s.sheen,transmission:!!s.transmission,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!_.geometry&&!!_.geometry.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!_.geometry&&!!_.geometry.attributes.color&&4===_.geometry.attributes.color.itemSize,vertexUvs:!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatMap||!!s.clearcoatRoughnessMap||!!s.clearcoatNormalMap||!!s.displacementMap||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularTintMap,uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularTintMap)&&!!s.displacementMap,fog:!!b,useFog:s.fog,fogExp2:b&&b.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:l,skinning:!0===_.isSkinnedMesh&&S>0,maxBones:S,useVertexTexture:u,morphTargets:!!_.geometry&&!!_.geometry.morphAttributes.position,morphNormals:!!_.geometry&&!!_.geometry.morphAttributes.normal,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&m.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,alphaTest:s.alphaTest,doubleSided:2===s.side,flipSided:1===s.side,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()};return A},getProgramCacheKey:function(e){let i=[];if(e.shaderID?i.push(e.shaderID):(i.push(e.fragmentShader),i.push(e.vertexShader)),void 0!==e.defines)for(let t in e.defines)i.push(t),i.push(e.defines[t]);if(!1===e.isRawShaderMaterial){for(let t=0;t<m.length;t++)i.push(e[m[t]]);i.push(t.outputEncoding),i.push(t.gammaFactor)}return i.push(e.customProgramCacheKey),i.join()},getUniforms:function(t){let e;let i=f[t.type];if(i){let t=u8[i];e=uz.clone(t.uniforms)}else e=t.uniforms;return e},acquireProgram:function(e,i){let r;// Check if code has been already compiled
for(let t=0,e=a.length;t<e;t++){let e=a[t];if(e.cacheKey===i){r=e,++r.usedTimes;break}}return void 0===r&&(r=new dq(t,i,e,s),a.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){// Remove from unordered set
let e=a.indexOf(t);a[e]=a[a.length-1],a.pop(),// Free WebGL resources
t.destroy()}},// Exposed for resource monitoring & error feedback via renderer.info:
programs:a}}function dJ(){let t=new WeakMap;return{get:function(e){let i=t.get(e);return void 0===i&&(i={},t.set(e,i)),i},remove:function(e){t.delete(e)},update:function(e,i,r){t.get(e)[i]=r},dispose:function(){t=new WeakMap}}}function dZ(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function d$(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function dQ(t){let e=[],i=0,r=[],n=[],s=[],o={id:-1};function a(r,n,s,a,h,l){let u=e[i],c=t.get(s);return void 0===u?(u={id:r.id,object:r,geometry:n,material:s,program:c.program||o,groupOrder:a,renderOrder:r.renderOrder,z:h,group:l},e[i]=u):(u.id=r.id,u.object=r,u.geometry=n,u.material=s,u.program=c.program||o,u.groupOrder=a,u.renderOrder=r.renderOrder,u.z=h,u.group=l),i++,u}return{opaque:r,transmissive:n,transparent:s,init:function(){i=0,r.length=0,n.length=0,s.length=0},push:function(t,e,i,o,h,l){let u=a(t,e,i,o,h,l);i.transmission>0?n.push(u):!0===i.transparent?s.push(u):r.push(u)},unshift:function(t,e,i,o,h,l){let u=a(t,e,i,o,h,l);i.transmission>0?n.unshift(u):!0===i.transparent?s.unshift(u):r.unshift(u)},finish:function(){// Clear references from inactive renderItems in the list
for(let t=i,r=e.length;t<r;t++){let i=e[t];if(null===i.id)break;i.id=null,i.object=null,i.geometry=null,i.material=null,i.program=null,i.group=null}},sort:function(t,e){r.length>1&&r.sort(t||dZ),n.length>1&&n.sort(e||d$),s.length>1&&s.sort(e||d$)}}}function d0(t){let e=new WeakMap;return{get:function(i,r){let n;return!1===e.has(i)?(n=new dQ(t),e.set(i,[n])):r>=e.get(i).length?(n=new dQ(t),e.get(i).push(n)):n=e.get(i)[r],n},dispose:function(){e=new WeakMap}}}function d1(){let t={};return{get:function(e){let i;if(void 0!==t[e.id])return t[e.id];switch(e.type){case"DirectionalLight":i={direction:new h1,color:new ur};break;case"SpotLight":i={position:new h1,direction:new h1,color:new ur,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new h1,color:new ur,distance:0,decay:0};break;case"HemisphereLight":i={direction:new h1,skyColor:new ur,groundColor:new ur};break;case"RectAreaLight":i={color:new ur,position:new h1,halfWidth:new h1,halfHeight:new h1}}return t[e.id]=i,i}}}let d2=0;function d3(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function d5(t,e){let i=new d1,r=function(){let t={};return{get:function(e){let i;if(void 0!==t[e.id])return t[e.id];switch(e.type){case"DirectionalLight":case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new hX};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new hX,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=i,i}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)n.probe.push(new h1);let s=new h1,o=new lE,a=new lE;return{setup:function(s){let o=0,a=0,h=0;for(let t=0;t<9;t++)n.probe[t].set(0,0,0);let l=0,u=0,c=0,d=0,p=0,f=0,m=0,g=0;s.sort(d3);for(let t=0,e=s.length;t<e;t++){let e=s[t],y=e.color,_=e.intensity,v=e.distance,x=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=y.r*_,a+=y.g*_,h+=y.b*_;else if(e.isLightProbe)for(let t=0;t<9;t++)n.probe[t].addScaledVector(e.sh.coefficients[t],_);else if(e.isDirectionalLight){let t=i.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),e.castShadow){let t=e.shadow,i=r.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,n.directionalShadow[l]=i,n.directionalShadowMap[l]=x,n.directionalShadowMatrix[l]=e.shadow.matrix,f++}n.directional[l]=t,l++}else if(e.isSpotLight){let t=i.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(y).multiplyScalar(_),t.distance=v,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){let t=e.shadow,i=r.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,n.spotShadow[c]=i,n.spotShadowMap[c]=x,n.spotShadowMatrix[c]=e.shadow.matrix,g++}n.spot[c]=t,c++}else if(e.isRectAreaLight){let t=i.get(e);// (a) intensity is the total visible light emitted
//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
// (b) intensity is the brightness of the light
t.color.copy(y).multiplyScalar(_),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),n.rectArea[d]=t,d++}else if(e.isPointLight){let t=i.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity),t.distance=e.distance,t.decay=e.decay,e.castShadow){let t=e.shadow,i=r.get(e);i.shadowBias=t.bias,i.shadowNormalBias=t.normalBias,i.shadowRadius=t.radius,i.shadowMapSize=t.mapSize,i.shadowCameraNear=t.camera.near,i.shadowCameraFar=t.camera.far,n.pointShadow[u]=i,n.pointShadowMap[u]=x,n.pointShadowMatrix[u]=e.shadow.matrix,m++}n.point[u]=t,u++}else if(e.isHemisphereLight){let t=i.get(e);t.skyColor.copy(e.color).multiplyScalar(_),t.groundColor.copy(e.groundColor).multiplyScalar(_),n.hemi[p]=t,p++}}d>0&&(e.isWebGL2?(// WebGL 2
n.rectAreaLTC1=u6.LTC_FLOAT_1,n.rectAreaLTC2=u6.LTC_FLOAT_2):!0===t.has("OES_texture_float_linear")?(n.rectAreaLTC1=u6.LTC_FLOAT_1,n.rectAreaLTC2=u6.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(n.rectAreaLTC1=u6.LTC_HALF_1,n.rectAreaLTC2=u6.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=o,n.ambient[1]=a,n.ambient[2]=h;let y=n.hash;(y.directionalLength!==l||y.pointLength!==u||y.spotLength!==c||y.rectAreaLength!==d||y.hemiLength!==p||y.numDirectionalShadows!==f||y.numPointShadows!==m||y.numSpotShadows!==g)&&(n.directional.length=l,n.spot.length=c,n.rectArea.length=d,n.point.length=u,n.hemi.length=p,n.directionalShadow.length=f,n.directionalShadowMap.length=f,n.pointShadow.length=m,n.pointShadowMap.length=m,n.spotShadow.length=g,n.spotShadowMap.length=g,n.directionalShadowMatrix.length=f,n.pointShadowMatrix.length=m,n.spotShadowMatrix.length=g,y.directionalLength=l,y.pointLength=u,y.spotLength=c,y.rectAreaLength=d,y.hemiLength=p,y.numDirectionalShadows=f,y.numPointShadows=m,y.numSpotShadows=g,n.version=d2++)},setupView:function(t,e){let i=0,r=0,h=0,l=0,u=0,c=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){let d=t[e];if(d.isDirectionalLight){let t=n.directional[i];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(c),i++}else if(d.isSpotLight){let t=n.spot[h];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(c),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(c),h++}else if(d.isRectAreaLight){let t=n.rectArea[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(c),// extract local rotation of light to derive width/height half vectors
a.identity(),o.copy(d.matrixWorld),o.premultiply(c),a.extractRotation(o),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),l++}else if(d.isPointLight){let t=n.point[r];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(c),r++}else if(d.isHemisphereLight){let t=n.hemi[u];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(c),t.direction.normalize(),u++}}},state:n}}function d4(t,e){let i=new d5(t,e),r=[],n=[];return{init:function(){r.length=0,n.length=0},state:{lightsArray:r,shadowsArray:n,lights:i},setupLights:function(){i.setup(r)},setupLightsView:function(t){i.setupView(r,t)},pushLight:function(t){r.push(t)},pushShadow:function(t){n.push(t)}}}function d6(t,e){let i=new WeakMap;return{get:function(r,n=0){let s;return!1===i.has(r)?(s=new d4(t,e),i.set(r,[s])):n>=i.get(r).length?(s=new d4(t,e),i.get(r).push(s)):s=i.get(r)[n],s},dispose:function(){i=new WeakMap}}}/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */class d8 extends l6{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}d8.prototype.isMeshDepthMaterial=!0;/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */class d7 extends l6{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new h1,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function d9(t,e,i){let r=new u1,n=new hX,s=new hX,o=new hZ,a=new d8({depthPacking:3201}),h=new d7,l={},u=i.maxTextureSize,c={0:1,1:0,2:2},d=new uj({defines:{SAMPLE_RATE:.25,HALF_SAMPLE_RATE:.125},uniforms:{shadow_pass:{value:null},resolution:{value:new hX},radius:{value:4}},vertexShader:"void main() {\n	gl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;let f=new uv;f.setAttribute("position",new ua(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let m=new uB(f,d),g=this;function y(e,i,r,n,s,o,u){let d=null,p=!0===n.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(d=void 0!==p?p:!0===n.isPointLight?h:a,t.localClippingEnabled&&!0===r.clipShadows&&0!==r.clippingPlanes.length){// in this case we need a unique material instance reflecting the
// appropriate state
let t=d.uuid,e=r.uuid,i=l[t];void 0===i&&(i={},l[t]=i);let n=i[e];void 0===n&&(n=d.clone(),i[e]=n),d=n}return d.visible=r.visible,d.wireframe=r.wireframe,3===u?d.side=null!==r.shadowSide?r.shadowSide:r.side:d.side=null!==r.shadowSide?r.shadowSide:c[r.side],d.clipShadows=r.clipShadows,d.clippingPlanes=r.clippingPlanes,d.clipIntersection=r.clipIntersection,d.wireframeLinewidth=r.wireframeLinewidth,d.linewidth=r.linewidth,!0===n.isPointLight&&!0===d.isMeshDistanceMaterial&&(d.referencePosition.setFromMatrixPosition(n.matrixWorld),d.nearDistance=s,d.farDistance=o),d}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(i,a,h){if(!1===g.enabled||!1===g.autoUpdate&&!1===g.needsUpdate||0===i.length)return;let l=t.getRenderTarget(),c=t.getActiveCubeFace(),f=t.getActiveMipmapLevel(),_=t.state;// Set GL state for depth map.
_.setBlending(0),_.buffers.color.setClear(1,1,1,1),_.buffers.depth.setTest(!0),_.setScissorTest(!1);// render depth map
for(let l=0,c=i.length;l<c;l++){let c=i[l],f=c.shadow;if(void 0===f){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===f.autoUpdate&&!1===f.needsUpdate)continue;n.copy(f.mapSize);let g=f.getFrameExtents();if(n.multiply(g),s.copy(f.mapSize),(n.x>u||n.y>u)&&(n.x>u&&(s.x=Math.floor(u/g.x),n.x=s.x*g.x,f.mapSize.x=s.x),n.y>u&&(s.y=Math.floor(u/g.y),n.y=s.y*g.y,f.mapSize.y=s.y)),null===f.map&&!f.isPointLightShadow&&3===this.type){let t={minFilter:1006,magFilter:1006,format:1023};f.map=new h$(n.x,n.y,t),f.map.texture.name=c.name+".shadowMap",f.mapPass=new h$(n.x,n.y,t),f.camera.updateProjectionMatrix()}if(null===f.map){let t={minFilter:1003,magFilter:1003,format:1023};f.map=new h$(n.x,n.y,t),f.map.texture.name=c.name+".shadowMap",f.camera.updateProjectionMatrix()}t.setRenderTarget(f.map),t.clear();let v=f.getViewportCount();for(let i=0;i<v;i++){let n=f.getViewport(i);o.set(s.x*n.x,s.y*n.y,s.x*n.z,s.y*n.w),_.viewport(o),f.updateMatrices(c,i),r=f.getFrustum(),function i(n,s,o,a,h){if(!1===n.visible)return;let l=n.layers.test(s.layers);if(l&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===h)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse,n.matrixWorld);let i=e.update(n),r=n.material;if(Array.isArray(r)){let e=i.groups;for(let s=0,l=e.length;s<l;s++){let l=e[s],u=r[l.materialIndex];if(u&&u.visible){let e=y(n,i,u,a,o.near,o.far,h);t.renderBufferDirect(o,null,i,e,n,l)}}}else if(r.visible){let e=y(n,i,r,a,o.near,o.far,h);t.renderBufferDirect(o,null,i,e,n,null)}}let u=n.children;for(let t=0,e=u.length;t<e;t++)i(u[t],s,o,a,h)}(a,h,f.camera,c,this.type)}f.isPointLightShadow||3!==this.type||function(i,r){let n=e.update(m);// vertical pass
d.uniforms.shadow_pass.value=i.map.texture,d.uniforms.resolution.value=i.mapSize,d.uniforms.radius.value=i.radius,t.setRenderTarget(i.mapPass),t.clear(),t.renderBufferDirect(r,null,n,d,m,null),// horizontal pass
p.uniforms.shadow_pass.value=i.mapPass.texture,p.uniforms.resolution.value=i.mapSize,p.uniforms.radius.value=i.radius,t.setRenderTarget(i.map),t.clear(),t.renderBufferDirect(r,null,n,p,m,null)}(f,h),f.needsUpdate=!1}g.needsUpdate=!1,t.setRenderTarget(l,c,f)}}function pt(t,e,i){let r=i.isWebGL2,n=new function(){let e=!1,i=new hZ,r=null,n=new hZ(0,0,0,0);return{setMask:function(i){r===i||e||(t.colorMask(i,i,i,i),r=i)},setLocked:function(t){e=t},setClear:function(e,r,s,o,a){!0===a&&(e*=o,r*=o,s*=o),i.set(e,r,s,o),!1===n.equals(i)&&(t.clearColor(e,r,s,o),n.copy(i))},reset:function(){e=!1,r=null,n.set(-1,0,0,0)}}},s=new function(){let e=!1,i=null,r=null,n=null;return{setTest:function(t){t?F(2929):B(2929)},setMask:function(r){i===r||e||(t.depthMask(r),i=r)},setFunc:function(e){if(r!==e){if(e)switch(e){case 0:t.depthFunc(512);break;case 1:t.depthFunc(519);break;case 2:t.depthFunc(513);break;case 3:default:t.depthFunc(515);break;case 4:t.depthFunc(514);break;case 5:t.depthFunc(518);break;case 6:t.depthFunc(516);break;case 7:t.depthFunc(517)}else t.depthFunc(515);r=e}},setLocked:function(t){e=t},setClear:function(e){n!==e&&(t.clearDepth(e),n=e)},reset:function(){e=!1,i=null,r=null,n=null}}},o=new function(){let e=!1,i=null,r=null,n=null,s=null,o=null,a=null,h=null,l=null;return{setTest:function(t){e||(t?F(2960):B(2960))},setMask:function(r){i===r||e||(t.stencilMask(r),i=r)},setFunc:function(e,i,o){(r!==e||n!==i||s!==o)&&(t.stencilFunc(e,i,o),r=e,n=i,s=o)},setOp:function(e,i,r){(o!==e||a!==i||h!==r)&&(t.stencilOp(e,i,r),o=e,a=i,h=r)},setLocked:function(t){e=t},setClear:function(e){l!==e&&(t.clearStencil(e),l=e)},reset:function(){e=!1,i=null,r=null,n=null,s=null,o=null,a=null,h=null,l=null}}},a={},h=null,l={},u=null,c=!1,d=null,p=null,f=null,m=null,g=null,y=null,_=null,v=!1,x=null,b=null,E=null,T=null,w=null,S=t.getParameter(35661),M=!1,A=t.getParameter(7938);-1!==A.indexOf("WebGL")?M=parseFloat(/^WebGL (\d)/.exec(A)[1])>=1:-1!==A.indexOf("OpenGL ES")&&(M=parseFloat(/^OpenGL ES (\d)/.exec(A)[1])>=2);let R=null,C={},P=t.getParameter(3088),I=t.getParameter(2978),O=new hZ().fromArray(P),L=new hZ().fromArray(I);function N(e,i,r){let n=new Uint8Array(4),s=t.createTexture();// 4 is required to match default unpack alignment of 4.
t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<r;e++)t.texImage2D(i+e,0,6408,1,1,0,6408,5121,n);return s}let D={};//
function F(e){!0!==a[e]&&(t.enable(e),a[e]=!0)}function B(e){!1!==a[e]&&(t.disable(e),a[e]=!1)}D[3553]=N(3553,3553,1),D[34067]=N(34067,34069,6),// init
n.setClear(0,0,0,1),s.setClear(1),o.setClear(0),F(2929),s.setFunc(3),H(!1),z(1),F(2884),k(0);let U={100:32774,101:32778,102:32779};if(r)U[103]=32775,U[104]=32776;else{let t=e.get("EXT_blend_minmax");null!==t&&(U[103]=t.MIN_EXT,U[104]=t.MAX_EXT)}let G={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function k(e,i,r,n,s,o,a,h){if(0===e){!0===c&&(B(3042),c=!1);return}if(!1===c&&(F(3042),c=!0),5!==e){if(e!==d||h!==v){if((100!==p||100!==g)&&(t.blendEquation(32774),p=100,g=100),h)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}f=null,m=null,y=null,_=null,d=e,v=h}return}// custom blending
s=s||i,o=o||r,a=a||n,(i!==p||s!==g)&&(t.blendEquationSeparate(U[i],U[s]),p=i,g=s),(r!==f||n!==m||o!==y||a!==_)&&(t.blendFuncSeparate(G[r],G[n],G[o],G[a]),f=r,m=n,y=o,_=a),d=e,v=null}//
function H(e){x!==e&&(e?t.frontFace(2304):t.frontFace(2305),x=e)}function z(e){0!==e?(F(2884),e!==b&&(1===e?t.cullFace(1029):2===e?t.cullFace(1028):t.cullFace(1032))):B(2884),b=e}function j(e,i,r){e?(F(32823),(T!==i||w!==r)&&(t.polygonOffset(i,r),T=i,w=r)):B(32823)}// texture
function V(e){void 0===e&&(e=33984+S-1),R!==e&&(t.activeTexture(e),R=e)}return{buffers:{color:n,depth:s,stencil:o},enable:F,disable:B,bindFramebuffer:function(e,i){return null===i&&null!==h&&(i=h),l[e]!==i&&(t.bindFramebuffer(e,i),l[e]=i,r&&(36009===e&&(l[36160]=i),36160===e&&(l[36009]=i)),!0)},bindXRFramebuffer:function(e){e!==h&&(t.bindFramebuffer(36160,e),h=e)},useProgram:function(e){return u!==e&&(t.useProgram(e),u=e,!0)},setBlending:k,setMaterial:function(t,e){2===t.side?B(2884):F(2884);let i=1===t.side;e&&(i=!i),H(i),1===t.blending&&!1===t.transparent?k(0):k(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),n.setMask(t.colorWrite);let r=t.stencilWrite;o.setTest(r),r&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),j(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?F(32926):B(32926)},setFlipSided:H,setCullFace:z,setLineWidth:function(e){e!==E&&(M&&t.lineWidth(e),E=e)},setPolygonOffset:j,setScissorTest:function(t){t?F(3089):B(3089)},activeTexture:V,bindTexture:function(e,i){null===R&&V();let r=C[R];void 0===r&&(r={type:void 0,texture:void 0},C[R]=r),(r.type!==e||r.texture!==i)&&(t.bindTexture(e,i||D[e]),r.type=e,r.texture=i)},unbindTexture:function(){let e=C[R];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor://
function(e){!1===O.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),O.copy(e))},viewport:function(e){!1===L.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),L.copy(e))},reset://
function(){// reset state
t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===r&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),// reset internals
a={},R=null,C={},h=null,l={},u=null,c=!1,d=null,p=null,f=null,m=null,g=null,y=null,_=null,v=!1,x=null,b=null,E=null,T=null,w=null,O.set(0,0,t.canvas.width,t.canvas.height),L.set(0,0,t.canvas.width,t.canvas.height),n.reset(),s.reset(),o.reset()}}}function pe(t,e,i,r,n,s,o){let a;let h=n.isWebGL2,l=n.maxTextures,u=n.maxCubemapSize,c=n.maxTextureSize,d=n.maxSamples,p=new WeakMap,f=!1;try{f="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){// Ignore any errors
}function m(t,e){// Use OffscreenCanvas when available. Specially needed in web workers
return f?new OffscreenCanvas(t,e):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(t,e,i,r){let n=1;// only perform resize if necessary
if((t.width>r||t.height>r)&&(n=r/Math.max(t.width,t.height)),n<1||!0===e){// only perform resize for certain image types
if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){let r=e?hV:Math.floor,s=r(n*t.width),o=r(n*t.height);void 0===a&&(a=m(s,o));// cube textures can't reuse the same canvas
let h=i?m(s,o):a;h.width=s,h.height=o;let l=h.getContext("2d");return l.drawImage(t,0,0,s,o),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+o+")."),h}"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+").")}return t}function y(t){return hj(t.width)&&hj(t.height)}function _(t,e){return t.generateMipmaps&&e&&1003!==t.minFilter&&1006!==t.minFilter}function v(e,i,n,s,o=1){t.generateMipmap(e);let a=r.get(i);a.__maxMipLevel=Math.log2(Math.max(n,s,o))}function x(i,r,n){if(!1===h)return r;if(null!==i){if(void 0!==t[i])return t[i];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let s=r;return 6403===r&&(5126===n&&(s=33326),5131===n&&(s=33325),5121===n&&(s=33321)),6407===r&&(5126===n&&(s=34837),5131===n&&(s=34843),5121===n&&(s=32849)),6408===r&&(5126===n&&(s=34836),5131===n&&(s=34842),5121===n&&(s=32856)),(33325===s||33326===s||34842===s||34836===s)&&e.get("EXT_color_buffer_float"),s}// Fallback filters for non-power-of-2 textures
function b(t){return 1003===t||1004===t||1005===t?9728:9729}//
function E(e){let i=e.target;i.removeEventListener("dispose",E),//
function(e){let i=r.get(e);void 0!==i.__webglInit&&(t.deleteTexture(i.__webglTexture),r.remove(e))}(i),i.isVideoTexture&&p.delete(i),o.memory.textures--}function T(e){let i=e.target;i.removeEventListener("dispose",T),function(e){let i=e.texture,n=r.get(e),s=r.get(i);if(e){if(void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),o.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(n.__webglFramebuffer[e]),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&t.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&t.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&t.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&t.deleteRenderbuffer(n.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,n=i.length;e<n;e++){let n=r.get(i[e]);n.__webglTexture&&(t.deleteTexture(n.__webglTexture),o.memory.textures--),r.remove(i[e])}r.remove(i),r.remove(e)}}(i)}//
let w=0;//
function S(t,e){let n=r.get(t);if(t.isVideoTexture&&function(t){let e=o.render.frame;// Check the last frame we updated the VideoTexture
p.get(t)!==e&&(p.set(t,e),t.update())}(t),t.version>0&&n.__version!==t.version){let i=t.image;if(void 0===i)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(!1===i.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{I(n,t,e);return}}i.activeTexture(33984+e),i.bindTexture(3553,n.__webglTexture)}function M(e,n){let o=r.get(e);if(e.version>0&&o.__version!==e.version){!function(e,r,n){let o;if(6!==r.image.length)return;P(e,r),i.activeTexture(33984+n),i.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);let a=r&&(r.isCompressedTexture||r.image[0].isCompressedTexture),l=r.image[0]&&r.image[0].isDataTexture,c=[];for(let t=0;t<6;t++)a||l?c[t]=l?r.image[t].image:r.image[t]:c[t]=g(r.image[t],!1,!0,u);let d=c[0],p=y(d)||h,f=s.convert(r.format),m=s.convert(r.type),b=x(r.internalFormat,f,m);if(C(34067,r,p),a){for(let t=0;t<6;t++){o=c[t].mipmaps;for(let e=0;e<o.length;e++){let n=o[e];1023!==r.format&&1022!==r.format?null!==f?i.compressedTexImage2D(34069+t,e,b,n.width,n.height,0,n.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):i.texImage2D(34069+t,e,b,n.width,n.height,0,f,m,n.data)}}e.__maxMipLevel=o.length-1}else{o=r.mipmaps;for(let t=0;t<6;t++)if(l){i.texImage2D(34069+t,0,b,c[t].width,c[t].height,0,f,m,c[t].data);for(let e=0;e<o.length;e++){let r=o[e],n=r.image[t].image;i.texImage2D(34069+t,e+1,b,n.width,n.height,0,f,m,n.data)}}else{i.texImage2D(34069+t,0,b,f,m,c[t]);for(let e=0;e<o.length;e++){let r=o[e];i.texImage2D(34069+t,e+1,b,f,m,r.image[t])}}e.__maxMipLevel=o.length}_(r,p)&&v(34067,r,d.width,d.height),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}(o,e,n);return}i.activeTexture(33984+n),i.bindTexture(34067,o.__webglTexture)}let A={1e3:10497,1001:33071,1002:33648},R={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function C(i,s,o){if(o?(t.texParameteri(i,10242,A[s.wrapS]),t.texParameteri(i,10243,A[s.wrapT]),(32879===i||35866===i)&&t.texParameteri(i,32882,A[s.wrapR]),t.texParameteri(i,10240,R[s.magFilter]),t.texParameteri(i,10241,R[s.minFilter])):(t.texParameteri(i,10242,33071),t.texParameteri(i,10243,33071),(32879===i||35866===i)&&t.texParameteri(i,32882,33071),(1001!==s.wrapS||1001!==s.wrapT)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(i,10240,b(s.magFilter)),t.texParameteri(i,10241,b(s.minFilter)),1003!==s.minFilter&&1006!==s.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){let o=e.get("EXT_texture_filter_anisotropic");(1015!==s.type||!1!==e.has("OES_texture_float_linear"))&&(!1!==h||1016!==s.type||!1!==e.has("OES_texture_half_float_linear"))&&(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(t.texParameterf(i,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,n.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy);// verify extension for WebGL 1 and WebGL 2
}}function P(e,i){void 0===e.__webglInit&&(e.__webglInit=!0,i.addEventListener("dispose",E),e.__webglTexture=t.createTexture(),o.memory.textures++)}function I(e,r,n){let o,a=3553;r.isDataTexture2DArray&&(a=35866),r.isDataTexture3D&&(a=32879),P(e,r),i.activeTexture(33984+n),i.bindTexture(a,e.__webglTexture),t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);let l=!h&&(1001!==r.wrapS||1001!==r.wrapT||1003!==r.minFilter&&1006!==r.minFilter)&&!1===y(r.image),u=g(r.image,l,!1,c),d=y(u)||h,p=s.convert(r.format),f=s.convert(r.type),m=x(r.internalFormat,p,f);C(a,r,d);let b=r.mipmaps;if(r.isDepthTexture)// populate depth texture with dummy data
m=6402,h?m=1015===r.type?36012:1014===r.type?33190:1020===r.type?35056:33189:1015===r.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===r.format&&6402===m&&1012!==r.type&&1014!==r.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=1012,f=s.convert(r.type)),1027===r.format&&6402===m&&(// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
m=34041,1020!==r.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=1020,f=s.convert(r.type))),//
i.texImage2D(3553,0,m,u.width,u.height,0,p,f,null);else if(r.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(b.length>0&&d){for(let t=0,e=b.length;t<e;t++)o=b[t],i.texImage2D(3553,t,m,o.width,o.height,0,p,f,o.data);r.generateMipmaps=!1,e.__maxMipLevel=b.length-1}else i.texImage2D(3553,0,m,u.width,u.height,0,p,f,u.data),e.__maxMipLevel=0}else if(r.isCompressedTexture){for(let t=0,e=b.length;t<e;t++)o=b[t],1023!==r.format&&1022!==r.format?null!==p?i.compressedTexImage2D(3553,t,m,o.width,o.height,0,o.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):i.texImage2D(3553,t,m,o.width,o.height,0,p,f,o.data);e.__maxMipLevel=b.length-1}else if(r.isDataTexture2DArray)i.texImage3D(35866,0,m,u.width,u.height,u.depth,0,p,f,u.data),e.__maxMipLevel=0;else if(r.isDataTexture3D)i.texImage3D(32879,0,m,u.width,u.height,u.depth,0,p,f,u.data),e.__maxMipLevel=0;else // use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(b.length>0&&d){for(let t=0,e=b.length;t<e;t++)o=b[t],i.texImage2D(3553,t,m,p,f,o);r.generateMipmaps=!1,e.__maxMipLevel=b.length-1}else i.texImage2D(3553,0,m,p,f,u),e.__maxMipLevel=0;_(r,d)&&v(a,r,u.width,u.height),e.__version=r.version,r.onUpdate&&r.onUpdate(r)}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function O(e,n,o,a,h){let l=s.convert(o.format),u=s.convert(o.type),c=x(o.internalFormat,l,u);32879===h||35866===h?i.texImage3D(h,0,c,n.width,n.height,n.depth,0,l,u,null):i.texImage2D(h,0,c,n.width,n.height,0,l,u,null),i.bindFramebuffer(36160,e),t.framebufferTexture2D(36160,a,h,r.get(o).__webglTexture,0),i.bindFramebuffer(36160,null)}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function L(e,i,r){if(t.bindRenderbuffer(36161,e),i.depthBuffer&&!i.stencilBuffer){let n=33189;if(r){let e=i.depthTexture;e&&e.isDepthTexture&&(1015===e.type?n=36012:1014===e.type&&(n=33190));let r=N(i);t.renderbufferStorageMultisample(36161,r,n,i.width,i.height)}else t.renderbufferStorage(36161,n,i.width,i.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(i.depthBuffer&&i.stencilBuffer){if(r){let e=N(i);t.renderbufferStorageMultisample(36161,e,35056,i.width,i.height)}else t.renderbufferStorage(36161,34041,i.width,i.height);t.framebufferRenderbuffer(36160,33306,36161,e)}else{// Use the first texture for MRT so far
let e=!0===i.isWebGLMultipleRenderTargets?i.texture[0]:i.texture,n=s.convert(e.format),o=s.convert(e.type),a=x(e.internalFormat,n,o);if(r){let e=N(i);t.renderbufferStorageMultisample(36161,e,a,i.width,i.height)}else t.renderbufferStorage(36161,a,i.width,i.height)}t.bindRenderbuffer(36161,null)}function N(t){return h&&t.isWebGLMultisampleRenderTarget?Math.min(d,t.samples):0}// backwards compatibility
let D=!1,F=!1;//
this.allocateTextureUnit=function(){let t=w;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),w+=1,t},this.resetTextureUnits=function(){w=0},this.setTexture2D=S,this.setTexture2DArray=function(t,e){let n=r.get(t);if(t.version>0&&n.__version!==t.version){I(n,t,e);return}i.activeTexture(33984+e),i.bindTexture(35866,n.__webglTexture)},this.setTexture3D=function(t,e){let n=r.get(t);if(t.version>0&&n.__version!==t.version){I(n,t,e);return}i.activeTexture(33984+e),i.bindTexture(32879,n.__webglTexture)},this.setTextureCube=M,this.setupRenderTarget=// Set up GL resources for the render target
function(e){let a=e.texture,l=r.get(e),u=r.get(a);e.addEventListener("dispose",T),!0!==e.isWebGLMultipleRenderTargets&&(u.__webglTexture=t.createTexture(),u.__version=a.version,o.memory.textures++);let c=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=!0===e.isWebGLMultisampleRenderTarget,f=a.isDataTexture3D||a.isDataTexture2DArray,m=y(e)||h;// Setup framebuffer
if(h&&1022===a.format&&(1015===a.type||1016===a.type)&&(a.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),c){l.__webglFramebuffer=[];for(let e=0;e<6;e++)l.__webglFramebuffer[e]=t.createFramebuffer()}else if(l.__webglFramebuffer=t.createFramebuffer(),d){if(n.drawBuffers){let i=e.texture;for(let e=0,n=i.length;e<n;e++){let n=r.get(i[e]);void 0===n.__webglTexture&&(n.__webglTexture=t.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")}else if(p){if(h){l.__webglMultisampledFramebuffer=t.createFramebuffer(),l.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,l.__webglColorRenderbuffer);let r=s.convert(a.format),n=s.convert(a.type),o=x(a.internalFormat,r,n),h=N(e);t.renderbufferStorageMultisample(36161,h,o,e.width,e.height),i.bindFramebuffer(36160,l.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,l.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(l.__webglDepthRenderbuffer=t.createRenderbuffer(),L(l.__webglDepthRenderbuffer,e,!0)),i.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}// Setup color buffer
if(c){i.bindTexture(34067,u.__webglTexture),C(34067,a,m);for(let t=0;t<6;t++)O(l.__webglFramebuffer[t],e,a,36064,34069+t);_(a,m)&&v(34067,a,e.width,e.height),i.bindTexture(34067,null)}else if(d){let t=e.texture;for(let n=0,s=t.length;n<s;n++){let s=t[n],o=r.get(s);i.bindTexture(3553,o.__webglTexture),C(3553,s,m),O(l.__webglFramebuffer,e,s,36064+n,3553),_(s,m)&&v(3553,s,e.width,e.height)}i.bindTexture(3553,null)}else{let t=3553;if(f){// Render targets containing layers, i.e: Texture 3D and 2d arrays
if(h){let e=a.isDataTexture3D;t=e?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")}i.bindTexture(t,u.__webglTexture),C(t,a,m),O(l.__webglFramebuffer,e,a,36064,t),_(a,m)&&v(t,a,e.width,e.height,e.depth),i.bindTexture(t,null)}e.depthBuffer&&// Setup GL resources for a non-texture depth buffer
function(e){let n=r.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture){if(s)throw Error("target.depthTexture not supported in Cube render targets");!// Setup resources for a Depth Texture for a FBO (needs an extension)
function(e,n){let s=n&&n.isWebGLCubeRenderTarget;if(s)throw Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(36160,e),!(n.depthTexture&&n.depthTexture.isDepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),S(n.depthTexture,0);let o=r.get(n.depthTexture).__webglTexture;if(1026===n.depthTexture.format)t.framebufferTexture2D(36160,36096,3553,o,0);else if(1027===n.depthTexture.format)t.framebufferTexture2D(36160,33306,3553,o,0);else throw Error("Unknown depthTexture format")}(n.__webglFramebuffer,e)}else if(s){n.__webglDepthbuffer=[];for(let r=0;r<6;r++)i.bindFramebuffer(36160,n.__webglFramebuffer[r]),n.__webglDepthbuffer[r]=t.createRenderbuffer(),L(n.__webglDepthbuffer[r],e,!1)}else i.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=t.createRenderbuffer(),L(n.__webglDepthbuffer,e,!1);i.bindFramebuffer(36160,null)}(e)},this.updateRenderTargetMipmap=function(t){let e=y(t)||h,n=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let s=0,o=n.length;s<o;s++){let o=n[s];if(_(o,e)){let e=t.isWebGLCubeRenderTarget?34067:3553,n=r.get(o).__webglTexture;i.bindTexture(e,n),v(e,o,t.width,t.height),i.bindTexture(e,null)}}},this.updateMultisampleRenderTarget=function(e){if(e.isWebGLMultisampleRenderTarget){if(h){let n=e.width,s=e.height,o=16384;e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024);let a=r.get(e);i.bindFramebuffer(36008,a.__webglMultisampledFramebuffer),i.bindFramebuffer(36009,a.__webglFramebuffer),t.blitFramebuffer(0,0,n,s,0,0,n,s,o,9728),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,a.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}},this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===D&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),D=!0),t=t.texture),S(t,e)},this.safeSetTextureCube=function(t,e){t&&t.isWebGLCubeRenderTarget&&(!1===F&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),F=!0),t=t.texture),M(t,e)}}function pi(t,e,i){let r=i.isWebGL2;return{convert:function(t){let i;if(1009===t)return 5121;if(1017===t)return 32819;if(1018===t)return 32820;if(1019===t)return 33635;if(1010===t)return 5120;if(1011===t)return 5122;if(1012===t)return 5123;if(1013===t)return 5124;if(1014===t)return 5125;if(1015===t)return 5126;if(1016===t)return r?5131:null!==(i=e.get("OES_texture_half_float"))?i.HALF_FLOAT_OES:null;if(1021===t)return 6406;if(1022===t)return 6407;if(1023===t)return 6408;if(1024===t)return 6409;if(1025===t)return 6410;if(1026===t)return 6402;if(1027===t)return 34041;if(1028===t)return 6403;// WebGL2 formats.
if(1029===t)return 36244;if(1030===t)return 33319;if(1031===t)return 33320;if(1032===t)return 36248;if(1033===t)return 36249;if(33776===t||33777===t||33778===t||33779===t){if(null===(i=e.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===t)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===t)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===t)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===t)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(null===(i=e.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===t)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t)return null!==(i=e.get("WEBGL_compressed_texture_etc1"))?i.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===t||37496===t)&&null!==(i=e.get("WEBGL_compressed_texture_etc"))){if(37492===t)return i.COMPRESSED_RGB8_ETC2;if(37496===t)return i.COMPRESSED_RGBA8_ETC2_EAC}return 37808===t||37809===t||37810===t||37811===t||37812===t||37813===t||37814===t||37815===t||37816===t||37817===t||37818===t||37819===t||37820===t||37821===t||37840===t||37841===t||37842===t||37843===t||37844===t||37845===t||37846===t||37847===t||37848===t||37849===t||37850===t||37851===t||37852===t||37853===t?null!==(i=e.get("WEBGL_compressed_texture_astc"))?t:null:36492===t?null!==(i=e.get("EXT_texture_compression_bptc"))?t:null:1020===t?r?34042:null!==(i=e.get("WEBGL_depth_texture"))?i.UNSIGNED_INT_24_8_WEBGL:null:void 0}}}d7.prototype.isMeshDistanceMaterial=!0;class pr extends uX{constructor(t=[]){super(),this.cameras=t}}pr.prototype.isArrayCamera=!0;class pn extends lY{constructor(){super(),this.type="Group"}}pn.prototype.isGroup=!0;const ps={type:"move"};class po{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new pn,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new pn,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new h1,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new h1),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new pn,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new h1,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new h1),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,i){let r=null,n=null,s=null,o=this._targetRay,a=this._grip,h=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(null!==o&&null!==(r=e.getPose(t.targetRaySpace,i))&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(ps)),h&&t.hand){for(let r of(s=!0,t.hand.values())){// Update the joints groups with the XRJoint poses
let t=e.getJointPose(r,i);if(void 0===h.joints[r.jointName]){// The transform of this joint will be updated with the joint pose on each frame
let t=new pn;t.matrixAutoUpdate=!1,t.visible=!1,h.joints[r.jointName]=t,// ??
h.add(t)}let n=h.joints[r.jointName];null!==t&&(n.matrix.fromArray(t.transform.matrix),n.matrix.decompose(n.position,n.rotation,n.scale),n.jointRadius=t.radius),n.visible=null!==t}// Custom events
// Check pinchz
let r=h.joints["index-finger-tip"],n=h.joints["thumb-tip"],o=r.position.distanceTo(n.position);h.inputState.pinching&&o>.025?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!h.inputState.pinching&&o<=.015&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==a&&t.gripSpace&&null!==(n=e.getPose(t.gripSpace,i))&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),n.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(n.linearVelocity)):a.hasLinearVelocity=!1,n.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(n.angularVelocity)):a.hasAngularVelocity=!1)}return null!==o&&(o.visible=null!==r),null!==a&&(a.visible=null!==n),null!==h&&(h.visible=null!==s),this}}class pa extends hB{constructor(t,e){super();let i=this,r=t.state,n=null,s=1,o=null,a="local-floor",h=null,l=null,u=null,c=null,d=null,p=[],f=new Map,m=new uX;m.layers.enable(1),m.viewport=new hZ;let g=new uX;g.layers.enable(2),g.viewport=new hZ;let y=[m,g],_=new pr;_.layers.enable(1),_.layers.enable(2);let v=null,x=null;//
function b(t){let e=f.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function E(){f.forEach(function(t,e){t.disconnect(e)}),f.clear(),v=null,x=null,// restore framebuffer/rendering state
r.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),//
R.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function T(t){let e=n.inputSources;// Assign inputSources to available controllers
for(let t=0;t<p.length;t++)f.set(e[t],p[t]);// Notify disconnected
for(let e=0;e<t.removed.length;e++){let i=t.removed[e],r=f.get(i);r&&(r.dispatchEvent({type:"disconnected",data:i}),f.delete(i))}// Notify connected
for(let e=0;e<t.added.length;e++){let i=t.added[e],r=f.get(i);r&&r.dispatchEvent({type:"connected",data:i})}}//
this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=p[t];return void 0===e&&(e=new po,p[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=p[t];return void 0===e&&(e=new po,p[t]=e),e.getGripSpace()},this.getHand=function(t){let e=p[t];return void 0===e&&(e=new po,p[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){a=t,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return n},this.setSession=async function(t){if(null!==(n=t)){n.addEventListener("select",b),n.addEventListener("selectstart",b),n.addEventListener("selectend",b),n.addEventListener("squeeze",b),n.addEventListener("squeezestart",b),n.addEventListener("squeezeend",b),n.addEventListener("end",E),n.addEventListener("inputsourceschange",T);let t=e.getContextAttributes();if(!0!==t.xrCompatible&&await e.makeXRCompatible(),void 0===n.renderState.layers){let i={antialias:t.antialias,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(n,e,i),n.updateRenderState({baseLayer:d})}else{let i=0;// for anti-aliased output, use classic webgllayer for now
if(t.antialias){let i={antialias:!0,alpha:t.alpha,depth:t.depth,stencil:t.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(n,e,i),n.updateRenderState({layers:[d]})}else{t.depth&&(i=t.stencil?34041:6402);let r={colorFormat:t.alpha?6408:6407,depthFormat:i,scaleFactor:s};c=(l=new XRWebGLBinding(n,e)).createProjectionLayer(r),u=e.createFramebuffer(),n.updateRenderState({layers:[c]})}}o=await n.requestReferenceSpace(a),R.setContext(n),R.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};//
let w=new h1,S=new h1;function M(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===n)return;_.near=g.near=m.near=t.near,_.far=g.far=m.far=t.far,(v!==_.near||x!==_.far)&&(// Note that the new renderState won't apply until the next frame. See #18320
n.updateRenderState({depthNear:_.near,depthFar:_.far}),v=_.near,x=_.far);let e=t.parent,i=_.cameras;M(_,e);for(let t=0;t<i.length;t++)M(i[t],e);_.matrixWorld.decompose(_.position,_.quaternion,_.scale),// update user camera and its children
t.position.copy(_.position),t.quaternion.copy(_.quaternion),t.scale.copy(_.scale),t.matrix.copy(_.matrix),t.matrixWorld.copy(_.matrixWorld);let r=t.children;for(let t=0,e=r.length;t<e;t++)r[t].updateMatrixWorld(!0);2===i.length?/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */function(t,e,i){w.setFromMatrixPosition(e.matrixWorld),S.setFromMatrixPosition(i.matrixWorld);let r=w.distanceTo(S),n=e.projectionMatrix.elements,s=i.projectionMatrix.elements,o=n[14]/(n[10]-1),a=n[14]/(n[10]+1),h=(n[9]+1)/n[5],l=(n[9]-1)/n[5],u=(n[8]-1)/n[0],c=(s[8]+1)/s[0],d=r/(-u+c),p=-(d*u);// TODO: Better way to apply this offset?
e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(p),t.translateZ(d),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
let f=o+d,m=a+d,g=o*u-p,y=o*c+(r-p),_=h*a/m*f,v=l*a/m*f;t.projectionMatrix.makePerspective(g,y,_,v,f,m)}(_,m,g):_.projectionMatrix.copy(m.projectionMatrix)},this.getCamera=function(){return _},this.getFoveation=function(){return null!==c?c.fixedFoveation:null!==d?d.fixedFoveation:void 0},this.setFoveation=function(t){null!==c&&(c.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};// Animation Loop
let A=null,R=new u2;R.setAnimationLoop(function(t,i){if(null!==(h=i.getViewerPose(o))){let t=h.views;null!==d&&r.bindXRFramebuffer(d.framebuffer);let i=!1;// check if it's necessary to rebuild cameraVR's camera list
t.length!==_.cameras.length&&(_.cameras.length=0,i=!0);for(let n=0;n<t.length;n++){let s=t[n],o=null;if(null!==d)o=d.getViewport(s);else{let t=l.getViewSubImage(c,s);r.bindXRFramebuffer(u),void 0!==t.depthStencilTexture&&e.framebufferTexture2D(36160,36096,3553,t.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,t.colorTexture,0),o=t.viewport}let a=y[n];a.matrix.fromArray(s.transform.matrix),a.projectionMatrix.fromArray(s.projectionMatrix),a.viewport.set(o.x,o.y,o.width,o.height),0===n&&_.matrix.copy(a.matrix),!0===i&&_.cameras.push(a)}}//
let s=n.inputSources;for(let t=0;t<p.length;t++){let e=p[t],r=s[t];e.update(r,i,o)}A&&A(t,i)}),this.setAnimationLoop=function(t){A=t},this.dispose=function(){}}}function ph(t){function e(e,i){let r,n;e.opacity.value=i.opacity,i.color&&e.diffuse.value.copy(i.color),i.emissive&&e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(e.map.value=i.map),i.alphaMap&&(e.alphaMap.value=i.alphaMap),i.specularMap&&(e.specularMap.value=i.specularMap);let s=t.get(i).envMap;if(s){e.envMap.value=s,e.flipEnvMap.value=s.isCubeTexture&&!1===s.isRenderTargetTexture?-1:1,e.reflectivity.value=i.reflectivity,e.refractionRatio.value=i.refractionRatio;let r=t.get(s).__maxMipLevel;void 0!==r&&(e.maxMipLevel.value=r)}i.lightMap&&(e.lightMap.value=i.lightMap,e.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(e.aoMap.value=i.aoMap,e.aoMapIntensity.value=i.aoMapIntensity),i.map?r=i.map:i.specularMap?r=i.specularMap:i.displacementMap?r=i.displacementMap:i.normalMap?r=i.normalMap:i.bumpMap?r=i.bumpMap:i.roughnessMap?r=i.roughnessMap:i.metalnessMap?r=i.metalnessMap:i.alphaMap?r=i.alphaMap:i.emissiveMap?r=i.emissiveMap:i.clearcoatMap?r=i.clearcoatMap:i.clearcoatNormalMap?r=i.clearcoatNormalMap:i.clearcoatRoughnessMap?r=i.clearcoatRoughnessMap:i.specularIntensityMap?r=i.specularIntensityMap:i.specularTintMap&&(r=i.specularTintMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix)),i.aoMap?n=i.aoMap:i.lightMap&&(n=i.lightMap),void 0!==n&&(n.isWebGLRenderTarget&&(n=n.texture),!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uv2Transform.value.copy(n.matrix))}function i(e,i){e.roughness.value=i.roughness,e.metalness.value=i.metalness,i.roughnessMap&&(e.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(e.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(e.emissiveMap.value=i.emissiveMap),i.bumpMap&&(e.bumpMap.value=i.bumpMap,e.bumpScale.value=i.bumpScale,1===i.side&&(e.bumpScale.value*=-1)),i.normalMap&&(e.normalMap.value=i.normalMap,e.normalScale.value.copy(i.normalScale),1===i.side&&e.normalScale.value.negate()),i.displacementMap&&(e.displacementMap.value=i.displacementMap,e.displacementScale.value=i.displacementScale,e.displacementBias.value=i.displacementBias);let r=t.get(i).envMap;r&&(e.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,r,n,s,o){let a,h;r.isMeshBasicMaterial?e(t,r):r.isMeshLambertMaterial?(e(t,r),r.emissiveMap&&(t.emissiveMap.value=r.emissiveMap)):r.isMeshToonMaterial?(e(t,r),r.gradientMap&&(t.gradientMap.value=r.gradientMap),r.emissiveMap&&(t.emissiveMap.value=r.emissiveMap),r.bumpMap&&(t.bumpMap.value=r.bumpMap,t.bumpScale.value=r.bumpScale,1===r.side&&(t.bumpScale.value*=-1)),r.normalMap&&(t.normalMap.value=r.normalMap,t.normalScale.value.copy(r.normalScale),1===r.side&&t.normalScale.value.negate()),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias)):r.isMeshPhongMaterial?(e(t,r),t.specular.value.copy(r.specular),t.shininess.value=Math.max(r.shininess,1e-4),r.emissiveMap&&(t.emissiveMap.value=r.emissiveMap),r.bumpMap&&(t.bumpMap.value=r.bumpMap,t.bumpScale.value=r.bumpScale,1===r.side&&(t.bumpScale.value*=-1)),r.normalMap&&(t.normalMap.value=r.normalMap,t.normalScale.value.copy(r.normalScale),1===r.side&&t.normalScale.value.negate()),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias)):r.isMeshStandardMaterial?(e(t,r),r.isMeshPhysicalMaterial?(i(t,r),t.reflectivity.value=r.reflectivity,t.clearcoat.value=r.clearcoat,t.clearcoatRoughness.value=r.clearcoatRoughness,r.sheen&&t.sheen.value.copy(r.sheen),r.clearcoatMap&&(t.clearcoatMap.value=r.clearcoatMap),r.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=r.clearcoatRoughnessMap),r.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(r.clearcoatNormalScale),t.clearcoatNormalMap.value=r.clearcoatNormalMap,1===r.side&&t.clearcoatNormalScale.value.negate()),t.transmission.value=r.transmission,r.transmissionMap&&(t.transmissionMap.value=r.transmissionMap),r.transmission>0&&(t.transmissionSamplerMap.value=o.texture,t.transmissionSamplerSize.value.set(o.width,o.height)),t.thickness.value=r.thickness,r.thicknessMap&&(t.thicknessMap.value=r.thicknessMap),t.attenuationDistance.value=r.attenuationDistance,t.attenuationTint.value.copy(r.attenuationTint),t.specularIntensity.value=r.specularIntensity,t.specularTint.value.copy(r.specularTint),r.specularIntensityMap&&(t.specularIntensityMap.value=r.specularIntensityMap),r.specularTintMap&&(t.specularTintMap.value=r.specularTintMap)):i(t,r)):r.isMeshMatcapMaterial?(e(t,r),r.matcap&&(t.matcap.value=r.matcap),r.bumpMap&&(t.bumpMap.value=r.bumpMap,t.bumpScale.value=r.bumpScale,1===r.side&&(t.bumpScale.value*=-1)),r.normalMap&&(t.normalMap.value=r.normalMap,t.normalScale.value.copy(r.normalScale),1===r.side&&t.normalScale.value.negate()),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias)):r.isMeshDepthMaterial?(e(t,r),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias)):r.isMeshDistanceMaterial?(e(t,r),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias),t.referencePosition.value.copy(r.referencePosition),t.nearDistance.value=r.nearDistance,t.farDistance.value=r.farDistance):r.isMeshNormalMaterial?(e(t,r),r.bumpMap&&(t.bumpMap.value=r.bumpMap,t.bumpScale.value=r.bumpScale,1===r.side&&(t.bumpScale.value*=-1)),r.normalMap&&(t.normalMap.value=r.normalMap,t.normalScale.value.copy(r.normalScale),1===r.side&&t.normalScale.value.negate()),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias)):r.isLineBasicMaterial?(t.diffuse.value.copy(r.color),t.opacity.value=r.opacity,r.isLineDashedMaterial&&(t.dashSize.value=r.dashSize,t.totalSize.value=r.dashSize+r.gapSize,t.scale.value=r.scale)):r.isPointsMaterial?(t.diffuse.value.copy(r.color),t.opacity.value=r.opacity,t.size.value=r.size*n,t.scale.value=.5*s,r.map&&(t.map.value=r.map),r.alphaMap&&(t.alphaMap.value=r.alphaMap),r.map?a=r.map:r.alphaMap&&(a=r.alphaMap),void 0!==a&&(!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uvTransform.value.copy(a.matrix))):r.isSpriteMaterial?(t.diffuse.value.copy(r.color),t.opacity.value=r.opacity,t.rotation.value=r.rotation,r.map&&(t.map.value=r.map),r.alphaMap&&(t.alphaMap.value=r.alphaMap),r.map?h=r.map:r.alphaMap&&(h=r.alphaMap),void 0!==h&&(!0===h.matrixAutoUpdate&&h.updateMatrix(),t.uvTransform.value.copy(h.matrix))):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1);// #15581
}}}function pl(t={}){let e,i,r,n,s,o,a,h,l,u,c,d,p,f,m,g,y,_,v,x,b,E,T;let w=void 0!==t.canvas?t.canvas:function(){let t=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return t.style.display="block",t}(),S=void 0!==t.context?t.context:null,M=void 0!==t.alpha&&t.alpha,A=void 0===t.depth||t.depth,R=void 0===t.stencil||t.stencil,C=void 0!==t.antialias&&t.antialias,P=void 0===t.premultipliedAlpha||t.premultipliedAlpha,I=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,O=void 0!==t.powerPreference?t.powerPreference:"default",L=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat,N=null,D=null,F=[],B=[];// public properties
this.domElement=w,// Debug configuration container
this.debug={/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */checkShaderErrors:!0},// clearing
this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,// scene graph
this.sortObjects=!0,// user-defined clipping
this.clippingPlanes=[],this.localClippingEnabled=!1,// physically based shading
this.gammaFactor=2,this.outputEncoding=3e3,// physical lights
this.physicallyCorrectLights=!1,// tone mapping
this.toneMapping=0,this.toneMappingExposure=1;// internal properties
let U=this,G=!1,k=0,H=0,z=null,j=-1,V=null,X=new hZ,W=new hZ,Y=null,q=w.width,K=w.height,J=1,Z=null,$=null,Q=new hZ(0,0,q,K),tt=new hZ(0,0,q,K),te=!1,ti=[],tr=new u1,tn=!1,ts=!1,to=null,ta=new lE,th=new h1,tl={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function tu(){return null===z?J:1}// initialize
let tc=S;function td(t,e){for(let i=0;i<t.length;i++){let r=t[i],n=w.getContext(r,e);if(null!==n)return n}return null}try{if(// event listeners must be registered before WebGL context is created, see #12753
w.addEventListener("webglcontextlost",tm,!1),w.addEventListener("webglcontextrestored",tg,!1),null===tc){let t=["webgl2","webgl","experimental-webgl"];if(!0===U.isWebGL1Renderer&&t.shift(),tc=td(t,{alpha:M,depth:A,stencil:R,antialias:C,premultipliedAlpha:P,preserveDrawingBuffer:I,powerPreference:O,failIfMajorPerformanceCaveat:L}),null===tc){if(td(t))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.")}}void 0===tc.getShaderPrecisionFormat&&(tc.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function tp(){e=new cC(tc),i=new ce(tc,e,t),e.init(i),E=new pi(tc,e,i),r=new pt(tc,e,i),ti[0]=1029,n=new cO(tc),s=new dJ,o=new pe(tc,e,r,s,i,E,n),a=new cr(U),h=new cR(U),l=new u3(tc,i),T=new u9(tc,e,l,i),u=new cP(tc,l,n,T),c=new cF(tc,u,l,n),v=new cD(tc),g=new ci(s),d=new dK(U,a,h,e,i,T,g),p=new ph(s),f=new d0(s),m=new d6(e,i),_=new u7(U,a,r,c,P),y=new d9(U,c,i),x=new ct(tc,e,n,i),b=new cI(tc,e,n,i),n.programs=d.programs,U.capabilities=i,U.extensions=e,U.properties=s,U.renderLists=f,U.shadowMap=y,U.state=r,U.info=n}tp();// xr
let tf=new pa(U,tc);// Events
function tm(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),G=!0}function tg(){console.log("THREE.WebGLRenderer: Context Restored."),G=!1;let t=n.autoReset,e=y.enabled,i=y.autoUpdate,r=y.needsUpdate,s=y.type;tp(),n.autoReset=t,y.enabled=e,y.autoUpdate=i,y.needsUpdate=r,y.type=s}function ty(t){let e=t.target;e.removeEventListener("dispose",ty),function(t){let e=s.get(t).programs;void 0!==e&&e.forEach(function(t){d.releaseProgram(t)})}(e),s.remove(e)}this.xr=tf,// API
this.getContext=function(){return tc},this.getContextAttributes=function(){return tc.getContextAttributes()},this.forceContextLoss=function(){let t=e.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){let t=e.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return J},this.setPixelRatio=function(t){void 0!==t&&(J=t,this.setSize(q,K,!1))},this.getSize=function(t){return t.set(q,K)},this.setSize=function(t,e,i){if(tf.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}q=t,K=e,w.width=Math.floor(t*J),w.height=Math.floor(e*J),!1!==i&&(w.style.width=t+"px",w.style.height=e+"px"),this.setViewport(0,0,t,e)},this.getDrawingBufferSize=function(t){return t.set(q*J,K*J).floor()},this.setDrawingBufferSize=function(t,e,i){q=t,K=e,J=i,w.width=Math.floor(t*i),w.height=Math.floor(e*i),this.setViewport(0,0,t,e)},this.getCurrentViewport=function(t){return t.copy(X)},this.getViewport=function(t){return t.copy(Q)},this.setViewport=function(t,e,i,n){t.isVector4?Q.set(t.x,t.y,t.z,t.w):Q.set(t,e,i,n),r.viewport(X.copy(Q).multiplyScalar(J).floor())},this.getScissor=function(t){return t.copy(tt)},this.setScissor=function(t,e,i,n){t.isVector4?tt.set(t.x,t.y,t.z,t.w):tt.set(t,e,i,n),r.scissor(W.copy(tt).multiplyScalar(J).floor())},this.getScissorTest=function(){return te},this.setScissorTest=function(t){r.setScissorTest(te=t)},this.setOpaqueSort=function(t){Z=t},this.setTransparentSort=function(t){$=t},// Clearing
this.getClearColor=function(t){return t.copy(_.getClearColor())},this.setClearColor=function(){_.setClearColor.apply(_,arguments)},this.getClearAlpha=function(){return _.getClearAlpha()},this.setClearAlpha=function(){_.setClearAlpha.apply(_,arguments)},this.clear=function(t,e,i){let r=0;(void 0===t||t)&&(r|=16384),(void 0===e||e)&&(r|=256),(void 0===i||i)&&(r|=1024),tc.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},//
this.dispose=function(){w.removeEventListener("webglcontextlost",tm,!1),w.removeEventListener("webglcontextrestored",tg,!1),f.dispose(),m.dispose(),s.dispose(),a.dispose(),h.dispose(),c.dispose(),T.dispose(),tf.dispose(),tf.removeEventListener("sessionstart",tv),tf.removeEventListener("sessionend",tx),to&&(to.dispose(),to=null),tb.stop()},this.renderBufferImmediate=function(t,e){T.initAttributes();let i=s.get(t);t.hasPositions&&!i.position&&(i.position=tc.createBuffer()),t.hasNormals&&!i.normal&&(i.normal=tc.createBuffer()),t.hasUvs&&!i.uv&&(i.uv=tc.createBuffer()),t.hasColors&&!i.color&&(i.color=tc.createBuffer());let r=e.getAttributes();t.hasPositions&&(tc.bindBuffer(34962,i.position),tc.bufferData(34962,t.positionArray,35048),T.enableAttribute(r.position),tc.vertexAttribPointer(r.position,3,5126,!1,0,0)),t.hasNormals&&(tc.bindBuffer(34962,i.normal),tc.bufferData(34962,t.normalArray,35048),T.enableAttribute(r.normal),tc.vertexAttribPointer(r.normal,3,5126,!1,0,0)),t.hasUvs&&(tc.bindBuffer(34962,i.uv),tc.bufferData(34962,t.uvArray,35048),T.enableAttribute(r.uv),tc.vertexAttribPointer(r.uv,2,5126,!1,0,0)),t.hasColors&&(tc.bindBuffer(34962,i.color),tc.bufferData(34962,t.colorArray,35048),T.enableAttribute(r.color),tc.vertexAttribPointer(r.color,3,5126,!1,0,0)),T.disableUnusedAttributes(),tc.drawArrays(4,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,i,n,s,o){let a;null===e&&(e=tl);let h=s.isMesh&&0>s.matrixWorld.determinant(),c=tM(t,e,n,s);r.setMaterial(n,h);//
let d=i.index,p=i.attributes.position;//
if(null===d){if(void 0===p||0===p.count)return}else if(0===d.count)return;//
let f=1;!0===n.wireframe&&(d=u.getWireframeAttribute(i),f=2),(void 0!==i.morphAttributes.position||void 0!==i.morphAttributes.normal)&&v.update(s,i,n,c),T.setup(s,n,c,i,d);let m=x;null!==d&&(a=l.get(d),(m=b).setIndex(a));//
let g=null!==d?d.count:p.count,y=i.drawRange.start*f,_=i.drawRange.count*f,E=null!==o?o.start*f:0,w=null!==o?o.count*f:1/0,S=Math.max(y,E),M=Math.min(g,y+_,E+w)-1,A=Math.max(0,M-S+1);if(0!==A){//
if(s.isMesh)!0===n.wireframe?(r.setLineWidth(n.wireframeLinewidth*tu()),m.setMode(1)):m.setMode(4);else if(s.isLine){let t=n.linewidth;void 0===t&&(t=1),r.setLineWidth(t*tu()),s.isLineSegments?m.setMode(1):s.isLineLoop?m.setMode(2):m.setMode(3)}else s.isPoints?m.setMode(0):s.isSprite&&m.setMode(4);if(s.isInstancedMesh)m.renderInstances(S,A,s.count);else if(i.isInstancedBufferGeometry){let t=Math.min(i.instanceCount,i._maxInstanceCount);m.renderInstances(S,A,t)}else m.render(S,A)}},// Compile
this.compile=function(t,e){(D=m.get(t)).init(),B.push(D),t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(D.pushLight(t),t.castShadow&&D.pushShadow(t))}),D.setupLights(),t.traverse(function(e){let i=e.material;if(i){if(Array.isArray(i))for(let r=0;r<i.length;r++){let n=i[r];tw(n,t,e)}else tw(i,t,e)}}),B.pop(),D=null};// Animation Loop
let t_=null;function tv(){tb.stop()}function tx(){tb.start()}let tb=new u2;function tE(t,e,i){let n=!0===e.isScene?e.overrideMaterial:null;if(i.isArrayCamera){let s=i.cameras;for(let i=0,o=s.length;i<o;i++){let o=s[i];r.viewport(X.copy(o.viewport)),D.setupLightsView(o);for(let i=0,r=t.length;i<r;i++){let r=t[i],s=r.object,a=r.geometry,h=null===n?r.material:n,l=r.group;s.layers.test(o.layers)&&tT(s,e,o,a,h,l)}}}else for(let r=0,s=t.length;r<s;r++){let s=t[r],o=s.object,a=s.geometry,h=null===n?s.material:n,l=s.group;tT(o,e,i,a,h,l)}}function tT(t,e,i,n,s,o){if(t.onBeforeRender(U,e,i,n,s,o),t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){let n=tM(i,e,s,t);r.setMaterial(s),T.reset(),// Buffer rendering
function(t,e){t.render(function(t){U.renderBufferImmediate(t,e)})}(t,n)}else!0===s.transparent&&2===s.side?(s.side=1,s.needsUpdate=!0,U.renderBufferDirect(i,e,n,s,t,o),s.side=0,s.needsUpdate=!0,U.renderBufferDirect(i,e,n,s,t,o),s.side=2):U.renderBufferDirect(i,e,n,s,t,o);t.onAfterRender(U,e,i,n,s,o)}function tw(t,e,i){!0!==e.isScene&&(e=tl);let r=s.get(t),n=D.state.lights,o=D.state.shadowsArray,l=n.state.version,u=d.getParameters(t,n.state,o,e,i),c=d.getProgramCacheKey(u),p=r.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(t.isMeshStandardMaterial?h:a).get(t.envMap||r.environment),void 0===p&&(// new material
t.addEventListener("dispose",ty),p=new Map,r.programs=p);let f=p.get(c);if(void 0!==f){if(r.currentProgram===f&&r.lightsStateVersion===l)return tS(t,u),f}else u.uniforms=d.getUniforms(t),t.onBuild(u,U),t.onBeforeCompile(u,U),f=d.acquireProgram(u,c),p.set(c,f),r.uniforms=u.uniforms;let m=r.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(m.clippingPlanes=g.uniform),tS(t,u),// store the light setup it was created for
r.needsLights=t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights,r.lightsStateVersion=l,r.needsLights&&(// wire up the material to this renderer's lighting state
m.ambientLightColor.value=n.state.ambient,m.lightProbe.value=n.state.probe,m.directionalLights.value=n.state.directional,m.directionalLightShadows.value=n.state.directionalShadow,m.spotLights.value=n.state.spot,m.spotLightShadows.value=n.state.spotShadow,m.rectAreaLights.value=n.state.rectArea,m.ltc_1.value=n.state.rectAreaLTC1,m.ltc_2.value=n.state.rectAreaLTC2,m.pointLights.value=n.state.point,m.pointLightShadows.value=n.state.pointShadow,m.hemisphereLights.value=n.state.hemi,m.directionalShadowMap.value=n.state.directionalShadowMap,m.directionalShadowMatrix.value=n.state.directionalShadowMatrix,m.spotShadowMap.value=n.state.spotShadowMap,m.spotShadowMatrix.value=n.state.spotShadowMatrix,m.pointShadowMap.value=n.state.pointShadowMap,m.pointShadowMatrix.value=n.state.pointShadowMatrix);let y=f.getUniforms(),_=dP.seqWithValue(y.seq,m);return r.currentProgram=f,r.uniformsList=_,f}function tS(t,e){let i=s.get(t);i.outputEncoding=e.outputEncoding,i.instancing=e.instancing,i.skinning=e.skinning,i.morphTargets=e.morphTargets,i.morphNormals=e.morphNormals,i.numClippingPlanes=e.numClippingPlanes,i.numIntersection=e.numClipIntersection,i.vertexAlphas=e.vertexAlphas,i.vertexTangents=e.vertexTangents}function tM(t,e,n,l){var u;!0!==e.isScene&&(e=tl),o.resetTextureUnits();let c=e.fog,d=n.isMeshStandardMaterial?e.environment:null,f=null===z?U.outputEncoding:z.texture.encoding,m=(n.isMeshStandardMaterial?h:a).get(n.envMap||d),y=!0===n.vertexColors&&!!l.geometry&&!!l.geometry.attributes.color&&4===l.geometry.attributes.color.itemSize,_=!!l.geometry&&!!l.geometry.attributes.tangent,v=!!l.geometry&&!!l.geometry.morphAttributes.position,x=!!l.geometry&&!!l.geometry.morphAttributes.normal,b=s.get(n),E=D.state.lights;if(!0===tn&&(!0===ts||t!==V)){let e=t===V&&n.id===j;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
g.setState(n,t,e)}//
let T=!1;n.version===b.__version?b.needsLights&&b.lightsStateVersion!==E.state.version?T=!0:b.outputEncoding!==f?T=!0:l.isInstancedMesh&&!1===b.instancing?T=!0:l.isInstancedMesh||!0!==b.instancing?l.isSkinnedMesh&&!1===b.skinning?T=!0:l.isSkinnedMesh||!0!==b.skinning?b.envMap!==m?T=!0:n.fog&&b.fog!==c?T=!0:void 0!==b.numClippingPlanes&&(b.numClippingPlanes!==g.numPlanes||b.numIntersection!==g.numIntersection)?T=!0:b.vertexAlphas!==y?T=!0:b.vertexTangents!==_?T=!0:b.morphTargets!==v?T=!0:b.morphNormals!==x&&(T=!0):T=!0:T=!0:(T=!0,b.__version=n.version);//
let w=b.currentProgram;!0===T&&(w=tw(n,e,l));let S=!1,M=!1,A=!1,R=w.getUniforms(),C=b.uniforms;if(r.useProgram(w.program)&&(S=!0,M=!0,A=!0),n.id!==j&&(j=n.id,M=!0),S||V!==t){// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(R.setValue(tc,"projectionMatrix",t.projectionMatrix),i.logarithmicDepthBuffer&&R.setValue(tc,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),V!==t&&(V=t,// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
M=!0,A=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){let e=R.map.cameraPosition;void 0!==e&&e.setValue(tc,th.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&R.setValue(tc,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||l.isSkinnedMesh)&&R.setValue(tc,"viewMatrix",t.matrixWorldInverse)}// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// otherwise textures used for skinning can take over texture units reserved for other material textures
if(l.isSkinnedMesh){R.setOptional(tc,l,"bindMatrix"),R.setOptional(tc,l,"bindMatrixInverse");let t=l.skeleton;t&&(i.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),R.setValue(tc,"boneTexture",t.boneTexture,o),R.setValue(tc,"boneTextureSize",t.boneTextureSize)):R.setOptional(tc,t,"boneMatrices"))}return(M||b.receiveShadow!==l.receiveShadow)&&(b.receiveShadow=l.receiveShadow,R.setValue(tc,"receiveShadow",l.receiveShadow)),M&&(R.setValue(tc,"toneMappingExposure",U.toneMappingExposure),b.needsLights&&(u=A,C.ambientLightColor.needsUpdate=u,C.lightProbe.needsUpdate=u,C.directionalLights.needsUpdate=u,C.directionalLightShadows.needsUpdate=u,C.pointLights.needsUpdate=u,C.pointLightShadows.needsUpdate=u,C.spotLights.needsUpdate=u,C.spotLightShadows.needsUpdate=u,C.rectAreaLights.needsUpdate=u,C.hemisphereLights.needsUpdate=u),c&&n.fog&&p.refreshFogUniforms(C,c),p.refreshMaterialUniforms(C,n,J,K,to),dP.upload(tc,b.uniformsList,C,o)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(dP.upload(tc,b.uniformsList,C,o),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&R.setValue(tc,"center",l.center),// common matrices
R.setValue(tc,"modelViewMatrix",l.modelViewMatrix),R.setValue(tc,"normalMatrix",l.normalMatrix),R.setValue(tc,"modelMatrix",l.matrixWorld),w}tb.setAnimationLoop(function(t){t_&&t_(t)}),"undefined"!=typeof window&&tb.setContext(window),this.setAnimationLoop=function(t){t_=t,tf.setAnimationLoop(t),null===t?tb.stop():tb.start()},tf.addEventListener("sessionstart",tv),tf.addEventListener("sessionend",tx),// Rendering
this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===G)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===tf.enabled&&!0===tf.isPresenting&&(!0===tf.cameraAutoUpdate&&tf.updateCamera(e),e=tf.getCamera()),!0===t.isScene&&t.onBeforeRender(U,t,e,z),(D=m.get(t,B.length)).init(),B.push(D),ta.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),tr.setFromProjectionMatrix(ta),ts=this.localClippingEnabled,tn=g.init(this.clippingPlanes,ts,e),(N=f.get(t,F.length)).init(),F.push(N),function t(e,i,r,s){if(!1===e.visible)return;let o=e.layers.test(i.layers);if(o){if(e.isGroup)r=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(i);else if(e.isLight)D.pushLight(e),e.castShadow&&D.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||tr.intersectsSprite(e)){s&&th.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ta);let t=c.update(e),i=e.material;i.visible&&N.push(e,t,i,r,th.z,null)}}else if(e.isImmediateRenderObject)s&&th.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ta),N.push(e,null,e.material,r,th.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==n.render.frame&&(e.skeleton.update(),e.skeleton.frame=n.render.frame),!e.frustumCulled||tr.intersectsObject(e))){s&&th.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ta);let t=c.update(e),i=e.material;if(Array.isArray(i)){let n=t.groups;for(let s=0,o=n.length;s<o;s++){let o=n[s],a=i[o.materialIndex];a&&a.visible&&N.push(e,t,a,r,th.z,o)}}else i.visible&&N.push(e,t,i,r,th.z,null)}}let a=e.children;for(let e=0,n=a.length;e<n;e++)t(a[e],i,r,s)}(t,e,0,U.sortObjects),N.finish(),!0===U.sortObjects&&N.sort(Z,$),!0===tn&&g.beginShadows();let s=D.state.shadowsArray;y.render(s,t,e),D.setupLights(),D.setupLightsView(e),!0===tn&&g.endShadows(),!0===this.info.autoReset&&this.info.reset(),//
_.render(N,t);// render scene
let a=N.opaque,h=N.transmissive,l=N.transparent;a.length>0&&tE(a,t,e),h.length>0&&function(t,e,r,n){if(null===to){let t=!0===C&&!0===i.isWebGL2,e=t?hQ:h$;to=new e(1024,1024,{generateMipmaps:!0,type:null!==E.convert(1016)?1016:1009,minFilter:1008,magFilter:1003,wrapS:1001,wrapT:1001})}let s=U.getRenderTarget();U.setRenderTarget(to),U.clear();// Turn off the features which can affect the frag color for opaque objects pass.
// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
let a=U.toneMapping;U.toneMapping=0,tE(t,r,n),U.toneMapping=a,o.updateMultisampleRenderTarget(to),o.updateRenderTargetMipmap(to),U.setRenderTarget(s),tE(e,r,n)}(a,h,t,e),l.length>0&&tE(l,t,e),null!==z&&(// resolve multisample renderbuffers to a single-sample texture if necessary
o.updateMultisampleRenderTarget(z),// Generate mipmap if we're using any kind of mipmap filtering
o.updateRenderTargetMipmap(z)),!0===t.isScene&&t.onAfterRender(U,t,e),// Ensure depth buffer writing is enabled so it can be cleared on next render
r.buffers.depth.setTest(!0),r.buffers.depth.setMask(!0),r.buffers.color.setMask(!0),r.setPolygonOffset(!1),// _gl.finish();
T.resetDefaultState(),j=-1,V=null,B.pop(),D=B.length>0?B[B.length-1]:null,F.pop(),N=F.length>0?F[F.length-1]:null},this.getActiveCubeFace=function(){return k},this.getActiveMipmapLevel=function(){return H},this.getRenderTarget=function(){return z},this.setRenderTarget=function(t,n=0,a=0){z=t,k=n,H=a,t&&void 0===s.get(t).__webglFramebuffer&&o.setupRenderTarget(t);let h=null,l=!1,u=!1;if(t){let e=t.texture;(e.isDataTexture3D||e.isDataTexture2DArray)&&(u=!0);let i=s.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(h=i[n],l=!0):h=t.isWebGLMultisampleRenderTarget?s.get(t).__webglMultisampledFramebuffer:i,X.copy(t.viewport),W.copy(t.scissor),Y=t.scissorTest}else X.copy(Q).multiplyScalar(J).floor(),W.copy(tt).multiplyScalar(J).floor(),Y=te;let c=r.bindFramebuffer(36160,h);if(c&&i.drawBuffers){let r=!1;if(t){if(t.isWebGLMultipleRenderTargets){let e=t.texture;if(ti.length!==e.length||36064!==ti[0]){for(let t=0,i=e.length;t<i;t++)ti[t]=36064+t;ti.length=e.length,r=!0}}else(1!==ti.length||36064!==ti[0])&&(ti[0]=36064,ti.length=1,r=!0)}else(1!==ti.length||1029!==ti[0])&&(ti[0]=1029,ti.length=1,r=!0);r&&(i.isWebGL2?tc.drawBuffers(ti):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ti))}if(r.viewport(X),r.scissor(W),r.setScissorTest(Y),l){let e=s.get(t.texture);tc.framebufferTexture2D(36160,36064,34069+n,e.__webglTexture,a)}else if(u){let e=s.get(t.texture),i=n||0;tc.framebufferTextureLayer(36160,36064,e.__webglTexture,a||0,i)}},this.readRenderTargetPixels=function(t,n,o,a,h,l,u){if(!(t&&t.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let c=s.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==u&&(c=c[u]),c){r.bindFramebuffer(36160,c);try{let r=t.texture,s=r.format,u=r.type;if(1023!==s&&E.convert(s)!==tc.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}let c=1016===u&&(e.has("EXT_color_buffer_half_float")||i.isWebGL2&&e.has("EXT_color_buffer_float"));if(1009!==u&&E.convert(u)!==tc.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
!(1015===u&&(i.isWebGL2||e.has("OES_texture_float")||e.has("WEBGL_color_buffer_float")))&&// Chrome Mac >= 52 and Firefox
!c){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}36053===tc.checkFramebufferStatus(36160)?n>=0&&n<=t.width-a&&o>=0&&o<=t.height-h&&tc.readPixels(n,o,a,h,E.convert(s),E.convert(u),l):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{// restore framebuffer of current render target if necessary
let t=null!==z?s.get(z).__webglFramebuffer:null;r.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){let s=Math.pow(2,-n),a=Math.floor(e.image.width*s),h=Math.floor(e.image.height*s),l=E.convert(e.format);i.isWebGL2&&(6407===l&&(l=32849),6408===l&&(l=32856)),o.setTexture2D(e,0),tc.copyTexImage2D(3553,n,l,t.x,t.y,a,h,0),r.unbindTexture()},this.copyTextureToTexture=function(t,e,i,n=0){let s=e.image.width,a=e.image.height,h=E.convert(i.format),l=E.convert(i.type);o.setTexture2D(i,0),// As another texture upload may have changed pixelStorei
// parameters, make sure they are correct for the dstTexture
tc.pixelStorei(37440,i.flipY),tc.pixelStorei(37441,i.premultiplyAlpha),tc.pixelStorei(3317,i.unpackAlignment),e.isDataTexture?tc.texSubImage2D(3553,n,t.x,t.y,s,a,h,l,e.image.data):e.isCompressedTexture?tc.compressedTexSubImage2D(3553,n,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,h,e.mipmaps[0].data):tc.texSubImage2D(3553,n,t.x,t.y,h,l,e.image),0===n&&i.generateMipmaps&&tc.generateMipmap(3553),r.unbindTexture()},this.copyTextureToTexture3D=function(t,e,i,n,s=0){let a;if(U.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}let h=t.max.x-t.min.x+1,l=t.max.y-t.min.y+1,u=t.max.z-t.min.z+1,c=E.convert(n.format),d=E.convert(n.type);if(n.isDataTexture3D)o.setTexture3D(n,0),a=32879;else if(n.isDataTexture2DArray)o.setTexture2DArray(n,0),a=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}tc.pixelStorei(37440,n.flipY),tc.pixelStorei(37441,n.premultiplyAlpha),tc.pixelStorei(3317,n.unpackAlignment);let p=tc.getParameter(3314),f=tc.getParameter(32878),m=tc.getParameter(3316),g=tc.getParameter(3315),y=tc.getParameter(32877),_=i.isCompressedTexture?i.mipmaps[0]:i.image;tc.pixelStorei(3314,_.width),tc.pixelStorei(32878,_.height),tc.pixelStorei(3316,t.min.x),tc.pixelStorei(3315,t.min.y),tc.pixelStorei(32877,t.min.z),i.isDataTexture||i.isDataTexture3D?tc.texSubImage3D(a,s,e.x,e.y,e.z,h,l,u,c,d,_.data):i.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),tc.compressedTexSubImage3D(a,s,e.x,e.y,e.z,h,l,u,c,_.data)):tc.texSubImage3D(a,s,e.x,e.y,e.z,h,l,u,c,d,_),tc.pixelStorei(3314,p),tc.pixelStorei(32878,f),tc.pixelStorei(3316,m),tc.pixelStorei(3315,g),tc.pixelStorei(32877,y),0===s&&n.generateMipmaps&&tc.generateMipmap(a),r.unbindTexture()},this.initTexture=function(t){o.setTexture2D(t,0),r.unbindTexture()},this.resetState=function(){k=0,H=0,z=null,r.reset(),T.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends pl{}).prototype.isWebGL1Renderer=!0;class pu{constructor(t,e=25e-5){this.name="",this.color=new ur(t),this.density=e}clone(){return new pu(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}pu.prototype.isFogExp2=!0;class pc{constructor(t,e=1,i=1e3){this.name="",this.color=new ur(t),this.near=e,this.far=i}clone(){return new pc(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}pc.prototype.isFog=!0;class pd extends lY{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){let e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}pd.prototype.isScene=!0;class pp{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=hH()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let r=0,n=this.stride;r<n;r++)this.array[t+r]=e.array[i+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=hH()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){//
return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=hH()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}pp.prototype.isInterleavedBuffer=!0;const pf=/*@__PURE__*/new h1;class pm{constructor(t,e,i,r=!1){this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)pf.x=this.getX(e),pf.y=this.getY(e),pf.z=this.getZ(e),pf.applyMatrix4(t),this.setXYZ(e,pf.x,pf.y,pf.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)pf.x=this.getX(e),pf.y=this.getY(e),pf.z=this.getZ(e),pf.applyNormalMatrix(t),this.setXYZ(e,pf.x,pf.y,pf.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)pf.x=this.getX(e),pf.y=this.getY(e),pf.z=this.getZ(e),pf.transformDirection(t),this.setXYZ(e,pf.x,pf.y,pf.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=r,this}setXYZW(t,e,i,r,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=r,this.data.array[t+3]=n,this}clone(t){if(void 0!==t)return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new pm(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");let t=[];for(let e=0;e<this.count;e++){let i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return new ua(new this.array.constructor(t),this.itemSize,this.normalized)}}toJSON(t){if(void 0!==t)return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");let t=[];for(let e=0;e<this.count;e++){let i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}// deinterleave data and save it as an ordinary buffer attribute for now
return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}}}pm.prototype.isInterleavedBufferAttribute=!0;/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */class pg extends l6{constructor(t){super(),this.type="SpriteMaterial",this.color=new ur(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}pg.prototype.isSpriteMaterial=!0;const py=/*@__PURE__*/new h1,p_=/*@__PURE__*/new h1,pv=/*@__PURE__*/new h1,px=/*@__PURE__*/new hX,pb=/*@__PURE__*/new hX,pE=/*@__PURE__*/new lE,pT=/*@__PURE__*/new h1,pw=/*@__PURE__*/new h1,pS=/*@__PURE__*/new h1,pM=/*@__PURE__*/new hX,pA=/*@__PURE__*/new hX,pR=/*@__PURE__*/new hX;function pC(t,e,i,r,n,s){// compute position in camera space
px.subVectors(t,i).addScalar(.5).multiply(r),void 0!==n?(pb.x=s*px.x-n*px.y,pb.y=n*px.x+s*px.y):pb.copy(px),t.copy(e),t.x+=pb.x,t.y+=pb.y,// transform to world space
t.applyMatrix4(pE)}(class extends lY{constructor(t){if(super(),this.type="Sprite",void 0===e){e=new uv;let t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new pp(t,5);e.setIndex([0,1,2,0,2,3]),e.setAttribute("position",new pm(i,3,0,!1)),e.setAttribute("uv",new pm(i,2,3,!1))}this.geometry=e,this.material=void 0!==t?t:new pg,this.center=new hX(.5,.5)}raycast(t,e){let i,r;null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),p_.setFromMatrixScale(this.matrixWorld),pE.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),pv.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&p_.multiplyScalar(-pv.z);let n=this.material.rotation;0!==n&&(r=Math.cos(n),i=Math.sin(n));let s=this.center;pC(pT.set(-.5,-.5,0),pv,s,p_,i,r),pC(pw.set(.5,-.5,0),pv,s,p_,i,r),pC(pS.set(.5,.5,0),pv,s,p_,i,r),pM.set(0,0),pA.set(1,0),pR.set(1,1);// check first triangle
let o=t.ray.intersectTriangle(pT,pw,pS,!1,py);if(null===o&&(// check second triangle
pC(pw.set(-.5,.5,0),pv,s,p_,i,r),pA.set(0,1),null===(o=t.ray.intersectTriangle(pT,pS,pw,!1,py))))return;let a=t.ray.origin.distanceTo(py);a<t.near||a>t.far||e.push({distance:a,point:py.clone(),uv:l5.getUV(py,pT,pw,pS,pM,pA,pR,new hX),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}).prototype.isSprite=!0;const pP=/*@__PURE__*/new h1,pI=/*@__PURE__*/new hZ,pO=/*@__PURE__*/new hZ,pL=/*@__PURE__*/new h1,pN=/*@__PURE__*/new lE;class pD extends uB{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new lE,this.bindMatrixInverse=new lE}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){let t=new hZ,e=this.geometry.attributes.skinWeight;for(let i=0,r=e.count;i<r;i++){t.x=e.getX(i),t.y=e.getY(i),t.z=e.getZ(i),t.w=e.getW(i);let r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){let i=this.skeleton,r=this.geometry;pI.fromBufferAttribute(r.attributes.skinIndex,t),pO.fromBufferAttribute(r.attributes.skinWeight,t),pP.fromBufferAttribute(r.attributes.position,t).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){let r=pO.getComponent(t);if(0!==r){let n=pI.getComponent(t);pN.multiplyMatrices(i.bones[n].matrixWorld,i.boneInverses[n]),e.addScaledVector(pL.copy(pP).applyMatrix4(pN),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}pD.prototype.isSkinnedMesh=!0,(class extends lY{constructor(){super(),this.type="Bone"}}).prototype.isBone=!0,(class extends hK{constructor(t=null,e=1,i=1,r,n,s,o,a,h=1003,l=1003,u,c){super(null,s,o,a,h,l,r,n,u,c),this.image={data:t,width:e,height:i},this.magFilter=h,this.minFilter=l,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}).prototype.isDataTexture=!0;const pF=/*@__PURE__*/new lE,pB=/*@__PURE__*/new lE,pU=[],pG=/*@__PURE__*/new uB;(class extends uB{constructor(t,e,i){super(t,e),this.instanceMatrix=new ua(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){let i=this.matrixWorld,r=this.count;if(pG.geometry=this.geometry,pG.material=this.material,void 0!==pG.material)for(let n=0;n<r;n++){// calculate the world matrix for each instance
this.getMatrixAt(n,pF),pB.multiplyMatrices(i,pF),// the mesh represents this single instance
pG.matrixWorld=pB,pG.raycast(t,pU);// process the result of raycast
for(let t=0,i=pU.length;t<i;t++){let i=pU[t];i.instanceId=n,i.object=this,e.push(i)}pU.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new ua(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */class pk extends l6{constructor(t){super(),this.type="LineBasicMaterial",this.color=new ur(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}pk.prototype.isLineBasicMaterial=!0;const pH=/*@__PURE__*/new h1,pz=/*@__PURE__*/new h1,pj=/*@__PURE__*/new lE,pV=/*@__PURE__*/new lb,pX=/*@__PURE__*/new lp;class pW extends lY{constructor(t=new uv,e=new pk){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){let t=this.geometry;if(t.isBufferGeometry){// we assume non-indexed geometry
if(null===t.index){let e=t.attributes.position,i=[0];for(let t=1,r=e.count;t<r;t++)pH.fromBufferAttribute(e,t-1),pz.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=pH.distanceTo(pz);t.setAttribute("lineDistance",new uu(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){let i=this.geometry,r=this.matrixWorld,n=t.params.Line.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),pX.copy(i.boundingSphere),pX.applyMatrix4(r),pX.radius+=n,!1===t.ray.intersectsSphere(pX))return;//
pj.copy(r).invert(),pV.copy(t.ray).applyMatrix4(pj);let o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,h=new h1,l=new h1,u=new h1,c=new h1,d=this.isLineSegments?2:1;if(i.isBufferGeometry){let r=i.index,n=i.attributes,o=n.position;if(null!==r){let i=Math.max(0,s.start),n=Math.min(r.count,s.start+s.count);for(let s=i,p=n-1;s<p;s+=d){let i=r.getX(s),n=r.getX(s+1);h.fromBufferAttribute(o,i),l.fromBufferAttribute(o,n);let d=pV.distanceSqToSegment(h,l,c,u);if(d>a)continue;c.applyMatrix4(this.matrixWorld);let p=t.ray.origin.distanceTo(c);p<t.near||p>t.far||e.push({distance:p,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:u.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}else{let i=Math.max(0,s.start),r=Math.min(o.count,s.start+s.count);for(let n=i,s=r-1;n<s;n+=d){h.fromBufferAttribute(o,n),l.fromBufferAttribute(o,n+1);let i=pV.distanceSqToSegment(h,l,c,u);if(i>a)continue;c.applyMatrix4(this.matrixWorld);let r=t.ray.origin.distanceTo(c);r<t.near||r>t.far||e.push({distance:r,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}}else i.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let t=this.geometry;if(t.isBufferGeometry){let e=t.morphAttributes,i=Object.keys(e);if(i.length>0){let t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){let i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{let e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}pW.prototype.isLine=!0;const pY=/*@__PURE__*/new h1,pq=/*@__PURE__*/new h1;class pK extends pW{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){let t=this.geometry;if(t.isBufferGeometry){// we assume non-indexed geometry
if(null===t.index){let e=t.attributes.position,i=[];for(let t=0,r=e.count;t<r;t+=2)pY.fromBufferAttribute(e,t),pq.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+pY.distanceTo(pq);t.setAttribute("lineDistance",new uu(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}pK.prototype.isLineSegments=!0,(class extends pW{constructor(t,e){super(t,e),this.type="LineLoop"}}).prototype.isLineLoop=!0;/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 * }
 */class pJ extends l6{constructor(t){super(),this.type="PointsMaterial",this.color=new ur(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}pJ.prototype.isPointsMaterial=!0;const pZ=/*@__PURE__*/new lE,p$=/*@__PURE__*/new lb,pQ=/*@__PURE__*/new lp,p0=/*@__PURE__*/new h1;class p1 extends lY{constructor(t=new uv,e=new pJ){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){let i=this.geometry,r=this.matrixWorld,n=t.params.Points.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),pQ.copy(i.boundingSphere),pQ.applyMatrix4(r),pQ.radius+=n,!1===t.ray.intersectsSphere(pQ))return;//
pZ.copy(r).invert(),p$.copy(t.ray).applyMatrix4(pZ);let o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o;if(i.isBufferGeometry){let n=i.index,o=i.attributes,h=o.position;if(null!==n){let i=Math.max(0,s.start),o=Math.min(n.count,s.start+s.count);for(let s=i;s<o;s++){let i=n.getX(s);p0.fromBufferAttribute(h,i),p2(p0,i,a,r,t,e,this)}}else{let i=Math.max(0,s.start),n=Math.min(h.count,s.start+s.count);for(let s=i;s<n;s++)p0.fromBufferAttribute(h,s),p2(p0,s,a,r,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let t=this.geometry;if(t.isBufferGeometry){let e=t.morphAttributes,i=Object.keys(e);if(i.length>0){let t=e[i[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,i=t.length;e<i;e++){let i=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=e}}}}else{let e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function p2(t,e,i,r,n,s,o){let a=p$.distanceSqToPoint(t);if(a<i){let i=new h1;p$.closestPointToPoint(t,i),i.applyMatrix4(r);let h=n.ray.origin.distanceTo(i);if(h<n.near||h>n.far)return;s.push({distance:h,distanceToRay:Math.sqrt(a),point:i,index:e,face:null,object:o})}}p1.prototype.isPoints=!0,(class extends hK{constructor(t,e,i,r,n,s,o,a,h){super(t,e,i,r,n,s,o,a,h),this.format=void 0!==o?o:1022,this.minFilter=void 0!==s?s:1006,this.magFilter=void 0!==n?n:1006,this.generateMipmaps=!1;let l=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(function e(){l.needsUpdate=!0,t.requestVideoFrameCallback(e)})}clone(){return new this.constructor(this.image).copy(this)}update(){let t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}).prototype.isVideoTexture=!0,(class extends hK{constructor(t,e,i,r,n,s,o,a,h,l,u,c){super(null,s,o,a,h,l,r,n,u,c),this.image={width:e,height:i},this.mipmaps=t,// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=!1,// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0,(class extends hK{constructor(t,e,i,r,n,s,o,a,h){super(t,e,i,r,n,s,o,a,h),this.needsUpdate=!0}}).prototype.isCanvasTexture=!0,(class extends hK{constructor(t,e,i,r,n,s,o,a,h,l){if(1026!==(l=void 0!==l?l:1026)&&1027!==l)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&1026===l&&(i=1012),void 0===i&&1027===l&&(i=1020),super(null,r,n,s,o,a,l,i,h),this.image={width:t,height:e},this.magFilter=void 0!==o?o:1003,this.minFilter=void 0!==a?a:1003,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isDepthTexture=!0;class p3 extends uv{constructor(t=1,e=8,i=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:r},e=Math.max(3,e);// buffers
let n=[],s=[],o=[],a=[],h=new h1,l=new hX;// center point
s.push(0,0,0),o.push(0,0,1),a.push(.5,.5);for(let n=0,u=3;n<=e;n++,u+=3){let c=i+n/e*r;// vertex
h.x=t*Math.cos(c),h.y=t*Math.sin(c),s.push(h.x,h.y,h.z),// normal
o.push(0,0,1),// uvs
l.x=(s[u]/t+1)/2,l.y=(s[u+1]/t+1)/2,a.push(l.x,l.y)}// indices
for(let t=1;t<=e;t++)n.push(t,t+1,0);// build geometry
this.setIndex(n),this.setAttribute("position",new uu(s,3)),this.setAttribute("normal",new uu(o,3)),this.setAttribute("uv",new uu(a,2))}static fromJSON(t){return new p3(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class p5 extends uv{constructor(t=1,e=1,i=1,r=8,n=1,s=!1,o=0,a=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:r,heightSegments:n,openEnded:s,thetaStart:o,thetaLength:a};let h=this;r=Math.floor(r),n=Math.floor(n);// buffers
let l=[],u=[],c=[],d=[],p=0,f=[],m=i/2,g=0;function y(i){// save the index of the first center vertex
let n=p,s=new hX,f=new h1,y=0,_=!0===i?t:e,v=!0===i?1:-1;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(let t=1;t<=r;t++)// vertex
u.push(0,m*v,0),// normal
c.push(0,v,0),// uv
d.push(.5,.5),// increase index
p++;// save the index of the last center vertex
let x=p;// now we generate the surrounding vertices, normals and uvs
for(let t=0;t<=r;t++){let e=t/r,i=e*a+o,n=Math.cos(i),h=Math.sin(i);// vertex
f.x=_*h,f.y=m*v,f.z=_*n,u.push(f.x,f.y,f.z),// normal
c.push(0,v,0),// uv
s.x=.5*n+.5,s.y=.5*h*v+.5,d.push(s.x,s.y),// increase index
p++}// generate indices
for(let t=0;t<r;t++){let e=n+t,r=x+t;!0===i?l.push(r,r+1,e):l.push(r+1,r,e),y+=3}// add a group to the geometry. this will ensure multi material support
h.addGroup(g,y,!0===i?1:2),// calculate new start value for groups
g+=y}// generate geometry
(function(){let s=new h1,y=new h1,_=0,v=(e-t)/i;// generate vertices, normals and uvs
for(let h=0;h<=n;h++){let l=[],g=h/n,_=g*(e-t)+t;for(let t=0;t<=r;t++){let e=t/r,n=e*a+o,h=Math.sin(n),f=Math.cos(n);// vertex
y.x=_*h,y.y=-g*i+m,y.z=_*f,u.push(y.x,y.y,y.z),// normal
s.set(h,v,f).normalize(),c.push(s.x,s.y,s.z),// uv
d.push(e,1-g),// save index of vertex in respective row
l.push(p++)}// now save vertices of the row in our index array
f.push(l)}// generate indices
for(let t=0;t<r;t++)for(let e=0;e<n;e++){// we use the index array to access the correct indices
let i=f[e][t],r=f[e+1][t],n=f[e+1][t+1],s=f[e][t+1];// faces
l.push(i,r,s),l.push(r,n,s),// update group counter
_+=6}// add a group to the geometry. this will ensure multi material support
h.addGroup(g,_,0),// calculate new start value for groups
g+=_})(),!1===s&&(t>0&&y(!0),e>0&&y(!1)),// build geometry
this.setIndex(l),this.setAttribute("position",new uu(u,3)),this.setAttribute("normal",new uu(c,3)),this.setAttribute("uv",new uu(d,2))}static fromJSON(t){return new p5(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class p4 extends p5{constructor(t=1,e=1,i=8,r=1,n=!1,s=0,o=2*Math.PI){super(0,t,e,i,r,n,s,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:r,openEnded:n,thetaStart:s,thetaLength:o}}static fromJSON(t){return new p4(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class p6 extends uv{constructor(t,e,i=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:r};// default buffer data
let n=[],s=[];function o(t){n.push(t.x,t.y,t.z)}function a(e,i){let r=3*e;i.x=t[r+0],i.y=t[r+1],i.z=t[r+2]}function h(t,e,i,r){r<0&&1===t.x&&(s[e]=t.x-1),0===i.x&&0===i.z&&(s[e]=r/2/Math.PI+.5)}// Angle around the Y axis, counter-clockwise when looking from above.
function l(t){return Math.atan2(t.z,-t.x)}// the subdivision creates the vertex buffer data
// helper functions
(function(t){let i=new h1,r=new h1,n=new h1;// iterate over all faces and apply a subdivison with the given detail value
for(let s=0;s<e.length;s+=3)// get the vertices of the face
a(e[s+0],i),a(e[s+1],r),a(e[s+2],n),// perform subdivision
function(t,e,i,r){let n=r+1,s=[];// construct all of the vertices for this subdivision
for(let r=0;r<=n;r++){s[r]=[];let o=t.clone().lerp(i,r/n),a=e.clone().lerp(i,r/n),h=n-r;for(let t=0;t<=h;t++)0===t&&r===n?s[r][t]=o:s[r][t]=o.clone().lerp(a,t/h)}// construct all of the faces
for(let t=0;t<n;t++)for(let e=0;e<2*(n-t)-1;e++){let i=Math.floor(e/2);e%2==0?(o(s[t][i+1]),o(s[t+1][i]),o(s[t][i])):(o(s[t][i+1]),o(s[t+1][i+1]),o(s[t+1][i]))}}(i,r,n,t)})(r),// all vertices should lie on a conceptual sphere with a given radius
function(t){let e=new h1;// iterate over the entire buffer and apply the radius to each vertex
for(let i=0;i<n.length;i+=3)e.x=n[i+0],e.y=n[i+1],e.z=n[i+2],e.normalize().multiplyScalar(t),n[i+0]=e.x,n[i+1]=e.y,n[i+2]=e.z}(i),// finally, create the uv data
function(){let t=new h1;for(let e=0;e<n.length;e+=3){t.x=n[e+0],t.y=n[e+1],t.z=n[e+2];let i=l(t)/2/Math.PI+.5,r=Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))/Math.PI+.5;s.push(i,1-r)}(function(){let t=new h1,e=new h1,i=new h1,r=new h1,o=new hX,a=new hX,u=new hX;for(let c=0,d=0;c<n.length;c+=9,d+=6){t.set(n[c+0],n[c+1],n[c+2]),e.set(n[c+3],n[c+4],n[c+5]),i.set(n[c+6],n[c+7],n[c+8]),o.set(s[d+0],s[d+1]),a.set(s[d+2],s[d+3]),u.set(s[d+4],s[d+5]),r.copy(t).add(e).add(i).divideScalar(3);let p=l(r);h(o,d+0,t,p),h(a,d+2,e,p),h(u,d+4,i,p)}})(),function(){// handle case when face straddles the seam, see #3269
for(let t=0;t<s.length;t+=6){// uv data of a single face
let e=s[t+0],i=s[t+2],r=s[t+4],n=Math.max(e,i,r),o=Math.min(e,i,r);// 0.9 is somewhat arbitrary
n>.9&&o<.1&&(e<.2&&(s[t+0]+=1),i<.2&&(s[t+2]+=1),r<.2&&(s[t+4]+=1))}}()}(),// build non-indexed geometry
this.setAttribute("position",new uu(n,3)),this.setAttribute("normal",new uu(n.slice(),3)),this.setAttribute("uv",new uu(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new p6(t.vertices,t.indices,t.radius,t.details)}}class p8 extends p6{constructor(t=1,e=0){let i=(1+Math.sqrt(5))/2,r=1/i,n=[// (1, 1, 1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, 1/, )
0,-r,-i,0,-r,i,0,r,-i,0,r,i,// (1/, , 0)
-r,-i,0,-r,i,0,r,-i,0,r,i,0,// (, 0, 1/)
-i,0,-r,i,0,-r,-i,0,r,i,0,r];super(n,[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new p8(t.radius,t.detail)}}new h1,new h1,new h1,new l5;/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/class p7{constructor(){this.type="Curve",this.arcLengthDivisions=200}// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt(t,e){let i=this.getUtoTmapping(t);return this.getPoint(i,e)}// Get sequence of points using getPoint( t )
getPoints(t=5){let e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}// Get sequence of points using getPointAt( u )
getSpacedPoints(t=5){let e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}// Get total curve arc length
getLength(){let t=this.getLengths();return t[t.length-1]}// Get list of cumulative segment lengths
getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let e=[],i,r=this.getPoint(0),n=0;e.push(0);for(let s=1;s<=t;s++)e.push(n+=(i=this.getPoint(s/t)).distanceTo(r)),r=i;return this.cacheArcLengths=e,e;// { sums: cache, sum: sum }; Sum is in the last element.
}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping(t,e){let i;let r=this.getLengths(),n=0,s=r.length;i=e||t*r[s-1];// binary search for the index with largest value smaller than target u distance
let o=0,a=s-1,h;for(;o<=a;)if((h=r[n=Math.floor(o+(a-o)/2)]-i)<0)o=n+1;else if(h>0)a=n-1;else{a=n;break;// DONE
}if(r[n=a]===i)return n/(s-1);// we could get finer grain at lengths, or use simple interpolation between two points
let l=r[n],u=r[n+1],c=(n+(i-l)/(u-l))/(s-1);return c}// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent(t,e){let i=t-1e-4,r=t+1e-4;i<0&&(i=0),r>1&&(r=1);let n=this.getPoint(i),s=this.getPoint(r),o=e||(n.isVector2?new hX:new h1);return o.copy(s).sub(n).normalize(),o}getTangentAt(t,e){let i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
let i=new h1,r=[],n=[],s=[],o=new h1,a=new lE;// compute the tangent vectors for each segment on the curve
for(let e=0;e<=t;e++){let i=e/t;r[e]=this.getTangentAt(i,new h1),r[e].normalize()}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
n[0]=new h1,s[0]=new h1;let h=Number.MAX_VALUE,l=Math.abs(r[0].x),u=Math.abs(r[0].y),c=Math.abs(r[0].z);l<=h&&(h=l,i.set(1,0,0)),u<=h&&(h=u,i.set(0,1,0)),c<=h&&i.set(0,0,1),o.crossVectors(r[0],i).normalize(),n[0].crossVectors(r[0],o),s[0].crossVectors(r[0],n[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(let e=1;e<=t;e++){if(n[e]=n[e-1].clone(),s[e]=s[e-1].clone(),o.crossVectors(r[e-1],r[e]),o.length()>Number.EPSILON){o.normalize();let t=Math.acos(hz(r[e-1].dot(r[e]),-1,1));// clamp for floating pt errors
n[e].applyMatrix4(a.makeRotationAxis(o,t))}s[e].crossVectors(r[e],n[e])}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(!0===e){let e=Math.acos(hz(n[0].dot(n[t]),-1,1));e/=t,r[0].dot(o.crossVectors(n[0],n[t]))>0&&(e=-e);for(let i=1;i<=t;i++)// twist a little...
n[i].applyMatrix4(a.makeRotationAxis(r[i],e*i)),s[i].crossVectors(r[i],n[i])}return{tangents:r,normals:n,binormals:s}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){let t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class p9 extends p7{constructor(t=0,e=0,i=1,r=1,n=0,s=2*Math.PI,o=!1,a=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=r,this.aStartAngle=n,this.aEndAngle=s,this.aClockwise=o,this.aRotation=a}getPoint(t,e){let i=e||new hX,r=2*Math.PI,n=this.aEndAngle-this.aStartAngle,s=Math.abs(n)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
for(;n<0;)n+=r;for(;n>r;)n-=r;n<Number.EPSILON&&(n=s?0:r),!0!==this.aClockwise||s||(n===r?n=-r:n-=r);let o=this.aStartAngle+t*n,a=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){let t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),i=a-this.aX,r=h-this.aY;// Rotate the point about the center of the ellipse.
a=i*t-r*e+this.aX,h=i*e+r*t+this.aY}return i.set(a,h)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){let t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}p9.prototype.isEllipseCurve=!0;class ft extends p9{constructor(t,e,i,r,n,s){super(t,e,i,i,r,n,s),this.type="ArcCurve"}}/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 *//*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function fe(){let t=0,e=0,i=0,r=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function n(n,s,o,a){t=n,e=o,i=-3*n+3*s-2*o-a,r=2*n-2*s+o+a}return{initCatmullRom:function(t,e,i,r,s){n(e,i,s*(i-t),s*(r-e))},initNonuniformCatmullRom:function(t,e,i,r,s,o,a){// compute tangents when parameterized in [t1,t2]
let h=(e-t)/s-(i-t)/(s+o)+(i-e)/o,l=(i-e)/o-(r-e)/(o+a)+(r-i)/a;n(e,i,// rescale tangents for parametrization in [0,1]
h*=o,l*=o)},calc:function(n){let s=n*n;return t+e*n+i*s+r*(s*n)}}}ft.prototype.isArcCurve=!0;//
const fi=new h1,fr=new fe,fn=new fe,fs=new fe;class fo extends p7{constructor(t=[],e=!1,i="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=r}getPoint(t,e=new h1){let i,r;let n=this.points,s=n.length,o=(s-(this.closed?0:1))*t,a=Math.floor(o),h=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:0===h&&a===s-1&&(a=s-2,h=1),this.closed||a>0?i=n[(a-1)%s]:(// extrapolate first point
fi.subVectors(n[0],n[1]).add(n[0]),i=fi);let l=n[a%s],u=n[(a+1)%s];if(this.closed||a+2<s?r=n[(a+2)%s]:(// extrapolate last point
fi.subVectors(n[s-1],n[s-2]).add(n[s-1]),r=fi),"centripetal"===this.curveType||"chordal"===this.curveType){// init Centripetal / Chordal Catmull-Rom
let t="chordal"===this.curveType?.5:.25,e=Math.pow(i.distanceToSquared(l),t),n=Math.pow(l.distanceToSquared(u),t),s=Math.pow(u.distanceToSquared(r),t);n<1e-4&&(n=1),e<1e-4&&(e=n),s<1e-4&&(s=n),fr.initNonuniformCatmullRom(i.x,l.x,u.x,r.x,e,n,s),fn.initNonuniformCatmullRom(i.y,l.y,u.y,r.y,e,n,s),fs.initNonuniformCatmullRom(i.z,l.z,u.z,r.z,e,n,s)}else"catmullrom"===this.curveType&&(fr.initCatmullRom(i.x,l.x,u.x,r.x,this.tension),fn.initCatmullRom(i.y,l.y,u.y,r.y,this.tension),fs.initCatmullRom(i.z,l.z,u.z,r.z,this.tension));return e.set(fr.calc(h),fn.calc(h),fs.calc(h)),e}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){let i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){let t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){let i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){let i=t.points[e];this.points.push(new h1().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */function fa(t,e,i,r,n){let s=(r-e)*.5,o=(n-i)*.5,a=t*t;return(2*i-2*r+s+o)*(t*a)+(-3*i+3*r-2*s-o)*a+s*t+i}function fh(t,e,i,r){return(//
function(t,e){let i=1-t;return i*i*e}(t,e)+2*(1-t)*t*i+t*t*r)}function fl(t,e,i,r,n){return(//
function(t,e){let i=1-t;return i*i*i*e}(t,e)+function(t,e){let i=1-t;return 3*i*i*t*e}(t,i)+3*(1-t)*t*t*r+t*t*t*n)}fo.prototype.isCatmullRomCurve3=!0;class fu extends p7{constructor(t=new hX,e=new hX,i=new hX,r=new hX){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=r}getPoint(t,e=new hX){let i=this.v0,r=this.v1,n=this.v2,s=this.v3;return e.set(fl(t,i.x,r.x,n.x,s.x),fl(t,i.y,r.y,n.y,s.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}fu.prototype.isCubicBezierCurve=!0;class fc extends p7{constructor(t=new h1,e=new h1,i=new h1,r=new h1){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=r}getPoint(t,e=new h1){let i=this.v0,r=this.v1,n=this.v2,s=this.v3;return e.set(fl(t,i.x,r.x,n.x,s.x),fl(t,i.y,r.y,n.y,s.y),fl(t,i.z,r.z,n.z,s.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}fc.prototype.isCubicBezierCurve3=!0;class fd extends p7{constructor(t=new hX,e=new hX){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new hX){return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){let i=e||new hX;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}fd.prototype.isLineCurve=!0;class fp extends p7{constructor(t=new hX,e=new hX,i=new hX){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new hX){let i=this.v0,r=this.v1,n=this.v2;return e.set(fh(t,i.x,r.x,n.x),fh(t,i.y,r.y,n.y)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}fp.prototype.isQuadraticBezierCurve=!0;class ff extends p7{constructor(t=new h1,e=new h1,i=new h1){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new h1){let i=this.v0,r=this.v1,n=this.v2;return e.set(fh(t,i.x,r.x,n.x),fh(t,i.y,r.y,n.y),fh(t,i.z,r.z,n.z)),e}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}ff.prototype.isQuadraticBezierCurve3=!0;class fm extends p7{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new hX){let i=this.points,r=(i.length-1)*t,n=Math.floor(r),s=r-n,o=i[0===n?n:n-1],a=i[n],h=i[n>i.length-2?i.length-1:n+1],l=i[n>i.length-3?i.length-1:n+2];return e.set(fa(s,o.x,a.x,h.x,l.x),fa(s,o.y,a.y,h.y,l.y)),e}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){let i=t.points[e];this.points.push(i.clone())}return this}toJSON(){let t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){let i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){let i=t.points[e];this.points.push(new hX().fromArray(i))}return this}}fm.prototype.isSplineCurve=!0;var fg=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:ft,CatmullRomCurve3:fo,CubicBezierCurve:fu,CubicBezierCurve3:fc,EllipseCurve:p9,LineCurve:fd,LineCurve3:class extends p7{constructor(t=new h1,e=new h1){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new h1){return 1===t?e.copy(this.v2):(e.copy(this.v2).sub(this.v1),e.multiplyScalar(t).add(this.v1)),e}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){let t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}},QuadraticBezierCurve:fp,QuadraticBezierCurve3:ff,SplineCurve:fm});/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */const fy={triangulate:function(t,e,i=2){let r,n,s,o,a,h,l;let u=e&&e.length,c=u?e[0]*i:t.length,d=f_(t,0,c,i,!0),p=[];if(!d||d.next===d.prev)return p;// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(u&&(d=// link every hole into the outer loop, producing a single-ring polygon without holes
function(t,e,i,r){let n,s,o,a,h;let l=[];for(n=0,s=e.length;n<s;n++)o=e[n]*r,a=n<s-1?e[n+1]*r:t.length,(h=f_(t,o,a,r,!1))===h.next&&(h.steiner=!0),l.push(// find the leftmost node of a polygon ring
function(t){let e=t,i=t;do(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next;while(e!==t)return i}(h));// process holes from left to right
for(l.sort(fx),n=0;n<l.length;n++)// find a bridge between vertices that connects hole with an outer ring and and link it
(function(t,e){if(e=// David Eberly's algorithm for finding a bridge between hole and outer polygon
function(t,e){let i=e,r=t.x,n=t.y,s=-1/0,o;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(n<=i.y&&n>=i.next.y&&i.next.y!==i.y){let t=i.x+(n-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(t<=r&&t>s){if(s=t,t===r){if(n===i.y)return i;if(n===i.next.y)return i.next}o=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e)if(!o)return null;if(r===s)return o;// hole touches outer segment; pick leftmost endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
let a=o,h=o.x,l=o.y,u=1/0,c;i=o;do{var d,p;r>=i.x&&i.x>=h&&r!==i.x&&fE(n<l?r:s,n,h,l,n<l?s:r,n,i.x,i.y)&&(c=Math.abs(n-i.y)/(r-i.x),fR(i,t)&&(c<u||c===u&&(i.x>o.x||i.x===o.x&&(d=o,p=i,0>fT(d.prev,d,p.prev)&&0>fT(p.next,d,d.next))))&&(o=i,u=c)),i=i.next}while(i!==a)return o}(t,e)){let i=fC(e,t);// filter collinear points around the cuts
fv(e,e.next),fv(i,i.next)}})(l[n],i),i=fv(i,i.next);return i}(t,e,d,i)),t.length>80*i){r=s=t[0],n=o=t[1];for(let e=i;e<c;e+=i)a=t[e],h=t[e+1],a<r&&(r=a),h<n&&(n=h),a>s&&(s=a),h>o&&(o=h);l=0!==// minX, minY and invSize are later used to transform coords into integers for z-order calculation
(l=Math.max(s-r,o-n))?1/l:0}return(// main ear slicing loop which triangulates a polygon (given as a linked list)
function t(e,i,r,n,s,o,a){if(!e)return;// interlink polygon nodes in z-order
!a&&o&&// interlink polygon nodes in z-order
function(t,e,i,r){let n=t;do null===n.z&&(n.z=fb(n.x,n.y,e,i,r)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==t)n.prevZ.nextZ=null,n.prevZ=null,// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function(t){let e,i,r,n,s,o,a,h,l=1;do{for(i=t,t=null,s=null,o=0;i;){for(o++,r=i,a=0,e=0;e<l&&(a++,r=r.nextZ);e++);for(h=l;a>0||h>0&&r;)0!==a&&(0===h||!r||i.z<=r.z)?(n=i,i=i.nextZ,a--):(n=r,r=r.nextZ,h--),s?s.nextZ=n:t=n,n.prevZ=s,s=n;i=r}s.nextZ=null,l*=2}while(o>1)}(n)}(e,n,s,o);let h=e,l,u;// iterate through ears, slicing them one by one
for(;e.prev!==e.next;){if(l=e.prev,u=e.next,o?function(t,e,i,r){let n=t.prev,s=t.next;if(fT(n,t,s)>=0)return!1;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
let o=n.x<t.x?n.x<s.x?n.x:s.x:t.x<s.x?t.x:s.x,a=n.y<t.y?n.y<s.y?n.y:s.y:t.y<s.y?t.y:s.y,h=n.x>t.x?n.x>s.x?n.x:s.x:t.x>s.x?t.x:s.x,l=n.y>t.y?n.y>s.y?n.y:s.y:t.y>s.y?t.y:s.y,u=fb(o,a,e,i,r),c=fb(h,l,e,i,r),d=t.prevZ,p=t.nextZ;// look for points inside the triangle in both directions
for(;d&&d.z>=u&&p&&p.z<=c;){if(d!==t.prev&&d!==t.next&&fE(n.x,n.y,t.x,t.y,s.x,s.y,d.x,d.y)&&fT(d.prev,d,d.next)>=0||(d=d.prevZ,p!==t.prev&&p!==t.next&&fE(n.x,n.y,t.x,t.y,s.x,s.y,p.x,p.y)&&fT(p.prev,p,p.next)>=0))return!1;p=p.nextZ}// look for remaining points in decreasing z-order
for(;d&&d.z>=u;){if(d!==t.prev&&d!==t.next&&fE(n.x,n.y,t.x,t.y,s.x,s.y,d.x,d.y)&&fT(d.prev,d,d.next)>=0)return!1;d=d.prevZ}// look for remaining points in increasing z-order
for(;p&&p.z<=c;){if(p!==t.prev&&p!==t.next&&fE(n.x,n.y,t.x,t.y,s.x,s.y,p.x,p.y)&&fT(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}(e,n,s,o):// check whether a polygon node forms a valid ear with adjacent nodes
function(t){let e=t.prev,i=t.next;if(fT(e,t,i)>=0)return!1;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
let r=t.next.next;for(;r!==t.prev;){if(fE(e.x,e.y,t.x,t.y,i.x,i.y,r.x,r.y)&&fT(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}(e)){// cut off the triangle
i.push(l.i/r),i.push(e.i/r),i.push(u.i/r),fI(e),// skipping the next vertex leads to less sliver triangles
e=u.next,h=u.next;continue}// if we looped through the whole remaining polygon and can't find any more ears
if((e=u)===h){// try filtering points and slicing again
a?1===a?t(e=// go through all polygon nodes and cure small local self-intersections
function(t,e,i){let r=t;do{let n=r.prev,s=r.next.next;!fw(n,s)&&fS(n,r,r.next,s)&&fR(n,s)&&fR(s,n)&&(e.push(n.i/i),e.push(r.i/i),e.push(s.i/i),// remove two nodes involved
fI(r),fI(r.next),r=t=s),r=r.next}while(r!==t)return fv(r)}(fv(e),i,r),i,r,n,s,o,2):2===a&&// try splitting polygon into two and triangulate them independently
function(e,i,r,n,s,o){// look for a valid diagonal that divides the polygon into two
let a=e;do{let e=a.next.next;for(;e!==a.prev;){var h,l;if(a.i!==e.i&&(h=a,l=e,h.next.i!==l.i&&h.prev.i!==l.i&&!// check if a polygon diagonal intersects any polygon segments
function(t,e){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&fS(i,i.next,t,e))return!0;i=i.next}while(i!==t)return!1}(h,l)&&// dones't intersect other edges
(fR(h,l)&&fR(l,h)&&// check if the middle point of a polygon diagonal is inside the polygon
function(t,e){let i=t,r=!1,n=(t.x+e.x)/2,s=(t.y+e.y)/2;do i.y>s!=i.next.y>s&&i.next.y!==i.y&&n<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==t)return r}(h,l)&&// locally visible
(fT(h.prev,h,l.prev)||fT(h,l.prev,l))||// does not create opposite-facing sectors
fw(h,l)&&fT(h.prev,h,h.next)>0&&fT(l.prev,l,l.next)>0))){// split the polygon in two by the diagonal
let h=fC(a,e);// filter colinear points around the cuts
a=fv(a,a.next),h=fv(h,h.next),// run earcut on each half
t(a,i,r,n,s,o),t(h,i,r,n,s,o);return}e=e.next}a=a.next}while(a!==e)}(e,i,r,n,s,o):t(fv(e),i,r,n,s,o,1);break}}}(d,p,i,r,n,l),p)}};// create a circular doubly linked list from polygon points in the specified winding order
function f_(t,e,i,r,n){let s,o;if(n===function(t,e,i,r){let n=0;for(let s=e,o=i-r;s<i;s+=r)n+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return n}(t,e,i,r)>0)for(s=e;s<i;s+=r)o=fP(s,t[s],t[s+1],o);else for(s=i-r;s>=e;s-=r)o=fP(s,t[s],t[s+1],o);return o&&fw(o,o.next)&&(fI(o),o=o.next),o}// eliminate colinear or duplicate points
function fv(t,e){if(!t)return t;e||(e=t);let i=t,r;do if(r=!1,!i.steiner&&(fw(i,i.next)||0===fT(i.prev,i,i.next))){if(fI(i),(i=e=i.prev)===i.next)break;r=!0}else i=i.next;while(r||i!==e)return e}function fx(t,e){return t.x-e.x}// z-order of a point given coords and inverse of the longer side of data bbox
function fb(t,e,i,r,n){return(t=((t=((t=((t=(// coords are transformed into non-negative 15-bit integer range
(t=32767*(t-i)*n)|t<<8)&16711935)|t<<4)&252645135)|t<<2)&858993459)|t<<1)&1431655765)|(e=((e=((e=((e=((e=32767*(e-r)*n)|e<<8)&16711935)|e<<4)&252645135)|e<<2)&858993459)|e<<1)&1431655765)<<1}// check if a point lies within a convex triangle
function fE(t,e,i,r,n,s,o,a){return(n-o)*(e-a)-(t-o)*(s-a)>=0&&(t-o)*(r-a)-(i-o)*(e-a)>=0&&(i-o)*(s-a)-(n-o)*(r-a)>=0}// signed area of a triangle
function fT(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}// check if two points are equal
function fw(t,e){return t.x===e.x&&t.y===e.y}// check if two segments intersect
function fS(t,e,i,r){let n=fA(fT(t,e,i)),s=fA(fT(t,e,r)),o=fA(fT(i,r,t)),a=fA(fT(i,r,e));return!!(n!==s&&o!==a||0===n&&fM(t,i,e)||0===s&&fM(t,r,e)||0===o&&fM(i,t,r)||0===a&&fM(i,e,r))}// for collinear points p, q, r, check if point q lies on segment pr
function fM(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function fA(t){return t>0?1:t<0?-1:0}// check if a polygon diagonal is locally inside the polygon
function fR(t,e){return 0>fT(t.prev,t,t.next)?fT(t,e,t.next)>=0&&fT(t,t.prev,e)>=0:0>fT(t,e,t.prev)||0>fT(t,t.next,e)}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function fC(t,e){let i=new fO(t.i,t.x,t.y),r=new fO(e.i,e.x,e.y),n=t.next,s=e.prev;return t.next=e,e.prev=t,i.next=n,n.prev=i,r.next=i,i.prev=r,s.next=r,r.prev=s,r}// create a node and optionally link it with previous one (in a circular doubly linked list)
function fP(t,e,i,r){let n=new fO(t,e,i);return r?(n.next=r.next,n.prev=r,r.next.prev=n,r.next=n):(n.prev=n,n.next=n),n}function fI(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function fO(t,e,i){// vertex index in coordinates array
this.i=t,// vertex coordinates
this.x=e,this.y=i,// previous and next vertex nodes in a polygon ring
this.prev=null,this.next=null,// z-order curve value
this.z=null,// previous and next nodes in z-order
this.prevZ=null,this.nextZ=null,// indicates whether this is a steiner point
this.steiner=!1}class fL{// calculate area of the contour polygon
static area(t){let e=t.length,i=0;for(let r=e-1,n=0;n<e;r=n++)i+=t[r].x*t[n].y-t[n].x*t[r].y;return .5*i}static isClockWise(t){return 0>fL.area(t)}static triangulateShape(t,e){let i=[],r=[],n=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
fN(t),fD(i,t);//
let s=t.length;e.forEach(fN);for(let t=0;t<e.length;t++)r.push(s),s+=e[t].length,fD(i,e[t]);//
let o=fy.triangulate(i,r);//
for(let t=0;t<o.length;t+=3)n.push(o.slice(t,t+3));return n}}function fN(t){let e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function fD(t,e){for(let i=0;i<e.length;i++)t.push(e[i].x),t.push(e[i].y)}/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */class fF extends uv{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];let i=this,r=[],n=[];for(let s=0,o=t.length;s<o;s++){let o=t[s];!// functions
function(t){let s,o,a,h;let l=[],u=void 0!==e.curveSegments?e.curveSegments:12,c=void 0!==e.steps?e.steps:1,d=void 0!==e.depth?e.depth:100,p=void 0===e.bevelEnabled||e.bevelEnabled,f=void 0!==e.bevelThickness?e.bevelThickness:6,m=void 0!==e.bevelSize?e.bevelSize:f-2,g=void 0!==e.bevelOffset?e.bevelOffset:0,y=void 0!==e.bevelSegments?e.bevelSegments:3,_=e.extrudePath,v=void 0!==e.UVGenerator?e.UVGenerator:fB;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),d=e.amount);//
let x,b=!1;_&&(x=_.getSpacedPoints(c),b=!0,p=!1,// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
s=_.computeFrenetFrames(c,!1),// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
o=new h1,a=new h1,h=new h1),p||(y=0,f=0,m=0,g=0);// Variables initialization
let E=t.extractPoints(u),T=E.shape,w=E.holes,S=!fL.isClockWise(T);if(S){T=T.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(let t=0,e=w.length;t<e;t++){let e=w[t];fL.isClockWise(e)&&(w[t]=e.reverse())}}let M=fL.triangulateShape(T,w),A=T;for(let t=0,e=w.length;t<e;t++){let e=w[t];T=T.concat(e)}function R(t,e,i){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(i).add(t)}let C=T.length,P=M.length;// Find directions for point movement
function I(t,e,i){let r,n,s;// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
let o=t.x-e.x,a=t.y-e.y,h=i.x-t.x,l=i.y-t.y,u=o*o+a*a,c=o*l-a*h;if(Math.abs(c)>Number.EPSILON){// not collinear
// length of vectors for normalizing
let c=Math.sqrt(u),d=Math.sqrt(h*h+l*l),p=e.x-a/c,f=e.y+o/c,m=i.x-l/d,g=i.y+h/d,y=((m-p)*l-(g-f)*h)/(o*l-a*h);// vector from inPt to intersection point
r=p+o*y-t.x,n=f+a*y-t.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
let _=r*r+n*n;if(_<=2)return new hX(r,n);s=Math.sqrt(_/2)}else{// handle special case of collinear edges
let t=!1;// assumes: opposite
o>Number.EPSILON?h>Number.EPSILON&&(t=!0):o<-Number.EPSILON?h<-Number.EPSILON&&(t=!0):Math.sign(a)===Math.sign(l)&&(t=!0),t?(// console.log("Warning: lines are a straight sequence");
r=-a,n=o,s=Math.sqrt(u)):(// console.log("Warning: lines are a straight spike");
r=o,n=a,s=Math.sqrt(u/2))}return new hX(r/s,n/s)}let O=[];for(let t=0,e=A.length,i=e-1,r=t+1;t<e;t++,i++,r++)i===e&&(i=0),r===e&&(r=0),//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
O[t]=I(A[t],A[i],A[r]);let L=[],N,D=O.concat();for(let t=0,e=w.length;t<e;t++){let e=w[t];N=[];for(let t=0,i=e.length,r=i-1,n=t+1;t<i;t++,r++,n++)r===i&&(r=0),n===i&&(n=0),//  (j)---(i)---(k)
N[t]=I(e[t],e[r],e[n]);L.push(N),D=D.concat(N)}// Loop bevelSegments, 1 for the front, 1 for the back
for(let t=0;t<y;t++){//for ( b = bevelSegments; b > 0; b -- ) {
let e=t/y,i=f*Math.cos(e*Math.PI/2),r=m*Math.sin(e*Math.PI/2)+g;// contract shape
for(let t=0,e=A.length;t<e;t++){let e=R(A[t],O[t],r);U(e.x,e.y,-i)}// expand holes
for(let t=0,e=w.length;t<e;t++){let e=w[t];N=L[t];for(let t=0,n=e.length;t<n;t++){let n=R(e[t],N[t],r);U(n.x,n.y,-i)}}}let F=m+g;// Back facing vertices
for(let t=0;t<C;t++){let e=p?R(T[t],D[t],F):T[t];b?(// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
a.copy(s.normals[0]).multiplyScalar(e.x),o.copy(s.binormals[0]).multiplyScalar(e.y),h.copy(x[0]).add(a).add(o),U(h.x,h.y,h.z)):U(e.x,e.y,0)}// Add stepped vertices...
// Including front facing vertices
for(let t=1;t<=c;t++)for(let e=0;e<C;e++){let i=p?R(T[e],D[e],F):T[e];b?(// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
a.copy(s.normals[t]).multiplyScalar(i.x),o.copy(s.binormals[t]).multiplyScalar(i.y),h.copy(x[t]).add(a).add(o),U(h.x,h.y,h.z)):U(i.x,i.y,d/c*t)}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(let t=y-1;t>=0;t--){let e=t/y,i=f*Math.cos(e*Math.PI/2),r=m*Math.sin(e*Math.PI/2)+g;// contract shape
for(let t=0,e=A.length;t<e;t++){let e=R(A[t],O[t],r);U(e.x,e.y,d+i)}// expand holes
for(let t=0,e=w.length;t<e;t++){let e=w[t];N=L[t];for(let t=0,n=e.length;t<n;t++){let n=R(e[t],N[t],r);b?U(n.x,n.y+x[c-1].y,x[c-1].x+i):U(n.x,n.y,d+i)}}}function B(t,e){let n=t.length;for(;--n>=0;){let s=n,o=n-1;o<0&&(o=t.length-1);//console.log('b', i,j, i-1, k,vertices.length);
for(let t=0,n=c+2*y;t<n;t++){let n=C*t,a=C*(t+1),h=e+s+n,l=e+o+n,u=e+o+a,c=e+s+a;!function(t,e,n,s){k(t),k(e),k(s),k(e),k(n),k(s);let o=r.length/3,a=v.generateSideWallUV(i,r,o-6,o-3,o-2,o-1);H(a[0]),H(a[1]),H(a[3]),H(a[1]),H(a[2]),H(a[3])}(h,l,u,c)}}}function U(t,e,i){l.push(t),l.push(e),l.push(i)}function G(t,e,n){k(t),k(e),k(n);let s=r.length/3,o=v.generateTopUV(i,r,s-3,s-2,s-1);H(o[0]),H(o[1]),H(o[2])}function k(t){r.push(l[3*t+0]),r.push(l[3*t+1]),r.push(l[3*t+2])}function H(t){n.push(t.x),n.push(t.y)}/* Faces */// Top and bottom faces
/////  Internal functions
(function(){let t=r.length/3;if(p){let t=0*C;// steps + 1
// Bottom faces
for(let e=0;e<P;e++){let i=M[e];G(i[2]+t,i[1]+t,i[0]+t)}t=C*(c+2*y);// Top faces
for(let e=0;e<P;e++){let i=M[e];G(i[0]+t,i[1]+t,i[2]+t)}}else{// Bottom faces
for(let t=0;t<P;t++){let e=M[t];G(e[2],e[1],e[0])}// Top faces
for(let t=0;t<P;t++){let e=M[t];G(e[0]+C*c,e[1]+C*c,e[2]+C*c)}}i.addGroup(t,r.length/3-t,0)})(),// Sides faces
// Create faces for the z-sides of the shape
function(){let t=r.length/3,e=0;B(A,0),e+=A.length;for(let t=0,i=w.length;t<i;t++){let i=w[t];B(i,e),//, true
e+=i.length}i.addGroup(t,r.length/3-t,1)}()}(o)}// build geometry
this.setAttribute("position",new uu(r,3)),this.setAttribute("uv",new uu(n,2)),this.computeVertexNormals()}toJSON(){let t=super.toJSON(),e=this.parameters.shapes,i=this.parameters.options;return function(t,e,i){if(i.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){let r=t[e];i.shapes.push(r.uuid)}else i.shapes.push(t.uuid);return void 0!==e.extrudePath&&(i.options.extrudePath=e.extrudePath.toJSON()),i}(e,i,t)}static fromJSON(t,e){let i=[];for(let r=0,n=t.shapes.length;r<n;r++){let n=e[t.shapes[r]];i.push(n)}let r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=new fg[r.type]().fromJSON(r)),new fF(i,t.options)}}const fB={generateTopUV:function(t,e,i,r,n){let s=e[3*i],o=e[3*i+1],a=e[3*r],h=e[3*r+1],l=e[3*n],u=e[3*n+1];return[new hX(s,o),new hX(a,h),new hX(l,u)]},generateSideWallUV:function(t,e,i,r,n,s){let o=e[3*i],a=e[3*i+1],h=e[3*i+2],l=e[3*r],u=e[3*r+1],c=e[3*r+2],d=e[3*n],p=e[3*n+1],f=e[3*n+2],m=e[3*s],g=e[3*s+1],y=e[3*s+2];return Math.abs(a-u)<Math.abs(o-l)?[new hX(o,1-h),new hX(l,1-c),new hX(d,1-f),new hX(m,1-y)]:[new hX(a,1-h),new hX(u,1-c),new hX(p,1-f),new hX(g,1-y)]}};class fU extends p6{constructor(t=1,e=0){let i=(1+Math.sqrt(5))/2,r=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1];super(r,[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new fU(t.radius,t.detail)}}class fG extends uv{constructor(t,e=12,i=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:r},e=Math.floor(e),// clamp phiLength so it's in range of [ 0, 2PI ]
r=hz(r,0,2*Math.PI);// buffers
let n=[],s=[],o=[],a=1/e,h=new h1,l=new hX;// generate vertices and uvs
for(let n=0;n<=e;n++){let u=i+n*a*r,c=Math.sin(u),d=Math.cos(u);for(let i=0;i<=t.length-1;i++)// vertex
h.x=t[i].x*c,h.y=t[i].y,h.z=t[i].x*d,s.push(h.x,h.y,h.z),// uv
l.x=n/e,l.y=i/(t.length-1),o.push(l.x,l.y)}// indices
for(let i=0;i<e;i++)for(let e=0;e<t.length-1;e++){let r=e+i*t.length,s=r+t.length,o=r+t.length+1,a=r+1;// faces
n.push(r,s,a),n.push(s,o,a)}// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).
if(// build geometry
this.setIndex(n),this.setAttribute("position",new uu(s,3)),this.setAttribute("uv",new uu(o,2)),// generate normals
this.computeVertexNormals(),r===2*Math.PI){let i=this.attributes.normal.array,r=new h1,n=new h1,s=new h1,o=e*t.length*3;for(let e=0,a=0;e<t.length;e++,a+=3)// select the normal of the vertex in the first line
r.x=i[a+0],r.y=i[a+1],r.z=i[a+2],// select the normal of the vertex in the last line
n.x=i[o+a+0],n.y=i[o+a+1],n.z=i[o+a+2],// average normals
s.addVectors(r,n).normalize(),// assign the new values to both normals
i[a+0]=i[o+a+0]=s.x,i[a+1]=i[o+a+1]=s.y,i[a+2]=i[o+a+2]=s.z}}static fromJSON(t){return new fG(t.points,t.segments,t.phiStart,t.phiLength)}}class fk extends p6{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new fk(t.radius,t.detail)}}class fH extends uv{constructor(t=.5,e=1,i=8,r=1,n=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:r,thetaStart:n,thetaLength:s},i=Math.max(3,i),r=Math.max(1,r);// buffers
let o=[],a=[],h=[],l=[],u=t,c=(e-t)/r,d=new h1,p=new hX;// generate vertices, normals and uvs
for(let t=0;t<=r;t++){for(let t=0;t<=i;t++){// values are generate from the inside of the ring to the outside
let r=n+t/i*s;// vertex
d.x=u*Math.cos(r),d.y=u*Math.sin(r),a.push(d.x,d.y,d.z),// normal
h.push(0,0,1),// uv
p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,l.push(p.x,p.y)}// increase the radius for next row of vertices
u+=c}// indices
for(let t=0;t<r;t++){let e=t*(i+1);for(let t=0;t<i;t++){let r=t+e,n=r+i+1,s=r+i+2,a=r+1;// faces
o.push(r,n,a),o.push(n,s,a)}}// build geometry
this.setIndex(o),this.setAttribute("position",new uu(a,3)),this.setAttribute("normal",new uu(h,3)),this.setAttribute("uv",new uu(l,2))}static fromJSON(t){return new fH(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class fz extends uv{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};// buffers
let i=[],r=[],n=[],s=[],o=0,a=0;// allow single and array values for "shapes" parameter
if(!1===Array.isArray(t))h(t);else for(let e=0;e<t.length;e++)h(t[e]),this.addGroup(o,a,e),o+=a,a=0;// helper functions
function h(t){let o=r.length/3,h=t.extractPoints(e),l=h.shape,u=h.holes;// check direction of vertices
!1===fL.isClockWise(l)&&(l=l.reverse());for(let t=0,e=u.length;t<e;t++){let e=u[t];!0===fL.isClockWise(e)&&(u[t]=e.reverse())}let c=fL.triangulateShape(l,u);// join vertices of inner and outer paths to a single array
for(let t=0,e=u.length;t<e;t++){let e=u[t];l=l.concat(e)}// vertices, normals, uvs
for(let t=0,e=l.length;t<e;t++){let e=l[t];r.push(e.x,e.y,0),n.push(0,0,1),s.push(e.x,e.y)}// incides
for(let t=0,e=c.length;t<e;t++){let e=c[t],r=e[0]+o,n=e[1]+o,s=e[2]+o;i.push(r,n,s),a+=3}}// build geometry
this.setIndex(i),this.setAttribute("position",new uu(r,3)),this.setAttribute("normal",new uu(n,3)),this.setAttribute("uv",new uu(s,2))}toJSON(){let t=super.toJSON(),e=this.parameters.shapes;return function(t,e){if(e.shapes=[],Array.isArray(t))for(let i=0,r=t.length;i<r;i++){let r=t[i];e.shapes.push(r.uuid)}else e.shapes.push(t.uuid);return e}(e,t)}static fromJSON(t,e){let i=[];for(let r=0,n=t.shapes.length;r<n;r++){let n=e[t.shapes[r]];i.push(n)}return new fz(i,t.curveSegments)}}class fj extends uv{constructor(t=1,e=32,i=16,r=0,n=2*Math.PI,s=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:r,phiLength:n,thetaStart:s,thetaLength:o},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));let a=Math.min(s+o,Math.PI),h=0,l=[],u=new h1,c=new h1,d=[],p=[],f=[],m=[];// generate vertices, normals and uvs
for(let d=0;d<=i;d++){let g=[],y=d/i,_=0;0==d&&0==s?_=.5/e:d==i&&a==Math.PI&&(_=-.5/e);for(let i=0;i<=e;i++){let a=i/e;// vertex
u.x=-t*Math.cos(r+a*n)*Math.sin(s+y*o),u.y=t*Math.cos(s+y*o),u.z=t*Math.sin(r+a*n)*Math.sin(s+y*o),p.push(u.x,u.y,u.z),// normal
c.copy(u).normalize(),f.push(c.x,c.y,c.z),// uv
m.push(a+_,1-y),g.push(h++)}l.push(g)}// indices
for(let t=0;t<i;t++)for(let r=0;r<e;r++){let e=l[t][r+1],n=l[t][r],o=l[t+1][r],h=l[t+1][r+1];(0!==t||s>0)&&d.push(e,n,h),(t!==i-1||a<Math.PI)&&d.push(n,o,h)}// build geometry
this.setIndex(d),this.setAttribute("position",new uu(p,3)),this.setAttribute("normal",new uu(f,3)),this.setAttribute("uv",new uu(m,2))}static fromJSON(t){return new fj(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class fV extends p6{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new fV(t.radius,t.detail)}}class fX extends uv{constructor(t=1,e=.4,i=8,r=6,n=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:r,arc:n},i=Math.floor(i),r=Math.floor(r);// buffers
let s=[],o=[],a=[],h=[],l=new h1,u=new h1,c=new h1;// generate vertices, normals and uvs
for(let s=0;s<=i;s++)for(let d=0;d<=r;d++){let p=d/r*n,f=s/i*Math.PI*2;// vertex
u.x=(t+e*Math.cos(f))*Math.cos(p),u.y=(t+e*Math.cos(f))*Math.sin(p),u.z=e*Math.sin(f),o.push(u.x,u.y,u.z),// normal
l.x=t*Math.cos(p),l.y=t*Math.sin(p),c.subVectors(u,l).normalize(),a.push(c.x,c.y,c.z),// uv
h.push(d/r),h.push(s/i)}// generate indices
for(let t=1;t<=i;t++)for(let e=1;e<=r;e++){// indices
let i=(r+1)*t+e-1,n=(r+1)*(t-1)+e-1,o=(r+1)*(t-1)+e,a=(r+1)*t+e;// faces
s.push(i,n,a),s.push(n,o,a)}// build geometry
this.setIndex(s),this.setAttribute("position",new uu(o,3)),this.setAttribute("normal",new uu(a,3)),this.setAttribute("uv",new uu(h,2))}static fromJSON(t){return new fX(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class fW extends uv{constructor(t=1,e=.4,i=64,r=8,n=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:r,p:n,q:s},i=Math.floor(i),r=Math.floor(r);// buffers
let o=[],a=[],h=[],l=[],u=new h1,c=new h1,d=new h1,p=new h1,f=new h1,m=new h1,g=new h1;// generate vertices, normals and uvs
for(let o=0;o<=i;++o){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
let _=o/i*n*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
y(_,n,s,t,d),y(_+.01,n,s,t,p),// calculate orthonormal basis
m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),// normalize B, N. T can be ignored, we don't use it
f.normalize(),g.normalize();for(let t=0;t<=r;++t){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
let n=t/r*Math.PI*2,s=-e*Math.cos(n),p=e*Math.sin(n);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
u.x=d.x+(s*g.x+p*f.x),u.y=d.y+(s*g.y+p*f.y),u.z=d.z+(s*g.z+p*f.z),a.push(u.x,u.y,u.z),// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
c.subVectors(u,d).normalize(),h.push(c.x,c.y,c.z),// uv
l.push(o/i),l.push(t/r)}}// generate indices
for(let t=1;t<=i;t++)for(let e=1;e<=r;e++){// indices
let i=(r+1)*(t-1)+(e-1),n=(r+1)*t+(e-1),s=(r+1)*t+e,a=(r+1)*(t-1)+e;// faces
o.push(i,n,a),o.push(n,s,a)}// this function calculates the current position on the torus curve
function y(t,e,i,r,n){let s=Math.cos(t),o=Math.sin(t),a=i/e*t,h=Math.cos(a);n.x=r*(2+h)*.5*s,n.y=r*(2+h)*o*.5,n.z=r*Math.sin(a)*.5}// build geometry
this.setIndex(o),this.setAttribute("position",new uu(a,3)),this.setAttribute("normal",new uu(h,3)),this.setAttribute("uv",new uu(l,2))}static fromJSON(t){return new fW(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class fY extends uv{constructor(t,e=64,i=1,r=8,n=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:r,closed:n};let s=t.computeFrenetFrames(e,n);// expose internals
this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;// helper variables
let o=new h1,a=new h1,h=new hX,l=new h1,u=[],c=[],d=[],p=[];function f(n){// we use getPointAt to sample evenly distributed points from the given path
l=t.getPointAt(n/e,l);// retrieve corresponding normal and binormal
let h=s.normals[n],d=s.binormals[n];// generate normals and vertices for the current segment
for(let t=0;t<=r;t++){let e=t/r*Math.PI*2,n=Math.sin(e),s=-Math.cos(e);// normal
a.x=s*h.x+n*d.x,a.y=s*h.y+n*d.y,a.z=s*h.z+n*d.z,a.normalize(),c.push(a.x,a.y,a.z),// vertex
o.x=l.x+i*a.x,o.y=l.y+i*a.y,o.z=l.z+i*a.z,u.push(o.x,o.y,o.z)}}// create buffer data
// functions
(function(){for(let t=0;t<e;t++)f(t);// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
f(!1===n?e:0),// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
function(){for(let t=0;t<=e;t++)for(let i=0;i<=r;i++)h.x=t/e,h.y=i/r,d.push(h.x,h.y)}(),// finally create faces
function(){for(let t=1;t<=e;t++)for(let e=1;e<=r;e++){let i=(r+1)*(t-1)+(e-1),n=(r+1)*t+(e-1),s=(r+1)*t+e,o=(r+1)*(t-1)+e;// faces
p.push(i,n,o),p.push(n,s,o)}}()})(),// build geometry
this.setIndex(p),this.setAttribute("position",new uu(u,3)),this.setAttribute("normal",new uu(c,3)),this.setAttribute("uv",new uu(d,2))}toJSON(){let t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
return new fY(new fg[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */(class extends l6{constructor(t){super(),this.type="ShadowMaterial",this.color=new ur(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}).prototype.isShadowMaterial=!0;/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */class fq extends l6{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ur(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ur(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new hX(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}fq.prototype.isMeshStandardMaterial=!0,/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationTint: <Color>,
 *
 *  specularIntensity: <float>,
 *  specularIntensityhMap: new THREE.Texture( <Image> ),
 *  specularTint: <Color>,
 *  specularTintMap: new THREE.Texture( <Image> )
 * }
 */(class extends fq{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new hX(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=hz(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new ur(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new ur(1,1,1),this.specularTintMap=null,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.reflectivity=t.reflectivity,t.sheen?this.sheen=(this.sheen||new ur).copy(t.sheen):this.sheen=null,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}).prototype.isMeshPhysicalMaterial=!0,/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */(class extends l6{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new ur(16777215),this.specular=new ur(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ur(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new hX(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}).prototype.isMeshPhongMaterial=!0,/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */(class extends l6{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ur(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ur(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new hX(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshToonMaterial=!0,/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  flatShading: <bool>
 * }
 */(class extends l6{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new hX(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}).prototype.isMeshNormalMaterial=!0,/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */(class extends l6{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new ur(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ur(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}).prototype.isMeshLambertMaterial=!0,/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  flatShading: <bool>
 * }
 */(class extends l6{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ur(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new hX(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}).prototype.isMeshMatcapMaterial=!0,/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */(class extends pk{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}).prototype.isLineDashedMaterial=!0;const fK={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function(t,e,i){return fK.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==i?i:t.length)):t.slice(e,i)},// converts an array to a specific type
convertArray:function(t,e,i){return t&&// let 'undefined' and 'null' pass
(i||t.constructor!==e)?"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t):t},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},// returns an array by which times and values can be sorted
getKeyframeOrder:function(t){let e=t.length,i=Array(e);for(let t=0;t!==e;++t)i[t]=t;return i.sort(function(e,i){return t[e]-t[i]}),i},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function(t,e,i){let r=t.length,n=new t.constructor(r);for(let s=0,o=0;o!==r;++s){let r=i[s]*e;for(let i=0;i!==e;++i)n[o++]=t[r+i]}return n},// function for parsing AOS keyframe formats
flattenJSON:function(t,e,i,r){let n=1,s=t[0];for(;void 0!==s&&void 0===s[r];)s=t[n++];if(void 0===s)return;// no data
let o=s[r];if(void 0!==o){if(Array.isArray(o))do void 0!==(o=s[r])&&(e.push(s.time),i.push.apply(i,o)),s=t[n++];while(void 0!==s)else if(void 0!==o.toArray)do void 0!==(o=s[r])&&(e.push(s.time),o.toArray(i,i.length)),s=t[n++];while(void 0!==s)else do void 0!==(o=s[r])&&(e.push(s.time),i.push(o)),s=t[n++];while(void 0!==s)}// no data
},subclip:function(t,e,i,r,n=30){let s=t.clone();s.name=e;let o=[];for(let t=0;t<s.tracks.length;++t){let e=s.tracks[t],a=e.getValueSize(),h=[],l=[];for(let t=0;t<e.times.length;++t){let s=e.times[t]*n;if(!(s<i)&&!(s>=r)){h.push(e.times[t]);for(let i=0;i<a;++i)l.push(e.values[t*a+i])}}0!==h.length&&(e.times=fK.convertArray(h,e.times.constructor),e.values=fK.convertArray(l,e.values.constructor),o.push(e))}s.tracks=o;// find minimum .times value across all tracks in the trimmed clip
let a=1/0;for(let t=0;t<s.tracks.length;++t)a>s.tracks[t].times[0]&&(a=s.tracks[t].times[0]);// shift all tracks such that clip begins at t=0
for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,i=t,r=30){r<=0&&(r=30);let n=i.tracks.length,s=e/r;// Make each track's values relative to the values at the reference frame
for(let e=0;e<n;++e){let r;let n=i.tracks[e],o=n.ValueTypeName;// Skip this track if it's non-numeric
if("bool"===o||"string"===o)continue;// Find the track in the target clip whose name and type matches the reference track
let a=t.tracks.find(function(t){return t.name===n.name&&t.ValueTypeName===o});if(void 0===a)continue;let h=0,l=n.getValueSize();n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=l/3);let u=0,c=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=c/3);let d=n.times.length-1;// Find the value to subtract out of the track
if(s<=n.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
let t=h,e=l-h;r=fK.arraySlice(n.values,t,e)}else if(s>=n.times[d]){// Reference frame is after the last keyframe, so just use the last keyframe
let t=d*l+h,e=t+l-h;r=fK.arraySlice(n.values,t,e)}else{// Interpolate to the reference value
let t=n.createInterpolant(),e=h,i=l-h;t.evaluate(s),r=fK.arraySlice(t.resultBuffer,e,i)}// Conjugate the quaternion
if("quaternion"===o){let t=new h0().fromArray(r).normalize().conjugate();t.toArray(r)}// Subtract the reference value from all of the track values
let p=a.times.length;for(let t=0;t<p;++t){let e=t*c+u;if("quaternion"===o)h0.multiplyQuaternionsFlat(a.values,e,r,0,a.values,e);else{let t=c-2*u;// Subtract each value for all other numeric track types
for(let i=0;i<t;++i)a.values[e+i]-=r[i]}}}return t.blendMode=2501,t}};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */class fJ{constructor(t,e,i,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){let e=this.parameterPositions,i=this._cachedIndex,r=e[i],n=e[i-1];t:{e:{let s;i:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
r:if(!(t<r)){for(let s=i+2;;){if(void 0===r){if(t<n)break r;return(// after end
i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,t,n))}if(i===s)break;// this loop
if(n=r,t<(r=e[++i]))break e}// prepare binary search on the right side of the index
s=e.length;break i}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=n)){// looping?
let o=e[1];t<o&&(i=2,n=o);// linear reverse scan
for(let s=i-2;;){if(void 0===n)return(// before start
this._cachedIndex=0,this.beforeStart_(0,t,r));if(i===s)break;// this loop
if(r=n,t>=(n=e[--i-1]))break e}// prepare binary search on the left side of the index
s=i,i=0;break i}break t}// linear scan
// binary search
for(;i<s;){let r=i+s>>>1;t<e[r]?s=r:i=r+1}// check boundary cases, again
if(r=e[i],void 0===(n=e[i-1]))return this._cachedIndex=0,this.beforeStart_(0,t,r);if(void 0===r)return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,n,t)}// seek
this._cachedIndex=i,this.intervalChanged_(i,n,r)}// validate_interval
return this.interpolate_(i,n,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){// copies a sample value to the result buffer
let e=this.resultBuffer,i=this.sampleValues,r=this.valueSize,n=t*r;for(let t=0;t!==r;++t)e[t]=i[n+t];return e}// Template methods for derived classes:
interpolate_(){throw Error("call to abstract method");// implementations shall return this.resultBuffer
}intervalChanged_(){// empty
}}// ALIAS DEFINITIONS
fJ.prototype.beforeStart_=fJ.prototype.copySampleValue_,fJ.prototype.afterEnd_=fJ.prototype.copySampleValue_;/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */class fZ extends fJ{constructor(t,e,i,r){super(t,e,i,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,i){let r=this.parameterPositions,n=t-2,s=t+1,o=r[n],a=r[s];if(void 0===o)switch(this.getSettings_().endingStart){case 2401:// f'(t0) = 0
n=t,o=2*e-i;break;case 2402:// use the other end of the curve
n=r.length-2,o=e+r[n]-r[n+1];break;default:// f''(t0) = 0 a.k.a. Natural Spline
n=t,o=i}if(void 0===a)switch(this.getSettings_().endingEnd){case 2401:// f'(tN) = 0
s=t,a=2*i-e;break;case 2402:// use the other end of the curve
s=1,a=i+r[1]-r[0];break;default:// f''(tN) = 0, a.k.a. Natural Spline
s=t-1,a=e}let h=(i-e)*.5,l=this.valueSize;this._weightPrev=h/(e-o),this._weightNext=h/(a-i),this._offsetPrev=n*l,this._offsetNext=s*l}interpolate_(t,e,i,r){let n=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,h=a-o,l=this._offsetPrev,u=this._offsetNext,c=this._weightPrev,d=this._weightNext,p=(i-e)/(r-e),f=p*p,m=f*p,g=-c*m+2*c*f-c*p,y=(1+c)*m+(-1.5-2*c)*f+(-.5+c)*p+1,_=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;// combine data linearly
for(let t=0;t!==o;++t)n[t]=g*s[l+t]+y*s[h+t]+_*s[a+t]+v*s[u+t];return n}}class f$ extends fJ{constructor(t,e,i,r){super(t,e,i,r)}interpolate_(t,e,i,r){let n=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=t*o,h=a-o,l=(i-e)/(r-e),u=1-l;for(let t=0;t!==o;++t)n[t]=s[h+t]*u+s[a+t]*l;return n}}/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */class fQ extends fJ{constructor(t,e,i,r){super(t,e,i,r)}interpolate_(t/*, t0, t, t1 */){return this.copySampleValue_(t-1)}}class f0{constructor(t,e,i,r){if(void 0===t)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=fK.convertArray(e,this.TimeBufferType),this.values=fK.convertArray(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
static toJSON(t){let e;let i=t.constructor;// derived classes can define a static toJSON method
if(i.toJSON!==this.toJSON)e=i.toJSON(t);else{// by default, we assume the data can be serialized as-is
e={name:t.name,times:fK.convertArray(t.times,Array),values:fK.convertArray(t.values,Array)};let i=t.getInterpolation();i!==t.DefaultInterpolation&&(e.interpolation=i)}return e.type=t.ValueTypeName,e}InterpolantFactoryMethodDiscrete(t){return new fQ(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new f$(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new fZ(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){let e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){// fall back to default, unless the default itself is messed up
if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(e);// fatal, in this case
}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}// move all keyframes either forwards or backwards in time
shift(t){if(0!==t){let e=this.times;for(let i=0,r=e.length;i!==r;++i)e[i]+=t}return this}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale(t){if(1!==t){let e=this.times;for(let i=0,r=e.length;i!==r;++i)e[i]*=t}return this}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim(t,e){let i=this.times,r=i.length,n=0,s=r-1;for(;n!==r&&i[n]<t;)++n;for(;-1!==s&&i[s]>e;)--s;if(++s,0!==n||s!==r){n>=s&&(n=(s=Math.max(s,1))-1);let t=this.getValueSize();this.times=fK.arraySlice(i,n,s),this.values=fK.arraySlice(this.values,n*t,s*t)}return this}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate(){let t=!0,e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);let i=this.times,r=this.values,n=i.length;0===n&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==n;e++){let r=i[e];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,r),t=!1;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,r,s),t=!1;break}s=r}if(void 0!==r&&fK.isTypedArray(r))for(let e=0,i=r.length;e!==i;++e){let i=r[e];if(isNaN(i)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,i),t=!1;break}}return t}// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
let t=fK.arraySlice(this.times),e=fK.arraySlice(this.values),i=this.getValueSize(),r=2302===this.getInterpolation(),n=t.length-1,s=1;for(let o=1;o<n;++o){let n=!1,a=t[o],h=t[o+1];// remove adjacent keyframes scheduled at the same time
if(a!==h&&(1!==o||a!==t[0])){if(r)n=!0;else{// remove unnecessary keyframes same as their neighbors
let t=o*i,r=t-i,s=t+i;for(let o=0;o!==i;++o){let i=e[t+o];if(i!==e[r+o]||i!==e[s+o]){n=!0;break}}}}// in-place compaction
if(n){if(o!==s){t[s]=t[o];let r=o*i,n=s*i;for(let t=0;t!==i;++t)e[n+t]=e[r+t]}++s}}// flush last keyframe (compaction looks ahead)
if(n>0){t[s]=t[n];for(let t=n*i,r=s*i,o=0;o!==i;++o)e[r+o]=e[t+o];++s}return s!==t.length?(this.times=fK.arraySlice(t,0,s),this.values=fK.arraySlice(e,0,s*i)):(this.times=t,this.values=e),this}clone(){let t=fK.arraySlice(this.times,0),e=fK.arraySlice(this.values,0),i=this.constructor,r=new i(this.name,t,e);return(// Interpolant argument to constructor is not saved, so copy the factory method directly.
r.createInterpolant=this.createInterpolant,r)}}f0.prototype.TimeBufferType=Float32Array,f0.prototype.ValueBufferType=Float32Array,f0.prototype.DefaultInterpolation=2301;/**
 * A Track of Boolean keyframe values.
 */class f1 extends f0{}f1.prototype.ValueTypeName="bool",f1.prototype.ValueBufferType=Array,f1.prototype.DefaultInterpolation=2300,f1.prototype.InterpolantFactoryMethodLinear=void 0,f1.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of keyframe values that represent color.
 */class f2 extends f0{}f2.prototype.ValueTypeName="color";/**
 * A Track of numeric keyframe values.
 */class f3 extends f0{}f3.prototype.ValueTypeName="number";/**
 * Spherical linear unit quaternion interpolant.
 */class f5 extends fJ{constructor(t,e,i,r){super(t,e,i,r)}interpolate_(t,e,i,r){let n=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(i-e)/(r-e),h=t*o;for(let t=h+o;h!==t;h+=4)h0.slerpFlat(n,0,s,h-o,s,h,a);return n}}/**
 * A Track of quaternion keyframe values.
 */class f4 extends f0{InterpolantFactoryMethodLinear(t){return new f5(this.times,this.values,this.getValueSize(),t)}}f4.prototype.ValueTypeName="quaternion",// ValueBufferType is inherited
f4.prototype.DefaultInterpolation=2301,f4.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track that interpolates Strings
 */class f6 extends f0{}f6.prototype.ValueTypeName="string",f6.prototype.ValueBufferType=Array,f6.prototype.DefaultInterpolation=2300,f6.prototype.InterpolantFactoryMethodLinear=void 0,f6.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of vectored keyframe values.
 */class f8 extends f0{}f8.prototype.ValueTypeName="vector";class f7{constructor(t,e=-1,i,r=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=r,this.uuid=hH(),this.duration<0&&this.resetDuration()}static parse(t){let e=[],i=t.tracks,r=1/(t.fps||1);for(let t=0,n=i.length;t!==n;++t)e.push((function(t){if(void 0===t.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");let e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return f3;case"vector":case"vector2":case"vector3":case"vector4":return f8;case"color":return f2;case"quaternion":return f4;case"bool":case"boolean":return f1;case"string":return f6}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){let e=[],i=[];fK.flattenJSON(t.keys,e,i,"value"),t.times=e,t.values=i}return(// derived classes can define a static parse method
void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation))})(i[t]).scale(r));let n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){let e=[],i=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,r=i.length;t!==r;++t)e.push(f0.toJSON(i[t]));return r}static CreateFromMorphTargetSequence(t,e,i,r){let n=e.length,s=[];for(let t=0;t<n;t++){let o=[],a=[];o.push((t+n-1)%n,t,(t+1)%n),a.push(0,1,0);let h=fK.getKeyframeOrder(o);o=fK.sortedArray(o,1,h),a=fK.sortedArray(a,1,h),r||0!==o[0]||(o.push(n),a.push(a[0])),s.push(new f3(".morphTargetInfluences["+e[t].name+"]",o,a).scale(1/i))}return new this(t,-1,s)}static findByName(t,e){let i=t;Array.isArray(t)||(i=t.geometry&&t.geometry.animations||t.animations);for(let t=0;t<i.length;t++)if(i[t].name===e)return i[t];return null}static CreateClipsFromMorphTargetSequences(t,e,i){let r={},n=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(let e=0,i=t.length;e<i;e++){let i=t[e],s=i.name.match(n);if(s&&s.length>1){let t=s[1],e=r[t];e||(r[t]=e=[]),e.push(i)}}let s=[];for(let t in r)s.push(this.CreateFromMorphTargetSequence(t,r[t],e,i));return s}// parse the animation.hierarchy format
static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;let i=function(t,e,i,r,n){// only return track if there are actually keys.
if(0!==i.length){let s=[],o=[];fK.flattenJSON(i,s,o,r),0!==s.length&&n.push(new t(e,s,o))}},r=[],n=t.name||"default",s=t.fps||30,o=t.blendMode,a=t.length||-1,h=t.hierarchy||[];for(let t=0;t<h.length;t++){let n=h[t].keys;// skip empty tracks
if(n&&0!==n.length){// process morph targets
if(n[0].morphTargets){let t;// figure out all morph targets used in this track
let e={};for(t=0;t<n.length;t++)if(n[t].morphTargets)for(let i=0;i<n[t].morphTargets.length;i++)e[n[t].morphTargets[i]]=-1;// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(let i in e){let e=[],s=[];for(let r=0;r!==n[t].morphTargets.length;++r){let r=n[t];e.push(r.time),s.push(r.morphTarget===i?1:0)}r.push(new f3(".morphTargetInfluence["+i+"]",e,s))}a=e.length*(s||1)}else{// ...assume skeletal animation
let s=".bones["+e[t].name+"]";i(f8,s+".position",n,"pos",r),i(f4,s+".quaternion",n,"rot",r),i(f8,s+".scale",n,"scl",r)}}}if(0===r.length)return null;let l=new this(n,a,r,o);return l}resetDuration(){let t=this.tracks,e=0;for(let i=0,r=t.length;i!==r;++i){let t=this.tracks[i];e=Math.max(e,t.times[t.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){let t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}const f9={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&// console.log( 'THREE.Cache', 'Adding key:', key );
(this.files[t]=e)},get:function(t){if(!1!==this.enabled)// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}},mt=new class{constructor(t,e,i){let r;let n=this,s=!1,o=0,a=0,h=[];// Refer to #5689 for the reason why we don't set .onStart
// in the constructor
this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(t){a++,!1===s&&void 0!==n.onStart&&n.onStart(t,o,a),s=!0},this.itemEnd=function(t){o++,void 0!==n.onProgress&&n.onProgress(t,o,a),o===a&&(s=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return h.push(t,e),this},this.removeHandler=function(t){let e=h.indexOf(t);return -1!==e&&h.splice(e,2),this},this.getHandler=function(t){for(let e=0,i=h.length;e<i;e+=2){let i=h[e],r=h[e+1];if(i.global&&(i.lastIndex=0),i.test(t))return r}return null}}};class me{constructor(t){this.manager=void 0!==t?t:mt,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){let i=this;return new Promise(function(r,n){i.load(t,r,e,n)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const mi={};class mr extends me{constructor(t){super(t)}load(t,e,i,r){let n;void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);let s=this,o=f9.get(t);if(void 0!==o)return s.manager.itemStart(t),setTimeout(function(){e&&e(o),s.manager.itemEnd(t)},0),o;// Check if request is duplicate
if(void 0!==mi[t]){mi[t].push({onLoad:e,onProgress:i,onError:r});return}let a=t.match(/^data:(.*?)(;base64)?,(.*)$/);// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(a){let i=a[1],n=!!a[2],o=a[3];o=decodeURIComponent(o),n&&(o=atob(o));try{let r;let n=(this.responseType||"").toLowerCase();switch(n){case"arraybuffer":case"blob":let a=new Uint8Array(o.length);for(let t=0;t<o.length;t++)a[t]=o.charCodeAt(t);r="blob"===n?new Blob([a.buffer],{type:i}):a.buffer;break;case"document":let h=new DOMParser;r=h.parseFromString(o,i);break;case"json":r=JSON.parse(o);break;default:r=o}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){e&&e(r),s.manager.itemEnd(t)},0)}catch(e){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){r&&r(e),s.manager.itemError(t),s.manager.itemEnd(t)},0)}}else{for(let o in // Initialise array for duplicate requests
mi[t]=[],mi[t].push({onLoad:e,onProgress:i,onError:r}),(n=new XMLHttpRequest).open("GET",t,!0),n.addEventListener("load",function(e){let i=this.response,r=mi[t];if(delete mi[t],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
f9.add(t,i);for(let t=0,e=r.length;t<e;t++){let e=r[t];e.onLoad&&e.onLoad(i)}s.manager.itemEnd(t)}else{for(let t=0,i=r.length;t<i;t++){let i=r[t];i.onError&&i.onError(e)}s.manager.itemError(t),s.manager.itemEnd(t)}},!1),n.addEventListener("progress",function(e){let i=mi[t];for(let t=0,r=i.length;t<r;t++){let r=i[t];r.onProgress&&r.onProgress(e)}},!1),n.addEventListener("error",function(e){let i=mi[t];delete mi[t];for(let t=0,r=i.length;t<r;t++){let r=i[t];r.onError&&r.onError(e)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),n.addEventListener("abort",function(e){let i=mi[t];delete mi[t];for(let t=0,r=i.length;t<r;t++){let r=i[t];r.onError&&r.onError(e)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),void 0!==this.responseType&&(n.responseType=this.responseType),void 0!==this.withCredentials&&(n.withCredentials=this.withCredentials),n.overrideMimeType&&n.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain"),this.requestHeader)n.setRequestHeader(o,this.requestHeader[o]);n.send(null)}return s.manager.itemStart(t),n}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class mn extends me{constructor(t){super(t)}load(t,e,i,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);let n=this,s=f9.get(t);if(void 0!==s)return n.manager.itemStart(t),setTimeout(function(){e&&e(s),n.manager.itemEnd(t)},0),s;let o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",h,!1),f9.add(t,this),e&&e(this),n.manager.itemEnd(t)}function h(e){o.removeEventListener("load",a,!1),o.removeEventListener("error",h,!1),r&&r(e),n.manager.itemError(t),n.manager.itemEnd(t)}return o.addEventListener("load",a,!1),o.addEventListener("error",h,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),n.manager.itemStart(t),o.src=t,o}}class ms extends me{constructor(t){super(t)}load(t,e,i,r){let n=new uY,s=new mn(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;for(let i=0;i<t.length;++i)!function(i){s.load(t[i],function(t){n.images[i]=t,6==++o&&(n.needsUpdate=!0,e&&e(n))},void 0,r)}(i);return n}}class mo extends me{constructor(t){super(t)}load(t,e,i,r){let n=new hK,s=new mn(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(i){n.image=i;// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
let r=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);n.format=r?1022:1023,n.needsUpdate=!0,void 0!==e&&e(n)},i,r),n}}/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/class ma extends p7{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){// Add a line curve if start and end of lines are not connected
let t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new fd(e,t))}// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint(t){let e=t*this.getLength(),i=this.getCurveLengths(),r=0;// To think about boundaries points.
for(;r<i.length;){if(i[r]>=e){let t=i[r]-e,n=this.curves[r],s=n.getLength(),o=0===s?0:1-t/s;return n.getPointAt(o)}r++}return null;// loop where sum != 0, sum > d , sum+1 <d
}// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength(){let t=this.getCurveLengths();return t[t.length-1]}// cacheLengths must be recalculated.
updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;// Get length of sub-curve
// Push sums into cached array
let t=[],e=0;for(let i=0,r=this.curves.length;i<r;i++)t.push(e+=this.curves[i].getLength());return this.cacheLengths=t,t}getSpacedPoints(t=40){let e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){let e;let i=[];for(let r=0,n=this.curves;r<n.length;r++){let s=n[r],o=s&&s.isEllipseCurve?2*t:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,a=s.getPoints(o);for(let t=0;t<a.length;t++){let r=a[t];e&&e.equals(r)||(i.push(r),e=r);// ensures no consecutive points are duplicates
}}return this.autoClose&&i.length>1&&!i[i.length-1].equals(i[0])&&i.push(i[0]),i}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){let i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){let t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){let i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){let i=t.curves[e];this.curves.push(new fg[i.type]().fromJSON(i))}return this}}class mh extends ma{constructor(t){super(),this.type="Path",this.currentPoint=new hX,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){let i=new fd(this.currentPoint.clone(),new hX(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,r){let n=new fp(this.currentPoint.clone(),new hX(t,e),new hX(i,r));return this.curves.push(n),this.currentPoint.set(i,r),this}bezierCurveTo(t,e,i,r,n,s){let o=new fu(this.currentPoint.clone(),new hX(t,e),new hX(i,r),new hX(n,s));return this.curves.push(o),this.currentPoint.set(n,s),this}splineThru(t/*Array of Vector*/){let e=[this.currentPoint.clone()].concat(t),i=new fm(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,r,n,s){let o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,i,r,n,s),this}absarc(t,e,i,r,n,s){return this.absellipse(t,e,i,i,r,n,s),this}ellipse(t,e,i,r,n,s,o,a){let h=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(t+h,e+l,i,r,n,s,o,a),this}absellipse(t,e,i,r,n,s,o,a){let h=new p9(t,e,i,r,n,s,o,a);if(this.curves.length>0){// if a previous curve is present, attempt to join
let t=h.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(h);let l=h.getPoint(1);return this.currentPoint.copy(l),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){let t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ml extends mh{constructor(t){super(t),this.uuid=hH(),this.type="Shape",this.holes=[]}getPointsHoles(t){let e=[];for(let i=0,r=this.holes.length;i<r;i++)e[i]=this.holes[i].getPoints(t);return e}// get points of shape and holes (keypoints based on segments parameter)
extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){let i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){let t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){let i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){let i=t.holes[e];this.holes.push(new mh().fromJSON(i))}return this}}class mu extends lY{constructor(t,e=1){super(),this.type="Light",this.color=new ur(t),this.intensity=e}dispose(){// Empty here in base class; some subclasses override.
}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){let e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}mu.prototype.isLight=!0,(class extends mu{constructor(t,e,i){super(t,i),this.type="HemisphereLight",this.position.copy(lY.DefaultUp),this.updateMatrix(),this.groundColor=new ur(e)}copy(t){return mu.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}).prototype.isHemisphereLight=!0;const mc=/*@__PURE__*/new lE,md=/*@__PURE__*/new h1,mp=/*@__PURE__*/new h1;class mf{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new hX(512,512),this.map=null,this.mapPass=null,this.matrix=new lE,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new u1,this._frameExtents=new hX(1,1),this._viewportCount=1,this._viewports=[new hZ(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){let e=this.camera,i=this.matrix;md.setFromMatrixPosition(t.matrixWorld),e.position.copy(md),mp.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(mp),e.updateMatrixWorld(),mc.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(mc),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class mm extends mf{constructor(){super(new uX(50,1,.5,500)),this.focus=1}updateMatrices(t){let e=this.camera,i=2*hk*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;(i!==e.fov||r!==e.aspect||n!==e.far)&&(e.fov=i,e.aspect=r,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}mm.prototype.isSpotLightShadow=!0,(class extends mu{constructor(t,e,i=0,r=Math.PI/3,n=0,s=1){super(t,e),this.type="SpotLight",this.position.copy(lY.DefaultUp),this.updateMatrix(),this.target=new lY,this.distance=i,this.angle=r,this.penumbra=n,this.decay=s,this.shadow=new mm}get power(){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*Math.PI}set power(t){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isSpotLight=!0;const mg=/*@__PURE__*/new lE,my=/*@__PURE__*/new h1,m_=/*@__PURE__*/new h1;class mv extends mf{constructor(){super(new uX(90,1,.5,500)),this._frameExtents=new hX(4,2),this._viewportCount=6,this._viewports=[// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
new hZ(2,1,1,1),// negative X
new hZ(0,1,1,1),// positive Z
new hZ(3,1,1,1),// negative Z
new hZ(1,1,1,1),// positive Y
new hZ(3,0,1,1),// negative Y
new hZ(1,0,1,1)],this._cubeDirections=[new h1(1,0,0),new h1(-1,0,0),new h1(0,0,1),new h1(0,0,-1),new h1(0,1,0),new h1(0,-1,0)],this._cubeUps=[new h1(0,1,0),new h1(0,1,0),new h1(0,1,0),new h1(0,1,0),new h1(0,0,1),new h1(0,0,-1)]}updateMatrices(t,e=0){let i=this.camera,r=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),my.setFromMatrixPosition(t.matrixWorld),i.position.copy(my),m_.copy(i.position),m_.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(m_),i.updateMatrixWorld(),r.makeTranslation(-my.x,-my.y,-my.z),mg.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(mg)}}mv.prototype.isPointLightShadow=!0,(class extends mu{constructor(t,e,i=0,r=1){super(t,e),this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new mv}get power(){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return 4*this.intensity*Math.PI}set power(t){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}).prototype.isPointLight=!0;class mx extends mf{constructor(){super(new cn(-5,5,5,-5,.5,500))}}mx.prototype.isDirectionalLightShadow=!0,(class extends mu{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(lY.DefaultUp),this.updateMatrix(),this.target=new lY,this.shadow=new mx}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}).prototype.isDirectionalLight=!0,(class extends mu{constructor(t,e){super(t,e),this.type="AmbientLight"}}).prototype.isAmbientLight=!0,(class extends mu{constructor(t,e,i=10,r=10){super(t,e),this.type="RectAreaLight",this.width=i,this.height=r}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){let e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}).prototype.isRectAreaLight=!0;/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */// 3-band SH defined by 9 coefficients
class mb{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new h1)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}// get the radiance in the direction of the normal
// target is a Vector3
getAt(t,e){// normal is assumed to be unit length
let i=t.x,r=t.y,n=t.z,s=this.coefficients;return(// band 0
e.copy(s[0]).multiplyScalar(.282095),// band 1
e.addScaledVector(s[1],.488603*r),e.addScaledVector(s[2],.488603*n),e.addScaledVector(s[3],.488603*i),// band 2
e.addScaledVector(s[4],1.092548*(i*r)),e.addScaledVector(s[5],1.092548*(r*n)),e.addScaledVector(s[6],.315392*(3*n*n-1)),e.addScaledVector(s[7],1.092548*(i*n)),e.addScaledVector(s[8],.546274*(i*i-r*r)),e)}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt(t,e){// normal is assumed to be unit length
let i=t.x,r=t.y,n=t.z,s=this.coefficients;return(// band 0
e.copy(s[0]).multiplyScalar(.886227),// band 1
e.addScaledVector(s[1],1.023328*r),e.addScaledVector(s[2],1.023328*n),e.addScaledVector(s[3],1.023328*i),// band 2
e.addScaledVector(s[4],.858086*i*r),e.addScaledVector(s[5],.858086*r*n),e.addScaledVector(s[6],.743125*n*n-.247708),e.addScaledVector(s[7],.858086*i*n),e.addScaledVector(s[8],.429043*(i*i-r*r)),e)}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){let i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(t,e+3*r);return this}toArray(t=[],e=0){let i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(t,e+3*r);return t}// evaluate the basis functions
// shBasis is an Array[ 9 ]
static getBasisAt(t,e){// normal is assumed to be unit length
let i=t.x,r=t.y,n=t.z;// band 0
e[0]=.282095,// band 1
e[1]=.488603*r,e[2]=.488603*n,e[3]=.488603*i,// band 2
e[4]=1.092548*i*r,e[5]=1.092548*r*n,e[6]=.315392*(3*n*n-1),e[7]=1.092548*i*n,e[8]=.546274*(i*i-r*r)}}mb.prototype.isSphericalHarmonics3=!0;class mE extends mu{constructor(t=new mb,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){let e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}mE.prototype.isLightProbe=!0;class mT{static decodeText(t){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(t);// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.
let e="";for(let i=0,r=t.length;i<r;i++)e+=String.fromCharCode(t[i]);try{// merges multi-byte utf-8 characters.
return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){let e=t.lastIndexOf("/");return -1===e?"./":t.substr(0,e+1)}}(class extends uv{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){let t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}).prototype.isInstancedBufferGeometry=!0,(class extends ua{constructor(t,e,i,r=1){"number"==typeof i&&(r=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,i),this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){let t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}).prototype.isInstancedBufferAttribute=!0,(class extends me{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);let n=this,s=f9.get(t);if(void 0!==s)return n.manager.itemStart(t),setTimeout(function(){e&&e(s),n.manager.itemEnd(t)},0),s;let o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(n.options,{colorSpaceConversion:"none"}))}).then(function(i){f9.add(t,i),e&&e(i),n.manager.itemEnd(t)}).catch(function(e){r&&r(e),n.manager.itemError(t),n.manager.itemEnd(t)}),n.manager.itemStart(t)}}).prototype.isImageBitmapLoader=!0;class mw{constructor(){this.type="ShapePath",this.color=new ur,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new mh,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,i,r){return this.currentPath.quadraticCurveTo(t,e,i,r),this}bezierCurveTo(t,e,i,r,n,s){return this.currentPath.bezierCurveTo(t,e,i,r,n,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){let i,r,n,s,o;function a(t){let e=[];for(let i=0,r=t.length;i<r;i++){let r=t[i],n=new ml;n.curves=r.curves,e.push(n)}return e}let h=fL.isClockWise,l=this.subPaths;if(0===l.length)return[];if(!0===e)return a(l);let u=[];if(1===l.length)return r=l[0],(n=new ml).curves=r.curves,u.push(n),u;let c=!h(l[0].getPoints());c=t?!c:c;// console.log("Holes first", holesFirst);
let d=[],p=[],f=[],m=0;p[0]=void 0,f[m]=[];for(let e=0,n=l.length;e<n;e++)i=h(s=(r=l[e]).getPoints()),(i=t?!i:i)?(!c&&p[m]&&m++,p[m]={s:new ml,p:s},p[m].s.curves=r.curves,c&&m++,f[m]=[]):f[m].push({h:r,p:s[0]});// only Holes? -> probably all Shapes with wrong orientation
if(!p[0])return a(l);if(p.length>1){let t=!1,e=[];for(let t=0,e=p.length;t<e;t++)d[t]=[];for(let i=0,r=p.length;i<r;i++){let r=f[i];for(let n=0;n<r.length;n++){let s=r[n],o=!0;for(let r=0;r<p.length;r++)(function(t,e){let i=e.length,r=!1;for(let n=i-1,s=0;s<i;n=s++){let i=e[n],o=e[s],a=o.x-i.x,h=o.y-i.y;if(Math.abs(h)>Number.EPSILON){if(h<0&&(i=e[s],a=-a,o=e[n],h=-h),t.y<i.y||t.y>o.y)continue;if(t.y===i.y){if(t.x===i.x)return!0;// inPt is on contour ?
}else{let e=h*(t.x-i.x)-a*(t.y-i.y);if(0===e)return!0;// inPt is on contour ?
if(e<0)continue;r=!r;// true intersection left of inPt
}}else{// parallel or collinear
if(t.y!==i.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(o.x<=t.x&&t.x<=i.x||i.x<=t.x&&t.x<=o.x)return!0;// inPt: Point on contour !
// continue;
}}return r})(s.p,p[r].p)&&(i!==r&&e.push({froms:i,tos:r,hole:n}),o?(o=!1,d[r].push(s)):t=!0);o&&d[i].push(s)}}// console.log("ambiguous: ", ambiguous);
e.length>0&&!t&&(f=d)}for(let t=0,e=p.length;t<e;t++){n=p[t].s,u.push(n),o=f[t];for(let t=0,e=o.length;t<e;t++)n.holes.push(o[t].h)}//console.log("shape", shapes);
return u}}(class{constructor(t){this.type="Font",this.data=t}generateShapes(t,e=100){let i=[],r=function(t,e,i){let r=Array.from(t),n=e/i.resolution,s=(i.boundingBox.yMax-i.boundingBox.yMin+i.underlineThickness)*n,o=[],a=0,h=0;for(let t=0;t<r.length;t++){let e=r[t];if("\n"===e)a=0,h-=s;else{let t=function(t,e,i,r,n){let s,o,a,h,l,u,c,d;let p=n.glyphs[t]||n.glyphs["?"];if(!p){console.error('THREE.Font: character "'+t+'" does not exists in font family '+n.familyName+".");return}let f=new mw;if(p.o){let t=p._cachedOutline||(p._cachedOutline=p.o.split(" "));for(let n=0,p=t.length;n<p;){let p=t[n++];switch(p){case"m":s=t[n++]*e+i,o=t[n++]*e+r,f.moveTo(s,o);break;case"l":s=t[n++]*e+i,o=t[n++]*e+r,f.lineTo(s,o);break;case"q":a=t[n++]*e+i,h=t[n++]*e+r,l=t[n++]*e+i,u=t[n++]*e+r,f.quadraticCurveTo(l,u,a,h);break;case"b":a=t[n++]*e+i,h=t[n++]*e+r,l=t[n++]*e+i,u=t[n++]*e+r,c=t[n++]*e+i,d=t[n++]*e+r,f.bezierCurveTo(l,u,c,d,a,h)}}}return{offsetX:p.ha*e,path:f}}(e,n,a,h,i);a+=t.offsetX,o.push(t.path)}}return o}(t,e,this.data);for(let t=0,e=r.length;t<e;t++)Array.prototype.push.apply(i,r[t].toShapes());return i}}).prototype.isFont=!0;const mS={getContext:function(){return void 0===i&&(i=new(window.AudioContext||window.webkitAudioContext)),i},setContext:function(t){i=t}};class mM extends me{constructor(t){super(t)}load(t,e,i,r){let n=this,s=new mr(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(i){try{// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
let t=i.slice(0),r=mS.getContext();r.decodeAudioData(t,function(t){e(t)})}catch(e){r?r(e):console.error(e),n.manager.itemError(t)}},i,r)}}(class extends mE{constructor(t,e,i=1){super(void 0,i);let r=new ur().set(t),n=new ur().set(e),s=new h1(r.r,r.g,r.b),o=new h1(n.r,n.g,n.b),a=Math.sqrt(Math.PI),h=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(h)}}).prototype.isHemisphereLightProbe=!0,(class extends mE{constructor(t,e=1){super(void 0,e);let i=new ur().set(t);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}).prototype.isAmbientLightProbe=!0;class mA{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=mR(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let e=mR();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function mR(){return("undefined"==typeof performance?Date:performance).now();// see #10732
}class mC{constructor(t,e,i){let r,n,s;// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
//
// 'add' is used for additive cumulative results
//
// 'work' is optional and is only present for quaternion types. It is used
// to store intermediate quaternion multiplication results
switch(this.binding=t,this.valueSize=i,e){case"quaternion":r=this._slerp,n=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":r=this._select,// Use the regular mix function and for additive on these types,
// additive is not relevant for non-numeric types
n=this._select,s=this._setAdditiveIdentityOther,this.buffer=Array(5*i);break;default:r=this._lerp,n=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=n,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}// accumulate data in the 'incoming' region into 'accu<i>'
accumulate(t,e){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
let i=this.buffer,r=this.valueSize,n=t*r+r,s=this.cumulativeWeight;if(0===s){// accuN := incoming * weight
for(let t=0;t!==r;++t)i[n+t]=i[t];s=e}else{// accuN := accuN + incoming * weight
s+=e;let t=e/s;this._mixBufferRegion(i,n,0,t,r)}this.cumulativeWeight=s}// accumulate data in the 'incoming' region into 'add'
accumulateAdditive(t){let e=this.buffer,i=this.valueSize,r=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),// add := add + incoming * weight
this._mixBufferRegionAdditive(e,r,0,t,i),this.cumulativeWeightAdditive+=t}// apply the state of 'accu<i>' to the binding when accus differ
apply(t){let e=this.valueSize,i=this.buffer,r=t*e+e,n=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,n<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
let t=e*this._origIndex;this._mixBufferRegion(i,r,t,1-n,e)}s>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*e,1,e);for(let t=e,n=e+e;t!==n;++t)if(i[t]!==i[t+e]){// value has changed -> update scene graph
o.setValue(i,r);break}}// remember the state of the bound property and copy it to both accus
saveOriginalState(){let t=this.binding,e=this.buffer,i=this.valueSize,r=i*this._origIndex;t.getValue(e,r);// accu[0..1] := orig -- initially detect changes against the original
for(let t=i;t!==r;++t)e[t]=e[r+t%i];// Add to identity for additive
this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState(){let t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){let t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){let t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}// mix functions
_select(t,e,i,r,n){if(r>=.5)for(let r=0;r!==n;++r)t[e+r]=t[i+r]}_slerp(t,e,i,r){h0.slerpFlat(t,e,t,e,t,i,r)}_slerpAdditive(t,e,i,r,n){let s=this._workIndex*n;// Store result in intermediate buffer offset
h0.multiplyQuaternionsFlat(t,s,t,e,t,i),// Slerp to the intermediate result
h0.slerpFlat(t,e,t,e,t,s,r)}_lerp(t,e,i,r,n){let s=1-r;for(let o=0;o!==n;++o){let n=e+o;t[n]=t[n]*s+t[i+o]*r}}_lerpAdditive(t,e,i,r,n){for(let s=0;s!==n;++s){let n=e+s;t[n]=t[n]+t[i+s]*r}}}// Characters [].:/ are reserved for track binding syntax.
const mP="\\[\\]\\.:\\/",mI=RegExp("["+mP+"]","g"),mO="[^"+mP+"]",mL="[^"+mP.replace("\\.","")+"]",mN=/((?:WC+[\/:])*)/.source.replace("WC",mO),mD=/(WCOD+)?/.source.replace("WCOD",mL),mF=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",mO),mB=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",mO),mU=RegExp("^"+mN+mD+mF+mB+"$"),mG=["material","materials","bones"];// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class mk{constructor(t,e,i){this.path=e,this.parsedPath=i||mk.parseTrackName(e),this.node=mk.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,// initial state of these methods that calls 'bind'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new mk.Composite(t,e,i):new mk(t,e,i)}/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(mI,"")}static parseTrackName(t){let e=mU.exec(t);if(!e)throw Error("PropertyBinding: Cannot parse trackName: "+t);let i={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){let t=i.nodeName.substring(r+1);// Object names must be checked against an allowlist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
-1!==mG.indexOf(t)&&(i.nodeName=i.nodeName.substring(0,r),i.objectName=t)}if(null===i.propertyName||0===i.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(!e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;// search into skeleton bones.
if(t.skeleton){let i=t.skeleton.getBoneByName(e);if(void 0!==i)return i}// search into node subtree.
if(t.children){let i=function(t){for(let r=0;r<t.length;r++){let n=t[r];if(n.name===e||n.uuid===e)return n;let s=i(n.children);if(s)return s}return null},r=i(t.children);if(r)return r}return null}// these are used to "bind" a nonexistent property
_getValue_unavailable(){}_setValue_unavailable(){}// Getters
_getValue_direct(t,e){t[e]=this.node[this.propertyName]}_getValue_array(t,e){let i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)t[e++]=i[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}// Direct
_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}// EntireArray
_setValue_array(t,e){let i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){let i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){let i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}// ArrayElement
_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}// HasToFromArray
_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}// create getter / setter pair for a property in the scene graph
bind(){let t=this.node,e=this.parsedPath,i=e.objectName,r=e.propertyName,n=e.propertyIndex;// ensure there is a value node
if(t||(t=mk.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let r=e.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
t=t.skeleton.bones;// support resolving morphTarget names into indices.
for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;default:if(void 0===t[i]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(void 0!==r){if(void 0===t[r]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[r]}}// resolve property
let s=t[r];if(void 0===s){let i=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+i+"."+r+" but it wasn't found.",t);return}// determine versioning scheme
let o=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?o=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(o=this.Versioning.MatrixWorldNeedsUpdate);// determine how the property gets bound
let a=this.BindingType.Direct;if(void 0!==n){// access a sub element of the property array (only primitives are supported right now)
if("morphTargetInfluences"===r){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==t.morphTargetDictionary[n]&&(n=t.morphTargetDictionary[n])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=n}else void 0!==s.fromArray&&void 0!==s.toArray?(// must use copy for Object3D.Euler/Quaternion
a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;// select getter / setter
this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}mk.Composite=class{constructor(t,e,i){let r=i||mk.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();// bind all binding
let i=this._targetGroup.nCachedObjects_,r=this._bindings[i];// and only call .getValue on the first
void 0!==r&&r.getValue(t,e)}setValue(t,e){let i=this._bindings;for(let r=this._targetGroup.nCachedObjects_,n=i.length;r!==n;++r)i[r].setValue(t,e)}bind(){let t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){let t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}},mk.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},mk.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},mk.prototype.GetterByBindingType=[mk.prototype._getValue_direct,mk.prototype._getValue_array,mk.prototype._getValue_arrayElement,mk.prototype._getValue_toArray],mk.prototype.SetterByBindingTypeAndVersioning=[[// Direct
mk.prototype._setValue_direct,mk.prototype._setValue_direct_setNeedsUpdate,mk.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
mk.prototype._setValue_array,mk.prototype._setValue_array_setNeedsUpdate,mk.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
mk.prototype._setValue_arrayElement,mk.prototype._setValue_arrayElement_setNeedsUpdate,mk.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
mk.prototype._setValue_fromArray,mk.prototype._setValue_fromArray_setNeedsUpdate,mk.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */(class{constructor(){this.uuid=hH(),// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;// note: read by PropertyBinding.Composite
let t={};this._indicesByUUID=t;for(let e=0,i=arguments.length;e!==i;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};let e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){let t=this._objects,e=this._indicesByUUID,i=this._paths,r=this._parsedPaths,n=this._bindings,s=n.length,o,a=t.length,h=this.nCachedObjects_;for(let l=0,u=arguments.length;l!==u;++l){let u=arguments[l],c=u.uuid,d=e[c];if(void 0===d){// unknown object -> add it to the ACTIVE region
d=a++,e[c]=d,t.push(u);// accounting is done, now do the same for all bindings
for(let t=0;t!==s;++t)n[t].push(new mk(u,i[t],r[t]))}else if(d<h){o=t[d];// move existing object to the ACTIVE region
let a=--h,l=t[a];e[l.uuid]=d,t[d]=l,e[c]=a,t[a]=u;// accounting is done, now do the same for all bindings
for(let t=0;t!==s;++t){let e=n[t],s=e[a],o=e[d];e[d]=s,void 0===o&&// for objects that are cached, the binding may
// or may not exist
(o=new mk(u,i[t],r[t])),e[a]=o}}else t[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=h}remove(){let t=this._objects,e=this._indicesByUUID,i=this._bindings,r=i.length,n=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){let o=arguments[s],a=o.uuid,h=e[a];if(void 0!==h&&h>=n){// move existing object into the CACHED region
let s=n++,l=t[s];e[l.uuid]=h,t[h]=l,e[a]=s,t[s]=o;// accounting is done, now do the same for all bindings
for(let t=0;t!==r;++t){let e=i[t],r=e[s],n=e[h];e[h]=r,e[s]=n}}}// for arguments
this.nCachedObjects_=n}// remove & forget
uncache(){let t=this._objects,e=this._indicesByUUID,i=this._bindings,r=i.length,n=this.nCachedObjects_,s=t.length;for(let o=0,a=arguments.length;o!==a;++o){let a=arguments[o],h=a.uuid,l=e[h];if(void 0!==l){if(delete e[h],l<n){// object is cached, shrink the CACHED region
let o=--n,a=t[o],h=--s,u=t[h];// last cached object takes this object's place
e[a.uuid]=l,t[l]=a,// last object goes to the activated slot and pop
e[u.uuid]=o,t[o]=u,t.pop();// accounting is done, now do the same for all bindings
for(let t=0;t!==r;++t){let e=i[t],r=e[o],n=e[h];e[l]=r,e[o]=n,e.pop()}}else{// object is active, just swap with the last and pop
let n=--s,o=t[n];n>0&&(e[o.uuid]=l),t[l]=o,t.pop();// accounting is done, now do the same for all bindings
for(let t=0;t!==r;++t){let e=i[t];e[l]=e[n],e.pop()}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=n}// Internal interface used by befriended PropertyBinding.Composite:
subscribe_(t,e){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
let i=this._bindingsIndicesByPath,r=i[t],n=this._bindings;if(void 0!==r)return n[r];let s=this._paths,o=this._parsedPaths,a=this._objects,h=a.length,l=this.nCachedObjects_,u=Array(h);r=n.length,i[t]=r,s.push(t),o.push(e),n.push(u);for(let i=l,r=a.length;i!==r;++i){let r=a[i];u[i]=new mk(r,t,e)}return u}unsubscribe_(t){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
let e=this._bindingsIndicesByPath,i=e[t];if(void 0!==i){let r=this._paths,n=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o],h=t[o];e[h]=i,s[i]=a,s.pop(),n[i]=n[o],n.pop(),r[i]=r[o],r.pop()}}}).prototype.isAnimationObjectGroup=!0;class mH{constructor(t,e,i=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=r;let n=e.tracks,s=n.length,o=Array(s),a={endingStart:2400,endingEnd:2400};for(let t=0;t!==s;++t){let e=n[t].createInterpolant(null);o[t]=e,e.settings=a}this._interpolantSettings=a,this._interpolants=o,// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null,// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}// State & Scheduling
play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}// return true when play has been called
isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight(t){return this.weight=t,// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?t:0,this.stopFading()}// return the weight considering fading and .enabled
getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){let i=this._clip.duration,r=t._clip.duration;t.warp(1,r/i,e),this.warp(i/r,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){let t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}// return the time scale considering warping and .paused
getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){let r=this._mixer,n=r.time,s=this.timeScale,o=this._timeScaleInterpolant;null===o&&(o=r._lendControlInterpolant(),this._timeScaleInterpolant=o);let a=o.parameterPositions,h=o.sampleValues;return a[0]=n,a[1]=n+i,h[0]=t/s,h[1]=e/s,this}stopWarping(){let t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}// Object Accessors
getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}// Interna
_update(t,e,i,r){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(t);return}let n=this._startTime;if(null!==n){// check for scheduled start of action
let r=(t-n)*i;if(r<0||0===i)return;// yet to come / don't decide when delta = 0
// start
this._startTime=null,e=i*r}// apply time scale and advance time
e*=this._updateTimeScale(t);let s=this._updateTime(e),o=this._updateWeight(t);if(o>0){let t=this._interpolants,e=this._propertyBindings;if(2501===this.blendMode)for(let i=0,r=t.length;i!==r;++i)t[i].evaluate(s),e[i].accumulateAdditive(o);else for(let i=0,n=t.length;i!==n;++i)t[i].evaluate(s),e[i].accumulate(r,o)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;let i=this._weightInterpolant;if(null!==i){let r=i.evaluate(t)[0];e*=r,t>i.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;let i=this._timeScaleInterpolant;if(null!==i){let r=i.evaluate(t)[0];e*=r,t>i.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){let e=this._clip.duration,i=this.loop,r=this.time+t,n=this._loopCount,s=2202===i;if(0===t)return -1===n?r:s&&(1&n)==1?e-r:r;if(2200===i){-1===n&&(// just started
this._loopCount=0,this._setEndings(!0,!0,!1));n:{if(r>=e)r=e;else if(r<0)r=0;else{this.time=r;break n}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===n&&(t>=0?(n=0,this._setEndings(!0,0===this.repetitions,s)):// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(0===this.repetitions,!0,s)),r>=e||r<0){// wrap around
let i=Math.floor(r/e);// signed
r-=e*i,n+=Math.abs(i);let o=this.repetitions-n;if(o<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{// keep running
if(1===o){// entering the last round
let e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=n,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=r;if(s&&(1&n)==1)return e-r}return r}_setEndings(t,e,i){let r=this._interpolantSettings;i?(r.endingStart=2401,r.endingEnd=2401):(t?r.endingStart=this.zeroSlopeAtStart?2401:2400:r.endingStart=2402,e?r.endingEnd=this.zeroSlopeAtEnd?2401:2400:r.endingEnd=2402)}_scheduleFading(t,e,i){let r=this._mixer,n=r.time,s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);let o=s.parameterPositions,a=s.sampleValues;return o[0]=n,a[0]=e,o[1]=n+t,a[1]=i,this}}(class extends hB{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){let i=t._localRoot||this._root,r=t._clip.tracks,n=r.length,s=t._propertyBindings,o=t._interpolants,a=i.uuid,h=this._bindingsByRootAndName,l=h[a];void 0===l&&(l={},h[a]=l);for(let t=0;t!==n;++t){let n=r[t],h=n.name,u=l[h];if(void 0!==u)s[t]=u;else{if(void 0!==(u=s[t])){// existing binding, make sure the cache knows
null===u._cacheIndex&&(++u.referenceCount,this._addInactiveBinding(u,a,h));continue}let r=e&&e._propertyBindings[t].binding.parsedPath;u=new mC(mk.create(i,h,r),n.ValueTypeName,n.getValueSize()),++u.referenceCount,this._addInactiveBinding(u,a,h),s[t]=u}o[t].resultBuffer=u.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
let e=(t._localRoot||this._root).uuid,i=t._clip.uuid,r=this._actionsByClip[i];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,i,e)}let e=t._propertyBindings;// increment reference counts / sort out state
for(let t=0,i=e.length;t!==i;++t){let i=e[t];0==i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){let e=t._propertyBindings;// decrement reference counts / sort out state
for(let t=0,i=e.length;t!==i;++t){let i=e[t];0==--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(t)}}// Memory manager
_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }
this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;let t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}// Memory management for AnimationAction objects
_isActiveAction(t){let e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,i){let r=this._actions,n=this._actionsByClip,s=n[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,n[e]=s;else{let e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=r.length,r.push(t),s.actionByRoot[i]=t}_removeInactiveAction(t){let e=this._actions,i=e[e.length-1],r=t._cacheIndex;i._cacheIndex=r,e[r]=i,e.pop(),t._cacheIndex=null;let n=t._clip.uuid,s=this._actionsByClip,o=s[n],a=o.knownActions,h=a[a.length-1],l=t._byClipCacheIndex;h._byClipCacheIndex=l,a[l]=h,a.pop(),t._byClipCacheIndex=null;let u=o.actionByRoot,c=(t._localRoot||this._root).uuid;delete u[c],0===a.length&&delete s[n],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){let e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){let i=e[t];0==--i.referenceCount&&this._removeInactiveBinding(i)}}_lendAction(t){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
let e=this._actions,i=t._cacheIndex,r=this._nActiveActions++,n=e[r];t._cacheIndex=r,e[r]=t,n._cacheIndex=i,e[i]=n}_takeBackAction(t){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
let e=this._actions,i=t._cacheIndex,r=--this._nActiveActions,n=e[r];t._cacheIndex=r,e[r]=t,n._cacheIndex=i,e[i]=n}// Memory management for PropertyMixer objects
_addInactiveBinding(t,e,i){let r=this._bindingsByRootAndName,n=this._bindings,s=r[e];void 0===s&&(s={},r[e]=s),s[i]=t,t._cacheIndex=n.length,n.push(t)}_removeInactiveBinding(t){let e=this._bindings,i=t.binding,r=i.rootNode.uuid,n=i.path,s=this._bindingsByRootAndName,o=s[r],a=e[e.length-1],h=t._cacheIndex;a._cacheIndex=h,e[h]=a,e.pop(),delete o[n],0===Object.keys(o).length&&delete s[r]}_lendBinding(t){let e=this._bindings,i=t._cacheIndex,r=this._nActiveBindings++,n=e[r];t._cacheIndex=r,e[r]=t,n._cacheIndex=i,e[i]=n}_takeBackBinding(t){let e=this._bindings,i=t._cacheIndex,r=--this._nActiveBindings,n=e[r];t._cacheIndex=r,e[r]=t,n._cacheIndex=i,e[i]=n}// Memory management of Interpolants for weight and time scale
_lendControlInterpolant(){let t=this._controlInterpolants,e=this._nActiveControlInterpolants++,i=t[e];return void 0===i&&((i=new f$(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){let e=this._controlInterpolants,i=t.__cacheIndex,r=--this._nActiveControlInterpolants,n=e[r];t.__cacheIndex=r,e[r]=t,n.__cacheIndex=i,e[i]=n}// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction(t,e,i){let r=e||this._root,n=r.uuid,s="string"==typeof t?f7.findByName(r,t):t,o=null!==s?s.uuid:t,a=this._actionsByClip[o],h=null;if(void 0===i&&(i=null!==s?s.blendMode:2500),void 0!==a){let t=a.actionByRoot[n];if(void 0!==t&&t.blendMode===i)return t;// we know the clip, so we don't have to parse all
// the bindings again but can just copy
h=a.knownActions[0],null===s&&(s=h._clip)}// clip must be known when specified via string
if(null===s)return null;// allocate all resources required to run it
let l=new mH(this,s,e,i);return this._bindAction(l,h),// and make the action known to the memory manager
this._addInactiveAction(l,o,n),l}// get an existing action
existingAction(t,e){let i=e||this._root,r=i.uuid,n="string"==typeof t?f7.findByName(i,t):t,s=n?n.uuid:t,o=this._actionsByClip[s];return void 0!==o&&o.actionByRoot[r]||null}// deactivates all previously scheduled actions
stopAllAction(){let t=this._actions,e=this._nActiveActions;for(let i=e-1;i>=0;--i)t[i].stop();return this}// advance the time and update apply the animation
update(t){t*=this.timeScale;let e=this._actions,i=this._nActiveActions,r=this.time+=t,n=Math.sign(t),s=this._accuIndex^=1;// run active actions
for(let o=0;o!==i;++o){let i=e[o];i._update(r,t,n,s)}// update scene graph
let o=this._bindings,a=this._nActiveBindings;for(let t=0;t!==a;++t)o[t].apply(s);return this}// Allows you to seek to a specific time in an animation.
setTime(t){this.time=0;// Zero out time attribute for AnimationMixer object;
for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;// Zero out time attribute for all associated AnimationAction objects.
return this.update(t);// Update used to set exact time. Returns "this" AnimationMixer object.
}// return this mixer's root target object
getRoot(){return this._root}// free all resources specific to a particular clip
uncacheClip(t){let e=this._actions,i=t.uuid,r=this._actionsByClip,n=r[i];if(void 0!==n){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
let t=n.knownActions;for(let i=0,r=t.length;i!==r;++i){let r=t[i];this._deactivateAction(r);let n=r._cacheIndex,s=e[e.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=n,e[n]=s,e.pop(),this._removeInactiveBindingsForAction(r)}delete r[i]}}// free all resources specific to a particular root target object
uncacheRoot(t){let e=t.uuid,i=this._actionsByClip;for(let t in i){let r=i[t].actionByRoot,n=r[e];void 0!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}let r=this._bindingsByRootAndName,n=r[e];if(void 0!==n)for(let t in n){let e=n[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}// remove a targeted clip from the cache
uncacheAction(t,e){let i=this.existingAction(t,e);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);class mz{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new mz(void 0===this.value.clone?this.value:this.value.clone())}}(class extends pp{constructor(t,e,i=1){super(t,e),this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){let e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){let e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}).prototype.isInstancedInterleavedBuffer=!0,(class{constructor(t,e,i,r,n){this.buffer=t,this.type=e,this.itemSize=i,this.elementSize=r,this.count=n,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}).prototype.isGLBufferAttribute=!0;const mj=/*@__PURE__*/new hX;class mV{constructor(t=new hX(1/0,1/0),e=new hX(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){let i=mj.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x)&&!(t.x>this.max.x)&&!(t.y<this.min.y)&&!(t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){// using 4 splitting planes to rule out intersections
return!(t.max.x<this.min.x)&&!(t.min.x>this.max.x)&&!(t.max.y<this.min.y)&&!(t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){let e=mj.copy(t).clamp(this.min,this.max);return e.sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}mV.prototype.isBox2=!0;const mX=/*@__PURE__*/new h1,mW=/*@__PURE__*/new h1;(class extends lY{constructor(t){super(),this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}).prototype.isImmediateRenderObject=!0;const mY=/*@__PURE__*/new h1,mq=/*@__PURE__*/new lE,mK=/*@__PURE__*/new lE,mJ=new Float32Array(1);new Int32Array(mJ.buffer),//
p7.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(p7.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},//
mh.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)},(class extends pK{constructor(t=10,e=10,i=4473924,r=8947848){i=new ur(i),r=new ur(r);let n=e/2,s=t/e,o=t/2,a=[],h=[];for(let t=0,l=0,u=-o;t<=e;t++,u+=s){a.push(-o,0,u,o,0,u),a.push(u,0,-o,u,0,o);let e=t===n?i:r;e.toArray(h,l),l+=3,e.toArray(h,l),l+=3,e.toArray(h,l),l+=3,e.toArray(h,l),l+=3}let l=new uv;l.setAttribute("position",new uu(a,3)),l.setAttribute("color",new uu(h,3));let u=new pk({vertexColors:!0,toneMapped:!1});super(l,u),this.type="GridHelper"}}).prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},(class extends pK{constructor(t){let e=function t(e){let i=[];e&&e.isBone&&i.push(e);for(let r=0;r<e.children.length;r++)i.push.apply(i,t(e.children[r]));return i}(t),i=new uv,r=[],n=[],s=new ur(0,0,1),o=new ur(0,1,0);for(let t=0;t<e.length;t++){let i=e[t];i.parent&&i.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),n.push(s.r,s.g,s.b),n.push(o.r,o.g,o.b))}i.setAttribute("position",new uu(r,3)),i.setAttribute("color",new uu(n,3));let a=new pk({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,a),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){let e=this.bones,i=this.geometry,r=i.getAttribute("position");mK.copy(this.root.matrixWorld).invert();for(let t=0,i=0;t<e.length;t++){let n=e[t];n.parent&&n.parent.isBone&&(mq.multiplyMatrices(mK,n.matrixWorld),mY.setFromMatrixPosition(mq),r.setXYZ(i,mY.x,mY.y,mY.z),mq.multiplyMatrices(mK,n.parent.matrixWorld),mY.setFromMatrixPosition(mq),r.setXYZ(i+1,mY.x,mY.y,mY.z),i+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}).prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},//
me.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),mT.extractUrlBase(t)},me.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},//
mV.prototype.center=function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},mV.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},mV.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},mV.prototype.size=function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)},//
h5.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},h5.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},h5.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},h5.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},h5.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},//
lp.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},//
u1.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},//
(class{constructor(t=new h1,e=new h1){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){mX.subVectors(t,this.start),mW.subVectors(this.end,this.start);let i=mW.dot(mW),r=mW.dot(mX),n=r/i;return e&&(n=hz(n,0,1)),n}closestPointToPoint(t,e,i){let r=this.closestPointToPointParameter(t,e);return this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}).prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},//
hW.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},hW.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},hW.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},hW.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},hW.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},hW.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},//
lE.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},lE.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},lE.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new h1().setFromMatrixColumn(this,3)},lE.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},lE.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},lE.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},lE.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},lE.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},lE.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},lE.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},lE.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},lE.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},lE.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},lE.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},lE.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},lE.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},lE.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},lE.prototype.makeFrustum=function(t,e,i,r,n,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,r,i,n,s)},lE.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},//
u$.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},//
h0.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},h0.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},//
lb.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},lb.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},lb.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},//
l5.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},l5.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},l5.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},l5.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},l5.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},l5.barycoordFromPoint=function(t,e,i,r,n){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),l5.getBarycoord(t,e,i,r,n)},l5.normal=function(t,e,i,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),l5.getNormal(t,e,i,r)},//
ml.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},ml.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new fF(this,t)},ml.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new fz(this,t)},//
hX.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},hX.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},hX.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
h1.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},h1.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},h1.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},h1.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},h1.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},h1.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},h1.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},h1.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},h1.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
hZ.prototype.fromAttribute=function(t,e,i){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},hZ.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
lY.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},lY.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},lY.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},lY.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},lY.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(lY.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),uB.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(uB.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),pD.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},//
uX.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},//
Object.defineProperties(mu.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),//
Object.defineProperties(ua.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),ua.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?35048:35044),this},ua.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ua.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},//
uv.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},uv.prototype.addAttribute=function(t,e){return(console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute)?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new ua(arguments[1],arguments[2])))},uv.prototype.addDrawCall=function(t,e,i){void 0!==i&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},uv.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},uv.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},uv.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},uv.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(uv.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),pp.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?35048:35044),this},pp.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},//
fF.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},fF.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},fF.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},//
pd.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},//
mz.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},//
Object.defineProperties(l6.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new ur}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(uj.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),//
pl.prototype.clearTarget=function(t,e,i,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,i,r)},pl.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},pl.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},pl.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},pl.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},pl.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},pl.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},pl.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},pl.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},pl.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},pl.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},pl.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},pl.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},pl.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},pl.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},pl.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},pl.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},pl.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},pl.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},pl.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},pl.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},pl.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},pl.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},pl.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},pl.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(pl.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(d9.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),//
Object.defineProperties(h$.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),//
(class extends lY{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;let e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return!0===this.isPlaying&&(// update current progress
this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this;// only set detune when available
}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}).prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");let e=this,i=new mM;return i.load(t,function(t){e.setBuffer(t)}),this},(class{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0,e=this.getFrequencyData();for(let i=0;i<e.length;i++)t+=e[i];return t/e.length}}).prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},//
uW.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},uW.prototype.clear=function(t,e,i,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,i,r)},hY.crossOrigin=void 0,hY.loadTexture=function(t,e,i,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");let n=new mo;n.setCrossOrigin(this.crossOrigin);let s=n.load(t,i,void 0,r);return e&&(s.mapping=e),s},hY.loadTextureCube=function(t,e,i,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");let n=new ms;n.setCrossOrigin(this.crossOrigin);let s=n.load(t,i,void 0,r);return e&&(s.mapping=e),s},hY.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},hY.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&/* eslint-disable no-undef */__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"131"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="131");const mZ=()=>window.BASE_URL||".";class m${init(t){"string"==typeof t?this.canvas=document.getElementById(t):this.canvas=t,this.renderer=new pl({canvas:this.canvas}),this.renderer.setSize(this.canvas.width,this.canvas.height),this.renderer.setPixelRatio(window.devicePixelRatio),this.scene=new pd,this.clock=new mA,this.load(),this.clock.start(),this.loop(0)}loop(t){let e=Math.min(t-this.lastTime,100);this.lastTime=t,this.gameTime+=e,this.update(16,this.gameTime),this.running&&(this.animFrameRequest=requestAnimationFrame(t=>this.loop(t)))}destroy(){cancelAnimationFrame(this.animFrameRequest),this.running=!1}constructor(){this.lastTime=0,this.gameTime=0,this.running=!0}}class mQ{constructor(t){this.config=t}init(t,e=!1){"string"==typeof t?this.canvas=document.getElementById(t):this.canvas=t,this.app=new sy({view:this.canvas,...this.config}),this.load(),e||this.app.ticker.add(t=>this.update(t))}destroy(){this.app.destroy()}}class m0{constructor(t){this.config=t}init(t){this.engine=new hm,"string"==typeof t?this.canvas=document.getElementById(t):this.canvas=t,this.engine.init(this.canvas,this.config),this.load()}destroy(){this.engine.destroy(),this.onDestroy()}onDestroy(){// override
}}class m1 extends mQ{static #t=(()=>{this.particlesNum=250})();load(){this.container=new s9(m1.particlesNum,{position:!0,rotation:!0});let t=rH.from(`${mZ()}/assets/02-pixi-intro/ghost.png`);for(let e=0;e<m1.particlesNum;e++){let e=new oB(t);e.position.set(Math.random()*this.app.screen.width,Math.random()*this.app.screen.height),e.anchor.set(.5),e.rotation=Math.random()*Math.PI,e.scale.set(.25),this.container.addChild(e)}this.app.stage.addChild(this.container)}update(t){for(let e of this.container.children)e.rotation+=.1*t}}/*!
 * pixi-sound - v3.0.5
 * https://github.com/pixijs/pixi-sound
 * Compiled Thu, 09 Jul 2020 17:33:34 UTC
 *
 * pixi-sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 *//*!
 * @pixi/loaders - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*!
 * resource-loader - v3.0.1
 * https://github.com/pixijs/pixi-sound
 * Compiled Tue, 02 Jul 2019 14:06:18 UTC
 *
 * resource-loader is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */var m2={};m2=(t,e={})=>{if(!t)return;let i={key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/}},r=i.parser[e.strictMode?"strict":"loose"].exec(t),n={},s=14;for(;s--;)n[i.key[s]]=r[s]||"";return n[i.q.name]={},n[i.key[12]].replace(i.q.parser,function(t,e,r){e&&(n[i.q.name][e]=r)}),n};var m3={};Object.defineProperty(m3,"__esModule",{value:!0});var m5=function(){function t(t,e){for(var i=0;i<e.length;i++){var r=e[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,i,r){return i&&t(e.prototype,i),r&&t(e,r),e}}();function m4(t,e){if(!(t instanceof e))throw TypeError("Cannot call a class as a function")}var m6=function(){function t(e,i,r){void 0===i&&(i=!1),m4(this,t),this._fn=e,this._once=i,this._thisArg=r,this._next=this._prev=this._owner=null}return m5(t,[{key:"detach",value:function(){return null!==this._owner&&(this._owner.detach(this),!0)}}]),t}();function m8(t,e){return t._head?(t._tail._next=e,e._prev=t._tail):t._head=e,t._tail=e,e._owner=t,e}var m7=function(){function t(){m4(this,t),this._head=this._tail=void 0}return m5(t,[{key:"handlers",value:function(){var t=!(arguments.length<=0)&&void 0!==arguments[0]&&arguments[0],e=this._head;if(t)return!!e;for(var i=[];e;)i.push(e),e=e._next;return i}},{key:"has",value:function(t){if(!(t instanceof m6))throw Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");return t._owner===this}},{key:"dispatch",value:function(){var t=this._head;if(!t)return!1;for(;t;)t._once&&this.detach(t),t._fn.apply(t._thisArg,arguments),t=t._next;return!0}},{key:"add",value:function(t){var e=arguments.length<=1||void 0===arguments[1]?null:arguments[1];if("function"!=typeof t)throw Error("MiniSignal#add(): First arg must be a Function.");return m8(this,new m6(t,!1,e))}},{key:"once",value:function(t){var e=arguments.length<=1||void 0===arguments[1]?null:arguments[1];if("function"!=typeof t)throw Error("MiniSignal#once(): First arg must be a Function.");return m8(this,new m6(t,!0,e))}},{key:"detach",value:function(t){if(!(t instanceof m6))throw Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");return t._owner!==this||(t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t===this._head?(this._head=t._next,null===t._next&&(this._tail=null)):t===this._tail&&(this._tail=t._prev,this._tail._next=null),t._owner=null),this}},{key:"detachAll",value:function(){var t=this._head;if(!t)return this;for(this._head=this._tail=null;t;)t._owner=null,t=t._next;return this}}]),t}();/**
 * Smaller version of the async library constructs.
 *
 * @namespace async
 *//**
 * Noop function
 *
 * @ignore
 * @function
 * @memberof async
 */function m9(){}/* empty *//**
 * Iterates an array in series.
 *
 * @memberof async
 * @function eachSeries
 * @param {Array.<*>} array - Array to iterate.
 * @param {function} iterator - Function to call for each element.
 * @param {function} callback - Function to call when done, or on error.
 * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.
 */function gt(t,e,i,r){var n=0,s=t.length;!function o(a){if(a||n===s){i&&i(a);return}r?setTimeout(function(){e(t[n++],o)},1):e(t[n++],o)}()}m7.MiniSignalBinding=m6,m3.default=m7,m3=m3.default;// a simple in-memory cache for resources
var ge={};function gi(t,e){for(var i=0;i<e.length;i++){var r=e[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function gr(t,e,i){return e&&gi(t.prototype,e),i&&gi(t,i),t}var gn=!!(window.XDomainRequest&&!("withCredentials"in new XMLHttpRequest)),gs=null;function go(){}/* empty *//**
 * Manages the state and loading of a resource and all child resources.
 *
 * @class
 */var ga=/*#__PURE__*/function(){function t(e,i,r){if("string"!=typeof e||"string"!=typeof i)throw Error("Both name and url are required for constructing a resource.");r=r||{},/**
     * The state flags of this resource.
     *
     * @private
     * @member {number}
     */this._flags=0,this._setFlag(t.STATUS_FLAGS.DATA_URL,0===i.indexOf("data:")),/**
     * The name of this resource.
     *
     * @readonly
     * @member {string}
     */this.name=e,/**
     * The url used to load this resource.
     *
     * @readonly
     * @member {string}
     */this.url=i,/**
     * The extension used to load this resource.
     *
     * @readonly
     * @member {string}
     */this.extension=this._getExtension(),/**
     * The data that was loaded by the resource.
     *
     * @member {any}
     */this.data=null,/**
     * Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}
     */this.crossOrigin=!0===r.crossOrigin?"anonymous":r.crossOrigin,/**
     * A timeout in milliseconds for the load. If the load takes longer than this time
     * it is cancelled and the load is considered a failure. If this value is set to `0`
     * then there is no explicit timeout.
     *
     * @member {number}
     */this.timeout=r.timeout||0,/**
     * The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}
     */this.loadType=r.loadType||this._determineLoadType(),/**
     * The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {string}
     */this.xhrType=r.xhrType,/**
     * Extra info for middleware, and controlling specifics about how the resource loads.
     *
     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
     * Meaning it will modify it as it sees fit.
     *
     * @member {Resource.IMetadata}
     */this.metadata=r.metadata||{},/**
     * The error that occurred while loading (if any).
     *
     * @readonly
     * @member {Error}
     */this.error=null,/**
     * The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @readonly
     * @member {XMLHttpRequest}
     */this.xhr=null,/**
     * The child resources this resource owns.
     *
     * @readonly
     * @member {Resource[]}
     */this.children=[],/**
     * The resource type.
     *
     * @readonly
     * @member {Resource.TYPE}
     */this.type=t.TYPE.UNKNOWN,/**
     * The progress chunk owned by this resource.
     *
     * @readonly
     * @member {number}
     */this.progressChunk=0,/**
     * The `dequeue` method that will be used a storage place for the async queue dequeue method
     * used privately by the loader.
     *
     * @private
     * @member {function}
     */this._dequeue=go,/**
     * Used a storage place for the on load binding used privately by the loader.
     *
     * @private
     * @member {function}
     */this._onLoadBinding=null,/**
     * The timer for element loads to check if they timeout.
     *
     * @private
     * @member {number}
     */this._elementTimer=0,/**
     * The `complete` function bound to this resource's context.
     *
     * @private
     * @member {function}
     */this._boundComplete=this.complete.bind(this),/**
     * The `_onError` function bound to this resource's context.
     *
     * @private
     * @member {function}
     */this._boundOnError=this._onError.bind(this),/**
     * The `_onProgress` function bound to this resource's context.
     *
     * @private
     * @member {function}
     */this._boundOnProgress=this._onProgress.bind(this),/**
     * The `_onTimeout` function bound to this resource's context.
     *
     * @private
     * @member {function}
     */this._boundOnTimeout=this._onTimeout.bind(this),this._boundXhrOnError=this._xhrOnError.bind(this),this._boundXhrOnTimeout=this._xhrOnTimeout.bind(this),this._boundXhrOnAbort=this._xhrOnAbort.bind(this),this._boundXhrOnLoad=this._xhrOnLoad.bind(this),/**
     * Dispatched when the resource beings to load.
     *
     * The callback looks like {@link Resource.OnStartSignal}.
     *
     * @member {Signal<Resource.OnStartSignal>}
     */this.onStart=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched each time progress of this resource load updates.
     * Not all resources types and loader systems can support this event
     * so sometimes it may not be available. If the resource
     * is being loaded on a modern browser, using XHR, and the remote server
     * properly sets Content-Length headers, then this will be available.
     *
     * The callback looks like {@link Resource.OnProgressSignal}.
     *
     * @member {Signal<Resource.OnProgressSignal>}
     */this.onProgress=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched once this resource has loaded, if there was an error it will
     * be in the `error` property.
     *
     * The callback looks like {@link Resource.OnCompleteSignal}.
     *
     * @member {Signal<Resource.OnCompleteSignal>}
     */this.onComplete=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched after this resource has had all the *after* middleware run on it.
     *
     * The callback looks like {@link Resource.OnCompleteSignal}.
     *
     * @member {Signal<Resource.OnCompleteSignal>}
     */this.onAfterMiddleware=new/*@__PURE__*/(tP(m3))}/**
   * Sets the load type to be used for a specific extension.
   *
   * @static
   * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
   * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
   */t.setExtensionLoadType=function(e,i){gh(t._loadTypeMap,e,i)}/**
   * Sets the load type to be used for a specific extension.
   *
   * @static
   * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
   * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
   */,t.setExtensionXhrType=function(e,i){gh(t._xhrTypeMap,e,i)}/**
   * @param {string} name - The name of the resource to load.
   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
   *      an array of sources.
   * @param {object} [options] - The options for the load.
   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
   *      determine automatically.
   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes
   *      longer than this time it is cancelled and the load is considered a failure. If this value is
   *      set to `0` then there is no explicit timeout.
   * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource
   *      be loaded?
   * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
   *      should the data being loaded be interpreted when using XHR?
   * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.
   */;/**
   * When the resource starts to load.
   *
   * @memberof Resource
   * @callback OnStartSignal
   * @param {Resource} resource - The resource that the event happened on.
   *//**
   * When the resource reports loading progress.
   *
   * @memberof Resource
   * @callback OnProgressSignal
   * @param {Resource} resource - The resource that the event happened on.
   * @param {number} percentage - The progress of the load in the range [0, 1].
   *//**
   * When the resource finishes loading.
   *
   * @memberof Resource
   * @callback OnCompleteSignal
   * @param {Resource} resource - The resource that the event happened on.
   *//**
   * @memberof Resource
   * @typedef {object} IMetadata
   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
   *      element to use for loading, instead of creating one.
   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
   *      is useful if you want to pass in a `loadElement` that you already added load sources to.
   * @property {string|string[]} [mimeType] - The mime type to use for the source element
   *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
   *      where each index is the mime type to use for the corresponding url index.
   *//**
   * Stores whether or not this url is a data url.
   *
   * @readonly
   * @member {boolean}
   */var e=t.prototype;return(/**
   * Marks the resource as complete.
   *
   */e.complete=function(){this._clearEvents(),this._finish()}/**
   * Aborts the loading of this resource, with an optional message.
   *
   * @param {string} message - The message to use for the error
   */,e.abort=function(e){// abort can be called multiple times, ignore subsequent calls.
if(!this.error){if(// store error
this.error=Error(e),this._clearEvents(),this.xhr)this.xhr.abort();else if(this.xdr)this.xdr.abort();else if(this.data){// single source
if(this.data.src)this.data.src=t.EMPTY_GIF;else for(;this.data.firstChild;)this.data.removeChild(this.data.firstChild)}// done now.
this._finish()}}/**
   * Kicks off loading of this resource. This method is asynchronous.
   *
   * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.
   */,e.load=function(e){var i=this;if(!this.isLoading){if(this.isComplete){e&&setTimeout(function(){return e(i)},1);return}switch(e&&this.onComplete.once(e),this._setFlag(t.STATUS_FLAGS.LOADING,!0),this.onStart.dispatch(this),(!1===this.crossOrigin||"string"!=typeof this.crossOrigin)&&(this.crossOrigin=this._determineCrossOrigin(this.url)),this.loadType){case t.LOAD_TYPE.IMAGE:this.type=t.TYPE.IMAGE,this._loadElement("image");break;case t.LOAD_TYPE.AUDIO:this.type=t.TYPE.AUDIO,this._loadSourceElement("audio");break;case t.LOAD_TYPE.VIDEO:this.type=t.TYPE.VIDEO,this._loadSourceElement("video");break;case t.LOAD_TYPE.XHR:/* falls through */default:gn&&this.crossOrigin?this._loadXdr():this._loadXhr()}}}/**
   * Checks if the flag is set.
   *
   * @private
   * @param {number} flag - The flag to check.
   * @return {boolean} True if the flag is set.
   */,e._hasFlag=function(t){return(this._flags&t)!=0}/**
   * (Un)Sets the flag.
   *
   * @private
   * @param {number} flag - The flag to (un)set.
   * @param {boolean} value - Whether to set or (un)set the flag.
   */,e._setFlag=function(t,e){this._flags=e?this._flags|t:this._flags&~t}/**
   * Clears all the events from the underlying loading source.
   *
   * @private
   */,e._clearEvents=function(){clearTimeout(this._elementTimer),this.data&&this.data.removeEventListener&&(this.data.removeEventListener("error",this._boundOnError,!1),this.data.removeEventListener("load",this._boundComplete,!1),this.data.removeEventListener("progress",this._boundOnProgress,!1),this.data.removeEventListener("canplaythrough",this._boundComplete,!1)),this.xhr&&(this.xhr.removeEventListener?(this.xhr.removeEventListener("error",this._boundXhrOnError,!1),this.xhr.removeEventListener("timeout",this._boundXhrOnTimeout,!1),this.xhr.removeEventListener("abort",this._boundXhrOnAbort,!1),this.xhr.removeEventListener("progress",this._boundOnProgress,!1),this.xhr.removeEventListener("load",this._boundXhrOnLoad,!1)):(this.xhr.onerror=null,this.xhr.ontimeout=null,this.xhr.onprogress=null,this.xhr.onload=null))}/**
   * Finalizes the load.
   *
   * @private
   */,e._finish=function(){if(this.isComplete)throw Error("Complete called again for an already completed resource.");this._setFlag(t.STATUS_FLAGS.COMPLETE,!0),this._setFlag(t.STATUS_FLAGS.LOADING,!1),this.onComplete.dispatch(this)}/**
   * Loads this resources using an element that has a single source,
   * like an HTMLImageElement.
   *
   * @private
   * @param {string} type - The type of element to use.
   */,e._loadElement=function(t){this.metadata.loadElement?this.data=this.metadata.loadElement:"image"===t&&void 0!==window.Image?this.data=new Image:this.data=document.createElement(t),this.crossOrigin&&(this.data.crossOrigin=this.crossOrigin),this.metadata.skipSource||(this.data.src=this.url),this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1),this.timeout&&(this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout))}/**
   * Loads this resources using an element that has multiple sources,
   * like an HTMLAudioElement or HTMLVideoElement.
   *
   * @private
   * @param {string} type - The type of element to use.
   */,e._loadSourceElement=function(t){if(this.metadata.loadElement?this.data=this.metadata.loadElement:"audio"===t&&void 0!==window.Audio?this.data=new Audio:this.data=document.createElement(t),null===this.data){this.abort("Unsupported element: "+t);return}if(this.crossOrigin&&(this.data.crossOrigin=this.crossOrigin),!this.metadata.skipSource){// support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
if(navigator.isCocoonJS)this.data.src=Array.isArray(this.url)?this.url[0]:this.url;else if(Array.isArray(this.url))for(var e=this.metadata.mimeType,i=0;i<this.url.length;++i)this.data.appendChild(this._createSource(t,this.url[i],Array.isArray(e)?e[i]:e));else{var r=this.metadata.mimeType;this.data.appendChild(this._createSource(t,this.url,Array.isArray(r)?r[0]:r))}}this.data.addEventListener("error",this._boundOnError,!1),this.data.addEventListener("load",this._boundComplete,!1),this.data.addEventListener("progress",this._boundOnProgress,!1),this.data.addEventListener("canplaythrough",this._boundComplete,!1),this.data.load(),this.timeout&&(this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout))}/**
   * Loads this resources using an XMLHttpRequest.
   *
   * @private
   */,e._loadXhr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var e=this.xhr=new XMLHttpRequest;// set the request type and url
e.open("GET",this.url,!0),e.timeout=this.timeout,this.xhrType===t.XHR_RESPONSE_TYPE.JSON||this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT?e.responseType=t.XHR_RESPONSE_TYPE.TEXT:e.responseType=this.xhrType,e.addEventListener("error",this._boundXhrOnError,!1),e.addEventListener("timeout",this._boundXhrOnTimeout,!1),e.addEventListener("abort",this._boundXhrOnAbort,!1),e.addEventListener("progress",this._boundOnProgress,!1),e.addEventListener("load",this._boundXhrOnLoad,!1),e.send()}/**
   * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
   *
   * @private
   */,e._loadXdr=function(){"string"!=typeof this.xhrType&&(this.xhrType=this._determineXhrType());var t=this.xhr=new XDomainRequest;// eslint-disable-line no-undef
// XDomainRequest has a few quirks. Occasionally it will abort requests
// A way to avoid this is to make sure ALL callbacks are set even if not used
// More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
t.timeout=this.timeout||5e3,t.onerror=this._boundXhrOnError,t.ontimeout=this._boundXhrOnTimeout,t.onprogress=this._boundOnProgress,t.onload=this._boundXhrOnLoad,t.open("GET",this.url,!0),// issue with the interface where some requests are lost if multiple
// XDomainRequests are being sent at the same time.
// Some info here: https://github.com/photonstorm/phaser/issues/1248
setTimeout(function(){return t.send()},1)}/**
   * Creates a source used in loading via an element.
   *
   * @private
   * @param {string} type - The element type (video or audio).
   * @param {string} url - The source URL to load from.
   * @param {string} [mime] - The mime type of the video
   * @return {HTMLSourceElement} The source element.
   */,e._createSource=function(t,e,i){i||(i=t+"/"+this._getExtension(e));var r=document.createElement("source");return r.src=e,r.type=i,r}/**
   * Called if a load errors out.
   *
   * @param {Event} event - The error event from the element that emits it.
   * @private
   */,e._onError=function(t){this.abort("Failed to load element using: "+t.target.nodeName)}/**
   * Called if a load progress event fires for an element or xhr/xdr.
   *
   * @private
   * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
   */,e._onProgress=function(t){t&&t.lengthComputable&&this.onProgress.dispatch(this,t.loaded/t.total)}/**
   * Called if a timeout event fires for an element.
   *
   * @private
   */,e._onTimeout=function(){this.abort("Load timed out.")}/**
   * Called if an error event fires for xhr/xdr.
   *
   * @private
   */,e._xhrOnError=function(){var t=this.xhr;this.abort(gl(t)+" Request failed. Status: "+t.status+', text: "'+t.statusText+'"')}/**
   * Called if an error event fires for xhr/xdr.
   *
   * @private
   */,e._xhrOnTimeout=function(){var t=this.xhr;this.abort(gl(t)+" Request timed out.")}/**
   * Called if an abort event fires for xhr/xdr.
   *
   * @private
   */,e._xhrOnAbort=function(){var t=this.xhr;this.abort(gl(t)+" Request was aborted by the user.")}/**
   * Called when data successfully loads from an xhr/xdr request.
   *
   * @private
   * @param {XMLHttpRequestLoadEvent|Event} event - Load event
   */,e._xhrOnLoad=function(){var e=this.xhr,i="",r=void 0===e.status?200:e.status;if((""===e.responseType||"text"===e.responseType||void 0===e.responseType)&&(i=e.responseText),0===r&&(i.length>0||e.responseType===t.XHR_RESPONSE_TYPE.BUFFER)?r=200:1223===r&&(r=204),(r/100|0)==2){// if text, just return it
if(this.xhrType===t.XHR_RESPONSE_TYPE.TEXT)this.data=i,this.type=t.TYPE.TEXT;else if(this.xhrType===t.XHR_RESPONSE_TYPE.JSON)try{this.data=JSON.parse(i),this.type=t.TYPE.JSON}catch(t){this.abort("Error trying to parse loaded json: "+t);return}else if(this.xhrType===t.XHR_RESPONSE_TYPE.DOCUMENT)try{if(window.DOMParser){var n=new DOMParser;this.data=n.parseFromString(i,"text/xml")}else{var s=document.createElement("div");s.innerHTML=i,this.data=s}this.type=t.TYPE.XML}catch(t){this.abort("Error trying to parse loaded xml: "+t);return}else this.data=e.response||i}else{this.abort("["+e.status+"] "+e.statusText+": "+e.responseURL);return}this.complete()}/**
   * Sets the `crossOrigin` property for this resource based on if the url
   * for this resource is cross-origin. If crossOrigin was manually set, this
   * function does nothing.
   *
   * @private
   * @param {string} url - The url to test.
   * @param {object} [loc=window.location] - The location object to test against.
   * @return {string} The crossOrigin value to use (or empty string for none).
   */,e._determineCrossOrigin=function(t,e){// data: and javascript: urls are considered same-origin
if(0===t.indexOf("data:"))return"";// A sandboxed iframe without the 'allow-same-origin' attribute will have a special
// origin designed not to match window.location.origin, and will always require
// crossOrigin requests regardless of whether the location matches.
if(window.origin!==window.location.origin)return"anonymous";// default is window.location
e=e||window.location,gs||(gs=document.createElement("a")),// let the browser determine the full href for the url of this resource and then
// parse with the node url lib, we can't use the properties of the anchor element
// because they don't work in IE9 :(
gs.href=t;var i=!(t=/*@__PURE__*/tP(m2)(gs.href,{strictMode:!0})).port&&""===e.port||t.port===e.port,r=t.protocol?t.protocol+":":"";return t.host===e.hostname&&i&&r===e.protocol?"":"anonymous"}/**
   * Determines the responseType of an XHR request based on the extension of the
   * resource being loaded.
   *
   * @private
   * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
   */,e._determineXhrType=function(){return t._xhrTypeMap[this.extension]||t.XHR_RESPONSE_TYPE.TEXT}/**
   * Determines the loadType of a resource based on the extension of the
   * resource being loaded.
   *
   * @private
   * @return {Resource.LOAD_TYPE} The loadType to use.
   */,e._determineLoadType=function(){return t._loadTypeMap[this.extension]||t.LOAD_TYPE.XHR}/**
   * Extracts the extension (sans '.') of the file being loaded by the resource.
   *
   * @private
   * @return {string} The extension.
   */,e._getExtension=function(){var t=this.url,e="";if(this.isDataUrl){var i=t.indexOf("/");e=t.substring(i+1,t.indexOf(";",i))}else{var r=t.indexOf("?"),n=t.indexOf("#"),s=Math.min(r>-1?r:t.length,n>-1?n:t.length);e=(t=t.substring(0,s)).substring(t.lastIndexOf(".")+1)}return e.toLowerCase()}/**
   * Determines the mime type of an XHR request based on the responseType of
   * resource being loaded.
   *
   * @private
   * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
   * @return {string} The mime type to use.
   */,e._getMimeFromXhrType=function(e){switch(e){case t.XHR_RESPONSE_TYPE.BUFFER:return"application/octet-binary";case t.XHR_RESPONSE_TYPE.BLOB:return"application/blob";case t.XHR_RESPONSE_TYPE.DOCUMENT:return"application/xml";case t.XHR_RESPONSE_TYPE.JSON:return"application/json";case t.XHR_RESPONSE_TYPE.DEFAULT:case t.XHR_RESPONSE_TYPE.TEXT:/* falls through */default:return"text/plain"}},gr(t,[{key:"isDataUrl",get:function(){return this._hasFlag(t.STATUS_FLAGS.DATA_URL)}},{key:"isComplete",get:function(){return this._hasFlag(t.STATUS_FLAGS.COMPLETE)}},{key:"isLoading",get:function(){return this._hasFlag(t.STATUS_FLAGS.LOADING)}}]),t)}();/**
 * Quick helper to set a value on one of the extension maps. Ensures there is no
 * dot at the start of the extension.
 *
 * @ignore
 * @param {object} map - The map to set on.
 * @param {string} extname - The extension (or key) to set.
 * @param {number} val - The value to set.
 */function gh(t,e,i){e&&0===e.indexOf(".")&&(e=e.substring(1)),e&&(t[e]=i)}/**
 * Quick helper to get string xhr type.
 *
 * @ignore
 * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
 * @return {string} The type.
 */function gl(t){return t.toString().replace("object ","")}/**
 * The types of resources a resource could represent.
 *
 * @static
 * @readonly
 * @enum {number}
 */ga.STATUS_FLAGS={NONE:0,DATA_URL:1,COMPLETE:2,LOADING:4},/**
 * The types of resources a resource could represent.
 *
 * @static
 * @readonly
 * @enum {number}
 */ga.TYPE={UNKNOWN:0,JSON:1,XML:2,IMAGE:3,AUDIO:4,VIDEO:5,TEXT:6},/**
 * The types of loading a resource can use.
 *
 * @static
 * @readonly
 * @enum {number}
 */ga.LOAD_TYPE={/** Uses XMLHttpRequest to load the resource. */XHR:1,/** Uses an `Image` object to load the resource. */IMAGE:2,/** Uses an `Audio` object to load the resource. */AUDIO:3,/** Uses a `Video` object to load the resource. */VIDEO:4},/**
 * The XHR ready states, used internally.
 *
 * @static
 * @readonly
 * @enum {string}
 */ga.XHR_RESPONSE_TYPE={/** string */DEFAULT:"text",/** ArrayBuffer */BUFFER:"arraybuffer",/** Blob */BLOB:"blob",/** Document */DOCUMENT:"document",/** Object */JSON:"json",/** String */TEXT:"text"},ga._loadTypeMap={// images
gif:ga.LOAD_TYPE.IMAGE,png:ga.LOAD_TYPE.IMAGE,bmp:ga.LOAD_TYPE.IMAGE,jpg:ga.LOAD_TYPE.IMAGE,jpeg:ga.LOAD_TYPE.IMAGE,tif:ga.LOAD_TYPE.IMAGE,tiff:ga.LOAD_TYPE.IMAGE,webp:ga.LOAD_TYPE.IMAGE,tga:ga.LOAD_TYPE.IMAGE,svg:ga.LOAD_TYPE.IMAGE,"svg+xml":ga.LOAD_TYPE.IMAGE,// for SVG data urls
// audio
mp3:ga.LOAD_TYPE.AUDIO,ogg:ga.LOAD_TYPE.AUDIO,wav:ga.LOAD_TYPE.AUDIO,// videos
mp4:ga.LOAD_TYPE.VIDEO,webm:ga.LOAD_TYPE.VIDEO},ga._xhrTypeMap={// xml
xhtml:ga.XHR_RESPONSE_TYPE.DOCUMENT,html:ga.XHR_RESPONSE_TYPE.DOCUMENT,htm:ga.XHR_RESPONSE_TYPE.DOCUMENT,xml:ga.XHR_RESPONSE_TYPE.DOCUMENT,tmx:ga.XHR_RESPONSE_TYPE.DOCUMENT,svg:ga.XHR_RESPONSE_TYPE.DOCUMENT,// This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
// Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
// this should probably be fine.
tsx:ga.XHR_RESPONSE_TYPE.DOCUMENT,// images
gif:ga.XHR_RESPONSE_TYPE.BLOB,png:ga.XHR_RESPONSE_TYPE.BLOB,bmp:ga.XHR_RESPONSE_TYPE.BLOB,jpg:ga.XHR_RESPONSE_TYPE.BLOB,jpeg:ga.XHR_RESPONSE_TYPE.BLOB,tif:ga.XHR_RESPONSE_TYPE.BLOB,tiff:ga.XHR_RESPONSE_TYPE.BLOB,webp:ga.XHR_RESPONSE_TYPE.BLOB,tga:ga.XHR_RESPONSE_TYPE.BLOB,// json
json:ga.XHR_RESPONSE_TYPE.JSON,// text
text:ga.XHR_RESPONSE_TYPE.TEXT,txt:ga.XHR_RESPONSE_TYPE.TEXT,// fonts
ttf:ga.XHR_RESPONSE_TYPE.BUFFER,otf:ga.XHR_RESPONSE_TYPE.BUFFER},ga.EMPTY_GIF="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";var gu=window.URL||window.webkitURL,gc=/(#[\w-]+)?$/,gd=/*#__PURE__*/function(){/**
   * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
   * @param {number} [concurrency=10] - The number of resources to load concurrently.
   */function t(e,i){var r=this;void 0===e&&(e=""),void 0===i&&(i=10),/**
     * The base url for all resources loaded by this loader.
     *
     * @member {string}
     */this.baseUrl=e,/**
     * The progress percent of the loader going through the queue.
     *
     * @member {number}
     * @default 0
     */this.progress=0,/**
     * Loading state of the loader, true if it is currently loading resources.
     *
     * @member {boolean}
     * @default false
     */this.loading=!1,/**
     * A querystring to append to every URL added to the loader.
     *
     * This should be a valid query string *without* the question-mark (`?`). The loader will
     * also *not* escape values for you. Make sure to escape your parameters with
     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.
     *
     * @example
     * const loader = new Loader();
     *
     * loader.defaultQueryString = 'user=me&password=secret';
     *
     * // This will request 'image.png?user=me&password=secret'
     * loader.add('image.png').load();
     *
     * loader.reset();
     *
     * // This will request 'image.png?v=1&user=me&password=secret'
     * loader.add('iamge.png?v=1').load();
     *
     * @member {string}
     * @default ''
     */this.defaultQueryString="",/**
     * The middleware to run before loading each resource.
     *
     * @private
     * @member {function[]}
     */this._beforeMiddleware=[],/**
     * The middleware to run after loading each resource.
     *
     * @private
     * @member {function[]}
     */this._afterMiddleware=[],/**
     * The tracks the resources we are currently completing parsing for.
     *
     * @private
     * @member {Resource[]}
     */this._resourcesParsing=[],/**
     * The `_loadResource` function bound with this object context.
     *
     * @private
     * @member {function}
     * @param {Resource} r - The resource to load
     * @param {Function} d - The dequeue function
     * @return {undefined}
     */this._boundLoadResource=function(t,e){return r._loadResource(t,e)},/**
     * The resources waiting to be loaded.
     *
     * @private
     * @member {Resource[]}
     */this._queue=/**
 * Async queue implementation,
 *
 * @memberof async
 * @function queue
 * @param {function} worker - The worker function to call for each task.
 * @param {number} concurrency - How many workers to run in parrallel.
 * @return {*} The async queue object.
 */function(t,e){if(null==e)e=1;else if(0===e)throw Error("Concurrency must not be zero");var i=0,r={_tasks:[],concurrency:e,saturated:m9,unsaturated:m9,buffer:e/4,empty:m9,drain:m9,error:m9,started:!1,paused:!1,push:function(t,e){n(t,!1,e)},kill:function(){i=0,r.drain=m9,r.started=!1,r._tasks=[]},unshift:function(t,e){n(t,!0,e)},process:function(){for(;!r.paused&&i<r.concurrency&&r._tasks.length;){var e=r._tasks.shift();0===r._tasks.length&&r.empty(),(i+=1)===r.concurrency&&r.saturated(),t(e.data,/**
 * Ensures a function is only called once.
 *
 * @ignore
 * @memberof async
 * @param {function} fn - The function to wrap.
 * @return {function} The wrapping function.
 */function(t){return function(){if(null===t)throw Error("Callback was already called.");var e=t;t=null,e.apply(this,arguments)}}(function(t){return function(){i-=1,t.callback.apply(t,arguments),null!=arguments[0]&&r.error(arguments[0],t.data),i<=r.concurrency-r.buffer&&r.unsaturated(),r.idle()&&r.drain(),r.process()}}(e)))}},length:function(){return r._tasks.length},running:function(){return i},idle:function(){return r._tasks.length+i===0},pause:function(){!0!==r.paused&&(r.paused=!0)},resume:function(){if(!1!==r.paused){r.paused=!1;// Need to call q.process once per concurrent
// worker to preserve full concurrency after pause
for(var t=1;t<=r.concurrency;t++)r.process()}}};function n(t,e,i){if(null!=i&&"function"!=typeof i)throw Error("task callback must be a function");if(r.started=!0,null==t&&r.idle()){// eslint-disable-line no-eq-null,eqeqeq
// call drain immediately if there are no tasks
setTimeout(function(){return r.drain()},1);return}var n={data:t,callback:"function"==typeof i?i:m9};e?r._tasks.unshift(n):r._tasks.push(n),setTimeout(function(){return r.process()},1)}return r}(this._boundLoadResource,i),this._queue.pause(),/**
     * All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}
     */this.resources={},/**
     * Dispatched once per loaded or errored resource.
     *
     * The callback looks like {@link Loader.OnProgressSignal}.
     *
     * @member {Signal<Loader.OnProgressSignal>}
     */this.onProgress=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched once per errored resource.
     *
     * The callback looks like {@link Loader.OnErrorSignal}.
     *
     * @member {Signal<Loader.OnErrorSignal>}
     */this.onError=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched once per loaded resource.
     *
     * The callback looks like {@link Loader.OnLoadSignal}.
     *
     * @member {Signal<Loader.OnLoadSignal>}
     */this.onLoad=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched when the loader begins to process the queue.
     *
     * The callback looks like {@link Loader.OnStartSignal}.
     *
     * @member {Signal<Loader.OnStartSignal>}
     */this.onStart=new/*@__PURE__*/(tP(m3)),/**
     * Dispatched when the queued resources all load.
     *
     * The callback looks like {@link Loader.OnCompleteSignal}.
     *
     * @member {Signal<Loader.OnCompleteSignal>}
     */this.onComplete=new/*@__PURE__*/(tP(m3));for(var n=0;n<t._defaultBeforeMiddleware.length;++n)this.pre(t._defaultBeforeMiddleware[n]);// Add default after middleware
for(var s=0;s<t._defaultAfterMiddleware.length;++s)this.use(t._defaultAfterMiddleware[s])}/**
   * When the progress changes the loader and resource are disaptched.
   *
   * @memberof Loader
   * @callback OnProgressSignal
   * @param {Loader} loader - The loader the progress is advancing on.
   * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.
   *//**
   * When an error occurrs the loader and resource are disaptched.
   *
   * @memberof Loader
   * @callback OnErrorSignal
   * @param {Loader} loader - The loader the error happened in.
   * @param {Resource} resource - The resource that caused the error.
   *//**
   * When a load completes the loader and resource are disaptched.
   *
   * @memberof Loader
   * @callback OnLoadSignal
   * @param {Loader} loader - The loader that laoded the resource.
   * @param {Resource} resource - The resource that has completed loading.
   *//**
   * When the loader starts loading resources it dispatches this callback.
   *
   * @memberof Loader
   * @callback OnStartSignal
   * @param {Loader} loader - The loader that has started loading resources.
   *//**
   * When the loader completes loading resources it dispatches this callback.
   *
   * @memberof Loader
   * @callback OnCompleteSignal
   * @param {Loader} loader - The loader that has finished loading resources.
   *//**
   * Options for a call to `.add()`.
   *
   * @see Loader#add
   *
   * @typedef {object} IAddOptions
   * @property {string} [name] - The name of the resource to load, if not passed the url is used.
   * @property {string} [key] - Alias for `name`.
   * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.
   * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to
   *      determine automatically.
   * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes
   *      longer than this time it is cancelled and the load is considered a failure. If this value is
   *      set to `0` then there is no explicit timeout.
   * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource
   *      be loaded?
   * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
   *      should the data being loaded be interpreted when using XHR?
   * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.
   * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.
   * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.
   *//* eslint-disable require-jsdoc,valid-jsdoc *//**
   * Adds a resource (or multiple resources) to the loader queue.
   *
   * This function can take a wide variety of different parameters. The only thing that is always
   * required the url to load. All the following will work:
   *
   * ```js
   * loader
   *     // normal param syntax
   *     .add('key', 'http://...', function () {})
   *     .add('http://...', function () {})
   *     .add('http://...')
   *
   *     // object syntax
   *     .add({
   *         name: 'key2',
   *         url: 'http://...'
   *     }, function () {})
   *     .add({
   *         url: 'http://...'
   *     }, function () {})
   *     .add({
   *         name: 'key3',
   *         url: 'http://...'
   *         onComplete: function () {}
   *     })
   *     .add({
   *         url: 'https://...',
   *         onComplete: function () {},
   *         crossOrigin: true
   *     })
   *
   *     // you can also pass an array of objects or urls or both
   *     .add([
   *         { name: 'key4', url: 'http://...', onComplete: function () {} },
   *         { url: 'http://...', onComplete: function () {} },
   *         'http://...'
   *     ])
   *
   *     // and you can use both params and options
   *     .add('key', 'http://...', { crossOrigin: true }, function () {})
   *     .add('http://...', { crossOrigin: true }, function () {});
   * ```
   *
   * @function
   * @variation 1
   * @param {string} name - The name of the resource to load.
   * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
   * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
   * @return {this} Returns itself.
   *//**
  * @function
  * @variation 2
  * @param {string} name - The name of the resource to load.
  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
  * @param {IAddOptions} [options] - The options for the load.
  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
  * @return {this} Returns itself.
  *//**
  * @function
  * @variation 3
  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
  * @return {this} Returns itself.
  *//**
  * @function
  * @variation 4
  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.
  * @param {IAddOptions} [options] - The options for the load.
  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
  * @return {this} Returns itself.
  *//**
  * @function
  * @variation 5
  * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.
  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
  * @return {this} Returns itself.
  *//**
  * @function
  * @variation 6
  * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is
  *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.
  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.
  * @return {this} Returns itself.
  */var e=t.prototype;return e.add=function(t,e,i,r){// special case of an array of objects or urls
if(Array.isArray(t)){for(var n=0;n<t.length;++n)this.add(t[n]);return this}// if an object is passed instead of params
if("object"==typeof t&&(r=e||t.callback||t.onComplete,i=t,e=t.url,t=t.name||t.key||t.url),"string"!=typeof e&&(r=i,i=e,e=t),"string"!=typeof e)throw Error("No url passed to add resource to loader.");if("function"==typeof i&&(r=i,i=null),this.loading&&(!i||!i.parentResource))throw Error("Cannot add resources while the loader is running.");// check if resource already exists.
if(this.resources[t])throw Error('Resource named "'+t+'" already exists.');// if actively loading, make sure to adjust progress chunks for that parent and its children
if(// add base url if this isn't an absolute url
e=this._prepareUrl(e),this.resources[t]=new ga(t,e,i),"function"==typeof r&&this.resources[t].onAfterMiddleware.once(r),this.loading){for(var s=i.parentResource,o=[],a=0;a<s.children.length;++a)s.children[a].isComplete||o.push(s.children[a]);var h=s.progressChunk*(o.length+1)/(o.length+2);s.children.push(this.resources[t]),s.progressChunk=h;for(var l=0;l<o.length;++l)o[l].progressChunk=h;this.resources[t].progressChunk=h}// add the resource to the queue
return this._queue.push(this.resources[t]),this}/**
   * Sets up a middleware function that will run *before* the
   * resource is loaded.
   *
   * @param {function} fn - The middleware function to register.
   * @return {this} Returns itself.
   */,e.pre=function(t){return this._beforeMiddleware.push(t),this}/**
   * Sets up a middleware function that will run *after* the
   * resource is loaded.
   *
   * @param {function} fn - The middleware function to register.
   * @return {this} Returns itself.
   */,e.use=function(t){return this._afterMiddleware.push(t),this}/**
   * Resets the queue of the loader to prepare for a new load.
   *
   * @return {this} Returns itself.
   */,e.reset=function(){for(var t in this.progress=0,this.loading=!1,this._queue.kill(),this._queue.pause(),this.resources){var e=this.resources[t];e._onLoadBinding&&e._onLoadBinding.detach(),e.isLoading&&e.abort()}return this.resources={},this}/**
   * Starts loading the queued resources.
   *
   * @param {function} [cb] - Optional callback that will be bound to the `complete` event.
   * @return {this} Returns itself.
   */,e.load=function(t){// if the queue has already started we are done here
if("function"==typeof t&&this.onComplete.once(t),this.loading)return this;if(this._queue.idle())this._onStart(),this._onComplete();else{for(var e=100/this._queue._tasks.length,i=0;i<this._queue._tasks.length;++i)this._queue._tasks[i].data.progressChunk=e;// notify we are starting
this._onStart(),this._queue.resume()}return this}/**
   * The number of resources to load concurrently.
   *
   * @member {number}
   * @default 10
   */,/**
   * Prepares a url for usage based on the configuration of this object
   *
   * @private
   * @param {string} url - The url to prepare.
   * @return {string} The prepared url.
   */e._prepareUrl=function(t){var e,i=/*@__PURE__*/tP(m2)(t,{strictMode:!0});// if we need to add a default querystring, there is a bit more work
if(e=i.protocol||!i.path||0===t.indexOf("//")?t:this.baseUrl.length&&this.baseUrl.lastIndexOf("/")!==this.baseUrl.length-1&&"/"!==t.charAt(0)?this.baseUrl+"/"+t:this.baseUrl+t,this.defaultQueryString){var r=gc.exec(e)[0];-1!==(e=e.substr(0,e.length-r.length)).indexOf("?")?e+="&"+this.defaultQueryString:e+="?"+this.defaultQueryString,e+=r}return e}/**
   * Loads a single resource.
   *
   * @private
   * @param {Resource} resource - The resource to load.
   * @param {function} dequeue - The function to call when we need to dequeue this item.
   */,e._loadResource=function(t,e){var i=this;t._dequeue=e,gt(this._beforeMiddleware,function(e,r){e.call(i,t,function(){// if the before middleware marks the resource as complete,
// break and don't process any more before middleware
r(t.isComplete?{}:null)})},function(){t.isComplete?i._onLoad(t):(t._onLoadBinding=t.onComplete.once(i._onLoad,i),t.load())},!0)}/**
   * Called once loading has started.
   *
   * @private
   */,e._onStart=function(){this.progress=0,this.loading=!0,this.onStart.dispatch(this)}/**
   * Called once each resource has loaded.
   *
   * @private
   */,e._onComplete=function(){this.progress=100,this.loading=!1,this.onComplete.dispatch(this,this.resources)}/**
   * Called each time a resources is loaded.
   *
   * @private
   * @param {Resource} resource - The resource that was loaded
   */,e._onLoad=function(t){var e=this;t._onLoadBinding=null,this._resourcesParsing.push(t),t._dequeue(),gt(this._afterMiddleware,function(i,r){i.call(e,t,r)},function(){t.onAfterMiddleware.dispatch(t),e.progress=Math.min(100,e.progress+t.progressChunk),e.onProgress.dispatch(e,t),t.error?e.onError.dispatch(t.error,e,t):e.onLoad.dispatch(e,t),e._resourcesParsing.splice(e._resourcesParsing.indexOf(t),1),e._queue.idle()&&0===e._resourcesParsing.length&&e._onComplete()},!0)},gr(t,[{key:"concurrency",get:function(){return this._queue.concurrency}// eslint-disable-next-line require-jsdoc
,set:function(t){this._queue.concurrency=t}}]),t}();/**
 * A default array of middleware to run before loading each resource.
 * Each of these middlewares are added to any new Loader instances when they are created.
 *
 * @private
 * @member {function[]}
 */gd._defaultBeforeMiddleware=[],/**
 * A default array of middleware to run after loading each resource.
 * Each of these middlewares are added to any new Loader instances when they are created.
 *
 * @private
 * @member {function[]}
 */gd._defaultAfterMiddleware=[],/**
 * Sets up a middleware function that will run *before* the
 * resource is loaded.
 *
 * @static
 * @param {function} fn - The middleware function to register.
 * @return {Loader} Returns itself.
 */gd.pre=function(t){return gd._defaultBeforeMiddleware.push(t),gd},/**
 * Sets up a middleware function that will run *after* the
 * resource is loaded.
 *
 * @static
 * @param {function} fn - The middleware function to register.
 * @return {Loader} Returns itself.
 */gd.use=function(t){return gd._defaultAfterMiddleware.push(t),gd};/*!
 * @pixi/core - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//*!
 * @pixi/settings - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */// The ESM/CJS versions of ismobilejs only
var gp=el(window.navigator),gf={/**
     * If set to true WebGL will attempt make textures mimpaped by default.
     * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
     *
     * @static
     * @name MIPMAP_TEXTURES
     * @memberof PIXI.settings
     * @type {PIXI.MIPMAP_MODES}
     * @default PIXI.MIPMAP_MODES.POW2
     */MIPMAP_TEXTURES:1,/**
     * Default anisotropic filtering level of textures.
     * Usually from 0 to 16
     *
     * @static
     * @name ANISOTROPIC_LEVEL
     * @memberof PIXI.settings
     * @type {number}
     * @default 0
     */ANISOTROPIC_LEVEL:0,/**
     * Default resolution / device pixel ratio of the renderer.
     *
     * @static
     * @name RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */RESOLUTION:1,/**
     * Default filter resolution.
     *
     * @static
     * @name FILTER_RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */FILTER_RESOLUTION:1,/**
     * The maximum textures that this device supports.
     *
     * @static
     * @name SPRITE_MAX_TEXTURES
     * @memberof PIXI.settings
     * @type {number}
     * @default 32
     */SPRITE_MAX_TEXTURES:/**
 * The maximum recommended texture units to use.
 * In theory the bigger the better, and for desktop we'll use as many as we can.
 * But some mobile devices slow down if there is to many branches in the shader.
 * So in practice there seems to be a sweet spot size that varies depending on the device.
 *
 * In v4, all mobile devices were limited to 4 texture units because for this.
 * In v5, we allow all texture units to be used on modern Apple or Android devices.
 *
 * @private
 * @param {number} max
 * @returns {number}
 */function(t){var e=!0;if(gp.tablet||gp.phone){if(gp.apple.device){var i=navigator.userAgent.match(/OS (\d+)_(\d+)?/);if(i){var r=parseInt(i[1],10);// Limit texture units on devices below iOS 11, which will be older hardware
r<11&&(e=!1)}}if(gp.android.device){var i=navigator.userAgent.match(/Android\s([0-9.]*)/);if(i){var r=parseInt(i[1],10);// Limit texture units on devices below Android 7 (Nougat), which will be older hardware
r<7&&(e=!1)}}}return e?32:4}(0),// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
     * The default sprite batch size.
     *
     * The default aims to balance desktop and mobile devices.
     *
     * @static
     * @name SPRITE_BATCH_SIZE
     * @memberof PIXI.settings
     * @type {number}
     * @default 4096
     */SPRITE_BATCH_SIZE:4096,/**
     * The default render options if none are supplied to {@link PIXI.Renderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @name RENDER_OPTIONS
     * @memberof PIXI.settings
     * @type {object}
     * @property {HTMLCanvasElement} view=null
     * @property {number} resolution=1
     * @property {boolean} antialias=false
     * @property {boolean} autoDensity=false
     * @property {boolean} transparent=false
     * @property {number} backgroundColor=0x000000
     * @property {boolean} clearBeforeRender=true
     * @property {boolean} preserveDrawingBuffer=false
     * @property {number} width=800
     * @property {number} height=600
     * @property {boolean} legacy=false
     */RENDER_OPTIONS:{view:null,antialias:!1,autoDensity:!1,transparent:!1,backgroundColor:0,clearBeforeRender:!0,preserveDrawingBuffer:!1,width:800,height:600,legacy:!1},/**
     * Default Garbage Collection mode.
     *
     * @static
     * @name GC_MODE
     * @memberof PIXI.settings
     * @type {PIXI.GC_MODES}
     * @default PIXI.GC_MODES.AUTO
     */GC_MODE:0,/**
     * Default Garbage Collection max idle.
     *
     * @static
     * @name GC_MAX_IDLE
     * @memberof PIXI.settings
     * @type {number}
     * @default 3600
     */GC_MAX_IDLE:3600,/**
     * Default Garbage Collection maximum check count.
     *
     * @static
     * @name GC_MAX_CHECK_COUNT
     * @memberof PIXI.settings
     * @type {number}
     * @default 600
     */GC_MAX_CHECK_COUNT:600,/**
     * Default wrap modes that are supported by pixi.
     *
     * @static
     * @name WRAP_MODE
     * @memberof PIXI.settings
     * @type {PIXI.WRAP_MODES}
     * @default PIXI.WRAP_MODES.CLAMP
     */WRAP_MODE:33071,/**
     * Default scale mode for textures.
     *
     * @static
     * @name SCALE_MODE
     * @memberof PIXI.settings
     * @type {PIXI.SCALE_MODES}
     * @default PIXI.SCALE_MODES.LINEAR
     */SCALE_MODE:1,/**
     * Default specify float precision in vertex shader.
     *
     * @static
     * @name PRECISION_VERTEX
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.HIGH
     */PRECISION_VERTEX:"highp",/**
     * Default specify float precision in fragment shader.
     * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
     *
     * @static
     * @name PRECISION_FRAGMENT
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.MEDIUM
     */PRECISION_FRAGMENT:gp.apple.device?"highp":"mediump",/**
     * Can we upload the same buffer in a single frame?
     *
     * @static
     * @name CAN_UPLOAD_SAME_BUFFER
     * @memberof PIXI.settings
     * @type {boolean}
     */CAN_UPLOAD_SAME_BUFFER:!gp.apple.device,/**
     * Enables bitmap creation before image load. This feature is experimental.
     *
     * @static
     * @name CREATE_IMAGE_BITMAP
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */CREATE_IMAGE_BITMAP:!1,/**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     *
     * @static
     * @constant
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */ROUND_PIXELS:!1};(xn=Er||(Er={}))[xn.WEBGL_LEGACY=0]="WEBGL_LEGACY",xn[xn.WEBGL=1]="WEBGL",xn[xn.WEBGL2=2]="WEBGL2",(xs=En||(En={}))[xs.UNKNOWN=0]="UNKNOWN",xs[xs.WEBGL=1]="WEBGL",xs[xs.CANVAS=2]="CANVAS",(xo=Es||(Es={}))[xo.COLOR=16384]="COLOR",xo[xo.DEPTH=256]="DEPTH",xo[xo.STENCIL=1024]="STENCIL",(xa=Eo||(Eo={}))[xa.NORMAL=0]="NORMAL",xa[xa.ADD=1]="ADD",xa[xa.MULTIPLY=2]="MULTIPLY",xa[xa.SCREEN=3]="SCREEN",xa[xa.OVERLAY=4]="OVERLAY",xa[xa.DARKEN=5]="DARKEN",xa[xa.LIGHTEN=6]="LIGHTEN",xa[xa.COLOR_DODGE=7]="COLOR_DODGE",xa[xa.COLOR_BURN=8]="COLOR_BURN",xa[xa.HARD_LIGHT=9]="HARD_LIGHT",xa[xa.SOFT_LIGHT=10]="SOFT_LIGHT",xa[xa.DIFFERENCE=11]="DIFFERENCE",xa[xa.EXCLUSION=12]="EXCLUSION",xa[xa.HUE=13]="HUE",xa[xa.SATURATION=14]="SATURATION",xa[xa.COLOR=15]="COLOR",xa[xa.LUMINOSITY=16]="LUMINOSITY",xa[xa.NORMAL_NPM=17]="NORMAL_NPM",xa[xa.ADD_NPM=18]="ADD_NPM",xa[xa.SCREEN_NPM=19]="SCREEN_NPM",xa[xa.NONE=20]="NONE",xa[xa.SRC_OVER=0]="SRC_OVER",xa[xa.SRC_IN=21]="SRC_IN",xa[xa.SRC_OUT=22]="SRC_OUT",xa[xa.SRC_ATOP=23]="SRC_ATOP",xa[xa.DST_OVER=24]="DST_OVER",xa[xa.DST_IN=25]="DST_IN",xa[xa.DST_OUT=26]="DST_OUT",xa[xa.DST_ATOP=27]="DST_ATOP",xa[xa.ERASE=26]="ERASE",xa[xa.SUBTRACT=28]="SUBTRACT",xa[xa.XOR=29]="XOR",(xh=Ea||(Ea={}))[xh.POINTS=0]="POINTS",xh[xh.LINES=1]="LINES",xh[xh.LINE_LOOP=2]="LINE_LOOP",xh[xh.LINE_STRIP=3]="LINE_STRIP",xh[xh.TRIANGLES=4]="TRIANGLES",xh[xh.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",xh[xh.TRIANGLE_FAN=6]="TRIANGLE_FAN",(xl=Eh||(Eh={}))[xl.RGBA=6408]="RGBA",xl[xl.RGB=6407]="RGB",xl[xl.ALPHA=6406]="ALPHA",xl[xl.LUMINANCE=6409]="LUMINANCE",xl[xl.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",xl[xl.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",xl[xl.DEPTH_STENCIL=34041]="DEPTH_STENCIL",(xu=El||(El={}))[xu.TEXTURE_2D=3553]="TEXTURE_2D",xu[xu.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",xu[xu.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",xu[xu.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",xu[xu.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",xu[xu.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",xu[xu.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",xu[xu.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",xu[xu.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",(xc=Eu||(Eu={}))[xc.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",xc[xc.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",xc[xc.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",xc[xc.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",xc[xc.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",xc[xc.FLOAT=5126]="FLOAT",xc[xc.HALF_FLOAT=36193]="HALF_FLOAT",(xd=Ec||(Ec={}))[xd.NEAREST=0]="NEAREST",xd[xd.LINEAR=1]="LINEAR",(xp=Ed||(Ed={}))[xp.CLAMP=33071]="CLAMP",xp[xp.REPEAT=10497]="REPEAT",xp[xp.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",(xf=Ep||(Ep={}))[xf.OFF=0]="OFF",xf[xf.POW2=1]="POW2",xf[xf.ON=2]="ON",(xm=Ef||(Ef={}))[xm.NPM=0]="NPM",xm[xm.UNPACK=1]="UNPACK",xm[xm.PMA=2]="PMA",xm[xm.NO_PREMULTIPLIED_ALPHA=0]="NO_PREMULTIPLIED_ALPHA",xm[xm.PREMULTIPLY_ON_UPLOAD=1]="PREMULTIPLY_ON_UPLOAD",xm[xm.PREMULTIPLY_ALPHA=2]="PREMULTIPLY_ALPHA",(xg=Em||(Em={}))[xg.NO=0]="NO",xg[xg.YES=1]="YES",xg[xg.AUTO=2]="AUTO",xg[xg.BLEND=0]="BLEND",xg[xg.CLEAR=1]="CLEAR",xg[xg.BLIT=2]="BLIT",(xy=Eg||(Eg={}))[xy.AUTO=0]="AUTO",xy[xy.MANUAL=1]="MANUAL",(x_=Ey||(Ey={})).LOW="lowp",x_.MEDIUM="mediump",x_.HIGH="highp",(xv=E_||(E_={}))[xv.NONE=0]="NONE",xv[xv.SCISSOR=1]="SCISSOR",xv[xv.STENCIL=2]="STENCIL",xv[xv.SPRITE=3]="SPRITE",(xx=Ev||(Ev={}))[xx.NONE=0]="NONE",xx[xx.LOW=2]="LOW",xx[xx.MEDIUM=4]="MEDIUM",xx[xx.HIGH=8]="HIGH";/*!
 * @pixi/utils - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var gm={},gg=Object.prototype.hasOwnProperty,gy="~";/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */function g_(){}/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */function gv(t,e,i){this.fn=t,this.context=e,this.once=i||!1}/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */function gx(t,e,i,r,n){if("function"!=typeof i)throw TypeError("The listener must be a function");var s=new gv(i,r||t,n),o=gy?gy+e:e;return t._events[o]?t._events[o].fn?t._events[o]=[t._events[o],s]:t._events[o].push(s):(t._events[o]=s,t._eventsCount++),t}/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */function gb(t,e){0==--t._eventsCount?t._events=new g_:delete t._events[e]}/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */function gE(){this._events=new g_,this._eventsCount=0}Object.create&&(g_.prototype=Object.create(null),new g_().__proto__||(gy=!1)),/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */gE.prototype.eventNames=function(){var t,e,i=[];if(0===this._eventsCount)return i;for(e in t=this._events)gg.call(t,e)&&i.push(gy?e.slice(1):e);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */gE.prototype.listeners=function(t){var e=gy?gy+t:t,i=this._events[e];if(!i)return[];if(i.fn)return[i.fn];for(var r=0,n=i.length,s=Array(n);r<n;r++)s[r]=i[r].fn;return s},/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */gE.prototype.listenerCount=function(t){var e=gy?gy+t:t,i=this._events[e];return i?i.fn?1:i.length:0},/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */gE.prototype.emit=function(t,e,i,r,n,s){var o=gy?gy+t:t;if(!this._events[o])return!1;var a,h,l=this._events[o],u=arguments.length;if(l.fn){switch(l.once&&this.removeListener(t,l.fn,void 0,!0),u){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,e),!0;case 3:return l.fn.call(l.context,e,i),!0;case 4:return l.fn.call(l.context,e,i,r),!0;case 5:return l.fn.call(l.context,e,i,r,n),!0;case 6:return l.fn.call(l.context,e,i,r,n,s),!0}for(h=1,a=Array(u-1);h<u;h++)a[h-1]=arguments[h];l.fn.apply(l.context,a)}else{var c,d=l.length;for(h=0;h<d;h++)switch(l[h].once&&this.removeListener(t,l[h].fn,void 0,!0),u){case 1:l[h].fn.call(l[h].context);break;case 2:l[h].fn.call(l[h].context,e);break;case 3:l[h].fn.call(l[h].context,e,i);break;case 4:l[h].fn.call(l[h].context,e,i,r);break;default:if(!a)for(c=1,a=Array(u-1);c<u;c++)a[c-1]=arguments[c];l[h].fn.apply(l[h].context,a)}}return!0},/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */gE.prototype.on=function(t,e,i){return gx(this,t,e,i,!1)},/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */gE.prototype.once=function(t,e,i){return gx(this,t,e,i,!0)},/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */gE.prototype.removeListener=function(t,e,i,r){var n=gy?gy+t:t;if(!this._events[n])return this;if(!e)return gb(this,n),this;var s=this._events[n];if(s.fn)s.fn!==e||r&&!s.once||i&&s.context!==i||gb(this,n);else{for(var o=0,a=[],h=s.length;o<h;o++)(s[o].fn!==e||r&&!s[o].once||i&&s[o].context!==i)&&a.push(s[o]);//
// Reset the array, or remove it completely if we have no more listeners.
//
a.length?this._events[n]=1===a.length?a[0]:a:gb(this,n)}return this},/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */gE.prototype.removeAllListeners=function(t){var e;return t?(e=gy?gy+t:t,this._events[e]&&gb(this,e)):(this._events=new g_,this._eventsCount=0),this},//
// Alias methods names because people roll like that.
//
gE.prototype.off=gE.prototype.removeListener,gE.prototype.addListener=gE.prototype.on,//
// Expose the prefix.
//
gE.prefixed=gy,//
// Allow `EventEmitter` to be imported as module namespace.
//
gE.EventEmitter=gE,gm=gE,gf.RETINA_PREFIX=/@([0-9\.]+)x/,gf.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT=!0;var gT=!1,gw="5.3.12",gS=/**
 * Corrects PixiJS blend, takes premultiplied alpha into account
 *
 * @memberof PIXI.utils
 * @function mapPremultipliedBlendModes
 * @private
 * @return {Array<number[]>} Mapped modes.
 */function(){for(var t=[],e=[],i=0;i<32;i++)t[i]=i,e[i]=i;t[Eo.NORMAL_NPM]=Eo.NORMAL,t[Eo.ADD_NPM]=Eo.ADD,t[Eo.SCREEN_NPM]=Eo.SCREEN,e[Eo.NORMAL]=Eo.NORMAL_NPM,e[Eo.ADD]=Eo.ADD_NPM,e[Eo.SCREEN]=Eo.SCREEN_NPM;var r=[];return r.push(e),r.push(t),r}();// Taken from the bit-twiddle package
/**
 * Rounds to next power of two.
 *
 * @function nextPow2
 * @memberof PIXI.utils
 * @param {number} v - input value
 * @return {number}
 */function gM(t){return t+=0===t?1:0,--t,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,(t|=t>>>16)+1}/**
 * Computes ceil of log base 2
 *
 * @function log2
 * @memberof PIXI.utils
 * @param {number} v - input value
 * @return {number} logarithm base 2
 */function gA(t){var e=(t>65535?1:0)<<4,i=((t>>>=e)>255?1:0)<<3;return t>>>=i,e|=i,i=(t>15?1:0)<<2,t>>>=i,e|=i,i=(t>3?1:0)<<1,t>>>=i,(e|=i)|t>>1}Float32Array,Uint32Array,Int32Array,Uint8Array;var gR=0,gC={};/**
 * Helper for warning developers about deprecated features & settings.
 * A stack track for warnings is given; useful for tracking-down where
 * deprecated methods/properties/classes are being used within the code.
 *
 * @memberof PIXI.utils
 * @function deprecation
 * @param {string} version - The version where the feature became deprecated
 * @param {string} message - Message should include what is deprecated, where, and the new solution
 * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack
 *        this is mostly to ignore internal deprecation calls.
 */function gP(t,e,i){// Ignore duplicat
if(void 0===i&&(i=3),!gC[e]){/* eslint-disable no-console */var r=Error().stack;void 0===r?console.warn("PixiJS Deprecation Warning: ",e+"\nDeprecated since v"+t):(// chop off the stack trace which includes PixiJS internal calls
r=r.split("\n").splice(i).join("\n"),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",e+"\nDeprecated since v"+t),console.warn(r),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",e+"\nDeprecated since v"+t),console.warn(r))),/* eslint-enable no-console */gC[e]=!0}}/**
 * @todo Describe property usage
 *
 * @static
 * @name ProgramCache
 * @memberof PIXI.utils
 * @type {Object}
 */var gI={},gO=Object.create(null),gL=Object.create(null);/**
 * get the resolution / device pixel ratio of an asset by looking for the prefix
 * used by spritesheets and image urls
 *
 * @memberof PIXI.utils
 * @function getResolutionOfUrl
 * @param {string} url - the image path
 * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
 * @return {number} resolution / device pixel ratio of an asset
 */function gN(t,e){var i=gf.RETINA_PREFIX.exec(t);return i?parseFloat(i[1]):void 0!==e?e:1}!/** @class */function(){/**
     * @param {number} width - the width for the newly created canvas
     * @param {number} height - the height for the newly created canvas
     * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
     */function t(t,e,i){/**
         * The Canvas object that belongs to this CanvasRenderTarget.
         *
         * @member {HTMLCanvasElement}
         */this.canvas=document.createElement("canvas"),/**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */this.context=this.canvas.getContext("2d"),this.resolution=i||gf.RESOLUTION,this.resize(t,e)}/**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */t.prototype.clear=function(){this.context.setTransform(1,0,0,1,0,0),this.context.clearRect(0,0,this.canvas.width,this.canvas.height)},/**
     * Resizes the canvas to the specified width and height.
     *
     * @param {number} width - the new width of the canvas
     * @param {number} height - the new height of the canvas
     */t.prototype.resize=function(t,e){this.canvas.width=t*this.resolution,this.canvas.height=e*this.resolution},/**
     * Destroys this canvas.
     *
     */t.prototype.destroy=function(){this.context=null,this.canvas=null},Object.defineProperty(t.prototype,"width",{/**
         * The width of the canvas buffer in pixels.
         *
         * @member {number}
         */get:function(){return this.canvas.width},set:function(t){this.canvas.width=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{/**
         * The height of the canvas buffer in pixels.
         *
         * @member {number}
         */get:function(){return this.canvas.height},set:function(t){this.canvas.height=t},enumerable:!1,configurable:!0})}();/*!
 * @pixi/runner - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * A Runner is a highly performant and simple alternative to signals. Best used in situations
 * where events are dispatched to many objects at high frequency (say every frame!)
 *
 *
 * like a signal..
 * ```
 * import { Runner } from '@pixi/runner';
 *
 * const myObject = {
 *     loaded: new Runner('loaded')
 * }
 *
 * const listener = {
 *     loaded: function(){
 *         // thin
 *     }
 * }
 *
 * myObject.update.add(listener);
 *
 * myObject.loaded.emit();
 * ```
 *
 * Or for handling calling the same function on many items
 * ```
 * import { Runner } from '@pixi/runner';
 *
 * const myGame = {
 *     update: new Runner('update')
 * }
 *
 * const gameObject = {
 *     update: function(time){
 *         // update my gamey state
 *     }
 * }
 *
 * myGame.update.add(gameObject1);
 *
 * myGame.update.emit(time);
 * ```
 * @class
 * @memberof PIXI
 */var gD=/** @class */function(){/**
     *  @param {string} name - the function name that will be executed on the listeners added to this Runner.
     */function t(t){this.items=[],this._name=t,this._aliasCount=0}return(/**
     * Dispatch/Broadcast Runner to all listeners added to the queue.
     * @param {...any} params - optional parameters to pass to each listener
     * @return {PIXI.Runner}
     */t.prototype.emit=function(t,e,i,r,n,s,o,a){if(arguments.length>8)throw Error("max arguments reached");var h=this.name,l=this.items;this._aliasCount++;for(var u=0,c=l.length;u<c;u++)l[u][h](t,e,i,r,n,s,o,a);return l===this.items&&this._aliasCount--,this},t.prototype.ensureNonAliasedItems=function(){this._aliasCount>0&&this.items.length>1&&(this._aliasCount=0,this.items=this.items.slice(0))},/**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * import { Runner } from '@pixi/runner';
     *
     * const complete = new Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     * @return {PIXI.Runner}
     */t.prototype.add=function(t){return t[this._name]&&(this.ensureNonAliasedItems(),this.remove(t),this.items.push(t)),this},/**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listenr that you would like to remove.
     * @return {PIXI.Runner}
     */t.prototype.remove=function(t){var e=this.items.indexOf(t);return -1!==e&&(this.ensureNonAliasedItems(),this.items.splice(e,1)),this},/**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */t.prototype.contains=function(t){return -1!==this.items.indexOf(t)},/**
     * Remove all listeners from the Runner
     * @return {PIXI.Runner}
     */t.prototype.removeAll=function(){return this.ensureNonAliasedItems(),this.items.length=0,this},/**
     * Remove all references, don't use after this.
     */t.prototype.destroy=function(){this.removeAll(),this.items=null,this._name=null},Object.defineProperty(t.prototype,"empty",{/**
         * `true` if there are no this Runner contains no listeners
         *
         * @member {boolean}
         * @readonly
         */get:function(){return 0===this.items.length},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"name",{/**
         * The name of the runner.
         *
         * @member {string}
         * @readonly
         */get:function(){return this._name},enumerable:!1,configurable:!0}),t)}();Object.defineProperties(gD.prototype,{/**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method dispatch
     * @see PIXI.Runner#emit
     */dispatch:{value:gD.prototype.emit},/**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method run
     * @see PIXI.Runner#emit
     */run:{value:gD.prototype.emit}}),gf.TARGET_FPMS=.06,(xb=EE||(EE={}))[xb.INTERACTION=50]="INTERACTION",xb[xb.HIGH=25]="HIGH",xb[xb.NORMAL=0]="NORMAL",xb[xb.LOW=-25]="LOW",xb[xb.UTILITY=-50]="UTILITY";/**
 * Internal class for handling the priority sorting of ticker handlers.
 *
 * @private
 * @class
 * @memberof PIXI
 */var gF=/** @class */function(){/**
     * Constructor
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context=null] - The listener context
     * @param {number} [priority=0] - The priority for emitting
     * @param {boolean} [once=false] - If the handler should fire once
     */function t(t,e,i,r){void 0===e&&(e=null),void 0===i&&(i=0),void 0===r&&(r=!1),/**
         * The handler function to execute.
         * @private
         * @member {Function}
         */this.fn=t,/**
         * The calling to execute.
         * @private
         * @member {*}
         */this.context=e,/**
         * The current priority.
         * @private
         * @member {number}
         */this.priority=i,/**
         * If this should only execute once.
         * @private
         * @member {boolean}
         */this.once=r,/**
         * The next item in chain.
         * @private
         * @member {TickerListener}
         */this.next=null,/**
         * The previous item in chain.
         * @private
         * @member {TickerListener}
         */this.previous=null,/**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */this._destroyed=!1}return(/**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {any} [context] - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */t.prototype.match=function(t,e){return void 0===e&&(e=null),this.fn===t&&this.context===e},/**
     * Emit by calling the current function.
     * @private
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */t.prototype.emit=function(t){this.fn&&(this.context?this.fn.call(this.context,t):this.fn(t));var e=this.next;return this.once&&this.destroy(!0),this._destroyed&&(this.next=null),e},/**
     * Connect to the list.
     * @private
     * @param {TickerListener} previous - Input node, previous listener
     */t.prototype.connect=function(t){this.previous=t,t.next&&(t.next.previous=this),this.next=t.next,t.next=this},/**
     * Destroy and don't use after this.
     * @private
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *        is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */t.prototype.destroy=function(t){void 0===t&&(t=!1),this._destroyed=!0,this.fn=null,this.context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);// Redirect to the next item
var e=this.next;return(// Remove references
this.next=t?null:e,this.previous=null,e)},t)}(),gB=/** @class */function(){function t(){var t=this;/**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */this._head=new gF(null,null,1/0),/**
         * Internal current frame request ID
         * @type {?number}
         * @private
         */this._requestId=null,/**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @type {number}
         * @private
         */this._maxElapsedMS=100,/**
         * Internal value managed by maxFPS property setter and getter.
         * This is the minimum allowed milliseconds between updates.
         * @type {number}
         * @private
         */this._minElapsedMS=0,/**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */this.autoStart=!1,/**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */this.deltaTime=1,/**
         * Scaler time elapsed in milliseconds from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */this.deltaMS=1/gf.TARGET_FPMS,/**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */this.elapsedMS=1/gf.TARGET_FPMS,/**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         *
         * @member {number}
         * @default -1
         */this.lastTime=-1,/**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */this.speed=1,/**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */this.started=!1,/**
         * If enabled, deleting is disabled.
         * @member {boolean}
         * @default false
         * @private
         */this._protected=!1,/**
         * The last time keyframe was executed.
         * Maintains a relatively fixed interval with the previous value.
         * @member {number}
         * @default -1
         * @private
         */this._lastFrame=-1,/**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */this._tick=function(e){t._requestId=null,t.started&&(// Invoke listeners now
t.update(e),t.started&&null===t._requestId&&t._head.next&&(t._requestId=requestAnimationFrame(t._tick)))}}return(/**
     * Conditionally requests a new animation frame.
     * If a frame has not already been requested, and if the internal
     * emitter has listeners, a new frame is requested.
     *
     * @private
     */t.prototype._requestIfNeeded=function(){null===this._requestId&&this._head.next&&(// ensure callbacks get correct delta
this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))},/**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */t.prototype._cancelIfNeeded=function(){null!==this._requestId&&(cancelAnimationFrame(this._requestId),this._requestId=null)},/**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */t.prototype._startIfPossible=function(){this.started?this._requestIfNeeded():this.autoStart&&this.start()},/**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */t.prototype.add=function(t,e,i){return void 0===i&&(i=EE.NORMAL),this._addListener(new gF(t,e,i))},/**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */t.prototype.addOnce=function(t,e,i){return void 0===i&&(i=EE.NORMAL),this._addListener(new gF(t,e,i,!0))},/**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.Ticker} This instance of a ticker
     */t.prototype._addListener=function(t){// For attaching to head
var e=this._head.next,i=this._head;// Add the first item
if(e){// Go from highest to lowest priority
for(;e;){if(t.priority>e.priority){t.connect(i);break}i=e,e=e.next}// Not yet connected
t.previous||t.connect(i)}else t.connect(i);return this._startIfPossible(),this},/**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {*} [context] - The listener context to be removed
     * @returns {PIXI.Ticker} This instance of a ticker
     */t.prototype.remove=function(t,e){for(var i=this._head.next;i;)// no break to delete all possible matches
// incase a listener was added 2+ times
i=i.match(t,e)?i.destroy():i.next;return this._head.next||this._cancelIfNeeded(),this},Object.defineProperty(t.prototype,"count",{/**
         * The number of listeners on this ticker, calculated by walking through linked list
         *
         * @readonly
         * @member {number}
         */get:function(){if(!this._head)return 0;for(var t=0,e=this._head;e=e.next;)t++;return t},enumerable:!1,configurable:!0}),/**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */t.prototype.start=function(){this.started||(this.started=!0,this._requestIfNeeded())},/**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */t.prototype.stop=function(){this.started&&(this.started=!1,this._cancelIfNeeded())},/**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */t.prototype.destroy=function(){if(!this._protected){this.stop();for(var t=this._head.next;t;)t=t.destroy(!0);this._head.destroy(),this._head=null}},/**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */t.prototype.update=function(t){// If the difference in time is zero or negative, we ignore most of the work done here.
// If there is no valid difference, then should be no reason to let anyone know about it.
// A zero delta, is exactly that, nothing should update.
//
// The difference in time can be negative, and no this does not mean time traveling.
// This can be the result of a race condition between when an animation frame is requested
// on the current JavaScript engine event loop, and when the ticker's start method is invoked
// (which invokes the internal _requestIfNeeded method). If a frame is requested before
// _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
// can receive a time argument that can be less than the lastTime value that was set within
// _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
//
// This check covers this browser engine timing issue, as well as if consumers pass an invalid
// currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
if(void 0===t&&(t=performance.now()),t>this.lastTime){// If not enough time has passed, exit the function.
// Get ready for next frame by setting _lastFrame, but based on _minElapsedMS
// adjustment to ensure a relatively stable interval.
if(// Save uncapped elapsedMS for measurement
(e=this.elapsedMS=t-this.lastTime)>this._maxElapsedMS&&(e=this._maxElapsedMS),e*=this.speed,this._minElapsedMS){var e,i=t-this._lastFrame|0;if(i<this._minElapsedMS)return;this._lastFrame=t-i%this._minElapsedMS}this.deltaMS=e,this.deltaTime=this.deltaMS*gf.TARGET_FPMS;for(// Cache a local reference, in-case ticker is destroyed
// during the emit, we can still check for head.next
var r=this._head,n=r.next;n;)n=n.emit(this.deltaTime);r.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=t},Object.defineProperty(t.prototype,"FPS",{/**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.Ticker#speed}, which is specific
         * to scaling {@link PIXI.Ticker#deltaTime}.
         *
         * @member {number}
         * @readonly
         */get:function(){return 1e3/this.elapsedMS},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"minFPS",{/**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This value is used to cap {@link PIXI.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         *
         * @member {number}
         * @default 10
         */get:function(){return 1e3/this._maxElapsedMS},set:function(t){// Must be at least 0, but below 1 / settings.TARGET_FPMS
var e=Math.min(Math.max(0,Math.min(this.maxFPS,t))/1e3,gf.TARGET_FPMS);this._maxElapsedMS=1/e},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"maxFPS",{/**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This will effect the measured value of {@link PIXI.Ticker#FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         *
         * @member {number}
         * @default 0
         */get:function(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0},set:function(t){if(0===t)this._minElapsedMS=0;else{// Max must be at least the minFPS
var e=Math.max(this.minFPS,t);this._minElapsedMS=1/(e/1e3)}},enumerable:!1,configurable:!0}),Object.defineProperty(t,"shared",{/**
         * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
         * {@link PIXI.VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         *
         * @example
         * let ticker = PIXI.Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the PIXI.Ticker.shared instance.
         * ticker.autoStart = false;
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         *
         * @example
         * // You may use the shared ticker to render...
         * let renderer = PIXI.autoDetectRenderer();
         * let stage = new PIXI.Container();
         * document.body.appendChild(renderer.view);
         * ticker.add(function (time) {
         *     renderer.render(stage);
         * });
         *
         * @example
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * function animate(time) {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * }
         * animate(performance.now());
         *
         * @member {PIXI.Ticker}
         * @static
         */get:function(){if(!t._shared){var e=t._shared=new t;e.autoStart=!0,e._protected=!0}return t._shared},enumerable:!1,configurable:!0}),Object.defineProperty(t,"system",{/**
         * The system ticker instance used by {@link PIXI.InteractionManager} and by
         * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
         * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         *
         * @member {PIXI.Ticker}
         * @static
         */get:function(){if(!t._system){var e=t._system=new t;e.autoStart=!0,e._protected=!0}return t._system},enumerable:!1,configurable:!0}),t)}();!/** @class */function(){function t(){}/**
     * Initialize the plugin with scope of application instance
     *
     * @static
     * @private
     * @param {object} [options] - See application options
     */t.init=function(t){var e=this;// Set default
t=Object.assign({autoStart:!0,sharedTicker:!1},t),// Create ticker setter
Object.defineProperty(this,"ticker",{set:function(t){this._ticker&&this._ticker.remove(this.render,this),this._ticker=t,t&&t.add(this.render,this,EE.LOW)},get:function(){return this._ticker}}),/**
         * Convenience method for stopping the render.
         *
         * @method PIXI.Application#stop
         */this.stop=function(){e._ticker.stop()},/**
         * Convenience method for starting the render.
         *
         * @method PIXI.Application#start
         */this.start=function(){e._ticker.start()},/**
         * Internal reference to the ticker.
         *
         * @type {PIXI.Ticker}
         * @name _ticker
         * @memberof PIXI.Application#
         * @private
         */this._ticker=null,/**
         * Ticker for doing render updates.
         *
         * @type {PIXI.Ticker}
         * @name ticker
         * @memberof PIXI.Application#
         * @default PIXI.Ticker.shared
         */this.ticker=t.sharedTicker?gB.shared:new gB,t.autoStart&&this.start()},/**
     * Clean up the ticker, scoped to application.
     *
     * @static
     * @private
     */t.destroy=function(){if(this._ticker){var t=this._ticker;this.ticker=null,t.destroy()}}}();/*!
 * @pixi/math - v5.3.12
 * Compiled Wed, 23 Mar 2022 18:34:28 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *//**
 * Two Pi.
 *
 * @static
 * @constant {number} PI_2
 * @memberof PIXI
 */var gU=2*Math.PI;(xE=ET||(ET={}))[xE.POLY=0]="POLY",xE[xE.RECT=1]="RECT",xE[xE.CIRC=2]="CIRC",xE[xE.ELIP=3]="ELIP",xE[xE.RREC=4]="RREC";/**
 * Constants that identify shapes, mainly to prevent `instanceof` calls.
 *
 * @static
 * @constant
 * @name SHAPES
 * @memberof PIXI
 * @type {enum}
 * @property {number} POLY Polygon
 * @property {number} RECT Rectangle
 * @property {number} CIRC Circle
 * @property {number} ELIP Ellipse
 * @property {number} RREC Rounded Rectangle
 * @enum {number}
 *//**
 * Size object, contains width and height
 *
 * @memberof PIXI
 * @typedef {object} ISize
 * @property {number} width - Width component
 * @property {number} height - Height component
 *//**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */var gG=/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
     * @param {number} [width=0] - The overall width of this rectangle
     * @param {number} [height=0] - The overall height of this rectangle
     */function t(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),/**
         * @member {number}
         * @default 0
         */this.x=Number(t),/**
         * @member {number}
         * @default 0
         */this.y=Number(e),/**
         * @member {number}
         * @default 0
         */this.width=Number(i),/**
         * @member {number}
         * @default 0
         */this.height=Number(r),/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */this.type=ET.RECT}return Object.defineProperty(t.prototype,"left",{/**
         * returns the left edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.x},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"right",{/**
         * returns the right edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.x+this.width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"top",{/**
         * returns the top edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.y},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"bottom",{/**
         * returns the bottom edge of the rectangle
         *
         * @member {number}
         */get:function(){return this.y+this.height},enumerable:!1,configurable:!0}),Object.defineProperty(t,"EMPTY",{/**
         * A constant empty rectangle.
         *
         * @static
         * @constant
         * @member {PIXI.Rectangle}
         * @return {PIXI.Rectangle} An empty rectangle
         */get:function(){return new t(0,0,0,0)},enumerable:!1,configurable:!0}),/**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},/**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this},/**
     * Copies this rectangle to another one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
     * @return {PIXI.Rectangle} Returns given parameter.
     */t.prototype.copyTo=function(t){return t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t},/**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */t.prototype.contains=function(t,e){return!(this.width<=0)&&!(this.height<=0)&&t>=this.x&&t<this.x+this.width&&e>=this.y&&e<this.y+this.height},/**
     * Pads the rectangle making it grow in all directions.
     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
     *
     * @param {number} [paddingX=0] - The horizontal padding amount.
     * @param {number} [paddingY=0] - The vertical padding amount.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.pad=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.x-=t,this.y-=e,this.width+=2*t,this.height+=2*e,this},/**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.fit=function(t){var e=Math.max(this.x,t.x),i=Math.min(this.x+this.width,t.x+t.width),r=Math.max(this.y,t.y),n=Math.min(this.y+this.height,t.y+t.height);return this.x=e,this.width=Math.max(i-e,0),this.y=r,this.height=Math.max(n-r,0),this},/**
     * Enlarges rectangle that way its corners lie on grid
     *
     * @param {number} [resolution=1] resolution
     * @param {number} [eps=0.001] precision
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.ceil=function(t,e){void 0===t&&(t=1),void 0===e&&(e=.001);var i=Math.ceil((this.x+this.width-e)*t)/t,r=Math.ceil((this.y+this.height-e)*t)/t;return this.x=Math.floor((this.x+e)*t)/t,this.y=Math.floor((this.y+e)*t)/t,this.width=i-this.x,this.height=r-this.y,this},/**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     * @return {PIXI.Rectangle} Returns itself.
     */t.prototype.enlarge=function(t){var e=Math.min(this.x,t.x),i=Math.max(this.x+this.width,t.x+t.width),r=Math.min(this.y,t.y),n=Math.max(this.y+this.height,t.y+t.height);return this.x=e,this.width=i-e,this.y=r,this.height=n-r,this},t}();!/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the center of this circle
     * @param {number} [y=0] - The Y coordinate of the center of this circle
     * @param {number} [radius=0] - The radius of the circle
     */function t(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.radius=i,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */this.type=ET.CIRC}/**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.radius)},/**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */t.prototype.contains=function(t,e){if(this.radius<=0)return!1;var i=this.radius*this.radius,r=this.x-t,n=this.y-e;return r*=r,n*=n,r+n<=i},/**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */t.prototype.getBounds=function(){return new gG(this.x-this.radius,this.y-this.radius,2*this.radius,2*this.radius)}}(),/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the center of this ellipse
     * @param {number} [y=0] - The Y coordinate of the center of this ellipse
     * @param {number} [halfWidth=0] - The half width of this ellipse
     * @param {number} [halfHeight=0] - The half height of this ellipse
     */function t(t,e,i,r){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.width=i,/**
         * @member {number}
         * @default 0
         */this.height=r,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */this.type=ET.ELIP}/**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height)},/**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;// normalize the coords to an ellipse with center 0,0
var i=(t-this.x)/this.width,r=(e-this.y)/this.height;return i*=i,r*=r,i+r<=1},/**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */t.prototype.getBounds=function(){return new gG(this.x-this.width,this.y-this.height,this.width,this.height)}}(),/** @class */function(){/**
     * @param {PIXI.IPoint[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */function t(){for(var t=arguments,e=[],i=0;i<arguments.length;i++)e[i]=t[i];var r=Array.isArray(e[0])?e[0]:e;// if this is an array of points, convert it to a flat array of numbers
if("number"!=typeof r[0]){for(var n=[],s=0,o=r.length;s<o;s++)n.push(r[s].x,r[s].y);r=n}/**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */this.points=r,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */this.type=ET.POLY,/**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */this.closeStroke=!0}/**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */t.prototype.clone=function(){var e=this.points.slice(),i=new t(e);return i.closeStroke=this.closeStroke,i},/**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */t.prototype.contains=function(t,e){for(var i=!1,r=this.points.length/2,n=0,s=r-1;n<r;s=n++){var o=this.points[2*n],a=this.points[2*n+1],h=this.points[2*s],l=this.points[2*s+1];a>e!=l>e&&t<(h-o)*((e-a)/(l-a))+o&&(i=!i)}return i}}(),/** @class */function(){/**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [width=0] - The overall width of this rounded rectangle
     * @param {number} [height=0] - The overall height of this rounded rectangle
     * @param {number} [radius=20] - Controls the radius of the rounded corners
     */function t(t,e,i,r,n){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=0),void 0===n&&(n=20),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e,/**
         * @member {number}
         * @default 0
         */this.width=i,/**
         * @member {number}
         * @default 0
         */this.height=r,/**
         * @member {number}
         * @default 20
         */this.radius=n,/**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */this.type=ET.RREC}/**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */t.prototype.clone=function(){return new t(this.x,this.y,this.width,this.height,this.radius)},/**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */t.prototype.contains=function(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){if(e>=this.y+this.radius&&e<=this.y+this.height-this.radius||t>=this.x+this.radius&&t<=this.x+this.width-this.radius)return!0;var i=t-(this.x+this.radius),r=e-(this.y+this.radius),n=this.radius*this.radius;if(i*i+r*r<=n||(i=t-(this.x+this.width-this.radius))*i+r*r<=n||i*i+(r=e-(this.y+this.height-this.radius))*r<=n||(i=t-(this.x+this.radius))*i+r*r<=n)return!0}return!1}}();/**
 * Common interface for points. Both Point and ObservablePoint implement it
 * @memberof PIXI
 * @interface IPointData
 *//**
 * X coord
 * @memberof PIXI.IPointData#
 * @member {number} x
 *//**
 * Y coord
 * @memberof PIXI.IPointData#
 * @member {number} y
 *//**
 * Common interface for points. Both Point and ObservablePoint implement it
 * @memberof PIXI
 * @interface IPoint
 * @extends PIXI.IPointData
 *//**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @method set
 * @memberof PIXI.IPoint#
 * @param {number} [x=0] - position of the point on the x axis
 * @param {number} [y=x] - position of the point on the y axis
 *//**
 * Copies x and y from the given point
 * @method copyFrom
 * @memberof PIXI.IPoint#
 * @param {PIXI.IPointData} p - The point to copy from
 * @returns {this} Returns itself.
 *//**
 * Copies x and y into the given point
 * @method copyTo
 * @memberof PIXI.IPoint#
 * @param {PIXI.IPoint} p - The point to copy.
 * @returns {PIXI.IPoint} Given point with values updated
 *//**
 * Returns true if the given point is equal to this point
 *
 * @method equals
 * @memberof PIXI.IPoint#
 * @param {PIXI.IPointData} p - The point to check
 * @returns {boolean} Whether the given point equal to this point
 *//**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 * @implements IPoint
 */var gk=/** @class */function(){/**
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */function t(t,e){void 0===t&&(t=0),void 0===e&&(e=0),/**
         * @member {number}
         * @default 0
         */this.x=t,/**
         * @member {number}
         * @default 0
         */this.y=e}return(/**
     * Creates a clone of this point
     *
     * @return {PIXI.Point} a copy of the point
     */t.prototype.clone=function(){return new t(this.x,this.y)},/**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPointData} p - The point to copy from
     * @returns {this} Returns itself.
     */t.prototype.copyFrom=function(t){return this.set(t.x,t.y),this},/**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */t.prototype.copyTo=function(t){return t.set(this.x,this.y),t},/**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPointData} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */t.prototype.equals=function(t){return t.x===this.x&&t.y===this.y},/**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns {this} Returns itself.
     */t.prototype.set=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),this.x=t,this.y=e,this},t)}(),gH=/** @class */function(){/**
     * @param {Function} cb - callback when changed
     * @param {object} scope - owner of callback
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */function t(t,e,i,r){void 0===i&&(i=0),void 0===r&&(r=0),this._x=i,this._y=r,this.cb=t,this.scope=e}return(/**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {PIXI.ObservablePoint} a copy of the point
     */t.prototype.clone=function(e,i){return void 0===e&&(e=this.cb),void 0===i&&(i=this.scope),new t(e,i,this._x,this._y)},/**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=x] - position of the point on the y axis
     * @returns {this} Returns itself.
     */t.prototype.set=function(t,e){return void 0===t&&(t=0),void 0===e&&(e=t),(this._x!==t||this._y!==e)&&(this._x=t,this._y=e,this.cb.call(this.scope)),this},/**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPointData} p - The point to copy from.
     * @returns {this} Returns itself.
     */t.prototype.copyFrom=function(t){return(this._x!==t.x||this._y!==t.y)&&(this._x=t.x,this._y=t.y,this.cb.call(this.scope)),this},/**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */t.prototype.copyTo=function(t){return t.set(this._x,this._y),t},/**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPointData} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */t.prototype.equals=function(t){return t.x===this._x&&t.y===this._y},Object.defineProperty(t.prototype,"x",{/**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */get:function(){return this._x},set:function(t){this._x!==t&&(this._x=t,this.cb.call(this.scope))},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"y",{/**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */get:function(){return this._y},set:function(t){this._y!==t&&(this._y=t,this.cb.call(this.scope))},enumerable:!1,configurable:!0}),t)}(),gz=/** @class */function(){/**
     * @param {number} [a=1] - x scale
     * @param {number} [b=0] - x skew
     * @param {number} [c=0] - y skew
     * @param {number} [d=1] - y scale
     * @param {number} [tx=0] - x translation
     * @param {number} [ty=0] - y translation
     */function t(t,e,i,r,n,s){void 0===t&&(t=1),void 0===e&&(e=0),void 0===i&&(i=0),void 0===r&&(r=1),void 0===n&&(n=0),void 0===s&&(s=0),this.array=null,/**
         * @member {number}
         * @default 1
         */this.a=t,/**
         * @member {number}
         * @default 0
         */this.b=e,/**
         * @member {number}
         * @default 0
         */this.c=i,/**
         * @member {number}
         * @default 1
         */this.d=r,/**
         * @member {number}
         * @default 0
         */this.tx=n,/**
         * @member {number}
         * @default 0
         */this.ty=s}return(/**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */t.prototype.fromArray=function(t){this.a=t[0],this.b=t[1],this.c=t[3],this.d=t[4],this.tx=t[2],this.ty=t[5]},/**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.set=function(t,e,i,r,n,s){return this.a=t,this.b=e,this.c=i,this.d=r,this.tx=n,this.ty=s,this},/**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */t.prototype.toArray=function(t,e){this.array||(this.array=new Float32Array(9));var i=e||this.array;return t?(i[0]=this.a,i[1]=this.b,i[2]=0,i[3]=this.c,i[4]=this.d,i[5]=0,i[6]=this.tx,i[7]=this.ty):(i[0]=this.a,i[1]=this.c,i[2]=this.tx,i[3]=this.b,i[4]=this.d,i[5]=this.ty,i[6]=0,i[7]=0),i[8]=1,i},/**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.IPointData} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */t.prototype.apply=function(t,e){e=e||new gk;var i=t.x,r=t.y;return e.x=this.a*i+this.c*r+this.tx,e.y=this.b*i+this.d*r+this.ty,e},/**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.IPointData} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */t.prototype.applyInverse=function(t,e){e=e||new gk;var i=1/(this.a*this.d+-(this.c*this.b)),r=t.x,n=t.y;return e.x=this.d*i*r+-this.c*i*n+(this.ty*this.c-this.tx*this.d)*i,e.y=this.a*i*n+-this.b*i*r+(-this.ty*this.a+this.tx*this.b)*i,e},/**
     * Translates the matrix on the x and y.
     *
     * @param {number} x - How much to translate x by
     * @param {number} y - How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.translate=function(t,e){return this.tx+=t,this.ty+=e,this},/**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x - The amount to scale horizontally
     * @param {number} y - The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.scale=function(t,e){return this.a*=t,this.d*=e,this.c*=t,this.b*=e,this.tx*=t,this.ty*=e,this},/**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.rotate=function(t){var e=Math.cos(t),i=Math.sin(t),r=this.a,n=this.c,s=this.tx;return this.a=r*e-this.b*i,this.b=r*i+this.b*e,this.c=n*e-this.d*i,this.d=n*i+this.d*e,this.tx=s*e-this.ty*i,this.ty=s*i+this.ty*e,this},/**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.append=function(t){var e=this.a,i=this.b,r=this.c,n=this.d;return this.a=t.a*e+t.b*r,this.b=t.a*i+t.b*n,this.c=t.c*e+t.d*r,this.d=t.c*i+t.d*n,this.tx=t.tx*e+t.ty*r+this.tx,this.ty=t.tx*i+t.ty*n+this.ty,this},/**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.setTransform=function(t,e,i,r,n,s,o,a,h){return this.a=Math.cos(o+h)*n,this.b=Math.sin(o+h)*n,this.c=-Math.sin(o-a)*s,this.d=Math.cos(o-a)*s,this.tx=t-(i*this.a+r*this.c),this.ty=e-(i*this.b+r*this.d),this},/**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.prepend=function(t){var e=this.tx;if(1!==t.a||0!==t.b||0!==t.c||1!==t.d){var i=this.a,r=this.c;this.a=i*t.a+this.b*t.c,this.b=i*t.b+this.b*t.d,this.c=r*t.a+this.d*t.c,this.d=r*t.b+this.d*t.d}return this.tx=e*t.a+this.ty*t.c+t.tx,this.ty=e*t.b+this.ty*t.d+t.ty,this},/**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */t.prototype.decompose=function(t){// sort out rotation / skew..
var e=this.a,i=this.b,r=this.c,n=this.d,s=-Math.atan2(-r,n),o=Math.atan2(i,e),a=Math.abs(s+o);return a<1e-5||1e-5>Math.abs(gU-a)?(t.rotation=o,t.skew.x=t.skew.y=0):(t.rotation=0,t.skew.x=s,t.skew.y=o),// next set scale
t.scale.x=Math.sqrt(e*e+i*i),t.scale.y=Math.sqrt(r*r+n*n),// next set position
t.position.x=this.tx,t.position.y=this.ty,t},/**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.invert=function(){var t=this.a,e=this.b,i=this.c,r=this.d,n=this.tx,s=t*r-e*i;return this.a=r/s,this.b=-e/s,this.c=-i/s,this.d=t/s,this.tx=(i*this.ty-r*n)/s,this.ty=-(t*this.ty-e*n)/s,this},/**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */t.prototype.identity=function(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this},/**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */t.prototype.clone=function(){var e=new t;return e.a=this.a,e.b=this.b,e.c=this.c,e.d=this.d,e.tx=this.tx,e.ty=this.ty,e},/**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */t.prototype.copyTo=function(t){return t.a=this.a,t.b=this.b,t.c=this.c,t.d=this.d,t.tx=this.tx,t.ty=this.ty,t},/**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */t.prototype.copyFrom=function(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this},Object.defineProperty(t,"IDENTITY",{/**
         * A default (identity) matrix
         *
         * @static
         * @const
         * @member {PIXI.Matrix}
         */get:function(){return new t},enumerable:!1,configurable:!0}),Object.defineProperty(t,"TEMP_MATRIX",{/**
         * A temp matrix
         *
         * @static
         * @const
         * @member {PIXI.Matrix}
         */get:function(){return new t},enumerable:!1,configurable:!0}),t)}(),gj=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],gV=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],gX=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],gW=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],gY=[],gq=[],gK=Math.sign;!/*
 * Initializes `rotationCayley` and `rotationMatrices`. It is called
 * only once below.
 */function(){for(var t=0;t<16;t++){var e=[];gY.push(e);for(var i=0;i<16;i++)/* Finds rotation matrix matching the product and pushes it. */for(var r=gK(gj[t]*gj[i]+gX[t]*gV[i]),n=gK(gV[t]*gj[i]+gW[t]*gV[i]),s=gK(gj[t]*gX[i]+gX[t]*gW[i]),o=gK(gV[t]*gX[i]+gW[t]*gW[i]),a=0;a<16;a++)if(gj[a]===r&&gV[a]===n&&gX[a]===s&&gW[a]===o){e.push(a);break}}for(var t=0;t<16;t++){var h=new gz;h.set(gj[t],gV[t],gX[t],gW[t],0,0),gq.push(h)}}();/**
 * @memberof PIXI
 * @typedef {number} GD8Symmetry
 * @see PIXI.groupD8
 *//**
 * Implements the dihedral group D8, which is similar to
 * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};
 * D8 is the same but with diagonals, and it is used for texture
 * rotations.
 *
 * The directions the U- and V- axes after rotation
 * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`
 * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.
 *
 * **Origin:**<br>
 *  This is the small part of gameofbombs.com portal system. It works.
 *
 * @see PIXI.groupD8.E
 * @see PIXI.groupD8.SE
 * @see PIXI.groupD8.S
 * @see PIXI.groupD8.SW
 * @see PIXI.groupD8.W
 * @see PIXI.groupD8.NW
 * @see PIXI.groupD8.N
 * @see PIXI.groupD8.NE
 * @author Ivan @ivanpopelyshev
 * @namespace PIXI.groupD8
 * @memberof PIXI
 */var gJ={/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0       | East      |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */E:0,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45     | Southeast |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */SE:1,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90     | South     |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */S:2,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135    | Southwest |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */SW:3,/**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180     | West      |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */W:4,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135/225 | Northwest    |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */NW:5,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90/270  | North        |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */N:6,/**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45/315  | Northeast    |
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */NE:7,/**
     * Reflection about Y-axis.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MIRROR_VERTICAL:8,/**
     * Reflection about the main diagonal.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MAIN_DIAGONAL:10,/**
     * Reflection about X-axis.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */MIRROR_HORIZONTAL:12,/**
     * Reflection about reverse diagonal.
     *
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */REVERSE_DIAGONAL:14,/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */uX:function(t){return gj[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */uY:function(t){return gV[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */vX:function(t){return gX[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @return {PIXI.GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */vY:function(t){return gW[t]},/**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
     */inv:function(t){return 8&t?15&t:7&-t// or rotation % 16
},/**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @return {PIXI.GD8Symmetry} Composed operation
     */add:function(t,e){return gY[t][e]},/**
     * Reverse of `add`.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation
     * @return {PIXI.GD8Symmetry} Result
     */sub:function(t,e){return gY[t][gJ.inv(e)]},/**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     *
     * @memberof PIXI.groupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */rotate180:function(t){return 4^t},/**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */isVertical:function(t){return(3&t)==2},/**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `groupD8`.
     *
     * @memberof PIXI.groupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @return {PIXI.GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */byDirection:function(t,e){return 2*Math.abs(t)<=Math.abs(e)?e>=0?gJ.S:gJ.N:2*Math.abs(e)<=Math.abs(t)?t>0?gJ.E:gJ.W:e>0?t>0?gJ.SE:gJ.SW:t>0?gJ.NE:gJ.NW},/**
     * Helps sprite to compensate texture packer rotation.
     *
     * @memberof PIXI.groupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */matrixAppendRotationInv:function(t,e,i,r){void 0===i&&(i=0),void 0===r&&(r=0);// Packer used "rotation", we use "inv(rotation)"
var n=gq[gJ.inv(e)];n.tx=i,n.ty=r,t.append(n)}};!/** @class */function(){function t(){/**
         * The world transformation matrix.
         *
         * @member {PIXI.Matrix}
         */this.worldTransform=new gz,/**
         * The local transformation matrix.
         *
         * @member {PIXI.Matrix}
         */this.localTransform=new gz,/**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @member {PIXI.ObservablePoint}
         */this.position=new gH(this.onChange,this,0,0),/**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */this.scale=new gH(this.onChange,this,1,1),/**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */this.pivot=new gH(this.onChange,this,0,0),/**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */this.skew=new gH(this.updateSkew,this,0,0),/**
         * The rotation amount.
         *
         * @protected
         * @member {number}
         */this._rotation=0,/**
         * The X-coordinate value of the normalized local X axis,
         * the first column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._cx=1,/**
         * The Y-coordinate value of the normalized local X axis,
         * the first column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._sx=0,/**
         * The X-coordinate value of the normalized local Y axis,
         * the second column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._cy=0,/**
         * The Y-coordinate value of the normalized local Y axis,
         * the second column of the local transformation matrix without a scale.
         *
         * @protected
         * @member {number}
         */this._sy=1,/**
         * The locally unique ID of the local transform.
         *
         * @protected
         * @member {number}
         */this._localID=0,/**
         * The locally unique ID of the local transform
         * used to calculate the current local transformation matrix.
         *
         * @protected
         * @member {number}
         */this._currentLocalID=0,/**
         * The locally unique ID of the world transform.
         *
         * @protected
         * @member {number}
         */this._worldID=0,/**
         * The locally unique ID of the parent's world transform
         * used to calculate the current world transformation matrix.
         *
         * @protected
         * @member {number}
         */this._parentID=0}/**
     * Called when a value changes.
     *
     * @protected
     */t.prototype.onChange=function(){this._localID++},/**
     * Called when the skew or the rotation changes.
     *
     * @protected
     */t.prototype.updateSkew=function(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this._localID++},/**
     * Updates the local transformation matrix.
     */t.prototype.updateLocalTransform=function(){var t=this.localTransform;this._localID!==this._currentLocalID&&(// get the matrix values of the displayobject based on its transform properties..
t.a=this._cx*this.scale.x,t.b=this._sx*this.scale.x,t.c=this._cy*this.scale.y,t.d=this._sy*this.scale.y,t.tx=this.position.x-(this.pivot.x*t.a+this.pivot.y*t.c),t.ty=this.position.y-(this.pivot.x*t.b+this.pivot.y*t.d),this._currentLocalID=this._localID,// force an update..
this._parentID=-1)},/**
     * Updates the local and the world transformation matrices.
     *
     * @param {PIXI.Transform} parentTransform - The parent transform
     */t.prototype.updateTransform=function(t){var e=this.localTransform;if(this._localID!==this._currentLocalID&&(// get the matrix values of the displayobject based on its transform properties..
e.a=this._cx*this.scale.x,e.b=this._sx*this.scale.x,e.c=this._cy*this.scale.y,e.d=this._sy*this.scale.y,e.tx=this.position.x-(this.pivot.x*e.a+this.pivot.y*e.c),e.ty=this.position.y-(this.pivot.x*e.b+this.pivot.y*e.d),this._currentLocalID=this._localID,// force an update..
this._parentID=-1),this._parentID!==t._worldID){// concat the parent matrix with the objects transform.
var i=t.worldTransform,r=this.worldTransform;r.a=e.a*i.a+e.b*i.c,r.b=e.a*i.b+e.b*i.d,r.c=e.c*i.a+e.d*i.c,r.d=e.c*i.b+e.d*i.d,r.tx=e.tx*i.a+e.ty*i.c+i.tx,r.ty=e.tx*i.b+e.ty*i.d+i.ty,this._parentID=t._worldID,// update the id of the transform..
this._worldID++}},/**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */t.prototype.setFromMatrix=function(t){t.decompose(this),this._localID++},Object.defineProperty(t.prototype,"rotation",{/**
         * The rotation of the object in radians.
         *
         * @member {number}
         */get:function(){return this._rotation},set:function(t){this._rotation!==t&&(this._rotation=t,this.updateSkew())},enumerable:!1,configurable:!0}),/**
     * A default (identity) transform
     *
     * @static
     * @constant
     * @member {PIXI.Transform}
     */t.IDENTITY=new t}(),gf.PREFER_ENV=gp.any?Er.WEBGL:Er.WEBGL2,gf.STRICT_TEXTURE_CACHE=!1;/**
 * Collection of installed resource types, class must extend {@link PIXI.resources.Resource}.
 * @example
 * class CustomResource extends PIXI.resources.Resource {
 *   // MUST have source, options constructor signature
 *   // for auto-detected resources to be created.
 *   constructor(source, options) {
 *     super();
 *   }
 *   upload(renderer, baseTexture, glTexture) {
 *     // upload with GL
 *     return true;
 *   }
 *   // used to auto-detect resource
 *   static test(source, extension) {
 *     return extension === 'xyz'|| source instanceof SomeClass;
 *   }
 * }
 * // Install the new resource type
 * PIXI.resources.INSTALLED.push(CustomResource);
 *
 * @name PIXI.resources.INSTALLED
 * @type {Array<*>}
 * @static
 * @readonly
 */var gZ=[];/**
 * Create a resource element from a single source element. This
 * auto-detects which type of resource to create. All resources that
 * are auto-detectable must have a static `test` method and a constructor
 * with the arguments `(source, options?)`. Currently, the supported
 * resources for auto-detection include:
 *  - {@link PIXI.resources.ImageResource}
 *  - {@link PIXI.resources.CanvasResource}
 *  - {@link PIXI.resources.VideoResource}
 *  - {@link PIXI.resources.SVGResource}
 *  - {@link PIXI.resources.BufferResource}
 * @static
 * @function PIXI.resources.autoDetectResource
 * @param {string|*} source - Resource source, this can be the URL to the resource,
 *        a typed-array (for BufferResource), HTMLVideoElement, SVG data-uri
 *        or any other resource that can be auto-detected. If not resource is
 *        detected, it's assumed to be an ImageResource.
 * @param {object} [options] - Pass-through options to use for Resource
 * @param {number} [options.width] - Width of BufferResource or SVG rasterization
 * @param {number} [options.height] - Height of BufferResource or SVG rasterization
 * @param {boolean} [options.autoLoad=true] - Image, SVG and Video flag to start loading
 * @param {number} [options.scale=1] - SVG source scale. Overridden by width, height
 * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - Image option to create Bitmap object
 * @param {boolean} [options.crossorigin=true] - Image and Video option to set crossOrigin
 * @param {boolean} [options.autoPlay=true] - Video option to start playing video immediately
 * @param {number} [options.updateFPS=0] - Video option to update how many times a second the
 *        texture should be updated from the video. Leave at 0 to update at every render
 * @return {PIXI.resources.Resource} The created resource.
 */function g$(t,e){if(!t)return null;var i="";if("string"==typeof t){// search for file extension: period, 3-4 chars, then ?, # or EOL
var r=/\.(\w{3,4})(?:$|\?|#)/i.exec(t);r&&(i=r[1].toLowerCase())}for(var n=gZ.length-1;n>=0;--n){var s=gZ[n];if(s.test&&s.test(t,i))return new s(t,e)}throw Error("Unrecognized source type to auto-detect Resource")}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var gQ=function(t,e){return(gQ=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function g0(t,e){function i(){this.constructor=t}gQ(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}/**
 * Base resource class for textures that manages validation and uploading, depending on its type.
 *
 * Uploading of a base texture to the GPU is required.
 *
 * @class
 * @memberof PIXI.resources
 */var g1=/** @class */function(){/**
     * @param {number} [width=0] - Width of the resource
     * @param {number} [height=0] - Height of the resource
     */function t(t,e){void 0===t&&(t=0),void 0===e&&(e=0),/**
         * Internal width of the resource
         * @member {number}
         * @protected
         */this._width=t,/**
         * Internal height of the resource
         * @member {number}
         * @protected
         */this._height=e,/**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */this.destroyed=!1,/**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */this.internal=!1,/**
         * Mini-runner for handling resize events
         * accepts 2 parameters: width, height
         *
         * @member {Runner}
         * @private
         */this.onResize=new gD("setRealSize"),/**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */this.onUpdate=new gD("update"),/**
         * Handle internal errors, such as loading errors
         * accepts 1 param: error
         *
         * @member {Runner}
         * @private
         */this.onError=new gD("onError")}return(/**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */t.prototype.bind=function(t){this.onResize.add(t),this.onUpdate.add(t),this.onError.add(t),(this._width||this._height)&&this.onResize.emit(this._width,this._height)},/**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */t.prototype.unbind=function(t){this.onResize.remove(t),this.onUpdate.remove(t),this.onError.remove(t)},/**
     * Trigger a resize event
     * @param {number} width - X dimension
     * @param {number} height - Y dimension
     */t.prototype.resize=function(t,e){(t!==this._width||e!==this._height)&&(this._width=t,this._height=e,this.onResize.emit(t,e))},Object.defineProperty(t.prototype,"valid",{/**
         * Has been validated
         * @readonly
         * @member {boolean}
         */get:function(){return!!this._width&&!!this._height},enumerable:!1,configurable:!0}),/**
     * Has been updated trigger event
     */t.prototype.update=function(){this.destroyed||this.onUpdate.emit()},/**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */t.prototype.load=function(){return Promise.resolve(this)},Object.defineProperty(t.prototype,"width",{/**
         * The width of the resource.
         *
         * @member {number}
         * @readonly
         */get:function(){return this._width},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"height",{/**
         * The height of the resource.
         *
         * @member {number}
         * @readonly
         */get:function(){return this._height},enumerable:!1,configurable:!0}),/**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */t.prototype.style=function(t,e,i){return!1},/**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */t.prototype.dispose=function(){// override
},/**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */t.prototype.destroy=function(){this.destroyed||(this.destroyed=!0,this.dispose(),this.onError.removeAll(),this.onError=null,this.onResize.removeAll(),this.onResize=null,this.onUpdate.removeAll(),this.onUpdate=null)},/**
     * Abstract, used to auto-detect resource type
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */t.test=function(t,e){return!1},t)}(),g2=/** @class */function(t){/**
     * @param {Float32Array|Uint8Array|Uint32Array} source - Source buffer
     * @param {object} options - Options
     * @param {number} options.width - Width of the texture
     * @param {number} options.height - Height of the texture
     */function e(e,i){var r=this,n=i||{},s=n.width,o=n.height;if(!s||!o)throw Error("BufferResource width or height invalid");return(/**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */(r=t.call(this,s,o)||this).data=e,r)}return g0(e,t),/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture - glTexture
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i){var r=t.gl;return r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===Ef.UNPACK),i.width===e.width&&i.height===e.height?r.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.type,this.data):(i.width=e.width,i.height=e.height,r.texImage2D(e.target,0,i.internalFormat,e.width,e.height,0,e.format,i.type,this.data)),!0},/**
     * Destroy and don't use after this
     * @override
     */e.prototype.dispose=function(){this.data=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */e.test=function(t){return t instanceof Float32Array||t instanceof Uint8Array||t instanceof Uint32Array},e}(g1),g3={scaleMode:Ec.NEAREST,format:Eh.RGBA,alphaMode:Ef.NPM},g5=/** @class */function(t){function e(e,i){void 0===e&&(e=null),void 0===i&&(i=null);var r=t.call(this)||this,n=(i=i||{}).alphaMode,s=i.mipmap,o=i.anisotropicLevel,a=i.scaleMode,h=i.width,l=i.height,u=i.wrapMode,c=i.format,d=i.type,p=i.target,f=i.resolution,m=i.resourceOptions;return!e||e instanceof g1||((e=g$(e,m)).internal=!0),/**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */r.width=h||0,/**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */r.height=l||0,/**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */r.resolution=f||gf.RESOLUTION,/**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */r.mipmap=void 0!==s?s:gf.MIPMAP_TEXTURES,/**
         * Anisotropic filtering level of texture
         *
         * @member {number}
         * @default PIXI.settings.ANISOTROPIC_LEVEL
         */r.anisotropicLevel=void 0!==o?o:gf.ANISOTROPIC_LEVEL,/**
         * How the texture wraps
         * @member {number}
         */r.wrapMode=u||gf.WRAP_MODE,/**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */r.scaleMode=void 0!==a?a:gf.SCALE_MODE,/**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */r.format=c||Eh.RGBA,/**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */r.type=d||Eu.UNSIGNED_BYTE,/**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */r.target=p||El.TEXTURE_2D,/**
         * How to treat premultiplied alpha, see {@link PIXI.ALPHA_MODES}.
         *
         * @member {PIXI.ALPHA_MODES}
         * @default PIXI.ALPHA_MODES.UNPACK
         */r.alphaMode=void 0!==n?n:Ef.UNPACK,void 0!==i.premultiplyAlpha&&(r.premultiplyAlpha=i.premultiplyAlpha),/**
         * Global unique identifier for this BaseTexture
         *
         * @member {number}
         * @protected
         */r.uid=++gR,/**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */r.touched=0,/**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */r.isPowerOfTwo=!1,r._refreshPOT(),/**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */r._glTextures={},/**
         * Used by TextureSystem to only update texture to the GPU when needed.
         * Please call `update()` to increment it.
         *
         * @readonly
         * @member {number}
         */r.dirtyId=0,/**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */r.dirtyStyleId=0,/**
         * Currently default cache ID.
         *
         * @member {string}
         */r.cacheId=null,/**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */r.valid=h>0&&l>0,/**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */r.textureCacheIds=[],/**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */r.destroyed=!1,/**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */r.resource=null,/**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */r._batchEnabled=0,/**
         * Location inside texture batch, used by multi-texture renderers
         *
         * @member {number}
         */r._batchLocation=0,/**
         * Whether its a part of another texture, handled by ArrayResource or CubeResource
         *
         * @member {PIXI.BaseTexture}
         */r.parentTextureArray=null,/**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         *//**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         * @param {ErrorEvent} event - Load error event.
         *//**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         *//**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         *//**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */// Set the resource
r.setResource(e),r}return g0(e,t),Object.defineProperty(e.prototype,"realWidth",{/**
         * Pixel width of the source of this texture
         *
         * @readonly
         * @member {number}
         */get:function(){return Math.ceil(this.width*this.resolution-1e-4)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"realHeight",{/**
         * Pixel height of the source of this texture
         *
         * @readonly
         * @member {number}
         */get:function(){return Math.ceil(this.height*this.resolution-1e-4)},enumerable:!1,configurable:!0}),/**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setStyle=function(t,e){var i;return void 0!==t&&t!==this.scaleMode&&(this.scaleMode=t,i=!0),void 0!==e&&e!==this.mipmap&&(this.mipmap=e,i=!0),i&&this.dirtyStyleId++,this},/**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width - Visual width
     * @param {number} height - Visual height
     * @param {number} [resolution] - Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setSize=function(t,e,i){return this.resolution=i||this.resolution,this.width=t,this.height=e,this._refreshPOT(),this.update(),this},/**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth - Full rendered width
     * @param {number} realHeight - Full rendered height
     * @param {number} [resolution] - Optionally set resolution
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setRealSize=function(t,e,i){return this.resolution=i||this.resolution,this.width=t/this.resolution,this.height=e/this.resolution,this._refreshPOT(),this.update(),this},/**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */e.prototype._refreshPOT=function(){var t,e;this.isPowerOfTwo=!((t=this.realWidth)&t-1)&&!!t&&!((e=this.realHeight)&e-1)&&!!e},/**
     * Changes resolution
     *
     * @param {number} resolution - res
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setResolution=function(t){var e=this.resolution;return e===t||(this.resolution=t,this.valid&&(this.width=this.width*e/t,this.height=this.height*e/t,this.emit("update",this)),this._refreshPOT()),this},/**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {PIXI.BaseTexture} this
     */e.prototype.setResource=function(t){if(this.resource===t)return this;if(this.resource)throw Error("Resource can be set only once");return t.bind(this),this.resource=t,this},/**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */e.prototype.update=function(){this.valid?(this.dirtyId++,this.dirtyStyleId++,this.emit("update",this)):this.width>0&&this.height>0&&(this.valid=!0,this.emit("loaded",this),this.emit("update",this))},/**
     * Handle errors with resources.
     * @private
     * @param {ErrorEvent} event - Error event emitted.
     */e.prototype.onError=function(t){this.emit("error",this,t)},/**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */e.prototype.destroy=function(){this.resource&&(this.resource.unbind(this),this.resource.internal&&this.resource.destroy(),this.resource=null),this.cacheId&&(delete gL[this.cacheId],delete gO[this.cacheId],this.cacheId=null),// finally let the WebGL renderer know..
this.dispose(),e.removeFromCache(this),this.textureCacheIds=null,this.destroyed=!0},/**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */e.prototype.dispose=function(){this.emit("dispose",this)},/**
     * Utility function for BaseTexture|Texture cast
     */e.prototype.castToBaseTexture=function(){return this},/**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
     * @returns {PIXI.BaseTexture} The new base texture.
     */e.from=function(t,i,r){void 0===r&&(r=gf.STRICT_TEXTURE_CACHE);var n="string"==typeof t,s=null;n?s=t:(t._pixiId||(t._pixiId="pixiid_"+ ++gR),s=t._pixiId);var o=gL[s];// Strict-mode rejects invalid cacheIds
if(n&&r&&!o)throw Error('The cacheId "'+s+'" does not exist in BaseTextureCache.');return o||((o=new e(t,i)).cacheId=s,e.addToCache(o,s)),o},/**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */e.fromBuffer=function(t,i,r,n){t=t||new Float32Array(i*r*4);var s=new g2(t,{width:i,height:r}),o=t instanceof Float32Array?Eu.FLOAT:Eu.UNSIGNED_BYTE;return new e(s,Object.assign(g3,n||{width:i,height:r,type:o}))},/**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */e.addToCache=function(t,e){e&&(-1===t.textureCacheIds.indexOf(e)&&t.textureCacheIds.push(e),gL[e]&&console.warn("BaseTexture added to the cache with an id ["+e+"] that already had an entry"),gL[e]=t)},/**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */e.removeFromCache=function(t){if("string"==typeof t){var e=gL[t];if(e){var i=e.textureCacheIds.indexOf(t);return i>-1&&e.textureCacheIds.splice(i,1),delete gL[t],e}}else if(t&&t.textureCacheIds){for(var r=0;r<t.textureCacheIds.length;++r)delete gL[t.textureCacheIds[r]];return t.textureCacheIds.length=0,t}return null},/**
     * Global number of the texture batch, used by multi-texture renderers
     *
     * @static
     * @member {number}
     */e._globalBatch=0,e}(/*@__PURE__*/tP(gm)),g4=/** @class */function(t){function e(e,i){var r=this,n=i||{},s=n.width,o=n.height;/**
         * Collection of partial baseTextures that correspond to resources
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */(r=t.call(this,s,o)||this).items=[],/**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */r.itemDirtyIds=[];for(var a=0;a<e;a++){var h=new g5;r.items.push(h),// -2 - first run of texture array upload
// -1 - texture item was allocated
// >=0 - texture item uploaded , in sync with items[i].dirtyId
r.itemDirtyIds.push(-2)}return(/**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */r.length=e,/**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */r._load=null,/**
         * Bound baseTexture, there can only be one
         * @member {PIXI.BaseTexture}
         */r.baseTexture=null,r)}return g0(e,t),/**
     * used from ArrayResource and CubeResource constructors
     * @param {Array<*>} resources - Can be resources, image elements, canvas, etc. ,
     *  length should be same as constructor length
     * @param {object} [options] - detect options for resources
     * @protected
     */e.prototype.initFromArray=function(t,e){for(var i=0;i<this.length;i++)t[i]&&(t[i].castToBaseTexture?this.addBaseTextureAt(t[i].castToBaseTexture(),i):t[i]instanceof g1?this.addResourceAt(t[i],i):this.addResourceAt(g$(t[i],e),i))},/**
     * Destroy this BaseImageResource
     * @override
     */e.prototype.dispose=function(){for(var t=0,e=this.length;t<e;t++)this.items[t].destroy();this.items=null,this.itemDirtyIds=null,this._load=null},/**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */e.prototype.addResourceAt=function(t,e){if(!this.items[e])throw Error("Index "+e+" is out of bounds");return t.valid&&!this.valid&&this.resize(t.width,t.height),this.items[e].setResource(t),this},/**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.bind=function(e){if(null!==this.baseTexture)throw Error("Only one base texture per TextureArray is allowed");t.prototype.bind.call(this,e);for(var i=0;i<this.length;i++)this.items[i].parentTextureArray=e,this.items[i].on("update",e.update,e)},/**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.unbind=function(e){t.prototype.unbind.call(this,e);for(var i=0;i<this.length;i++)this.items[i].parentTextureArray=null,this.items[i].off("update",e.update,e)},/**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */e.prototype.load=function(){var t=this;if(this._load)return this._load;// TODO: also implement load part-by-part strategy
var e=this.items.map(function(t){return t.resource}).filter(function(t){return t}).map(function(t){return t.load()});return this._load=Promise.all(e).then(function(){var e=t.items[0],i=e.realWidth,r=e.realHeight;return t.resize(i,r),Promise.resolve(t)}),this._load},e}(g1),g6=/** @class */function(t){function e(e,i){var r,n,s=this,o=i||{},a=o.width,h=o.height;return Array.isArray(e)?(r=e,n=e.length):n=e,s=t.call(this,n,{width:a,height:h})||this,r&&s.initFromArray(r,i),s}return g0(e,t),/**
     * Set a baseTexture by ID,
     * ArrayResource just takes resource from it, nothing more
     *
     * @param {PIXI.BaseTexture} baseTexture
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */e.prototype.addBaseTextureAt=function(t,e){if(t.resource)this.addResourceAt(t.resource,e);else throw Error("ArrayResource does not support RenderTexture");return this},/**
     * Add binding
     * @member {PIXI.BaseTexture}
     * @override
     */e.prototype.bind=function(e){t.prototype.bind.call(this,e),e.target=El.TEXTURE_2D_ARRAY},/**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */e.prototype.upload=function(t,e,i){var r=this.length,n=this.itemDirtyIds,s=this.items,o=t.gl;i.dirtyId<0&&o.texImage3D(o.TEXTURE_2D_ARRAY,0,e.format,this._width,this._height,r,0,e.format,e.type,null);for(var a=0;a<r;a++){var h=s[a];n[a]<h.dirtyId&&(n[a]=h.dirtyId,h.valid&&o.texSubImage3D(o.TEXTURE_2D_ARRAY,0,0,0,a,h.resource.width,h.resource.height,1,e.format,e.type,h.resource.source))}return!0},e}(g4),g8=/** @class */function(t){/**
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} source
     */function e(e){var i=this,r=e.naturalWidth||e.videoWidth||e.width,n=e.naturalHeight||e.videoHeight||e.height;return(/**
         * The source element
         * @member {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement}
         * @readonly
         */(i=t.call(this,r,n)||this).source=e,/**
         * If set to `true`, will force `texImage2D` over `texSubImage2D` for uploading.
         * Certain types of media (e.g. video) using `texImage2D` is more performant.
         * @member {boolean}
         * @default false
         * @private
         */i.noSubImage=!1,i)}return g0(e,t),/**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */e.crossOrigin=function(t,e,i){void 0===i&&0!==e.indexOf("data:")?t.crossOrigin=/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 * Nipped from the resource loader!
 *
 * @ignore
 * @param {string} url - The url to test.
 * @param {object} [loc=window.location] - The location object to test against.
 * @return {string} The crossOrigin value to use (or empty string for none).
 */function(t,e){// data: and javascript: urls are considered same-origin
if(void 0===e&&(e=window.location),0===t.indexOf("data:"))return"";// default is window.location
e=e||window.location,Eb||(Eb=document.createElement("a")),// let the browser determine the full href for the url of this resource and then
// parse with the node url lib, we can't use the properties of the anchor element
// because they don't work in IE9 :(
Eb.href=t;var i=xV(Eb.href),r=!i.port&&""===e.port||i.port===e.port;return(// if cross origin
i.hostname===e.hostname&&r&&i.protocol===e.protocol?"":"anonymous")}(e):!1!==i&&(t.crossOrigin="string"==typeof i?i:"anonymous")},/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i,r){var n=t.gl,s=e.realWidth,o=e.realHeight;return r=r||this.source,n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===Ef.UNPACK),this.noSubImage||e.target!==n.TEXTURE_2D||i.width!==s||i.height!==o?(i.width=s,i.height=o,n.texImage2D(e.target,0,e.format,e.format,e.type,r)):n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.format,e.type,r),!0},/**
     * Checks if source width/height was changed, resize can cause extra baseTexture update.
     * Triggers one update in any case.
     */e.prototype.update=function(){if(!this.destroyed){var e=this.source,i=e.naturalWidth||e.videoWidth||e.width,r=e.naturalHeight||e.videoHeight||e.height;this.resize(i,r),t.prototype.update.call(this)}},/**
     * Destroy this BaseImageResource
     * @override
     */e.prototype.dispose=function(){this.source=null},e}(g1),g7=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return g0(e,t),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {HTMLCanvasElement|OffscreenCanvas} source - The source object
     * @return {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas
     */e.test=function(t){var e=window.OffscreenCanvas;return(// Check for browsers that don't yet support OffscreenCanvas
!!e&&t instanceof e||t instanceof HTMLCanvasElement)},e}(g8),g9=/** @class */function(t){function e(i,r){var n=this,s=r||{},o=s.width,a=s.height,h=s.autoLoad,l=s.linkBaseTexture;if(i&&i.length!==e.SIDES)throw Error("Invalid length. Got "+i.length+", expected 6");n=t.call(this,6,{width:o,height:a})||this;for(var u=0;u<e.SIDES;u++)n.items[u].target=El.TEXTURE_CUBE_MAP_POSITIVE_X+u;return(/**
         * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself
         * @member {boolean}
         * @protected
         */n.linkBaseTexture=!1!==l,i&&n.initFromArray(i,r),!1!==h&&n.load(),n)}return g0(e,t),/**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */e.prototype.bind=function(e){t.prototype.bind.call(this,e),e.target=El.TEXTURE_CUBE_MAP},e.prototype.addBaseTextureAt=function(t,e,i){if(void 0===i&&(i=this.linkBaseTexture),!this.items[e])throw Error("Index "+e+" is out of bounds");if(!this.linkBaseTexture||t.parentTextureArray||Object.keys(t._glTextures).length>0){// copy mode
if(t.resource)this.addResourceAt(t.resource,e);else throw Error("CubeResource does not support copying of renderTexture.")}else // link mode, the difficult one!
t.target=El.TEXTURE_CUBE_MAP_POSITIVE_X+e,t.parentTextureArray=this.baseTexture,this.items[e]=t;return t.valid&&!this.valid&&this.resize(t.realWidth,t.realHeight),this.items[e]=t,this},/**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,i,r){for(var n=this.itemDirtyIds,s=0;s<e.SIDES;s++){var o=this.items[s];n[s]<o.dirtyId&&(o.valid&&o.resource?(o.resource.upload(t,o,r),n[s]=o.dirtyId):n[s]<-1&&(// either item is not valid yet, either its a renderTexture
// allocate the memory
t.gl.texImage2D(o.target,0,r.internalFormat,i.realWidth,i.realHeight,0,i.format,r.type,null),n[s]=-1))}return!0},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {object} source - The source object
     * @return {boolean} `true` if source is an array of 6 elements
     */e.test=function(t){return Array.isArray(t)&&t.length===e.SIDES},/**
     * Number of texture sides to store for CubeResources
     *
     * @name PIXI.resources.CubeResource.SIDES
     * @static
     * @member {number}
     * @default 6
     */e.SIDES=6,e}(g4),yt=/** @class */function(t){/**
     * @param {HTMLImageElement|string} source - image source or URL
     * @param {object} [options]
     * @param {boolean} [options.autoLoad=true] - start loading process
     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create
     *        a bitmap before upload
     * @param {boolean} [options.crossorigin=true] - Load image using cross origin
     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap
     */function e(e,i){var r=this;if(i=i||{},!(e instanceof HTMLImageElement)){var n=new Image;g8.crossOrigin(n,e,i.crossorigin),n.src=e,e=n}return r=t.call(this,e)||this,!e.complete&&r._width&&r._height&&(r._width=0,r._height=0),/**
         * URL of the image source
         * @member {string}
         */r.url=e.src,/**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */r._process=null,/**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */r.preserveBitmap=!1,/**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */r.createBitmap=(void 0!==i.createBitmap?i.createBitmap:gf.CREATE_IMAGE_BITMAP)&&!!window.createImageBitmap,/**
         * Controls texture alphaMode field
         * Copies from options
         * Default is `null`, copies option from baseTexture
         *
         * @member {PIXI.ALPHA_MODES|null}
         * @readonly
         */r.alphaMode="number"==typeof i.alphaMode?i.alphaMode:null,void 0!==i.premultiplyAlpha&&(r.premultiplyAlpha=i.premultiplyAlpha),/**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */r.bitmap=null,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */r._load=null,!1!==i.autoLoad&&r.load(),r}return g0(e,t),/**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap] - whether process image into bitmap
     * @returns {Promise<void>}
     */e.prototype.load=function(t){var e=this;return this._load||(void 0!==t&&(this.createBitmap=t),this._load=new Promise(function(t,i){var r=e.source;e.url=r.src;var n=function(){e.destroyed||(r.onload=null,r.onerror=null,e.resize(r.width,r.height),e._load=null,e.createBitmap?t(e.process()):t(e))};r.complete&&r.src?n():(r.onload=n,r.onerror=function(t){// Avoids Promise freezing when resource broken
i(t),e.onError.emit(t)})})),this._load},/**
     * Called when we need to convert image into BitmapImage.
     * Can be called multiple times, real promise is cached inside.
     *
     * @returns {Promise<void>} cached promise to fill that bitmap
     */e.prototype.process=function(){var t=this,e=this.source;return null!==this._process?this._process:null===this.bitmap&&window.createImageBitmap?(this._process=window.createImageBitmap(e,0,0,e.width,e.height,{premultiplyAlpha:this.alphaMode===Ef.UNPACK?"premultiply":"none"}).then(function(e){return t.destroyed?Promise.reject():(t.bitmap=e,t.update(),t._process=null,Promise.resolve(t))}),this._process):Promise.resolve(this)},/**
     * Upload the image resource to GPU.
     *
     * @param {PIXI.Renderer} renderer - Renderer to upload to
     * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
     * @param {PIXI.GLTexture} glTexture - GLTexture to use
     * @returns {boolean} true is success
     */e.prototype.upload=function(e,i,r){if("number"==typeof this.alphaMode&&(i.alphaMode=this.alphaMode),!this.createBitmap)return t.prototype.upload.call(this,e,i,r);if(!this.bitmap&&(// yeah, ignore the output
this.process(),!this.bitmap))return!1;if(t.prototype.upload.call(this,e,i,r,this.bitmap),!this.preserveBitmap){// checks if there are other renderers that possibly need this bitmap
var n=!0,s=i._glTextures;for(var o in s){var a=s[o];if(a!==r&&a.dirtyId!==i.dirtyId){n=!1;break}}n&&(this.bitmap.close&&this.bitmap.close(),this.bitmap=null)}return!0},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){this.source.onload=null,this.source.onerror=null,t.prototype.dispose.call(this),this.bitmap&&(this.bitmap.close(),this.bitmap=null),this._process=null,this._load=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {string|HTMLImageElement} source - The source object
     * @return {boolean} `true` if source is string or HTMLImageElement
     */e.test=function(t){return"string"==typeof t||t instanceof HTMLImageElement},e}(g8),ye=/** @class */function(t){function e(e,i){var r=this;return i=i||{},(r=t.call(this,document.createElement("canvas"))||this)._width=0,r._height=0,/**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */r.svg=e,/**
         * The source scale to apply when rasterizing on load
         * @readonly
         * @member {number}
         */r.scale=i.scale||1,/**
         * A width override for rasterization on load
         * @readonly
         * @member {number}
         */r._overrideWidth=i.width,/**
         * A height override for rasterization on load
         * @readonly
         * @member {number}
         */r._overrideHeight=i.height,/**
         * Call when completely loaded
         * @private
         * @member {function}
         */r._resolve=null,/**
         * Cross origin value to use
         * @private
         * @member {boolean|string}
         */r._crossorigin=i.crossorigin,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */r._load=null,!1!==i.autoLoad&&r.load(),r}return g0(e,t),e.prototype.load=function(){var t=this;return this._load||(this._load=new Promise(function(e){// Convert SVG inline string to data-uri
if(// Save this until after load is finished
t._resolve=function(){t.resize(t.source.width,t.source.height),e(t)},/^\<svg/.test(t.svg.trim())){if(!btoa)throw Error("Your browser doesn't support base64 conversions.");t.svg="data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(t.svg)))}t._loadSvg()})),this._load},/**
     * Loads an SVG image from `imageUrl` or `data URL`.
     *
     * @private
     */e.prototype._loadSvg=function(){var t=this,e=new Image;g8.crossOrigin(e,this.svg,this._crossorigin),e.src=this.svg,e.onerror=function(i){t._resolve&&(e.onerror=null,t.onError.emit(i))},e.onload=function(){if(t._resolve){var i=e.width,r=e.height;if(!i||!r)throw Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");// Set render size
var n=i*t.scale,s=r*t.scale;(t._overrideWidth||t._overrideHeight)&&(n=t._overrideWidth||t._overrideHeight/r*i,s=t._overrideHeight||t._overrideWidth/i*r),n=Math.round(n),s=Math.round(s);// Create a canvas element
var o=t.source;o.width=n,o.height=s,o._pixiId="canvas_"+ ++gR,// Draw the Svg to the canvas
o.getContext("2d").drawImage(e,0,0,i,r,0,0,n,s),t._resolve(),t._resolve=null}}},/**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.ISize} image extension
     */e.getSize=function(t){var i=e.SVG_SIZE.exec(t),r={};return i&&(r[i[1]]=Math.round(parseFloat(i[3])),r[i[5]]=Math.round(parseFloat(i[7]))),r},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){t.prototype.dispose.call(this),this._resolve=null,this._crossorigin=null},/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */e.test=function(t,e){// url file extension is SVG
return"svg"===e||"string"==typeof t&&/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)||"string"==typeof t&&0===t.indexOf("<svg")},/**
     * RegExp for SVG size.
     *
     * @static
     * @constant {RegExp|string} SVG_SIZE
     * @memberof PIXI.resources.SVGResource
     * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
     */e.SVG_SIZE=/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i,e}(g8),yi=/** @class */function(t){function e(i,r){var n=this;if(r=r||{},!(i instanceof HTMLVideoElement)){var s=document.createElement("video");// workaround for https://github.com/pixijs/pixi.js/issues/5996
s.setAttribute("preload","auto"),s.setAttribute("webkit-playsinline",""),s.setAttribute("playsinline",""),"string"==typeof i&&(i=[i]);var o=i[0].src||i[0];g8.crossOrigin(s,o,r.crossorigin);// array of objects or strings
for(var a=0;a<i.length;++a){var h=document.createElement("source"),l=i[a],u=l.src,c=l.mime,d=(u=u||i[a]).split("?").shift().toLowerCase(),p=d.substr(d.lastIndexOf(".")+1);c=c||e.MIME_TYPES[p]||"video/"+p,h.src=u,h.type=c,s.appendChild(h)}// Override the source
i=s}return(n=t.call(this,i)||this).noSubImage=!0,/**
         * `true` to use PIXI.Ticker.shared to auto update the base texture.
         *
         * @type {boolean}
         * @default true
         * @private
         */n._autoUpdate=!0,/**
         * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update the base texture.
         *
         * @type {boolean}
         * @default false
         * @private
         */n._isConnectedToTicker=!1,n._updateFPS=r.updateFPS||0,n._msToNextUpdate=0,/**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */n.autoPlay=!1!==r.autoPlay,/**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */n._load=null,/**
         * Callback when completed with load.
         * @member {function}
         * @private
         */n._resolve=null,// Bind for listeners
n._onCanPlay=n._onCanPlay.bind(n),n._onError=n._onError.bind(n),!1!==r.autoLoad&&n.load(),n}return g0(e,t),/**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */e.prototype.update=function(e){if(void 0===e&&(e=0),!this.destroyed){// account for if video has had its playbackRate changed
var i=gB.shared.elapsedMS*this.source.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-i),(!this._updateFPS||this._msToNextUpdate<=0)&&(t.prototype.update.call(this),this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0)}},/**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */e.prototype.load=function(){var t=this;if(this._load)return this._load;var e=this.source;return(e.readyState===e.HAVE_ENOUGH_DATA||e.readyState===e.HAVE_FUTURE_DATA)&&e.width&&e.height&&(e.complete=!0),e.addEventListener("play",this._onPlayStart.bind(this)),e.addEventListener("pause",this._onPlayStop.bind(this)),this._isSourceReady()?this._onCanPlay():(e.addEventListener("canplay",this._onCanPlay),e.addEventListener("canplaythrough",this._onCanPlay),e.addEventListener("error",this._onError,!0)),this._load=new Promise(function(i){t.valid?i(t):(t._resolve=i,e.load())}),this._load},/**
     * Handle video error events.
     *
     * @private
     */e.prototype._onError=function(t){this.source.removeEventListener("error",this._onError,!0),this.onError.emit(t)},/**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */e.prototype._isSourcePlaying=function(){var t=this.source;return t.currentTime>0&&!1===t.paused&&!1===t.ended&&t.readyState>2},/**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */e.prototype._isSourceReady=function(){var t=this.source;return 3===t.readyState||4===t.readyState},/**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */e.prototype._onPlayStart=function(){this.valid||this._onCanPlay(),this.autoUpdate&&!this._isConnectedToTicker&&(gB.shared.add(this.update,this),this._isConnectedToTicker=!0)},/**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */e.prototype._onPlayStop=function(){this._isConnectedToTicker&&(gB.shared.remove(this.update,this),this._isConnectedToTicker=!1)},/**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */e.prototype._onCanPlay=function(){var t=this.source;t.removeEventListener("canplay",this._onCanPlay),t.removeEventListener("canplaythrough",this._onCanPlay);var e=this.valid;this.resize(t.videoWidth,t.videoHeight),!e&&this._resolve&&(this._resolve(this),this._resolve=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&t.play()},/**
     * Destroys this texture
     * @override
     */e.prototype.dispose=function(){this._isConnectedToTicker&&gB.shared.remove(this.update,this);var e=this.source;e&&(e.removeEventListener("error",this._onError,!0),e.pause(),e.src="",e.load()),t.prototype.dispose.call(this)},Object.defineProperty(e.prototype,"autoUpdate",{/**
         * Should the base texture automatically update itself, set to true by default
         *
         * @member {boolean}
         */get:function(){return this._autoUpdate},set:function(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(gB.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._isSourcePlaying()&&(gB.shared.add(this.update,this),this._isConnectedToTicker=!0))},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"updateFPS",{/**
         * How many times a second to update the texture from the video. Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         *
         * @member {number}
         */get:function(){return this._updateFPS},set:function(t){t!==this._updateFPS&&(this._updateFPS=t)},enumerable:!1,configurable:!0}),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */e.test=function(t,i){return t instanceof HTMLVideoElement||e.TYPES.indexOf(i)>-1},/**
     * List of common video file extensions supported by VideoResource.
     * @constant
     * @member {Array<string>}
     * @static
     * @readonly
     */e.TYPES=["mp4","m4v","webm","ogg","ogv","h264","avi","mov"],/**
     * Map of video MIME types that can't be directly derived from file extensions.
     * @constant
     * @member {object}
     * @static
     * @readonly
     */e.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"},e}(g8),yr=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return g0(e,t),/**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {ImageBitmap} source - The source object
     * @return {boolean} `true` if source is an ImageBitmap
     */e.test=function(t){return!!window.createImageBitmap&&t instanceof ImageBitmap},e}(g8);gZ.push(yt,yr,g7,yi,ye,g2,g9,g6);/**
 * System is a base class used for extending systems used by the {@link PIXI.Renderer}
 *
 * @see PIXI.Renderer#addSystem
 * @class
 * @memberof PIXI
 */var yn=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this manager works for.
     */function t(t){/**
         * The renderer this manager works for.
         *
         * @member {PIXI.Renderer}
         */this.renderer=t}return(/**
     * Generic destroy methods to be overridden by the subclass
     */t.prototype.destroy=function(){this.renderer=null},t)}(),ys=/** @class */function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return g0(e,t),/**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer - Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture - Reference to parent texture
     * @param {PIXI.GLTexture} glTexture - glTexture
     * @returns {boolean} true is success
     */e.prototype.upload=function(t,e,i){var r=t.gl;return r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.alphaMode===Ef.UNPACK),i.width===e.width&&i.height===e.height?r.texSubImage2D(e.target,0,0,0,e.width,e.height,e.format,e.type,this.data):(i.width=e.width,i.height=e.height,r.texImage2D(e.target,0,1===t.context.webGLVersion?r.DEPTH_COMPONENT:r.DEPTH_COMPONENT16,e.width,e.height,0,e.format,e.type,this.data)),!0},e}(g2),yo=/** @class */function(){/**
     * @param {number} width - Width of the frame buffer
     * @param {number} height - Height of the frame buffer
     */function t(t,e){/**
         * Width of framebuffer in pixels
         * @member {number}
         */this.width=Math.ceil(t||100),/**
         * Height of framebuffer in pixels
         * @member {number}
         */this.height=Math.ceil(e||100),this.stencil=!1,this.depth=!1,this.dirtyId=0,this.dirtyFormat=0,this.dirtySize=0,this.depthTexture=null,this.colorTextures=[],this.glFramebuffers={},this.disposeRunner=new gD("disposeFramebuffer"),/**
         * Desired number of samples for antialiasing. 0 means AA should not be used.
         *
         * Experimental WebGL2 feature, allows to use antialiasing in individual renderTextures.
         * Antialiasing is the same as for main buffer with renderer `antialias:true` options.
         * Seriously affects GPU memory consumption and GPU performance.
         *
         *```js
         * renderTexture.framebuffer.multisample = PIXI.MSAA_QUALITY.HIGH;
         * //...
         * renderer.render(renderTexture, myContainer);
         * renderer.framebuffer.blit(); // copies data from MSAA framebuffer to texture
         *  ```
         *
         * @member {PIXI.MSAA_QUALITY}
         * @default PIXI.MSAA_QUALITY.NONE
         */this.multisample=Ev.NONE}return Object.defineProperty(t.prototype,"colorTexture",{/**
         * Reference to the colorTexture.
         *
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */get:function(){return this.colorTextures[0]},enumerable:!1,configurable:!0}),/**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.BaseTexture} [texture] - Texture to add to the array
     */t.prototype.addColorTexture=function(t,e){return void 0===t&&(t=0),// TODO add some validation to the texture - same width / height etc?
this.colorTextures[t]=e||new g5(null,{scaleMode:Ec.NEAREST,resolution:1,mipmap:Ep.OFF,width:this.width,height:this.height}),this.dirtyId++,this.dirtyFormat++,this},/**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.BaseTexture} [texture] - Texture to add
     */t.prototype.addDepthTexture=function(t){return(/* eslint-disable max-len */this.depthTexture=t||new g5(new ys(null,{width:this.width,height:this.height}),{scaleMode:Ec.NEAREST,resolution:1,width:this.width,height:this.height,mipmap:Ep.OFF,format:Eh.DEPTH_COMPONENT,type:Eu.UNSIGNED_SHORT}),this.dirtyId++,this.dirtyFormat++,this)},/**
     * Enable depth on the frame buffer
     */t.prototype.enableDepth=function(){return this.depth=!0,this.dirtyId++,this.dirtyFormat++,this},/**
     * Enable stencil on the frame buffer
     */t.prototype.enableStencil=function(){return this.stencil=!0,this.dirtyId++,this.dirtyFormat++,this},/**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */t.prototype.resize=function(t,e){if(t=Math.ceil(t),e=Math.ceil(e),t!==this.width||e!==this.height){this.width=t,this.height=e,this.dirtyId++,this.dirtySize++;for(var i=0;i<this.colorTextures.length;i++){var r=this.colorTextures[i],n=r.resolution;// take into acount the fact the texture may have a different resolution..
r.setSize(t/n,e/n)}if(this.depthTexture){var n=this.depthTexture.resolution;this.depthTexture.setSize(t/n,e/n)}}},/**
     * Disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys and removes the depth texture added to this framebuffer.
     */t.prototype.destroyDepthTexture=function(){this.depthTexture&&(this.depthTexture.destroy(),this.depthTexture=null,++this.dirtyId,++this.dirtyFormat)},t}(),ya=/** @class */function(t){/**
     * @param {object} [options]
     * @param {number} [options.width=100] - The width of the base render texture.
     * @param {number} [options.height=100] - The height of the base render texture.
     * @param {PIXI.SCALE_MODES} [options.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated.
     */function e(e){var i=this;if("number"==typeof e){/* eslint-disable prefer-rest-params */// Backward compatibility of signature
var r=arguments[0],n=arguments[1],s=arguments[2],o=arguments[3];e={width:r,height:n,scaleMode:s,resolution:o};/* eslint-enable prefer-rest-params */}i=t.call(this,null,e)||this;var a=e||{},h=a.width,l=a.height;return(// Set defaults
i.mipmap=0,i.width=Math.ceil(h)||100,i.height=Math.ceil(l)||100,i.valid=!0,i.clearColor=[0,0,0,0],i.framebuffer=new yo(i.width*i.resolution,i.height*i.resolution).addColorTexture(0,i),// TODO - could this be added the systems?
/**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.MaskData[]}
         */i.maskStack=[],/**
         * The data structure for the filters.
         *
         * @member {Object[]}
         */i.filterStack=[{}],i)}return g0(e,t),/**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */e.prototype.resize=function(t,e){t=Math.ceil(t),e=Math.ceil(e),this.framebuffer.resize(t*this.resolution,e*this.resolution)},/**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */e.prototype.dispose=function(){this.framebuffer.dispose(),t.prototype.dispose.call(this)},/**
     * Destroys this texture.
     */e.prototype.destroy=function(){t.prototype.destroy.call(this),this.framebuffer.destroyDepthTexture(),this.framebuffer=null},e}(g5),yh=/** @class */function(){function t(){/**
         * X-component of top-left corner `(x0,y0)`.
         *
         * @member {number}
         */this.x0=0,/**
         * Y-component of top-left corner `(x0,y0)`.
         *
         * @member {number}
         */this.y0=0,/**
         * X-component of top-right corner `(x1,y1)`.
         *
         * @member {number}
         */this.x1=1,/**
         * Y-component of top-right corner `(x1,y1)`.
         *
         * @member {number}
         */this.y1=0,/**
         * X-component of bottom-right corner `(x2,y2)`.
         *
         * @member {number}
         */this.x2=1,/**
         * Y-component of bottom-right corner `(x2,y2)`.
         *
         * @member {number}
         */this.y2=1,/**
         * X-component of bottom-left corner `(x3,y3)`.
         *
         * @member {number}
         */this.x3=0,/**
         * Y-component of bottom-right corner `(x3,y3)`.
         *
         * @member {number}
         */this.y3=1,this.uvsFloat32=new Float32Array(8)}return(/**
     * Sets the texture Uvs based on the given frame information.
     *
     * @protected
     * @param {PIXI.Rectangle} frame - The frame of the texture
     * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
     * @param {number} rotate - Rotation of frame, see {@link PIXI.groupD8}
     */t.prototype.set=function(t,e,i){var r=e.width,n=e.height;if(i){// width and height div 2 div baseFrame size
var s=t.width/2/r,o=t.height/2/n,a=t.x/r+s,h=t.y/n+o;i=gJ.add(i,gJ.NW),this.x0=a+s*gJ.uX(i),this.y0=h+o*gJ.uY(i),i=gJ.add(i,2),this.x1=a+s*gJ.uX(i),this.y1=h+o*gJ.uY(i),i=gJ.add(i,2),this.x2=a+s*gJ.uX(i),this.y2=h+o*gJ.uY(i),i=gJ.add(i,2),this.x3=a+s*gJ.uX(i),this.y3=h+o*gJ.uY(i)}else this.x0=t.x/r,this.y0=t.y/n,this.x1=(t.x+t.width)/r,this.y1=t.y/n,this.x2=(t.x+t.width)/r,this.y2=(t.y+t.height)/n,this.x3=t.x/r,this.y3=(t.y+t.height)/n;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3},t)}(),yl=new yh,yu=/** @class */function(t){/**
     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     * @param {PIXI.Rectangle} [orig] - The area of original texture
     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}
     * @param {PIXI.IPointData} [anchor] - Default anchor point used for sprite placement / rotation
     */function e(i,r,n,s,o,a){var h=t.call(this)||this;if(/**
         * Does this Texture have any frame data assigned to it?
         *
         * This mode is enabled automatically if no frame was passed inside constructor.
         *
         * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.
         *
         * Beware, after loading or resize of baseTexture event can fired two times!
         * If you want more control, subscribe on baseTexture itself.
         *
         * ```js
         * texture.on('update', () => {});
         * ```
         *
         * Any assignment of `frame` switches off `noFrame` mode.
         *
         * @member {boolean}
         */h.noFrame=!1,r||(h.noFrame=!0,r=new gG(0,0,1,1)),i instanceof e&&(i=i.baseTexture),/**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */h.baseTexture=i,/**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */h._frame=r,/**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */h.trim=s,/**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */h.valid=!1,/**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */h._uvs=yl,/**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */h.uvMatrix=null,/**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */h.orig=n||r,h._rotate=Number(o||0),!0===o)h._rotate=2;else if(h._rotate%2!=0)throw Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");return(/**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */h.defaultAnchor=a?new gk(a.x,a.y):new gk(0,0),/**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */h._updateID=0,/**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */h.textureCacheIds=[],i.valid?h.noFrame?i.valid&&h.onBaseTextureUpdated(i):h.frame=r:i.once("loaded",h.onBaseTextureUpdated,h),h.noFrame&&i.on("update",h.onBaseTextureUpdated,h),h)}return g0(e,t),/**
     * Updates this texture on the gpu.
     *
     * Calls the TextureResource update.
     *
     * If you adjusted `frame` manually, please call `updateUvs()` instead.
     *
     */e.prototype.update=function(){this.baseTexture.resource&&this.baseTexture.resource.update()},/**
     * Called when the base texture is updated
     *
     * @protected
     * @param {PIXI.BaseTexture} baseTexture - The base texture.
     */e.prototype.onBaseTextureUpdated=function(t){if(this.noFrame){if(!this.baseTexture.valid)return;this._frame.width=t.width,this._frame.height=t.height,this.valid=!0,this.updateUvs()}else // if user gave us frame that has bigger size than resized texture it can be a problem
this.frame=this._frame;this.emit("update",this)},/**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
     */e.prototype.destroy=function(t){if(this.baseTexture){if(t){var i=this.baseTexture;i&&i.url&&gO[i.url]&&e.removeFromCache(i.url),this.baseTexture.destroy()}this.baseTexture.off("loaded",this.onBaseTextureUpdated,this),this.baseTexture.off("update",this.onBaseTextureUpdated,this),this.baseTexture=null}this._frame=null,this._uvs=null,this.trim=null,this.orig=null,this.valid=!1,e.removeFromCache(this),this.textureCacheIds=null},/**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */e.prototype.clone=function(){return new e(this.baseTexture,this.frame.clone(),this.orig.clone(),this.trim&&this.trim.clone(),this.rotate,this.defaultAnchor)},/**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */e.prototype.updateUvs=function(){this._uvs===yl&&(this._uvs=new yh),this._uvs.set(this._frame,this.baseTexture,this.rotate),this._updateID++},/**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
     * @return {PIXI.Texture} The newly created texture
     */e.from=function(t,i,r){void 0===i&&(i={}),void 0===r&&(r=gf.STRICT_TEXTURE_CACHE);var n="string"==typeof t,s=null;n?s=t:(t._pixiId||(t._pixiId="pixiid_"+ ++gR),s=t._pixiId);var o=gO[s];// Strict-mode rejects invalid cacheIds
if(n&&r&&!o)throw Error('The cacheId "'+s+'" does not exist in TextureCache.');// lets assume its a base texture!
return o||(i.resolution||(i.resolution=gN(t)),(o=new e(new g5(t,i))).baseTexture.cacheId=s,g5.addToCache(o.baseTexture,s),e.addToCache(o,s)),o},/**
     * Useful for loading textures via URLs. Use instead of `Texture.from` because
     * it does a better job of handling failed URLs more effectively. This also ignores
     * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.
     * @param {string} url The remote URL to load.
     * @param {object} [options] Optional options to include
     * @return {Promise<PIXI.Texture>} A Promise that resolves to a Texture.
     */e.fromURL=function(t,i){var r=Object.assign({autoLoad:!1},null==i?void 0:i.resourceOptions),n=e.from(t,Object.assign({resourceOptions:r},i),!1),s=n.baseTexture.resource;return(// The texture was already loaded
n.baseTexture.valid?Promise.resolve(n):s.load().then(function(){return Promise.resolve(n)}))},/**
     * Create a new Texture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The resulting new BaseTexture
     */e.fromBuffer=function(t,i,r,n){return new e(g5.fromBuffer(t,i,r,n))},/**
     * Create a texture from a source and add to the cache.
     *
     * @static
     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
     * @param {String} [name] - Human readable name for the texture cache. If no name is
     *        specified, only `imageUrl` will be used as the cache ID.
     * @return {PIXI.Texture} Output texture
     */e.fromLoader=function(t,i,r){var n=new yt(t);n.url=i;var s=new g5(n,{scaleMode:gf.SCALE_MODE,resolution:gN(i)}),o=new e(s);return r||(r=i),// lets also add the frame to pixi's global cache for 'fromLoader' function
g5.addToCache(o.baseTexture,r),e.addToCache(o,r),r!==i&&(g5.addToCache(o.baseTexture,i),e.addToCache(o,i)),o},/**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */e.addToCache=function(t,e){e&&(-1===t.textureCacheIds.indexOf(e)&&t.textureCacheIds.push(e),gO[e]&&console.warn("Texture added to the cache with an id ["+e+"] that already had an entry"),gO[e]=t)},/**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */e.removeFromCache=function(t){if("string"==typeof t){var e=gO[t];if(e){var i=e.textureCacheIds.indexOf(t);return i>-1&&e.textureCacheIds.splice(i,1),delete gO[t],e}}else if(t&&t.textureCacheIds){for(var r=0;r<t.textureCacheIds.length;++r)gO[t.textureCacheIds[r]]===t&&delete gO[t.textureCacheIds[r]];return t.textureCacheIds.length=0,t}return null},Object.defineProperty(e.prototype,"resolution",{/**
         * Returns resolution of baseTexture
         *
         * @member {number}
         * @readonly
         */get:function(){return this.baseTexture.resolution},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"frame",{/**
         * The frame specifies the region of the base texture that this texture uses.
         * Please call `updateUvs()` after you change coordinates of `frame` manually.
         *
         * @member {PIXI.Rectangle}
         */get:function(){return this._frame},set:function(t){this._frame=t,this.noFrame=!1;var e=t.x,i=t.y,r=t.width,n=t.height,s=e+r>this.baseTexture.width,o=i+n>this.baseTexture.height;if(s||o)throw Error("Texture Error: frame does not fit inside the base Texture dimensions: "+("X: "+e+" + "+r+" = "+(e+r)+" > "+this.baseTexture.width+" ")+(s&&o?"and":"or")+" "+("Y: "+i+" + "+n+" = "+(i+n))+" > "+this.baseTexture.height);this.valid=r&&n&&this.baseTexture.valid,this.trim||this.rotate||(this.orig=t),this.valid&&this.updateUvs()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"rotate",{/**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.groupD8} for explanation
         *
         * @member {number}
         */get:function(){return this._rotate},set:function(t){this._rotate=t,this.valid&&this.updateUvs()},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"width",{/**
         * The width of the Texture in pixels.
         *
         * @member {number}
         */get:function(){return this.orig.width},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * The height of the Texture in pixels.
         *
         * @member {number}
         */get:function(){return this.orig.height},enumerable:!1,configurable:!0}),/**
     * Utility function for BaseTexture|Texture cast
     */e.prototype.castToBaseTexture=function(){return this.baseTexture},e}(/*@__PURE__*/tP(gm));function yc(t){t.destroy=function(){},t.on=function(){},t.once=function(){},t.emit=function(){}}/**
 * An empty texture, used often to not have to create multiple empty textures.
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */yu.EMPTY=new yu(new g5),yc(yu.EMPTY),yc(yu.EMPTY.baseTexture),/**
 * A white texture of 16x16 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */yu.WHITE=((xT=document.createElement("canvas")).width=16,xT.height=16,(xw=xT.getContext("2d")).fillStyle="white",xw.fillRect(0,0,16,16),new yu(new g5(new g7(xT)))),yc(yu.WHITE),yc(yu.WHITE.baseTexture);/**
 * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * __Hint-2__: The actual memory allocation will happen on first render.
 * You shouldn't create renderTextures each frame just to delete them after, try to reuse them.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
 *
 * ```js
 * let renderer = PIXI.autoDetectRenderer();
 * let renderTexture = PIXI.RenderTexture.create({ width: 800, height: 600 });
 * let sprite = PIXI.Sprite.from("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderer.render(sprite, renderTexture);
 * ```
 *
 * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
 * you can clear the transform
 *
 * ```js
 *
 * sprite.setTransform()
 *
 * let renderTexture = new PIXI.RenderTexture.create(100, 100);
 *
 * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
 * ```
 *
 * @class
 * @extends PIXI.Texture
 * @memberof PIXI
 */var yd=/** @class */function(t){/**
     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The base texture object that this texture uses
     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
     */function e(e,i){var r=this,n=null;if(!(e instanceof ya)){/* eslint-disable prefer-rest-params, no-console */var s=arguments[1],o=arguments[2],a=arguments[3],h=arguments[4];// we have an old render texture..
console.warn("Please use RenderTexture.create("+s+", "+o+") instead of the ctor directly."),n=arguments[0],/* eslint-enable prefer-rest-params, no-console */i=null,e=new ya({width:s,height:o,scaleMode:a,resolution:h})}return(/**
         * The base texture object that this texture uses
         *
         * @member {PIXI.BaseTexture}
         */(r=t.call(this,e,i)||this).legacyRenderer=n,/**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */r.valid=!0,/**
         * Stores `sourceFrame` when this texture is inside current filter stack.
         * You can read it inside filters.
         *
         * @readonly
         * @member {PIXI.Rectangle}
         */r.filterFrame=null,/**
         * The key for pooled texture of FilterSystem
         * @protected
         * @member {string}
         */r.filterPoolKey=null,r.updateUvs(),r)}return g0(e,t),Object.defineProperty(e.prototype,"framebuffer",{/**
         * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
         * @member {PIXI.Framebuffer}
         * @readonly
         */get:function(){return this.baseTexture.framebuffer},enumerable:!1,configurable:!0}),/**
     * Resizes the RenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
     */e.prototype.resize=function(t,e,i){void 0===i&&(i=!0),t=Math.ceil(t),e=Math.ceil(e),// TODO - could be not required..
this.valid=t>0&&e>0,this._frame.width=this.orig.width=t,this._frame.height=this.orig.height=e,i&&this.baseTexture.resize(t,e),this.updateUvs()},/**
     * Changes the resolution of baseTexture, but does not change framebuffer size.
     *
     * @param {number} resolution - The new resolution to apply to RenderTexture
     */e.prototype.setResolution=function(t){var e=this.baseTexture;e.resolution!==t&&(e.setResolution(t),this.resize(e.width,e.height,!1))},/**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */e.create=function(t){return"number"==typeof t&&/* eslint-disable prefer-rest-params */(t={width:t,height:arguments[1],scaleMode:arguments[2],resolution:arguments[3]}),new e(new ya(t))},e}(yu),yp=/** @class */function(){/**
     * @param {object} [textureOptions] - options that will be passed to BaseRenderTexture constructor
     * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
     */function t(t){this.texturePool={},this.textureOptions=t||{},/**
         * Allow renderTextures of the same size as screen, not just pow2
         *
         * Automatically sets to true after `setScreenSize`
         *
         * @member {boolean}
         * @default false
         */this.enableFullScreen=!1,this._pixelsWidth=0,this._pixelsHeight=0}return(/**
     * creates of texture with params that were specified in pool constructor
     *
     * @param {number} realWidth - width of texture in pixels
     * @param {number} realHeight - height of texture in pixels
     * @returns {RenderTexture}
     */t.prototype.createTexture=function(t,e){var i=new ya(Object.assign({width:t,height:e,resolution:1},this.textureOptions));return new yd(i)},/**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */t.prototype.getOptimalTexture=function(e,i,r){void 0===r&&(r=1);var n=t.SCREEN_KEY;e*=r,i*=r,this.enableFullScreen&&e===this._pixelsWidth&&i===this._pixelsHeight||(n=(65535&(e=gM(e)))<<16|65535&(i=gM(i))),this.texturePool[n]||(this.texturePool[n]=[]);var s=this.texturePool[n].pop();return s||(s=this.createTexture(e,i)),s.filterPoolKey=n,s.setResolution(r),s},/**
     * Gets extra texture of the same size as input renderTexture
     *
     * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
     *
     * @param {PIXI.RenderTexture} input - renderTexture from which size and resolution will be copied
     * @param {number} [resolution] - override resolution of the renderTexture
     *  It overrides, it does not multiply
     * @returns {PIXI.RenderTexture}
     */t.prototype.getFilterTexture=function(t,e){var i=this.getOptimalTexture(t.width,t.height,e||t.resolution);return i.filterFrame=t.filterFrame,i},/**
     * Place a render texture back into the pool.
     * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
     */t.prototype.returnTexture=function(t){var e=t.filterPoolKey;t.filterFrame=null,this.texturePool[e].push(t)},/**
     * Alias for returnTexture, to be compliant with FilterSystem interface
     * @param {PIXI.RenderTexture} renderTexture - The renderTexture to free
     */t.prototype.returnFilterTexture=function(t){this.returnTexture(t)},/**
     * Clears the pool
     *
     * @param {boolean} [destroyTextures=true] - destroy all stored textures
     */t.prototype.clear=function(t){if(t=!1!==t)for(var e in this.texturePool){var i=this.texturePool[e];if(i)for(var r=0;r<i.length;r++)i[r].destroy(!0)}this.texturePool={}},/**
     * If screen size was changed, drops all screen-sized textures,
     * sets new screen size, sets `enableFullScreen` to true
     *
     * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
     *
     * @param {PIXI.ISize} size - Initial size of screen
     */t.prototype.setScreenSize=function(e){if(e.width!==this._pixelsWidth||e.height!==this._pixelsHeight){var i=t.SCREEN_KEY,r=this.texturePool[i];if(this.enableFullScreen=e.width>0&&e.height>0,r)for(var n=0;n<r.length;n++)r[n].destroy(!0);this.texturePool[i]=[],this._pixelsWidth=e.width,this._pixelsHeight=e.height}},/**
     * Key that is used to store fullscreen renderTextures in a pool
     *
     * @static
     * @const {string}
     */t.SCREEN_KEY="screen",t)}(),yf=/** @class */function(){/**
     * @param {string} buffer - the id of the buffer that this attribute will look for
     * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.
     * @param {Boolean} [normalized=false] - should the data be normalized.
     * @param {Number} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
     * @param {Number} [stride=0] - How far apart (in floats) the start of each value is. (used for interleaving data)
     * @param {Number} [start=0] - How far into the array to start reading values (used for interleaving data)
     */function t(t,e,i,r,n,s,o){void 0===e&&(e=0),void 0===i&&(i=!1),void 0===r&&(r=5126),this.buffer=t,this.size=e,this.normalized=i,this.type=r,this.stride=n,this.start=s,this.instance=o}return(/**
     * Destroys the Attribute.
     */t.prototype.destroy=function(){this.buffer=null},/**
     * Helper function that creates an Attribute based on the information provided
     *
     * @static
     * @param {string} buffer - the id of the buffer that this attribute will look for
     * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
     * @param {Boolean} [normalized=false] - should the data be normalized.
     * @param {Number} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
     * @param {Number} [stride=0] - How far apart (in floats) the start of each value is. (used for interleaving data)
     *
     * @returns {PIXI.Attribute} A new {@link PIXI.Attribute} based on the information provided
     */t.from=function(e,i,r,n,s){return new t(e,i,r,n,s)},t)}(),ym=0,yg=/** @class */function(){/**
     * @param {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} data - the data to store in the buffer.
     * @param {boolean} [_static=true] - `true` for static buffer
     * @param {boolean} [index=false] - `true` for index buffer
     */function t(t,e,i){void 0===e&&(e=!0),void 0===i&&(i=!1),/**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer | ArrayBufferView}
         */this.data=t||new Float32Array(1),/**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */this._glBuffers={},this._updateID=0,this.index=i,this.static=e,this.id=ym++,this.disposeRunner=new gD("disposeBuffer")}return(// TODO could explore flagging only a partial upload?
/**
     * flags this buffer as requiring an upload to the GPU
     * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView} [data] - the data to update in the buffer.
     */t.prototype.update=function(t){this.data=t||this.data,this._updateID++},/**
     * disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys the buffer
     */t.prototype.destroy=function(){this.dispose(),this.data=null},/**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */t.from=function(e){return e instanceof Array&&(e=new Float32Array(e)),new t(e)},t)}();function yy(t){if(4===t.BYTES_PER_ELEMENT)return t instanceof Float32Array?"Float32Array":t instanceof Uint32Array?"Uint32Array":"Int32Array";if(2===t.BYTES_PER_ELEMENT){if(t instanceof Uint16Array)return"Uint16Array"}else if(1===t.BYTES_PER_ELEMENT&&t instanceof Uint8Array)return"Uint8Array";// TODO map out the rest of the array elements!
return null}/* eslint-disable object-shorthand */var y_={Float32Array:Float32Array,Uint32Array:Uint32Array,Int32Array:Int32Array,Uint8Array:Uint8Array},yv={5126:4,5123:2,5121:1},yx=0,yb={Float32Array:Float32Array,Uint32Array:Uint32Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array},yE=/** @class */function(){/**
     * @param {PIXI.Buffer[]} [buffers] - an array of buffers. optional.
     * @param {object} [attributes] - of the geometry, optional structure of the attributes layout
     */function t(t,e){void 0===t&&(t=[]),void 0===e&&(e={}),this.buffers=t,this.indexBuffer=null,this.attributes=e,/**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */this.glVertexArrayObjects={},this.id=yx++,this.instanced=!1,/**
         * Number of instances in this geometry, pass it to `GeometrySystem.draw()`
         * @member {number}
         * @default 1
         */this.instanceCount=1,this.disposeRunner=new gD("disposeGeometry"),/**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {number}
         */this.refCount=0}return(/**
    *
    * Adds an attribute to the geometry
    * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer|number[]} [buffer] - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] - should the data be normalized.
    * @param {Number} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride] - How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start] - How far into the array to start reading values (used for interleaving data)
    * @param {boolean} [instance=false] - Instancing flag
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */t.prototype.addAttribute=function(t,e,i,r,n,s,o,a){if(void 0===i&&(i=0),void 0===r&&(r=!1),void 0===a&&(a=!1),!e)throw Error("You must pass a buffer when creating an attribute");e instanceof yg||(e instanceof Array&&(e=new Float32Array(e)),e=new yg(e));var h=t.split("|");if(h.length>1){for(var l=0;l<h.length;l++)this.addAttribute(h[l],e,i,r,n);return this}var u=this.buffers.indexOf(e);return -1===u&&(this.buffers.push(e),u=this.buffers.length-1),this.attributes[t]=new yf(u,i,r,n,s,o,a),// assuming that if there is instanced data then this will be drawn with instancing!
this.instanced=this.instanced||a,this},/**
     * returns the requested attribute
     *
     * @param {String} id - the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */t.prototype.getAttribute=function(t){return this.attributes[t]},/**
     * returns the requested buffer
     *
     * @param {String} id - the name of the buffer required
     * @return {PIXI.Buffer} the buffer requested.
     */t.prototype.getBuffer=function(t){return this.buffers[this.getAttribute(t).buffer]},/**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, ). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer|number[]} [buffer] - the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */t.prototype.addIndex=function(t){return t instanceof yg||(t instanceof Array&&(t=new Uint16Array(t)),t=new yg(t)),t.index=!0,this.indexBuffer=t,-1===this.buffers.indexOf(t)&&this.buffers.push(t),this},/**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */t.prototype.getIndex=function(){return this.indexBuffer},/**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */t.prototype.interleave=function(){// a simple check to see if buffers are already interleaved..
if(1===this.buffers.length||2===this.buffers.length&&this.indexBuffer)return this;// assume already that no buffers are interleaved
var t,e=[],i=[],r=new yg;for(t in this.attributes){var n=this.attributes[t],s=this.buffers[n.buffer];e.push(s.data),i.push(n.size*yv[n.type]/4),n.buffer=0}for(t=0,r.data=function(t,e){for(var i=0,r=0,n={},s=0;s<t.length;s++)r+=e[s],i+=t[s].length;for(var o=new ArrayBuffer(4*i),a=null,h=0,s=0;s<t.length;s++){var l=e[s],u=t[s],c=yy(u);n[c]||(n[c]=new y_[c](o)),a=n[c];for(var d=0;d<u.length;d++)a[(d/l|0)*r+h+d%l]=u[d];h+=l}return new Float32Array(o)}(e,i);t<this.buffers.length;t++)this.buffers[t]!==this.indexBuffer&&this.buffers[t].destroy();return this.buffers=[r],this.indexBuffer&&this.buffers.push(this.indexBuffer),this},t.prototype.getSize=function(){for(var t in this.attributes){var e=this.attributes[t];return this.buffers[e.buffer].data.length/(e.stride/4||e.size)}return 0},/**
     * disposes WebGL resources that are connected to this geometry
     */t.prototype.dispose=function(){this.disposeRunner.emit(this,!1)},/**
     * Destroys the geometry.
     */t.prototype.destroy=function(){this.dispose(),this.buffers=null,this.indexBuffer=null,this.attributes=null},/**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */t.prototype.clone=function(){for(var e=new t,i=0;i<this.buffers.length;i++)e.buffers[i]=new yg(this.buffers[i].data.slice(0));for(var i in this.attributes){var r=this.attributes[i];e.attributes[i]=new yf(r.buffer,r.size,r.normalized,r.type,r.stride,r.start,r.instance)}return this.indexBuffer&&(e.indexBuffer=e.buffers[this.buffers.indexOf(this.indexBuffer)],e.indexBuffer.index=!0),e},/**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries - array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */t.merge=function(e){// pass one.. get sizes..
for(var i,r=new t,n=[],s=[],o=[],a=0;a<e.length;a++){i=e[a];for(var h=0;h<i.buffers.length;h++)s[h]=s[h]||0,s[h]+=i.buffers[h].data.length,o[h]=0}// build the correct size arrays..
for(var a=0;a<i.buffers.length;a++)// TODO types!
n[a]=new yb[yy(i.buffers[a].data)](s[a]),r.buffers[a]=new yg(n[a]);// pass to set data..
for(var a=0;a<e.length;a++){i=e[a];for(var h=0;h<i.buffers.length;h++)n[h].set(i.buffers[h].data,o[h]),o[h]+=i.buffers[h].data.length}if(r.attributes=i.attributes,i.indexBuffer){r.indexBuffer=r.buffers[i.buffers.indexOf(i.indexBuffer)],r.indexBuffer.index=!0;// get a buffer
for(var l=0,u=0,c=0,d=0,a=0;a<i.buffers.length;a++)if(i.buffers[a]!==i.indexBuffer){d=a;break}// figure out the stride of one buffer..
for(var a in i.attributes){var p=i.attributes[a];(0|p.buffer)===d&&(u+=p.size*yv[p.type]/4)}// time to off set all indexes..
for(var a=0;a<e.length;a++){for(var f=e[a].indexBuffer.data,h=0;h<f.length;h++)r.indexBuffer.data[h+c]+=l;l+=i.buffers[d].data.length/u,c+=f.length}}return r},t)}(),yT=/** @class */function(t){function e(){var e=t.call(this)||this;return e.addAttribute("aVertexPosition",new Float32Array([0,0,1,0,1,1,0,1])).addIndex([0,1,3,2]),e}return g0(e,t),e}(yE),yw=/** @class */function(t){function e(){var e=t.call(this)||this;return(/**
         * An array of vertices
         *
         * @member {Float32Array}
         */e.vertices=new Float32Array([-1,-1,1,-1,1,1,-1,1]),/**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */e.uvs=new Float32Array([0,0,1,0,1,1,0,1]),e.vertexBuffer=new yg(e.vertices),e.uvBuffer=new yg(e.uvs),e.addAttribute("aVertexPosition",e.vertexBuffer).addAttribute("aTextureCoord",e.uvBuffer).addIndex([0,1,2,0,2,3]),e)}return g0(e,t),/**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */e.prototype.map=function(t,e){var i=0,r=0;// destinationFrame.x / targetTextureFrame.width;
return this.uvs[0]=i,this.uvs[1]=r,this.uvs[2]=i+e.width/t.width,this.uvs[3]=r,this.uvs[4]=i+e.width/t.width,this.uvs[5]=r+e.height/t.height,this.uvs[6]=i,this.uvs[7]=r+e.height/t.height,i=e.x,r=e.y,this.vertices[0]=i,this.vertices[1]=r,this.vertices[2]=i+e.width,this.vertices[3]=r,this.vertices[4]=i+e.width,this.vertices[5]=r+e.height,this.vertices[6]=i,this.vertices[7]=r+e.height,this.invalidate(),this},/**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */e.prototype.invalidate=function(){return this.vertexBuffer._updateID++,this.uvBuffer._updateID++,this},e}(yE),yS=0,yM=/** @class */function(){/**
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     * @param {boolean} [_static] - Uniforms wont be changed after creation
     */function t(t,e){/**
         * uniform values
         * @member {object}
         * @readonly
         */this.uniforms=t,/**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */this.group=!0,// lets generate this when the shader ?
this.syncUniforms={},/**
         * dirty version
         * @protected
         * @member {number}
         */this.dirtyId=0,/**
         * unique id
         * @protected
         * @member {number}
         */this.id=yS++,/**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */this.static=!!e}return t.prototype.update=function(){this.dirtyId++},t.prototype.add=function(e,i,r){this.uniforms[e]=new t(i,r)},t.from=function(e,i){return new t(e,i)},t}(),yA=/** @class */function(){function t(){this.renderTexture=null,/**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */this.target=null,/**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */this.legacy=!1,/**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */this.resolution=1,// next three fields are created only for root
// re-assigned for everything else
/**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */this.sourceFrame=new gG,/**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */this.destinationFrame=new gG,/**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */this.filters=[]}return(/**
     * clears the state
     * @private
     */t.prototype.clear=function(){this.target=null,this.filters=null,this.renderTexture=null},t)}(),yR=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */i.defaultFilterStack=[{}],/**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */i.texturePool=new yp,i.texturePool.setScreenSize(e.view),/**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */i.statePool=[],/**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */i.quad=new yT,/**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */i.quadUv=new yw,/**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */i.tempRect=new gG,/**
         * Active state
         * @member {object}
         */i.activeState={},/**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */i.globalUniforms=new yM({outputFrame:i.tempRect,inputSize:new Float32Array(4),inputPixel:new Float32Array(4),inputClamp:new Float32Array(4),resolution:1,// legacy variables
filterArea:new Float32Array(4),filterClamp:new Float32Array(4)},!0),/**
         * Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}
         * @member {boolean}
         */i.forceClear=!1,/**
         * Old padding behavior is to use the max amount instead of sum padding.
         * Use this flag if you need the old behavior.
         * @member {boolean}
         * @default false
         */i.useMaxPadding=!1,i)}return g0(e,t),/**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */e.prototype.push=function(t,e){for(var i=this.renderer,r=this.defaultFilterStack,n=this.statePool.pop()||new yA,s=e[0].resolution,o=e[0].padding,a=e[0].autoFit,h=e[0].legacy,l=1;l<e.length;l++){var u=e[l];// lets use the lowest resolution..
s=Math.min(s,u.resolution),// figure out the padding required for filters
o=this.useMaxPadding?Math.max(o,u.padding):o+u.padding,// only auto fit if all filters are autofit
a=a&&u.autoFit,h=h||u.legacy}1===r.length&&(this.defaultFilterStack[0].renderTexture=i.renderTexture.current),r.push(n),n.resolution=s,n.legacy=h,n.target=t,n.sourceFrame.copyFrom(t.filterArea||t.getBounds(!0)),n.sourceFrame.pad(o),a&&n.sourceFrame.fit(this.renderer.renderTexture.sourceFrame),// round to whole number based on resolution
n.sourceFrame.ceil(s),n.renderTexture=this.getOptimalFilterTexture(n.sourceFrame.width,n.sourceFrame.height,s),n.filters=e,n.destinationFrame.width=n.renderTexture.width,n.destinationFrame.height=n.renderTexture.height;var c=this.tempRect;c.width=n.sourceFrame.width,c.height=n.sourceFrame.height,n.renderTexture.filterFrame=n.sourceFrame,i.renderTexture.bind(n.renderTexture,n.sourceFrame,c),i.renderTexture.clear()},/**
     * Pops off the filter and applies it.
     *
     */e.prototype.pop=function(){var t=this.defaultFilterStack,e=t.pop(),i=e.filters;this.activeState=e;var r=this.globalUniforms.uniforms;r.outputFrame=e.sourceFrame,r.resolution=e.resolution;var n=r.inputSize,s=r.inputPixel,o=r.inputClamp;// only update the rect if its legacy..
if(n[0]=e.destinationFrame.width,n[1]=e.destinationFrame.height,n[2]=1/n[0],n[3]=1/n[1],s[0]=n[0]*e.resolution,s[1]=n[1]*e.resolution,s[2]=1/s[0],s[3]=1/s[1],o[0]=.5*s[2],o[1]=.5*s[3],o[2]=e.sourceFrame.width*n[2]-.5*s[2],o[3]=e.sourceFrame.height*n[3]-.5*s[3],e.legacy){var a=r.filterArea;a[0]=e.destinationFrame.width,a[1]=e.destinationFrame.height,a[2]=e.sourceFrame.x,a[3]=e.sourceFrame.y,r.filterClamp=r.inputClamp}this.globalUniforms.update();var h=t[t.length-1];if(e.renderTexture.framebuffer.multisample>1&&this.renderer.framebuffer.blit(),1===i.length)i[0].apply(this,e.renderTexture,h.renderTexture,Em.BLEND,e),this.returnFilterTexture(e.renderTexture);else{var l=e.renderTexture,u=this.getOptimalFilterTexture(l.width,l.height,e.resolution);u.filterFrame=l.filterFrame;var c=0;for(c=0;c<i.length-1;++c){i[c].apply(this,l,u,Em.CLEAR,e);var d=l;l=u,u=d}i[c].apply(this,l,h.renderTexture,Em.BLEND,e),this.returnFilterTexture(l),this.returnFilterTexture(u)}e.clear(),this.statePool.push(e)},/**
     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.
     * @param {PIXI.RenderTexture} filterTexture - renderTexture to bind, should belong to filter pool or filter stack
     * @param {PIXI.CLEAR_MODES} [clearMode] - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}
     */e.prototype.bindAndClear=function(t,e){if(void 0===e&&(e=Em.CLEAR),t&&t.filterFrame){var i=this.tempRect;i.width=t.filterFrame.width,i.height=t.filterFrame.height,this.renderer.renderTexture.bind(t,t.filterFrame,i)}else this.renderer.renderTexture.bind(t);"boolean"==typeof e&&(e=e?Em.CLEAR:Em.BLEND,gP("5.2.1","Use CLEAR_MODES when using clear applyFilter option")),(e===Em.CLEAR||e===Em.BLIT&&this.forceClear)&&this.renderer.renderTexture.clear()},/**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it
     */e.prototype.applyFilter=function(t,e,i,r){var n=this.renderer;this.bindAndClear(i,r),// set the uniforms..
t.uniforms.uSampler=e,t.uniforms.filterGlobals=this.globalUniforms,// TODO make it so that the order of this does not matter..
// because it does at the moment cos of global uniforms.
// they need to get resynced
n.state.set(t.state),n.shader.bind(t),t.legacy?(this.quadUv.map(e._frame,e.filterFrame),n.geometry.bind(this.quadUv),n.geometry.draw(Ea.TRIANGLES)):(n.geometry.bind(this.quad),n.geometry.draw(Ea.TRIANGLE_STRIP))},/**
     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
     *
     * Use `outputMatrix * vTextureCoord` in the shader.
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */e.prototype.calculateSpriteMatrix=function(t,e){var i=this.activeState,r=i.sourceFrame,n=i.destinationFrame,s=e._texture.orig,o=t.set(n.width,0,0,n.height,r.x,r.y),a=e.worldTransform.copyTo(gz.TEMP_MATRIX);return a.invert(),o.prepend(a),o.scale(1/s.width,1/s.height),o.translate(e.anchor.x,e.anchor.y),o},/**
     * Destroys this Filter System.
     */e.prototype.destroy=function(){// Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem
this.texturePool.clear(!1)},/**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */e.prototype.getOptimalFilterTexture=function(t,e,i){return void 0===i&&(i=1),this.texturePool.getOptimalTexture(t,e,i)},/**
     * Gets extra render texture to use inside current filter
     * To be compliant with older filters, you can use params in any order
     *
     * @param {PIXI.RenderTexture} [input] - renderTexture from which size and resolution will be copied
     * @param {number} [resolution] - override resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */e.prototype.getFilterTexture=function(t,e){if("number"==typeof t){var i=t;t=e,e=i}t=t||this.activeState.renderTexture;var r=this.texturePool.getOptimalTexture(t.width,t.height,e||t.resolution);return r.filterFrame=t.filterFrame,r},/**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */e.prototype.returnFilterTexture=function(t){this.texturePool.returnTexture(t)},/**
     * Empties the texture pool.
     */e.prototype.emptyPool=function(){this.texturePool.clear(!0)},/**
     * calls `texturePool.resize()`, affects fullScreen renderTextures
     */e.prototype.resize=function(){this.texturePool.setScreenSize(this.renderer.view)},e}(yn),yC=/** @class */function(){/**
     * @param {PIXI.Renderer} renderer - The renderer this manager works for.
     */function t(t){/**
         * The renderer this manager works for.
         *
         * @member {PIXI.Renderer}
         */this.renderer=t}return(/**
     * Stub method that should be used to empty the current
     * batch by rendering objects now.
     */t.prototype.flush=function(){// flush!
},/**
     * Generic destruction method that frees all resources. This
     * should be called by subclasses.
     */t.prototype.destroy=function(){this.renderer=null},/**
     * Stub method that initializes any state required before
     * rendering starts. It is different from the `prerender`
     * signal, which occurs every frame, in that it is called
     * whenever an object requests _this_ renderer specifically.
     */t.prototype.start=function(){// set the shader..
},/**
     * Stops the renderer. It should free up any state and
     * become dormant.
     */t.prototype.stop=function(){this.flush()},/**
     * Keeps the object to render. It doesn't have to be
     * rendered immediately.
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */t.prototype.render=function(t){// render the object
},t)}(),yP=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */i.emptyRenderer=new yC(e),/**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */i.currentRenderer=i.emptyRenderer,i)}return g0(e,t),/**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */e.prototype.setObjectRenderer=function(t){this.currentRenderer!==t&&(this.currentRenderer.stop(),this.currentRenderer=t,this.currentRenderer.start())},/**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */e.prototype.flush=function(){this.setObjectRenderer(this.emptyRenderer)},/**
     * Reset the system to an empty renderer
     */e.prototype.reset=function(){this.setObjectRenderer(this.emptyRenderer)},/**
     * Handy function for batch renderers: copies bound textures in first maxTextures locations to array
     * sets actual _batchLocation for them
     *
     * @param {PIXI.BaseTexture[]} - arr copy destination
     * @param {number} maxTextures - number of copied elements
     */e.prototype.copyBoundTextures=function(t,e){for(var i=this.renderer.texture.boundTextures,r=e-1;r>=0;--r)t[r]=i[r]||null,t[r]&&(t[r]._batchLocation=r)},/**
     * Assigns batch locations to textures in array based on boundTextures state.
     * All textures in texArray should have `_batchEnabled = _batchId`,
     * and their count should be less than `maxTextures`.
     *
     * @param {PIXI.BatchTextureArray} texArray - textures to bound
     * @param {PIXI.BaseTexture[]} boundTextures - current state of bound textures
     * @param {number} batchId - marker for _batchEnabled param of textures in texArray
     * @param {number} maxTextures - number of texture locations to manipulate
     */e.prototype.boundArray=function(t,e,i,r){for(var n=t.elements,s=t.ids,o=t.count,a=0,h=0;h<o;h++){var l=n[h],u=l._batchLocation;if(u>=0&&u<r&&e[u]===l){s[h]=u;continue}for(;a<r;){var c=e[a];if(c&&c._batchEnabled===i&&c._batchLocation===a){a++;continue}s[h]=a,l._batchLocation=a,e[a]=l;break}}},e}(yn),yI=0,yO=/** @class */function(t){/* eslint-enable camelcase *//**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */i.webGLVersion=1,/**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension
         */i.extensions={},/**
         * Features supported by current context
         * @member {object}
         * @private
         * @readonly
         * @property {boolean} uint32Indices - Supports of 32-bit indices buffer
         */i.supports={uint32Indices:!1},// Bind functions
i.handleContextLost=i.handleContextLost.bind(i),i.handleContextRestored=i.handleContextRestored.bind(i),e.view.addEventListener("webglcontextlost",i.handleContextLost,!1),e.view.addEventListener("webglcontextrestored",i.handleContextRestored,!1),i)}return g0(e,t),Object.defineProperty(e.prototype,"isLost",{/**
         * `true` if the context is lost
         * @member {boolean}
         * @readonly
         */get:function(){return!this.gl||this.gl.isContextLost()},enumerable:!1,configurable:!0}),/**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl - new webgl context
     */e.prototype.contextChange=function(t){this.gl=t,this.renderer.gl=t,this.renderer.CONTEXT_UID=yI++,t.isContextLost()&&t.getExtension("WEBGL_lose_context")&&t.getExtension("WEBGL_lose_context").restoreContext()},/**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */e.prototype.initFromContext=function(t){this.gl=t,this.validateContext(t),this.renderer.gl=t,this.renderer.CONTEXT_UID=yI++,this.renderer.runners.contextChange.emit(t)},/**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */e.prototype.initFromOptions=function(t){var e=this.createContext(this.renderer.view,t);this.initFromContext(e)},/**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */e.prototype.createContext=function(t,e){var i;if(gf.PREFER_ENV>=Er.WEBGL2&&(i=t.getContext("webgl2",e)),i)this.webGLVersion=2;else if(this.webGLVersion=1,!(i=t.getContext("webgl",e)||t.getContext("experimental-webgl",e)))throw Error("This browser does not support WebGL. Try using the canvas renderer");return this.gl=i,this.getExtensions(),this.gl},/**
     * Auto-populate the extensions
     *
     * @protected
     */e.prototype.getExtensions=function(){// time to set up default extensions that Pixi uses.
var t=this.gl;1===this.webGLVersion?Object.assign(this.extensions,{drawBuffers:t.getExtension("WEBGL_draw_buffers"),depthTexture:t.getExtension("WEBGL_depth_texture"),loseContext:t.getExtension("WEBGL_lose_context"),vertexArrayObject:t.getExtension("OES_vertex_array_object")||t.getExtension("MOZ_OES_vertex_array_object")||t.getExtension("WEBKIT_OES_vertex_array_object"),anisotropicFiltering:t.getExtension("EXT_texture_filter_anisotropic"),uint32ElementIndex:t.getExtension("OES_element_index_uint"),// Floats and half-floats
floatTexture:t.getExtension("OES_texture_float"),floatTextureLinear:t.getExtension("OES_texture_float_linear"),textureHalfFloat:t.getExtension("OES_texture_half_float"),textureHalfFloatLinear:t.getExtension("OES_texture_half_float_linear")}):2===this.webGLVersion&&Object.assign(this.extensions,{anisotropicFiltering:t.getExtension("EXT_texture_filter_anisotropic"),// Floats and half-floats
colorBufferFloat:t.getExtension("EXT_color_buffer_float"),floatTextureLinear:t.getExtension("OES_texture_float_linear")})},/**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */e.prototype.handleContextLost=function(t){t.preventDefault()},/**
     * Handles a restored webgl context
     *
     * @protected
     */e.prototype.handleContextRestored=function(){this.renderer.runners.contextChange.emit(this.gl)},e.prototype.destroy=function(){var t=this.renderer.view;// remove listeners
t.removeEventListener("webglcontextlost",this.handleContextLost),t.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()},/**
     * Handle the post-render runner event
     *
     * @protected
     */e.prototype.postrender=function(){this.renderer.renderingToScreen&&this.gl.flush()},/**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */e.prototype.validateContext=function(t){var e=t.getContextAttributes(),i="WebGL2RenderingContext"in window&&t instanceof window.WebGL2RenderingContext;i&&(this.webGLVersion=2),e.stencil||/* eslint-disable max-len, no-console */console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");var r=i||!!t.getExtension("OES_element_index_uint");this.supports.uint32Indices=r,r||/* eslint-disable max-len, no-console */console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")},e}(yn),yL=function(t){/**
         * The WebGL framebuffer
         * @member {WebGLFramebuffer}
         */this.framebuffer=t,/**
         * stencil+depth , usually costs 32bits per pixel
         * @member {WebGLRenderbuffer}
         */this.stencil=null,/**
         * latest known version of framebuffer
         * @member {number}
         * @protected
         */this.dirtyId=0,/**
         * latest known version of framebuffer format
         * @member {number}
         * @protected
         */this.dirtyFormat=0,/**
         * latest known version of framebuffer size
         * @member {number}
         * @protected
         */this.dirtySize=0,/**
         * Detected AA samples number
         * @member {PIXI.MSAA_QUALITY}
         */this.multisample=Ev.NONE,/**
         * In case MSAA, we use this Renderbuffer instead of colorTextures[0] when we write info
         * @member {WebGLRenderbuffer}
         */this.msaaBuffer=null,/**
         * In case we use MSAA, this is actual framebuffer that has colorTextures[0]
         * The contents of that framebuffer are read when we use that renderTexture in sprites
         * @member {PIXI.Framebuffer}
         */this.blitFramebuffer=null},yN=new gG,yD=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */i.managedFramebuffers=[],/**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */i.unknownFramebuffer=new yo(10,10),i.msaaSamples=null,i)}return g0(e,t),/**
     * Sets up the renderer context and necessary buffers.
     */e.prototype.contextChange=function(){var t=this.gl=this.renderer.gl;// webgl2
if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.current=this.unknownFramebuffer,this.viewport=new gG,this.hasMRT=!0,this.writeDepthTexture=!0,this.disposeAll(!0),1===this.renderer.context.webGLVersion){// webgl 1!
var e=this.renderer.context.extensions.drawBuffers,i=this.renderer.context.extensions.depthTexture;gf.PREFER_ENV===Er.WEBGL_LEGACY&&(e=null,i=null),e?t.drawBuffers=function(t){return e.drawBuffersWEBGL(t)}:(this.hasMRT=!1,t.drawBuffers=function(){// empty
}),i||(this.writeDepthTexture=!1)}else // cache possible MSAA samples
this.msaaSamples=t.getInternalformatParameter(t.RENDERBUFFER,t.RGBA8,t.SAMPLES)},/**
     * Bind a framebuffer
     *
     * @param {PIXI.Framebuffer} framebuffer
     * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
     */e.prototype.bind=function(t,e){var i=this.gl;if(t){// TODO caching layer!
var r=t.glFramebuffers[this.CONTEXT_UID]||this.initFramebuffer(t);this.current!==t&&(this.current=t,i.bindFramebuffer(i.FRAMEBUFFER,r.framebuffer)),r.dirtyId!==t.dirtyId&&(r.dirtyId=t.dirtyId,r.dirtyFormat!==t.dirtyFormat?(r.dirtyFormat=t.dirtyFormat,this.updateFramebuffer(t)):r.dirtySize!==t.dirtySize&&(r.dirtySize=t.dirtySize,this.resizeFramebuffer(t)));for(var n=0;n<t.colorTextures.length;n++){var s=t.colorTextures[n];this.renderer.texture.unbind(s.parentTextureArray||s)}t.depthTexture&&this.renderer.texture.unbind(t.depthTexture),e?this.setViewport(e.x,e.y,e.width,e.height):this.setViewport(0,0,t.width,t.height)}else this.current&&(this.current=null,i.bindFramebuffer(i.FRAMEBUFFER,null)),e?this.setViewport(e.x,e.y,e.width,e.height):this.setViewport(0,0,this.renderer.width,this.renderer.height)},/**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */e.prototype.setViewport=function(t,e,i,r){var n=this.viewport;(n.width!==i||n.height!==r||n.x!==t||n.y!==e)&&(n.x=t,n.y=e,n.width=i,n.height=r,this.gl.viewport(t,e,i,r))},Object.defineProperty(e.prototype,"size",{/**
         * Get the size of the current width and height. Returns object with `width` and `height` values.
         *
         * @member {object}
         * @readonly
         */get:function(){return this.current?{x:0,y:0,width:this.current.width,height:this.current.height}:{x:0,y:0,width:this.renderer.width,height:this.renderer.height}},enumerable:!1,configurable:!0}),/**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
     */e.prototype.clear=function(t,e,i,r,n){void 0===n&&(n=Es.COLOR|Es.DEPTH);var s=this.gl;// TODO clear color can be set only one right?
s.clearColor(t,e,i,r),s.clear(n)},/**
     * Initialize framebuffer for this context
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     * @returns {PIXI.GLFramebuffer} created GLFramebuffer
     */e.prototype.initFramebuffer=function(t){var e=this.gl,i=new yL(e.createFramebuffer());return i.multisample=this.detectSamples(t.multisample),t.glFramebuffers[this.CONTEXT_UID]=i,this.managedFramebuffers.push(t),t.disposeRunner.add(this),i},/**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */e.prototype.resizeFramebuffer=function(t){var e=this.gl,i=t.glFramebuffers[this.CONTEXT_UID];i.stencil&&(e.bindRenderbuffer(e.RENDERBUFFER,i.stencil),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,t.width,t.height));for(var r=t.colorTextures,n=0;n<r.length;n++)this.renderer.texture.bind(r[n],0);t.depthTexture&&this.renderer.texture.bind(t.depthTexture,0)},/**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */e.prototype.updateFramebuffer=function(t){var e=this.gl,i=t.glFramebuffers[this.CONTEXT_UID],r=t.colorTextures.length;e.drawBuffers||(r=Math.min(r,1)),i.multisample>1&&(i.msaaBuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,i.msaaBuffer),e.renderbufferStorageMultisample(e.RENDERBUFFER,i.multisample,e.RGBA8,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,i.msaaBuffer));for(var n=[],s=0;s<r;s++)if(0!==s||!(i.multisample>1)){var o=t.colorTextures[s],a=o.parentTextureArray||o;this.renderer.texture.bind(a,0),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+s,o.target,a._glTextures[this.CONTEXT_UID].texture,0),n.push(e.COLOR_ATTACHMENT0+s)}if(n.length>1&&e.drawBuffers(n),t.depthTexture&&this.writeDepthTexture){var h=t.depthTexture;this.renderer.texture.bind(h,0),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,h._glTextures[this.CONTEXT_UID].texture,0)}!i.stencil&&(t.stencil||t.depth)&&(i.stencil=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,i.stencil),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,t.width,t.height),t.depthTexture||e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,i.stencil))},/**
     * Detects number of samples that is not more than a param but as close to it as possible
     *
     * @param {PIXI.MSAA_QUALITY} samples - number of samples
     * @returns {PIXI.MSAA_QUALITY} - recommended number of samples
     */e.prototype.detectSamples=function(t){var e=this.msaaSamples,i=Ev.NONE;if(t<=1||null===e)return i;for(var r=0;r<e.length;r++)if(e[r]<=t){i=e[r];break}return 1===i&&(i=Ev.NONE),i},/**
     * Only works with WebGL2
     *
     * blits framebuffer to another of the same or bigger size
     * after that target framebuffer is bound
     *
     * Fails with WebGL warning if blits multisample framebuffer to different size
     *
     * @param {PIXI.Framebuffer} [framebuffer] - by default it blits "into itself", from renderBuffer to texture.
     * @param {PIXI.Rectangle} [sourcePixels] - source rectangle in pixels
     * @param {PIXI.Rectangle} [destPixels] - dest rectangle in pixels, assumed to be the same as sourcePixels
     */e.prototype.blit=function(t,e,i){var r=this.current,n=this.renderer,s=this.gl,o=this.CONTEXT_UID;if(2===n.context.webGLVersion&&r){var a=r.glFramebuffers[o];if(a){if(!t){if(a.multisample<=1)return;a.blitFramebuffer||(a.blitFramebuffer=new yo(r.width,r.height),a.blitFramebuffer.addColorTexture(0,r.colorTextures[0])),(t=a.blitFramebuffer).width=r.width,t.height=r.height}e||((e=yN).width=r.width,e.height=r.height),i||(i=e);var h=e.width===i.width&&e.height===i.height;this.bind(t),s.bindFramebuffer(s.READ_FRAMEBUFFER,a.framebuffer),s.blitFramebuffer(e.x,e.y,e.width,e.height,i.x,i.y,i.width,i.height,s.COLOR_BUFFER_BIT,h?s.NEAREST:s.LINEAR)}}},/**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer - framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] - If context was lost, we suppress all delete function calls
     */e.prototype.disposeFramebuffer=function(t,e){var i=t.glFramebuffers[this.CONTEXT_UID],r=this.gl;if(i){delete t.glFramebuffers[this.CONTEXT_UID];var n=this.managedFramebuffers.indexOf(t);n>=0&&this.managedFramebuffers.splice(n,1),t.disposeRunner.remove(this),!e&&(r.deleteFramebuffer(i.framebuffer),i.stencil&&r.deleteRenderbuffer(i.stencil))}},/**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] - If context was lost, we suppress all delete function calls
     */e.prototype.disposeAll=function(t){var e=this.managedFramebuffers;this.managedFramebuffers=[];for(var i=0;i<e.length;i++)this.disposeFramebuffer(e[i],t)},/**
     * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.
     * Used by MaskSystem, when its time to use stencil mask for Graphics element.
     *
     * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.
     *
     * @private
     */e.prototype.forceStencil=function(){var t=this.current;if(t){var e=t.glFramebuffers[this.CONTEXT_UID];if(e&&!e.stencil){t.enableStencil();var i=t.width,r=t.height,n=this.gl,s=n.createRenderbuffer();n.bindRenderbuffer(n.RENDERBUFFER,s),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,i,r),e.stencil=s,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,s)}}},/**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */e.prototype.reset=function(){this.current=this.unknownFramebuffer,this.viewport=new gG},e}(yn),yF=function(t){this.buffer=t||null,this.updateID=-1,this.byteLength=-1,this.refCount=0},yB={5126:4,5123:2,5121:1},yU=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i._activeGeometry=null,i._activeVao=null,/**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */i.hasVao=!0,/**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */i.hasInstance=!0,/**
         * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`
         * @member {boolean}
         * @readonly
         */i.canUseUInt32ElementIndex=!1,/**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */i.managedGeometries={},/**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */i.managedBuffers={},i}return g0(e,t),/**
     * Sets up the renderer context and necessary buffers.
     */e.prototype.contextChange=function(){this.disposeAll(!0);var t=this.gl=this.renderer.gl,e=this.renderer.context;// webgl2
if(this.CONTEXT_UID=this.renderer.CONTEXT_UID,2!==e.webGLVersion){// webgl 1!
var i=this.renderer.context.extensions.vertexArrayObject;gf.PREFER_ENV===Er.WEBGL_LEGACY&&(i=null),i?(t.createVertexArray=function(){return i.createVertexArrayOES()},t.bindVertexArray=function(t){return i.bindVertexArrayOES(t)},t.deleteVertexArray=function(t){return i.deleteVertexArrayOES(t)}):(this.hasVao=!1,t.createVertexArray=function(){return null},t.bindVertexArray=function(){return null},t.deleteVertexArray=function(){return null})}if(2!==e.webGLVersion){var r=t.getExtension("ANGLE_instanced_arrays");r?(t.vertexAttribDivisor=function(t,e){return r.vertexAttribDivisorANGLE(t,e)},t.drawElementsInstanced=function(t,e,i,n,s){return r.drawElementsInstancedANGLE(t,e,i,n,s)},t.drawArraysInstanced=function(t,e,i,n){return r.drawArraysInstancedANGLE(t,e,i,n)}):this.hasInstance=!1}this.canUseUInt32ElementIndex=2===e.webGLVersion||!!e.extensions.uint32ElementIndex},/**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     *
     * @param {PIXI.Geometry} geometry - instance of geometry to bind
     * @param {PIXI.Shader} [shader] - instance of shader to use vao for
     */e.prototype.bind=function(t,e){e=e||this.renderer.shader.shader;var i=this.gl,r=t.glVertexArrayObjects[this.CONTEXT_UID],n=!1;r||(this.managedGeometries[t.id]=t,t.disposeRunner.add(this),t.glVertexArrayObjects[this.CONTEXT_UID]=r={},n=!0);var s=r[e.program.id]||this.initGeometryVao(t,e.program,n);this._activeGeometry=t,this._activeVao!==s&&(this._activeVao=s,this.hasVao?i.bindVertexArray(s):this.activateVao(t,e.program)),// TODO - optimise later!
// don't need to loop through if nothing changed!
// maybe look to add an 'autoupdate' to geometry?
this.updateBuffers()},/**
     * Reset and unbind any active VAO and geometry
     */e.prototype.reset=function(){this.unbind()},/**
     * Update buffers
     * @protected
     */e.prototype.updateBuffers=function(){for(var t=this._activeGeometry,e=this.gl,i=0;i<t.buffers.length;i++){var r=t.buffers[i],n=r._glBuffers[this.CONTEXT_UID];if(r._updateID!==n.updateID){n.updateID=r._updateID;// TODO can cache this on buffer! maybe added a getter / setter?
var s=r.index?e.ELEMENT_ARRAY_BUFFER:e.ARRAY_BUFFER;if(// TODO this could change if the VAO changes...
// need to come up with a better way to cache..
// if (this.boundBuffers[type] !== glBuffer)
// {
// this.boundBuffers[type] = glBuffer;
e.bindBuffer(s,n.buffer),// }
this._boundBuffer=n,n.byteLength>=r.data.byteLength)e.bufferSubData(s,0,r.data);else{var o=r.static?e.STATIC_DRAW:e.DYNAMIC_DRAW;n.byteLength=r.data.byteLength,e.bufferData(s,r.data,o)}}}},/**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */e.prototype.checkCompatibility=function(t,e){// geometry must have at least all the attributes that the shader requires.
var i=t.attributes,r=e.attributeData;for(var n in r)if(!i[n])throw Error('shader and geometry incompatible, geometry missing the "'+n+'" attribute')},/**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry - to get signature from
     * @param {PIXI.Program} program - to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */e.prototype.getSignature=function(t,e){var i=t.attributes,r=e.attributeData,n=["g",t.id];for(var s in i)r[s]&&n.push(s);return n.join("-")},/**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     * @param {boolean} [incRefCount=false] - Increment refCount of all geometry buffers
     */e.prototype.initGeometryVao=function(t,e,i){void 0===i&&(i=!0),this.checkCompatibility(t,e);var r=this.gl,n=this.CONTEXT_UID,s=this.getSignature(t,e),o=t.glVertexArrayObjects[this.CONTEXT_UID],a=o[s];if(a)return(// this will give us easy access to the vao
o[e.id]=a,a);var h=t.buffers,l=t.attributes,u={},c={};for(var d in h)u[d]=0,c[d]=0;for(var d in l)!l[d].size&&e.attributeData[d]?l[d].size=e.attributeData[d].size:l[d].size||console.warn("PIXI Geometry attribute '"+d+"' size cannot be determined (likely the bound shader does not have the attribute)"),u[l[d].buffer]+=l[d].size*yB[l[d].type];for(var d in l){var p=l[d],f=p.size;void 0===p.stride&&(u[p.buffer]===f*yB[p.type]?p.stride=0:p.stride=u[p.buffer]),void 0===p.start&&(p.start=c[p.buffer],c[p.buffer]+=f*yB[p.type])}a=r.createVertexArray(),r.bindVertexArray(a);// first update - and create the buffers!
// only create a gl buffer if it actually gets
for(var m=0;m<h.length;m++){var g=h[m];g._glBuffers[n]||(g._glBuffers[n]=new yF(r.createBuffer()),this.managedBuffers[g.id]=g,g.disposeRunner.add(this)),i&&g._glBuffers[n].refCount++}return(// TODO - maybe make this a data object?
// lets wait to see if we need to first!
this.activateVao(t,e),this._activeVao=a,// add it to the cache!
o[e.id]=a,o[s]=a,a)},/**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer - buffer with data
     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */e.prototype.disposeBuffer=function(t,e){if(this.managedBuffers[t.id]){delete this.managedBuffers[t.id];var i=t._glBuffers[this.CONTEXT_UID],r=this.gl;t.disposeRunner.remove(this),i&&(e||r.deleteBuffer(i.buffer),delete t._glBuffers[this.CONTEXT_UID])}},/**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry - Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
     */e.prototype.disposeGeometry=function(t,e){if(this.managedGeometries[t.id]){delete this.managedGeometries[t.id];var i=t.glVertexArrayObjects[this.CONTEXT_UID],r=this.gl,n=t.buffers;if(t.disposeRunner.remove(this),i){for(var s=0;s<n.length;s++){var o=n[s]._glBuffers[this.CONTEXT_UID];o.refCount--,0!==o.refCount||e||this.disposeBuffer(n[s],e)}if(!e){for(var a in i)if("g"===a[0]){var h=i[a];this._activeVao===h&&this.unbind(),r.deleteVertexArray(h)}}delete t.glVertexArrayObjects[this.CONTEXT_UID]}}},/**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
     */e.prototype.disposeAll=function(t){for(var e=Object.keys(this.managedGeometries),i=0;i<e.length;i++)this.disposeGeometry(this.managedGeometries[e[i]],t);e=Object.keys(this.managedBuffers);for(var i=0;i<e.length;i++)this.disposeBuffer(this.managedBuffers[e[i]],t)},/**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */e.prototype.activateVao=function(t,e){var i=this.gl,r=this.CONTEXT_UID,n=t.buffers,s=t.attributes;t.indexBuffer&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,t.indexBuffer._glBuffers[r].buffer);var o=null;// add a new one!
for(var a in s){var h=s[a],l=n[h.buffer]._glBuffers[r];if(e.attributeData[a]){o!==l&&(i.bindBuffer(i.ARRAY_BUFFER,l.buffer),o=l);var u=e.attributeData[a].location;if(// TODO introduce state again
// we can optimise this for older devices that have no VAOs
i.enableVertexAttribArray(u),i.vertexAttribPointer(u,h.size,h.type||i.FLOAT,h.normalized,h.stride,h.start),h.instance){// TODO calculate instance count based of this...
if(this.hasInstance)i.vertexAttribDivisor(u,1);else throw Error("geometry error, GPU Instancing is not supported on this device")}}}},/**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */e.prototype.draw=function(t,e,i,r){var n=this.gl,s=this._activeGeometry;// TODO.. this should not change so maybe cache the function?
if(s.indexBuffer){var o=s.indexBuffer.data.BYTES_PER_ELEMENT,a=2===o?n.UNSIGNED_SHORT:n.UNSIGNED_INT;2===o||4===o&&this.canUseUInt32ElementIndex?s.instanced?/* eslint-disable max-len */n.drawElementsInstanced(t,e||s.indexBuffer.data.length,a,(i||0)*o,r||1):/* eslint-disable max-len */n.drawElements(t,e||s.indexBuffer.data.length,a,(i||0)*o):console.warn("unsupported index buffer type: uint32")}else s.instanced?n.drawArraysInstanced(t,i,e||s.getSize(),r||1):n.drawArrays(t,i,e||s.getSize());return this},/**
     * Unbind/reset everything
     * @protected
     */e.prototype.unbind=function(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null},e}(yn),yG=/** @class */function(){/**
     * Create MaskData
     *
     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask
     */function t(t){void 0===t&&(t=null),/**
         * Mask type
         * @member {PIXI.MASK_TYPES}
         */this.type=E_.NONE,/**
         * Whether we know the mask type beforehand
         * @member {boolean}
         * @default true
         */this.autoDetect=!0,/**
         * Which element we use to mask
         * @member {PIXI.DisplayObject}
         */this.maskObject=t||null,/**
         * Whether it belongs to MaskSystem pool
         * @member {boolean}
         */this.pooled=!1,/**
         * Indicator of the type
         * @member {boolean}
         */this.isMaskData=!0,/**
         * Stencil counter above the mask in stack
         * @member {number}
         * @private
         */this._stencilCounter=0,/**
         * Scissor counter above the mask in stack
         * @member {number}
         * @private
         */this._scissorCounter=0,/**
         * Scissor operation above the mask in stack.
         * Null if _scissorCounter is zero, rectangle instance if positive.
         * @member {PIXI.Rectangle}
         */this._scissorRect=null,/**
         * Targeted element. Temporary variable set by MaskSystem
         * @member {PIXI.DisplayObject}
         * @private
         */this._target=null}return(/**
     * resets the mask data after popMask()
     */t.prototype.reset=function(){this.pooled&&(this.maskObject=null,this.type=E_.NONE,this.autoDetect=!0),this._target=null},/**
     * copies counters from maskData above, called from pushMask()
     * @param {PIXI.MaskData|null} maskAbove
     */t.prototype.copyCountersOrReset=function(t){t?(this._stencilCounter=t._stencilCounter,this._scissorCounter=t._scissorCounter,this._scissorRect=t._scissorRect):(this._stencilCounter=0,this._scissorCounter=0,this._scissorRect=null)},t)}();/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param src {string} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */function yk(t,e,i){var r=t.createShader(e);return t.shaderSource(r,i),t.compileShader(r),r}/**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */function yH(t,e,i,r){var n=yk(t,t.VERTEX_SHADER,e),s=yk(t,t.FRAGMENT_SHADER,i),o=t.createProgram();// optionally, set the attributes manually for the program rather than letting WebGL decide..
if(t.attachShader(o,n),t.attachShader(o,s),r)for(var a in r)t.bindAttribLocation(o,r[a],a);return t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS)||(t.getShaderParameter(n,t.COMPILE_STATUS)||(console.warn(e),console.error(t.getShaderInfoLog(n))),t.getShaderParameter(s,t.COMPILE_STATUS)||(console.warn(i),console.error(t.getShaderInfoLog(s))),console.error("Pixi.js Error: Could not initialize shader."),console.error("gl.VALIDATE_STATUS",t.getProgramParameter(o,t.VALIDATE_STATUS)),console.error("gl.getError()",t.getError()),""!==t.getProgramInfoLog(o)&&console.warn("Pixi.js Warning: gl.getProgramInfoLog()",t.getProgramInfoLog(o)),t.deleteProgram(o),o=null),// clean up some shaders
t.deleteShader(n),t.deleteShader(s),o}function yz(t){for(var e=Array(t),i=0;i<e.length;i++)e[i]=!1;return e}/**
 * @method defaultValue
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 * @private
 */function yj(t,e){switch(t){case"float":case"int":case"sampler2D":case"sampler2DArray":return 0;case"vec2":return new Float32Array(2*e);case"vec3":return new Float32Array(3*e);case"vec4":return new Float32Array(4*e);case"ivec2":return new Int32Array(2*e);case"ivec3":return new Int32Array(3*e);case"ivec4":return new Int32Array(4*e);case"bool":return!1;case"bvec2":return yz(2*e);case"bvec3":return yz(3*e);case"bvec4":return yz(4*e);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}var yV={},yX=yV;/**
 * returns a little WebGL context to use for program inspection.
 *
 * @static
 * @private
 * @returns {WebGLRenderingContext} a gl context to test with
 */function yW(){if(yX===yV||yX&&yX.isContextLost()){var t=document.createElement("canvas"),e=void 0;gf.PREFER_ENV>=Er.WEBGL2&&(e=t.getContext("webgl2",{})),e||((e=t.getContext("webgl",{})||t.getContext("experimental-webgl",{}))?e.getExtension("WEBGL_draw_buffers"):e=null),yX=e}return yX}/**
 * Sets the float precision on the shader, ensuring the device supports the request precision.
 * If the precision is already present, it just ensures that the device is able to handle it.
 *
 * @private
 * @param {string} src - The shader source
 * @param {string} requestedPrecision - The request float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param {string} maxSupportedPrecision - The maximum precision the shader supports.
 *
 * @return {string} modified shader source
 */function yY(t,e,i){if("precision"!==t.substring(0,9)){// no precision supplied, so PixiJS will add the requested level.
var r=e;return e===Ey.HIGH&&i!==Ey.HIGH&&(r=Ey.MEDIUM),"precision "+r+" float;\n"+t}return i!==Ey.HIGH&&"precision highp"===t.substring(0,15)?t.replace("precision highp","precision mediump"):t}var yq={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1},yK=null,yJ={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function yZ(t,e){if(!yK){var i=Object.keys(yJ);yK={};for(var r=0;r<i.length;++r){var n=i[r];yK[t[n]]=yJ[n]}}return yK[e]}/* eslint-disable @typescript-eslint/explicit-module-boundary-types */// Parsers, each one of these will take a look at the type of shader property and uniform.
// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.
// Shader upload code is automagically generated with these parsers.
// If no parser is valid then the default upload functions are used.
// exposing Parsers means that custom upload logic can be added to pixi's shaders.
// A good example would be a pixi rectangle can be directly set on a uniform.
// If the shader sees it it knows how to upload the rectangle structure as a vec4
// format is as follows:
//
// {
//     test: (data, uniform) => {} <--- test is this code should be used for this uniform
//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform
// }
var y$=[// a float cache layer
{test:function(t){return"float"===t.type&&1===t.size},code:function(t){return'\n            if(uv["'+t+'"] !== ud["'+t+'"].value)\n            {\n                ud["'+t+'"].value = uv["'+t+'"]\n                gl.uniform1f(ud["'+t+'"].location, uv["'+t+'"])\n            }\n            '}},// handling samplers
{test:function(t){// eslint-disable-next-line max-len
return("sampler2D"===t.type||"samplerCube"===t.type||"sampler2DArray"===t.type)&&1===t.size&&!t.isArray},code:function(t){return't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["'+t+'"], t);\n\n            if(ud["'+t+'"].value !== t)\n            {\n                ud["'+t+'"].value = t;\n                gl.uniform1i(ud["'+t+'"].location, t);\n; // eslint-disable-line max-len\n            }'}},// uploading pixi matrix object to mat3
{test:function(t,e){return"mat3"===t.type&&1===t.size&&void 0!==e.a},code:function(t){// TODO and some smart caching dirty ids here!
return'\n            gl.uniformMatrix3fv(ud["'+t+'"].location, false, uv["'+t+'"].toArray(true));\n            '}},// uploading a pixi point as a vec2 with caching layer
{test:function(t,e){return"vec2"===t.type&&1===t.size&&void 0!==e.x},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["'+t+'"].location, v.x, v.y);\n                }'}},// caching layer for a vec2
{test:function(t){return"vec2"===t.type&&1===t.size},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["'+t+'"].location, v[0], v[1]);\n                }\n            '}},// upload a pixi rectangle as a vec4 with caching layer
{test:function(t,e){return"vec4"===t.type&&1===t.size&&void 0!==e.width},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["'+t+'"].location, v.x, v.y, v.width, v.height)\n                }'}},// a caching layer for vec4 uploading
{test:function(t){return"vec4"===t.type&&1===t.size},code:function(t){return'\n                cv = ud["'+t+'"].value;\n                v = uv["'+t+'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["'+t+'"].location, v[0], v[1], v[2], v[3])\n                }'}}],yQ={float:"\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",vec2:"\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",vec3:"\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",vec4:"gl.uniform4f(location, v[0], v[1], v[2], v[3])",int:"gl.uniform1i(location, v)",ivec2:"gl.uniform2i(location, v[0], v[1])",ivec3:"gl.uniform3i(location, v[0], v[1], v[2])",ivec4:"gl.uniform4i(location, v[0], v[1], v[2], v[3])",bool:"gl.uniform1i(location, v)",bvec2:"gl.uniform2i(location, v[0], v[1])",bvec3:"gl.uniform3i(location, v[0], v[1], v[2])",bvec4:"gl.uniform4i(location, v[0], v[1], v[2], v[3])",mat2:"gl.uniformMatrix2fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",sampler2D:"gl.uniform1i(location, v)",samplerCube:"gl.uniform1i(location, v)",sampler2DArray:"gl.uniform1i(location, v)"},y0={float:"gl.uniform1fv(location, v)",vec2:"gl.uniform2fv(location, v)",vec3:"gl.uniform3fv(location, v)",vec4:"gl.uniform4fv(location, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat2:"gl.uniformMatrix2fv(location, false, v)",int:"gl.uniform1iv(location, v)",ivec2:"gl.uniform2iv(location, v)",ivec3:"gl.uniform3iv(location, v)",ivec4:"gl.uniform4iv(location, v)",bool:"gl.uniform1iv(location, v)",bvec2:"gl.uniform2iv(location, v)",bvec3:"gl.uniform3iv(location, v)",bvec4:"gl.uniform4iv(location, v)",sampler2D:"gl.uniform1iv(location, v)",samplerCube:"gl.uniform1iv(location, v)",sampler2DArray:"gl.uniform1iv(location, v)"},y1=0,y2={},y3=/** @class */function(){/**
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {string} [name] - Name for shader
     */function t(e,i,r){void 0===r&&(r="pixi-shader"),this.id=y1++,/**
         * The vertex shader.
         *
         * @member {string}
         */this.vertexSrc=e||t.defaultVertexSrc,/**
         * The fragment shader.
         *
         * @member {string}
         */this.fragmentSrc=i||t.defaultFragmentSrc,this.vertexSrc=this.vertexSrc.trim(),this.fragmentSrc=this.fragmentSrc.trim(),"#version"!==this.vertexSrc.substring(0,8)&&(y2[r=r.replace(/\s+/g,"-")]?(y2[r]++,r+="-"+y2[r]):y2[r]=1,this.vertexSrc="#define SHADER_NAME "+r+"\n"+this.vertexSrc,this.fragmentSrc="#define SHADER_NAME "+r+"\n"+this.fragmentSrc,this.vertexSrc=yY(this.vertexSrc,gf.PRECISION_VERTEX,Ey.HIGH),this.fragmentSrc=yY(this.fragmentSrc,gf.PRECISION_FRAGMENT,function(){if(!Ew){Ew=Ey.MEDIUM;var t=yW();t&&t.getShaderPrecisionFormat&&(Ew=t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision?Ey.HIGH:Ey.MEDIUM)}return Ew}())),// currently this does not extract structs only default types
this.extractData(this.vertexSrc,this.fragmentSrc),// this is where we store shader references..
this.glPrograms={},this.syncUniforms=null}return(/**
     * Extracts the data for a buy creating a small test program
     * or reading the src directly.
     * @protected
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     */t.prototype.extractData=function(t,e){var i=yW();if(i){var r=yH(i,t,e);this.attributeData=this.getAttributeData(r,i),this.uniformData=this.getUniformData(r,i),i.deleteProgram(r)}else this.uniformData={},this.attributeData={}},/**
     * returns the attribute data from the program
     * @private
     *
     * @param {WebGLProgram} [program] - the WebGL program
     * @param {WebGLRenderingContext} [gl] - the WebGL context
     *
     * @returns {object} the attribute data for this program
     */t.prototype.getAttributeData=function(t,e){for(var i={},r=[],n=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES),s=0;s<n;s++){var o=e.getActiveAttrib(t,s),a=yZ(e,o.type),h={type:a,name:o.name,size:yq[a],location:0};/* eslint-enable */i[o.name]=h,r.push(h)}r.sort(function(t,e){return t.name>e.name?1:-1});// eslint-disable-line no-confusing-arrow
for(var s=0;s<r.length;s++)r[s].location=s;return i},/**
     * returns the uniform data from the program
     * @private
     *
     * @param {webGL-program} [program] - the webgl program
     * @param {context} [gl] - the WebGL context
     *
     * @returns {object} the uniform data for this program
     */t.prototype.getUniformData=function(t,e){// TODO expose this as a prop?
// const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
// const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
for(var i={},r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),n=0;n<r;n++){var s=e.getActiveUniform(t,n),o=s.name.replace(/\[.*?\]$/,""),a=s.name.match(/\[.*?\]$/),h=yZ(e,s.type);/*eslint-disable */i[o]={type:h,size:s.size,isArray:a,value:yj(h,s.size)};/* eslint-enable */}return i},Object.defineProperty(t,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @constant
         * @member {string}
         */get:function(){return"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"},enumerable:!1,configurable:!0}),Object.defineProperty(t,"defaultFragmentSrc",{/**
         * The default fragment shader source
         *
         * @static
         * @constant
         * @member {string}
         */get:function(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"},enumerable:!1,configurable:!0}),/**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {string} [name=pixi-shader] - Name for shader
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */t.from=function(e,i,r){var n=e+i,s=gI[n];return s||(gI[n]=s=new t(e,i,r)),s},t)}(),y5=/** @class */function(){/**
     * @param {PIXI.Program} [program] - The program the shader will use.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     */function t(t,e){// time to build some getters and setters!
// I guess down the line this could sort of generate an instruction list rather than use dirty ids?
// does the trick for now though!
for(var i in /**
         * Program that the shader uses
         *
         * @member {PIXI.Program}
         */this.program=t,e?e instanceof yM?this.uniformGroup=e:this.uniformGroup=new yM(e):this.uniformGroup=new yM({}),t.uniformData)this.uniformGroup.uniforms[i]instanceof Array&&(this.uniformGroup.uniforms[i]=new Float32Array(this.uniformGroup.uniforms[i]))}return(// TODO move to shader system..
t.prototype.checkUniformExists=function(t,e){if(e.uniforms[t])return!0;for(var i in e.uniforms){var r=e.uniforms[i];if(r.group&&this.checkUniformExists(t,r))return!0}return!1},t.prototype.destroy=function(){// usage count on programs?
// remove if not used!
this.uniformGroup=null},Object.defineProperty(t.prototype,"uniforms",{/**
         * Shader uniform values, shortcut for `uniformGroup.uniforms`
         * @readonly
         * @member {object}
         */get:function(){return this.uniformGroup.uniforms},enumerable:!1,configurable:!0}),/**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */t.from=function(e,i,r){var n=y3.from(e,i);return new t(n,r)},t)}(),y4=/** @class */function(){function t(){this.data=0,this.blendMode=Eo.NORMAL,this.polygonOffset=0,this.blend=!0;//  this.depthTest = true;
}return Object.defineProperty(t.prototype,"blend",{/**
         * Activates blending of the computed fragment color values
         *
         * @member {boolean}
         */get:function(){return!!(1&this.data)},set:function(t){!!(1&this.data)!==t&&(this.data^=1)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"offsets",{/**
         * Activates adding an offset to depth values of polygon's fragments
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(2&this.data)},set:function(t){!!(2&this.data)!==t&&(this.data^=2)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"culling",{/**
         * Activates culling of polygons.
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(4&this.data)},set:function(t){!!(4&this.data)!==t&&(this.data^=4)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"depthTest",{/**
         * Activates depth comparisons and updates to the depth buffer.
         *
         * @member {boolean}
         * @default false
         */get:function(){return!!(8&this.data)},set:function(t){!!(8&this.data)!==t&&(this.data^=8)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"clockwiseFrontFace",{/**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @member {boolean}
         * @default false
         */get:function(){return!!(16&this.data)},set:function(t){!!(16&this.data)!==t&&(this.data^=16)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"blendMode",{/**
         * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */get:function(){return this._blendMode},set:function(t){this.blend=t!==Eo.NONE,this._blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"polygonOffset",{/**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         *
         * @member {number}
         * @default 0
         */get:function(){return this._polygonOffset},set:function(t){this.offsets=!!t,this._polygonOffset=t},enumerable:!1,configurable:!0}),t.for2d=function(){var e=new t;return e.depthTest=!1,e.blend=!0,e},t}(),y6=/** @class */function(t){/**
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     */function e(i,r,n){var s=this,o=y3.from(i||e.defaultVertexSrc,r||e.defaultFragmentSrc);return(/**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */(s=t.call(this,o,n)||this).padding=0,/**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */s.resolution=gf.FILTER_RESOLUTION,/**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */s.enabled=!0,/**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */s.autoFit=!0,/**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */s.legacy=!!s.program.attributeData.aTextureCoord,/**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */s.state=new y4,s)}return g0(e,t),/**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} clearMode - Should the output be cleared before rendering to it.
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */e.prototype.apply=function(t,e,i,r,n){// do as you please!
t.applyFilter(this,e,i,r);// or just do a regular render..
},Object.defineProperty(e.prototype,"blendMode",{/**
         * Sets the blendmode of the filter
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         */get:function(){return this.state.blendMode},set:function(t){this.state.blendMode=t},enumerable:!1,configurable:!0}),Object.defineProperty(e,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"},enumerable:!1,configurable:!0}),Object.defineProperty(e,"defaultFragmentSrc",{/**
         * The default fragment shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"},enumerable:!1,configurable:!0}),e}(y5),y8=new gz,y7=/** @class */function(){/**
     *
     * @param {PIXI.Texture} texture - observed texture
     * @param {number} [clampMargin] - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
     * @constructor
     */function t(t,e){this._texture=t,/**
         * Matrix operation that converts texture region coords to texture coords
         * @member {PIXI.Matrix}
         * @readonly
         */this.mapCoord=new gz,/**
         * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.
         * Calculated based on clampOffset.
         * @member {Float32Array}
         * @readonly
         */this.uClampFrame=new Float32Array(4),/**
         * Normalized clamp offset.
         * Calculated based on clampOffset.
         * @member {Float32Array}
         * @readonly
         */this.uClampOffset=new Float32Array(2),/**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */this._textureID=-1,/**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */this._updateID=0,/**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */this.clampOffset=0,/**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */this.clampMargin=void 0===e?.5:e,/**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */this.isSimple=!1}return Object.defineProperty(t.prototype,"texture",{/**
         * texture property
         * @member {PIXI.Texture}
         */get:function(){return this._texture},set:function(t){this._texture=t,this._textureID=-1},enumerable:!1,configurable:!0}),/**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs - mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */t.prototype.multiplyUvs=function(t,e){void 0===e&&(e=t);for(var i=this.mapCoord,r=0;r<t.length;r+=2){var n=t[r],s=t[r+1];e[r]=n*i.a+s*i.c+i.tx,e[r+1]=n*i.b+s*i.d+i.ty}return e},/**
     * updates matrices if texture was changed
     * @param {boolean} [forceUpdate=false] - if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */t.prototype.update=function(t){var e=this._texture;if(!e||!e.valid||!t&&this._textureID===e._updateID)return!1;this._textureID=e._updateID,this._updateID++;var i=e._uvs;this.mapCoord.set(i.x1-i.x0,i.y1-i.y0,i.x3-i.x0,i.y3-i.y0,i.x0,i.y0);var r=e.orig,n=e.trim;n&&(y8.set(r.width/n.width,0,0,r.height/n.height,-n.x/n.width,-n.y/n.height),this.mapCoord.append(y8));var s=e.baseTexture,o=this.uClampFrame,a=this.clampMargin/s.resolution,h=this.clampOffset;return o[0]=(e._frame.x+a+h)/s.width,o[1]=(e._frame.y+a+h)/s.height,o[2]=(e._frame.x+e._frame.width-a+h)/s.width,o[3]=(e._frame.y+e._frame.height-a+h)/s.height,this.uClampOffset[0]=h/s.realWidth,this.uClampOffset[1]=h/s.realHeight,this.isSimple=e._frame.width===s.width&&e._frame.height===s.height&&0===e.rotate,!0},t}(),y9=/** @class */function(t){/**
     * @param {PIXI.Sprite} sprite - the target sprite
     */function e(e){var i=this,r=new gz;return i=t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n","varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n")||this,e.renderable=!1,/**
         * Sprite mask
         * @member {PIXI.Sprite}
         */i.maskSprite=e,/**
         * Mask matrix
         * @member {PIXI.Matrix}
         */i.maskMatrix=r,i}return g0(e,t),/**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {PIXI.CLEAR_MODES} clearMode - Should the output be cleared before rendering to it.
     */e.prototype.apply=function(t,e,i,r){var n=this.maskSprite,s=n._texture;s.valid&&(s.uvMatrix||// assuming that atlas textures were made with 1-pixel padding
(s.uvMatrix=new y7(s,0)),s.uvMatrix.update(),this.uniforms.npmAlpha=s.baseTexture.alphaMode?0:1,this.uniforms.mask=s,// get _normalized sprite texture coords_ and convert them to _normalized atlas texture coords_ with `prepend`
this.uniforms.otherMatrix=t.calculateSpriteMatrix(this.maskMatrix,n).prepend(s.uvMatrix.mapCoord),this.uniforms.alpha=n.worldAlpha,this.uniforms.maskClamp=s.uvMatrix.uClampFrame,t.applyFilter(this,e,i,r))},e}(y6),_t=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */i.enableScissor=!1,/**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */i.alphaMaskPool=[],/**
         * Pool of mask data
         * @member {PIXI.MaskData[]}
         * @readonly
         */i.maskDataPool=[],i.maskStack=[],/**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */i.alphaMaskIndex=0,i)}return g0(e,t),/**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.MaskData[]} maskStack - The mask stack
     */e.prototype.setMaskStack=function(t){this.maskStack=t,this.renderer.scissor.setMaskStack(t),this.renderer.stencil.setMaskStack(t)},/**
     * Applies the Mask and adds it to the current filter stack.
     * Renderer batch must be flushed beforehand.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskData - The masking data.
     */e.prototype.push=function(t,e){var i=e;if(!i.isMaskData){var r=this.maskDataPool.pop()||new yG;r.pooled=!0,r.maskObject=e,i=r}switch(i.autoDetect&&this.detect(i),i.copyCountersOrReset(this.maskStack[this.maskStack.length-1]),i._target=t,i.type){case E_.SCISSOR:this.maskStack.push(i),this.renderer.scissor.push(i);break;case E_.STENCIL:this.maskStack.push(i),this.renderer.stencil.push(i);break;case E_.SPRITE:i.copyCountersOrReset(null),this.pushSpriteMask(i),this.maskStack.push(i)}},/**
     * Removes the last mask from the mask stack and doesn't return it.
     * Renderer batch must be flushed beforehand.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     */e.prototype.pop=function(t){var e=this.maskStack.pop();if(e&&e._target===t){switch(e.type){case E_.SCISSOR:this.renderer.scissor.pop();break;case E_.STENCIL:this.renderer.stencil.pop(e.maskObject);break;case E_.SPRITE:this.popSpriteMask()}e.reset(),e.pooled&&this.maskDataPool.push(e)}},/**
     * Sets type of MaskData based on its maskObject
     * @param {PIXI.MaskData} maskData
     */e.prototype.detect=function(t){var e=t.maskObject;if(e.isSprite){t.type=E_.SPRITE;return}// detect scissor in graphics
if(t.type=E_.STENCIL,this.enableScissor&&e.isFastRect&&e.isFastRect()){var i=e.worldTransform,r=Math.atan2(i.b,i.a),n=Math.atan2(i.d,i.c);n=((n=Math.round(n*(180/Math.PI)*100)-// use the nearest degree to 0.01
(r=Math.round(r*(180/Math.PI)*100)))%18e3+18e3)%18e3,0==(r=(r%9e3+9e3)%9e3)&&9e3===n&&(t.type=E_.SCISSOR)}},/**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.MaskData} maskData - Sprite to be used as the mask
     */e.prototype.pushSpriteMask=function(t){var e=t.maskObject,i=t._target,r=this.alphaMaskPool[this.alphaMaskIndex];r||(r=this.alphaMaskPool[this.alphaMaskIndex]=[new y9(e)]),r[0].resolution=this.renderer.resolution,r[0].maskSprite=e;var n=i.filterArea;i.filterArea=e.getBounds(!0),this.renderer.filter.push(i,r),i.filterArea=n,this.alphaMaskIndex++},/**
     * Removes the last filter from the filter stack and doesn't return it.
     */e.prototype.popSpriteMask=function(){this.renderer.filter.pop(),this.alphaMaskIndex--},e}(yn),_e=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * The mask stack
         * @member {PIXI.MaskData[]}
         */i.maskStack=[],/**
         * Constant for gl.enable
         * @member {number}
         * @private
         */i.glConst=0,i)}return g0(e,t),/**
     * gets count of masks of certain type
     * @returns {number}
     */e.prototype.getStackLength=function(){return this.maskStack.length},/**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.MaskData[]} maskStack - The mask stack
     */e.prototype.setMaskStack=function(t){var e=this.renderer.gl,i=this.getStackLength();this.maskStack=t;var r=this.getStackLength();r!==i&&(0===r?e.disable(this.glConst):(e.enable(this.glConst),this._useCurrent()))},/**
     * Setup renderer to use the current mask data.
     * @private
     */e.prototype._useCurrent=function(){// OVERWRITE;
},/**
     * Destroys the mask stack.
     *
     */e.prototype.destroy=function(){t.prototype.destroy.call(this),this.maskStack=null},e}(yn),_i=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i.glConst=WebGLRenderingContext.SCISSOR_TEST,i}return g0(e,t),e.prototype.getStackLength=function(){var t=this.maskStack[this.maskStack.length-1];return t?t._scissorCounter:0},/**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.MaskData} maskData - The mask data
     */e.prototype.push=function(t){var e=t.maskObject;e.renderable=!0;var i=t._scissorRect,r=e.getBounds(!0),n=this.renderer.gl;e.renderable=!1,i?r.fit(i):n.enable(n.SCISSOR_TEST),t._scissorCounter++,t._scissorRect=r,this._useCurrent()},/**
     * Pops scissor mask. MaskData is already removed from stack
     */e.prototype.pop=function(){var t=this.renderer.gl;this.getStackLength()>0?this._useCurrent():t.disable(t.SCISSOR_TEST)},/**
     * Setup renderer to use the current scissor data.
     * @private
     */e.prototype._useCurrent=function(){var t=this.maskStack[this.maskStack.length-1]._scissorRect,e=this.renderer.renderTexture.current,i=this.renderer.projection,r=i.transform,n=i.sourceFrame,s=i.destinationFrame,o=e?e.resolution:this.renderer.resolution,a=(t.x-n.x)*o+s.x,h=(t.y-n.y)*o+s.y,l=t.width*o,u=t.height*o;r&&(a+=r.tx*o,h+=r.ty*o),e||(h=this.renderer.height-u-h),this.renderer.gl.scissor(a,h,l,u)},e}(_e),_r=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i.glConst=WebGLRenderingContext.STENCIL_TEST,i}return g0(e,t),e.prototype.getStackLength=function(){var t=this.maskStack[this.maskStack.length-1];return t?t._stencilCounter:0},/**
     * Applies the Mask and adds it to the current stencil stack.
     *
     * @param {PIXI.MaskData} maskData - The mask data
     */e.prototype.push=function(t){var e=t.maskObject,i=this.renderer.gl,r=t._stencilCounter;0===r&&(// force use stencil texture in current framebuffer
this.renderer.framebuffer.forceStencil(),i.enable(i.STENCIL_TEST)),t._stencilCounter++,// Increment the reference stencil value where the new mask overlaps with the old ones.
i.colorMask(!1,!1,!1,!1),i.stencilFunc(i.EQUAL,r,this._getBitwiseMask()),i.stencilOp(i.KEEP,i.KEEP,i.INCR),e.renderable=!0,e.render(this.renderer),this.renderer.batch.flush(),e.renderable=!1,this._useCurrent()},/**
     * Pops stencil mask. MaskData is already removed from stack
     *
     * @param {PIXI.DisplayObject} maskObject - object of popped mask data
     */e.prototype.pop=function(t){var e=this.renderer.gl;0===this.getStackLength()?(// the stack is empty!
e.disable(e.STENCIL_TEST),e.clear(e.STENCIL_BUFFER_BIT),e.clearStencil(0)):(// Decrement the reference stencil value where the popped mask overlaps with the other ones
e.colorMask(!1,!1,!1,!1),e.stencilOp(e.KEEP,e.KEEP,e.DECR),t.renderable=!0,t.render(this.renderer),this.renderer.batch.flush(),t.renderable=!1,this._useCurrent())},/**
     * Setup renderer to use the current stencil data.
     * @private
     */e.prototype._useCurrent=function(){var t=this.renderer.gl;t.colorMask(!0,!0,!0,!0),t.stencilFunc(t.EQUAL,this.getStackLength(),this._getBitwiseMask()),t.stencilOp(t.KEEP,t.KEEP,t.KEEP)},/**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */e.prototype._getBitwiseMask=function(){return(1<<this.getStackLength())-1},e}(_e),_n=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */i.destinationFrame=null,/**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */i.sourceFrame=null,/**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */i.defaultFrame=null,/**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */i.projectionMatrix=new gz,/**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */i.transform=null,i)}return g0(e,t),/**
     * Updates the projection matrix based on a projection frame (which is a rectangle).
     *
     * Make sure to run `renderer.framebuffer.setViewport(destinationFrame)` after calling this.
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */e.prototype.update=function(t,e,i,r){this.destinationFrame=t||this.destinationFrame||this.defaultFrame,this.sourceFrame=e||this.sourceFrame||t,// Calculate object-space to clip-space projection
this.calculateProjection(this.destinationFrame,this.sourceFrame,i,r),this.transform&&this.projectionMatrix.append(this.transform);var n=this.renderer;n.globalUniforms.uniforms.projectionMatrix=this.projectionMatrix,n.globalUniforms.update(),n.shader.shader&&n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)},/**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */e.prototype.calculateProjection=function(t,e,i,r){var n=this.projectionMatrix,s=r?-1:1;n.identity(),n.a=1/e.width*2,n.d=s*(1/e.height*2),n.tx=-1-e.x*n.a,n.ty=-s-e.y*n.d},/**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */e.prototype.setTransform=function(t){// this._activeRenderTarget.transform = matrix;
},e}(yn),_s=new gG,_o=new gG,_a=new gG,_h=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * The clear background color as rgba
         * @member {number[]}
         */i.clearColor=e._backgroundColorRgba,// TODO move this property somewhere else!
/**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */i.defaultMaskStack=[],// empty render texture?
/**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */i.current=null,/**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */i.sourceFrame=new gG,/**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */i.destinationFrame=new gG,i)}return g0(e,t),/**
     * Bind the current render texture
     *
     * @param {PIXI.RenderTexture} [renderTexture] - RenderTexture to bind, by default its `null`, the screen
     * @param {PIXI.Rectangle} [sourceFrame] - part of screen that is mapped to the renderTexture
     * @param {PIXI.Rectangle} [destinationFrame] - part of renderTexture, by default it has the same size as sourceFrame
     */e.prototype.bind=function(t,e,i){void 0===t&&(t=null);var r,n,s,o=this.renderer;this.current=t,t?(s=(r=t.baseTexture).resolution,e||(_s.width=t.frame.width,_s.height=t.frame.height,e=_s),i||(_o.x=t.frame.x,_o.y=t.frame.y,_o.width=e.width,_o.height=e.height,i=_o),n=r.framebuffer):(s=o.resolution,e||(_s.width=o.screen.width,_s.height=o.screen.height,e=_s),i||((i=_s).width=e.width,i.height=e.height)),_a.x=i.x*s,_a.y=i.y*s,_a.width=i.width*s,_a.height=i.height*s,this.renderer.framebuffer.bind(n,_a),this.renderer.projection.update(i,e,s,!n),t?this.renderer.mask.setMaskStack(r.maskStack):this.renderer.mask.setMaskStack(this.defaultMaskStack),this.sourceFrame.copyFrom(e),this.destinationFrame.copyFrom(i)},/**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
     * @return {PIXI.Renderer} Returns itself.
     */e.prototype.clear=function(t,e){t=this.current?t||this.current.baseTexture.clearColor:t||this.clearColor,this.renderer.framebuffer.clear(t[0],t[1],t[2],t[3],e)},e.prototype.resize=function(){// resize the root only!
this.bind(null)},/**
     * Resets renderTexture state
     */e.prototype.reset=function(){this.bind(null)},e}(yn),_l=/** @class */function(){/**
     * Makes a new Pixi program
     *
     * @param program {WebGLProgram} webgl program
     * @param uniformData {Object} uniforms
     */function t(t,e){/**
         * The shader program
         *
         * @member {WebGLProgram}
         */this.program=t,/**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */this.uniformData=e,/**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */this.uniformGroups={}}return(/**
     * Destroys this program
     */t.prototype.destroy=function(){this.uniformData=null,this.uniformGroups=null,this.program=null},t)}(),_u=0,_c={textureCount:0},_d=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return i.destroyed=!1,// Validation check that this environment support `new Function`
i.systemCheck(),/**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */i.gl=null,i.shader=null,i.program=null,/**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */i.cache={},i.id=_u++,i}return g0(e,t),/**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */e.prototype.systemCheck=function(){if(!/**
 * Not all platforms allow to generate function code (e.g., `new Function`).
 * this provides the platform-level detection.
 *
 * @private
 * @returns {boolean}
 */function(){if("boolean"==typeof ES)return ES;try{/* eslint-disable no-new-func */var t=Function("param1","param2","param3","return param1[param2] === param3;");/* eslint-enable no-new-func */ES=!0===t({a:"b"},"a","b")}catch(t){ES=!1}return ES}())throw Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")},e.prototype.contextChange=function(t){this.gl=t,this.reset()},/**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} [dontSync] - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */e.prototype.bind=function(t,e){t.uniforms.globals=this.renderer.globalUniforms;var i=t.program,r=i.glPrograms[this.renderer.CONTEXT_UID]||this.generateShader(t);return this.shader=t,this.program!==i&&(this.program=i,this.gl.useProgram(r.program)),e||(_c.textureCount=0,this.syncUniformGroup(t.uniformGroup,_c)),r},/**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */e.prototype.setUniforms=function(t){var e=this.shader.program,i=e.glPrograms[this.renderer.CONTEXT_UID];e.syncUniforms(i.uniformData,t,this.renderer)},/* eslint-disable @typescript-eslint/explicit-module-boundary-types *//**
     *
     * syncs uniforms on the group
     * @param {*} group - the uniform group to sync
     * @param {*} [syncData] - this is data that is passed to the sync function and any nested sync functions
     */e.prototype.syncUniformGroup=function(t,e){var i=this.getglProgram();t.static&&t.dirtyId===i.uniformGroups[t.id]||(i.uniformGroups[t.id]=t.dirtyId,this.syncUniforms(t,i,e))},/**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */e.prototype.syncUniforms=function(t,e,i){(t.syncUniforms[this.shader.program.id]||this.createSyncGroups(t))(e.uniformData,t.uniforms,this.renderer,i)},/* eslint-enable @typescript-eslint/explicit-module-boundary-types */e.prototype.createSyncGroups=function(t){var e=this.getSignature(t,this.shader.program.uniformData);return this.cache[e]||(this.cache[e]=function(t,e){var i=["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];for(var r in t.uniforms){var n=e[r];if(!n){t.uniforms[r].group&&i.push('\n                    renderer.shader.syncUniformGroup(uv["'+r+'"], syncData);\n                ');continue}for(var s=t.uniforms[r],o=!1,a=0;a<y$.length;a++)if(y$[a].test(n,s)){i.push(y$[a].code(r,s)),o=!0;break}if(!o){var h=(1===n.size?yQ:y0)[n.type].replace("location",'ud["'+r+'"].location');i.push('\n            cv = ud["'+r+'"].value;\n            v = uv["'+r+'"];\n            '+h+";")}}/**
     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly
     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used
     * no matter which group is being used
     *
     */// eslint-disable-next-line no-new-func
return Function("ud","uv","renderer","syncData",i.join("\n"))}(t,this.shader.program.uniformData)),t.syncUniforms[this.shader.program.id]=this.cache[e],t.syncUniforms[this.shader.program.id]},/**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group - the uniform group to get signature of
     * @param {Object} uniformData - uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */e.prototype.getSignature=function(t,e){var i=t.uniforms,r=[];for(var n in i)r.push(n),e[n]&&r.push(e[n].type);return r.join("-")},/**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */e.prototype.getglProgram=function(){return this.shader?this.shader.program.glPrograms[this.renderer.CONTEXT_UID]:null},/**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader - the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */e.prototype.generateShader=function(t){var e=this.gl,i=t.program,r={};for(var n in i.attributeData)r[n]=i.attributeData[n].location;var s=yH(e,i.vertexSrc,i.fragmentSrc,r),o={};for(var n in i.uniformData){var a=i.uniformData[n];o[n]={location:e.getUniformLocation(s,n),value:yj(a.type,a.size)}}var h=new _l(s,o);return i.glPrograms[this.renderer.CONTEXT_UID]=h,h},/**
     * Resets ShaderSystem state, does not affect WebGL state
     */e.prototype.reset=function(){this.program=null,this.shader=null},/**
     * Destroys this System and removes all its textures
     */e.prototype.destroy=function(){// TODO implement destroy method for ShaderSystem
this.destroyed=!0},e}(yn),_p=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */i.gl=null,/**
         * State ID
         * @member {number}
         * @readonly
         */i.stateId=0,/**
         * Polygon offset
         * @member {number}
         * @readonly
         */i.polygonOffset=0,/**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */i.blendMode=Eo.NONE,/**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */i._blendEq=!1,/**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */i.map=[],// map functions for when we set state..
i.map[0]=i.setBlend,i.map[1]=i.setOffset,i.map[2]=i.setCullFace,i.map[3]=i.setDepthTest,i.map[4]=i.setFrontFace,/**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */i.checks=[],/**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */i.defaultState=new y4,i.defaultState.blend=!0,i)}return g0(e,t),e.prototype.contextChange=function(t){var e;this.gl=t,this.blendModes=(void 0===e&&(e=[]),// TODO - premultiply alpha would be different.
// add a boolean for that!
e[Eo.NORMAL]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.ADD]=[t.ONE,t.ONE],e[Eo.MULTIPLY]=[t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.SCREEN]=[t.ONE,t.ONE_MINUS_SRC_COLOR,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.OVERLAY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.DARKEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.LIGHTEN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.COLOR_DODGE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.COLOR_BURN]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.HARD_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.SOFT_LIGHT]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.DIFFERENCE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.EXCLUSION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.HUE]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.SATURATION]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.COLOR]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.LUMINOSITY]=[t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.NONE]=[0,0],// not-premultiplied blend modes
e[Eo.NORMAL_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA],e[Eo.ADD_NPM]=[t.SRC_ALPHA,t.ONE,t.ONE,t.ONE],e[Eo.SCREEN_NPM]=[t.SRC_ALPHA,t.ONE_MINUS_SRC_COLOR,t.ONE,t.ONE_MINUS_SRC_ALPHA],// composite operations
e[Eo.SRC_IN]=[t.DST_ALPHA,t.ZERO],e[Eo.SRC_OUT]=[t.ONE_MINUS_DST_ALPHA,t.ZERO],e[Eo.SRC_ATOP]=[t.DST_ALPHA,t.ONE_MINUS_SRC_ALPHA],e[Eo.DST_OVER]=[t.ONE_MINUS_DST_ALPHA,t.ONE],e[Eo.DST_IN]=[t.ZERO,t.SRC_ALPHA],e[Eo.DST_OUT]=[t.ZERO,t.ONE_MINUS_SRC_ALPHA],e[Eo.DST_ATOP]=[t.ONE_MINUS_DST_ALPHA,t.SRC_ALPHA],e[Eo.XOR]=[t.ONE_MINUS_DST_ALPHA,t.ONE_MINUS_SRC_ALPHA],// SUBTRACT from flash
e[Eo.SUBTRACT]=[t.ONE,t.ONE,t.ONE,t.ONE,t.FUNC_REVERSE_SUBTRACT,t.FUNC_ADD],e),this.set(this.defaultState),this.reset()},/**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */e.prototype.set=function(t){// TODO maybe to an object check? ( this.state === state )?
if(t=t||this.defaultState,this.stateId!==t.data){// order from least to most common
for(var e=this.stateId^t.data,i=0;e;)1&e&&this.map[i].call(this,!!(t.data&1<<i)),e>>=1,i++;this.stateId=t.data}// based on the above settings we check for specific modes..
// for example if blend is active we check and set the blend modes
// or of polygon offset is active we check the poly depth.
for(var i=0;i<this.checks.length;i++)this.checks[i](this,t)},/**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */e.prototype.forceState=function(t){t=t||this.defaultState;for(var e=0;e<this.map.length;e++)this.map[e].call(this,!!(t.data&1<<e));for(var e=0;e<this.checks.length;e++)this.checks[e](this,t);this.stateId=t.data},/**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */e.prototype.setBlend=function(t){this.updateCheck(e.checkBlendMode,t),this.gl[t?"enable":"disable"](this.gl.BLEND)},/**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */e.prototype.setOffset=function(t){this.updateCheck(e.checkPolygonOffset,t),this.gl[t?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)},/**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */e.prototype.setDepthTest=function(t){this.gl[t?"enable":"disable"](this.gl.DEPTH_TEST)},/**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */e.prototype.setCullFace=function(t){this.gl[t?"enable":"disable"](this.gl.CULL_FACE)},/**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */e.prototype.setFrontFace=function(t){this.gl.frontFace(this.gl[t?"CW":"CCW"])},/**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */e.prototype.setBlendMode=function(t){if(t!==this.blendMode){this.blendMode=t;var e=this.blendModes[t],i=this.gl;2===e.length?i.blendFunc(e[0],e[1]):i.blendFuncSeparate(e[0],e[1],e[2],e[3]),6===e.length?(this._blendEq=!0,i.blendEquationSeparate(e[4],e[5])):this._blendEq&&(this._blendEq=!1,i.blendEquationSeparate(i.FUNC_ADD,i.FUNC_ADD))}},/**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */e.prototype.setPolygonOffset=function(t,e){this.gl.polygonOffset(t,e)},// used
/**
     * Resets all the logic and disables the vaos
     */e.prototype.reset=function(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode=-1,this.setBlendMode(0)},/**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func - the checking function to add or remove
     * @param {boolean} value - should the check function be added or removed.
     */e.prototype.updateCheck=function(t,e){var i=this.checks.indexOf(t);e&&-1===i?this.checks.push(t):e||-1===i||this.checks.splice(i,1)},/**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System - the System to perform the state check on
     * @param {PIXI.State} state - the state that the blendMode will pulled from
     */e.checkBlendMode=function(t,e){t.setBlendMode(e.blendMode)},/**
     * A private little wrapper function that we call to check the polygon offset.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System - the System to perform the state check on
     * @param {PIXI.State} state - the state that the blendMode will pulled from
     */e.checkPolygonOffset=function(t,e){t.setPolygonOffset(1,e.polygonOffset)},e}(yn),_f=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * Count
         * @member {number}
         * @readonly
         */i.count=0,/**
         * Check count
         * @member {number}
         * @readonly
         */i.checkCount=0,/**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */i.maxIdle=gf.GC_MAX_IDLE,/**
         * Maximum number of item to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */i.checkCountMax=gf.GC_MAX_CHECK_COUNT,/**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */i.mode=gf.GC_MODE,i)}return g0(e,t),/**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */e.prototype.postrender=function(){this.renderer.renderingToScreen&&(this.count++,this.mode!==Eg.MANUAL&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))},/**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */e.prototype.run=function(){for(var t=this.renderer.texture,e=t.managedTextures,i=!1,r=0;r<e.length;r++){var n=e[r];// only supports non generated textures at the moment!
!n.framebuffer&&this.count-n.touched>this.maxIdle&&(t.destroyTexture(n,!0),e[r]=null,i=!0)}if(i){for(var s=0,r=0;r<e.length;r++)null!==e[r]&&(e[s++]=e[r]);e.length=s}},/**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */e.prototype.unload=function(t){var e=this.renderer.texture,i=t._texture;// only destroy non generated textures
i&&!i.framebuffer&&e.destroyTexture(i);for(var r=t.children.length-1;r>=0;r--)this.unload(t.children[r])},e}(yn),_m=function(t){/**
         * The WebGL texture
         * @member {WebGLTexture}
         */this.texture=t,/**
         * Width of texture that was used in texImage2D
         * @member {number}
         */this.width=-1,/**
         * Height of texture that was used in texImage2D
         * @member {number}
         */this.height=-1,/**
         * Texture contents dirty flag
         * @member {number}
         */this.dirtyId=-1,/**
         * Texture style dirty flag
         * @member {number}
         */this.dirtyStyleId=-1,/**
         * Whether mip levels has to be generated
         * @member {boolean}
         */this.mipmap=!1,/**
         * WrapMode copied from baseTexture
         * @member {number}
         */this.wrapMode=33071,/**
         * Type copied from baseTexture
         * @member {number}
         */this.type=6408,/**
         * Type copied from baseTexture
         * @member {number}
         */this.internalFormat=5121},_g=/** @class */function(t){/**
     * @param {PIXI.Renderer} renderer - The renderer this System works for.
     */function e(e){var i=t.call(this,e)||this;return(// TODO set to max textures...
/**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */i.boundTextures=[],/**
         * Current location
         * @member {number}
         * @readonly
         */i.currentLocation=-1,/**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */i.managedTextures=[],/**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */i._unknownBoundTextures=!1,/**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */i.unknownTexture=new g5,i)}return g0(e,t),/**
     * Sets up the renderer context and necessary buffers.
     */e.prototype.contextChange=function(){var t=this.gl=this.renderer.gl;this.CONTEXT_UID=this.renderer.CONTEXT_UID,this.webGLVersion=this.renderer.context.webGLVersion;var e=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);this.boundTextures.length=e;for(var i=0;i<e;i++)this.boundTextures[i]=null;// TODO move this.. to a nice make empty textures class..
this.emptyTextures={};var r=new _m(t.createTexture());t.bindTexture(t.TEXTURE_2D,r.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,new Uint8Array(4)),this.emptyTextures[t.TEXTURE_2D]=r,this.emptyTextures[t.TEXTURE_CUBE_MAP]=new _m(t.createTexture()),t.bindTexture(t.TEXTURE_CUBE_MAP,this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);for(var i=0;i<6;i++)t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,null);t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR);for(var i=0;i<this.boundTextures.length;i++)this.bind(null,i)},/**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture_ - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */e.prototype.bind=function(t,e){void 0===e&&(e=0);var i=this.gl;if(t){if((t=t.castToBaseTexture()).parentTextureArray)// TODO: report a warning
return;if(t.valid){t.touched=this.renderer.textureGC.count;var r=t._glTextures[this.CONTEXT_UID]||this.initTexture(t);this.boundTextures[e]!==t&&(this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),i.bindTexture(t.target,r.texture)),r.dirtyId!==t.dirtyId&&(this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),this.updateTexture(t)),this.boundTextures[e]=t}}else this.currentLocation!==e&&(this.currentLocation=e,i.activeTexture(i.TEXTURE0+e)),i.bindTexture(i.TEXTURE_2D,this.emptyTextures[i.TEXTURE_2D].texture),this.boundTextures[e]=null},/**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */e.prototype.reset=function(){this._unknownBoundTextures=!0,this.currentLocation=-1;for(var t=0;t<this.boundTextures.length;t++)this.boundTextures[t]=this.unknownTexture},/**
     * Unbind a texture
     * @param {PIXI.BaseTexture} texture - Texture to bind
     */e.prototype.unbind=function(t){var e=this.gl,i=this.boundTextures;if(this._unknownBoundTextures){this._unknownBoundTextures=!1;// someone changed webGL state,
// we have to be sure that our texture does not appear in multi-texture renderer samplers
for(var r=0;r<i.length;r++)i[r]===this.unknownTexture&&this.bind(null,r)}for(var r=0;r<i.length;r++)i[r]===t&&(this.currentLocation!==r&&(e.activeTexture(e.TEXTURE0+r),this.currentLocation=r),e.bindTexture(t.target,this.emptyTextures[t.target].texture),i[r]=null)},/**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */e.prototype.initTexture=function(t){var e=new _m(this.gl.createTexture());return(// guarantee an update..
e.dirtyId=-1,t._glTextures[this.CONTEXT_UID]=e,this.managedTextures.push(t),t.on("dispose",this.destroyTexture,this),e)},e.prototype.initTextureType=function(t,e){if(e.internalFormat=t.format,e.type=t.type,2===this.webGLVersion){var i=this.renderer.gl;t.type===i.FLOAT&&t.format===i.RGBA&&(e.internalFormat=i.RGBA32F),t.type===Eu.HALF_FLOAT&&(e.type=i.HALF_FLOAT),e.type===i.HALF_FLOAT&&t.format===i.RGBA&&(e.internalFormat=i.RGBA16F)}},/**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */e.prototype.updateTexture=function(t){var e=t._glTextures[this.CONTEXT_UID];if(e){var i=this.renderer;if(this.initTextureType(t,e),t.resource&&t.resource.upload(i,t,e));else{// default, renderTexture-like logic
var r=t.realWidth,n=t.realHeight,s=i.gl;(e.width!==r||e.height!==n||e.dirtyId<0)&&(e.width=r,e.height=n,s.texImage2D(t.target,0,e.internalFormat,r,n,0,t.format,e.type,null))}t.dirtyStyleId!==e.dirtyStyleId&&this.updateTextureStyle(t),e.dirtyId=t.dirtyId}},/**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture_ - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */e.prototype.destroyTexture=function(t,e){var i=this.gl;if((t=t.castToBaseTexture())._glTextures[this.CONTEXT_UID]&&(this.unbind(t),i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),t.off("dispose",this.destroyTexture,this),delete t._glTextures[this.CONTEXT_UID],!e)){var r=this.managedTextures.indexOf(t);-1!==r&&/**
 * Remove items from a javascript array without generating garbage
 *
 * @function removeItems
 * @memberof PIXI.utils
 * @param {Array<any>} arr - Array to remove elements from
 * @param {number} startIdx - starting index
 * @param {number} removeCount - how many to remove
 */function(t,e,i){var r,n=t.length;if(!(e>=n)&&0!==i){i=e+i>n?n-e:i;var s=n-i;for(r=e;r<s;++r)t[r]=t[r+i];t.length=s}}(this.managedTextures,r,1)}},/**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */e.prototype.updateTextureStyle=function(t){var e=t._glTextures[this.CONTEXT_UID];e&&(t.mipmap!==Ep.POW2&&2===this.webGLVersion||t.isPowerOfTwo?e.mipmap=t.mipmap>=1:e.mipmap=!1,2===this.webGLVersion||t.isPowerOfTwo?e.wrapMode=t.wrapMode:e.wrapMode=Ed.CLAMP,t.resource&&t.resource.style(this.renderer,t,e)||this.setStyle(t,e),e.dirtyStyleId=t.dirtyStyleId)},/**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {PIXI.GLTexture} glTexture
     */e.prototype.setStyle=function(t,e){var i=this.gl;if(e.mipmap&&i.generateMipmap(t.target),i.texParameteri(t.target,i.TEXTURE_WRAP_S,e.wrapMode),i.texParameteri(t.target,i.TEXTURE_WRAP_T,e.wrapMode),e.mipmap){/* eslint-disable max-len */i.texParameteri(t.target,i.TEXTURE_MIN_FILTER,t.scaleMode===Ec.LINEAR?i.LINEAR_MIPMAP_LINEAR:i.NEAREST_MIPMAP_NEAREST);/* eslint-disable max-len */var r=this.renderer.context.extensions.anisotropicFiltering;if(r&&t.anisotropicLevel>0&&t.scaleMode===Ec.LINEAR){var n=Math.min(t.anisotropicLevel,i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));i.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY_EXT,n)}}else i.texParameteri(t.target,i.TEXTURE_MIN_FILTER,t.scaleMode===Ec.LINEAR?i.LINEAR:i.NEAREST);i.texParameteri(t.target,i.TEXTURE_MAG_FILTER,t.scaleMode===Ec.LINEAR?i.LINEAR:i.NEAREST)},e}(yn),_y=new gz;!/** @class */function(t){/**
     * @param {object} [options] - The optional renderer parameters.
     * @param {number} [options.width=800] - The width of the screen.
     * @param {number} [options.height=600] - The height of the screen.
     * @param {HTMLCanvasElement} [options.view] - The canvas to use as a view, optional.
     * @param {boolean} [options.transparent=false] - If the render view is transparent.
     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
     *   resolutions other than 1.
     * @param {boolean} [options.antialias=false] - Sets antialias. If not available natively then FXAA
     *  antialiasing is used.
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
     *  The resolution of the renderer retina would be 2.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear
     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
     *  preserveDrawingBuffer to `true`.
     * @param {boolean} [options.preserveDrawingBuffer=false] - Enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the WebGL context.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     * @param {string} [options.powerPreference] - Parameter passed to WebGL context, set to "high-performance"
     *  for devices with dual graphics card.
     * @param {object} [options.context] - If WebGL context already exists, all parameters must be taken from it.
     * @public
     */function e(i){var r=t.call(this,En.WEBGL,i)||this;return(// the options will have been modified here in the super constructor with pixi's default settings..
i=r.options,/**
         * WebGL context, set by the contextSystem (this.context)
         *
         * @readonly
         * @member {WebGLRenderingContext}
         */r.gl=null,r.CONTEXT_UID=0,// TODO legacy!
/**
         * Internal signal instances of **runner**, these
         * are assigned to each system created.
         * @see PIXI.Runner
         * @name PIXI.Renderer#runners
         * @private
         * @type {object}
         * @readonly
         * @property {PIXI.Runner} destroy - Destroy runner
         * @property {PIXI.Runner} contextChange - Context change runner
         * @property {PIXI.Runner} reset - Reset runner
         * @property {PIXI.Runner} update - Update runner
         * @property {PIXI.Runner} postrender - Post-render runner
         * @property {PIXI.Runner} prerender - Pre-render runner
         * @property {PIXI.Runner} resize - Resize runner
         */r.runners={destroy:new gD("destroy"),contextChange:new gD("contextChange"),reset:new gD("reset"),update:new gD("update"),postrender:new gD("postrender"),prerender:new gD("prerender"),resize:new gD("resize")},/**
         * Global uniforms
         * @member {PIXI.UniformGroup}
         */r.globalUniforms=new yM({projectionMatrix:new gz},!0),/**
         * Mask system instance
         * @member {PIXI.systems.MaskSystem} mask
         * @memberof PIXI.Renderer#
         * @readonly
         */r.addSystem(_t,"mask")/**
             * Context system instance
             * @member {PIXI.systems.ContextSystem} context
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(yO,"context")/**
             * State system instance
             * @member {PIXI.systems.StateSystem} state
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_p,"state")/**
             * Shader system instance
             * @member {PIXI.systems.ShaderSystem} shader
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_d,"shader")/**
             * Texture system instance
             * @member {PIXI.systems.TextureSystem} texture
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_g,"texture")/**
             * Geometry system instance
             * @member {PIXI.systems.GeometrySystem} geometry
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(yU,"geometry")/**
             * Framebuffer system instance
             * @member {PIXI.systems.FramebufferSystem} framebuffer
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(yD,"framebuffer")/**
             * Scissor system instance
             * @member {PIXI.systems.ScissorSystem} scissor
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_i,"scissor")/**
             * Stencil system instance
             * @member {PIXI.systems.StencilSystem} stencil
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_r,"stencil")/**
             * Projection system instance
             * @member {PIXI.systems.ProjectionSystem} projection
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_n,"projection")/**
             * Texture garbage collector system instance
             * @member {PIXI.systems.TextureGCSystem} textureGC
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_f,"textureGC")/**
             * Filter system instance
             * @member {PIXI.systems.FilterSystem} filter
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(yR,"filter")/**
             * RenderTexture system instance
             * @member {PIXI.systems.RenderTextureSystem} renderTexture
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(_h,"renderTexture")/**
             * Batch system instance
             * @member {PIXI.systems.BatchSystem} batch
             * @memberof PIXI.Renderer#
             * @readonly
             */.addSystem(yP,"batch"),r.initPlugins(e.__plugins),i.context?r.context.initFromContext(i.context):r.context.initFromOptions({alpha:!!r.transparent,antialias:i.antialias,premultipliedAlpha:r.transparent&&"notMultiplied"!==r.transparent,stencil:!0,preserveDrawingBuffer:i.preserveDrawingBuffer,powerPreference:r.options.powerPreference}),/**
         * Flag if we are rendering to the screen vs renderTexture
         * @member {boolean}
         * @readonly
         * @default true
         */r.renderingToScreen=!0,!/**
 * Logs out the version and renderer information for this running instance of PIXI.
 * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
 * creating your renderer. Keep in mind that doing that will forever make you a jerk face.
 *
 * @static
 * @function sayHello
 * @memberof PIXI.utils
 * @param {string} type - The string renderer type to log.
 */function(t){var e;if(!gT){if(navigator.userAgent.toLowerCase().indexOf("chrome")>-1){var i=["\n %c %c %c PixiJS "+gw+" -  "+t+"   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n","background: #ff66a5; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff66a5; background: #030307; padding:5px 0;","background: #ff66a5; padding:5px 0;","background: #ffc3dc; padding:5px 0;","background: #ff66a5; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;","color: #ff2424; background: #fff; padding:5px 0;"];(e=window.console).log.apply(e,i)}else window.console&&window.console.log("PixiJS "+gw+" - "+t+" - http://www.pixijs.com/");gT=!0}}(2===r.context.webGLVersion?"WebGL 2":"WebGL 1"),r.resize(r.options.width,r.options.height),r)}g0(e,t),/**
     * Create renderer if WebGL is available. Overrideable
     * by the **@pixi/canvas-renderer** package to allow fallback.
     * throws error if WebGL is not available.
     * @static
     * @private
     */e.create=function(t){if(void 0===Ex&&(Ex=function(){var t={stencil:!0,failIfMajorPerformanceCaveat:gf.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT};try{if(!window.WebGLRenderingContext)return!1;var e=document.createElement("canvas"),i=e.getContext("webgl",t)||e.getContext("experimental-webgl",t),r=!!(i&&i.getContextAttributes().stencil);if(i){var n=i.getExtension("WEBGL_lose_context");n&&n.loseContext()}return i=null,r}catch(t){return!1}}()),Ex)return new e(t);throw Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')},/**
     * Add a new system to the renderer.
     * @param {Function} ClassRef - Class reference
     * @param {string} [name] - Property name for system, if not specified
     *        will use a static `name` property on the class itself. This
     *        name will be assigned as s property on the Renderer so make
     *        sure it doesn't collide with properties on Renderer.
     * @return {PIXI.Renderer} Return instance of renderer
     */e.prototype.addSystem=function(t,e){e||(e=t.name);var i=new t(this);if(this[e])throw Error('Whoops! The name "'+e+'" is already in use');for(var r in this[e]=i,this.runners)this.runners[r].add(i);/**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         *//**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         *//**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */return this},/**
     * Renders the object to its WebGL view
     *
     * @param {PIXI.DisplayObject} displayObject - The object to be rendered.
     * @param {PIXI.RenderTexture} [renderTexture] - The render texture to render to.
     * @param {boolean} [clear=true] - Should the canvas be cleared before the new render.
     * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.
     * @param {boolean} [skipUpdateTransform=false] - Should we skip the update transform pass?
     */e.prototype.render=function(t,e,i,r,n){// no point rendering if our context has been blown up!
if(// can be handy to know!
this.renderingToScreen=!e,this.runners.prerender.emit(),this.emit("prerender"),// apply a transform at a GPU level
this.projection.transform=r,!this.context.isLost){if(e||(this._lastObjectRendered=t),!n){// update the scene graph
var s=t.enableTempParent();t.updateTransform(),t.disableTempParent(s);// displayObject.hitArea = //TODO add a temp hit area
}this.renderTexture.bind(e),this.batch.currentRenderer.start(),(void 0!==i?i:this.clearBeforeRender)&&this.renderTexture.clear(),t.render(this),// apply transform..
this.batch.currentRenderer.flush(),e&&e.baseTexture.update(),this.runners.postrender.emit(),// reset transform after render
this.projection.transform=null,this.emit("postrender")}},/**
     * Resizes the WebGL view to the specified width and height.
     *
     * @param {number} screenWidth - The new width of the screen.
     * @param {number} screenHeight - The new height of the screen.
     */e.prototype.resize=function(e,i){t.prototype.resize.call(this,e,i),this.runners.resize.emit(e,i)},/**
     * Resets the WebGL state so you can render things however you fancy!
     *
     * @return {PIXI.Renderer} Returns itself.
     */e.prototype.reset=function(){return this.runners.reset.emit(),this},/**
     * Clear the frame buffer
     */e.prototype.clear=function(){this.renderTexture.bind(),this.renderTexture.clear()},/**
     * Removes everything from the renderer (event listeners, spritebatch, etc...)
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     *  See: https://github.com/pixijs/pixi.js/issues/2233
     */e.prototype.destroy=function(e){for(var i in this.runners.destroy.emit(),this.runners)this.runners[i].destroy();// call base destroy
t.prototype.destroy.call(this,e),// TODO nullify all the managers..
this.gl=null},/**
     * Adds a plugin to the renderer.
     *
     * @method
     * @param {string} pluginName - The name of the plugin.
     * @param {Function} ctor - The constructor function or class for the plugin.
     */e.registerPlugin=function(t,i){e.__plugins=e.__plugins||{},e.__plugins[t]=i}}(/** @class */function(t){/**
     * @param {string} system - The name of the system this renderer is for.
     * @param {object} [options] - The optional renderer parameters.
     * @param {number} [options.width=800] - The width of the screen.
     * @param {number} [options.height=600] - The height of the screen.
     * @param {HTMLCanvasElement} [options.view] - The canvas to use as a view, optional.
     * @param {boolean} [options.transparent=false] - If the render view is transparent.
     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for
     *   resolutions other than 1.
     * @param {boolean} [options.antialias=false] - Sets antialias
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
     *  resolution of the renderer retina would be 2.
     * @param {boolean} [options.preserveDrawingBuffer=false] - Enables drawing buffer preservation,
     *  enable this if you need to call toDataUrl on the WebGL context.
     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or
     *      not before the new render pass.
     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
     *  (shown if not transparent).
     */function e(e,i){void 0===e&&(e=En.UNKNOWN);var r=t.call(this)||this;return(// Add the default render options
(i=Object.assign({},gf.RENDER_OPTIONS,i)).roundPixels&&(gf.ROUND_PIXELS=i.roundPixels,gP("5.0.0","Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS",2)),/**
         * The supplied constructor options.
         *
         * @member {Object}
         * @readOnly
         */r.options=i,/**
         * The type of the renderer.
         *
         * @member {number}
         * @default PIXI.RENDERER_TYPE.UNKNOWN
         * @see PIXI.RENDERER_TYPE
         */r.type=e,/**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         *
         * @member {PIXI.Rectangle}
         */r.screen=new gG(0,0,i.width,i.height),/**
         * The canvas element that everything is drawn to.
         *
         * @member {HTMLCanvasElement}
         */r.view=i.view||document.createElement("canvas"),/**
         * The resolution / device pixel ratio of the renderer.
         *
         * @member {number}
         * @default 1
         */r.resolution=i.resolution||gf.RESOLUTION,/**
         * Whether the render view is transparent.
         *
         * @member {boolean}
         */r.transparent=i.transparent,/**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         *
         * @member {boolean}
         */r.autoDensity=i.autoDensity||i.autoResize||!1,// autoResize is deprecated, provides fallback support
/**
         * The value of the preserveDrawingBuffer flag affects whether or not the contents of
         * the stencil buffer is retained after rendering.
         *
         * @member {boolean}
         */r.preserveDrawingBuffer=i.preserveDrawingBuffer,/**
         * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
         * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every
         * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect
         * to clear the canvas every frame. Disable this by setting this to false. For example, if
         * your game has a canvas filling background image you often don't need this set.
         *
         * @member {boolean}
         * @default
         */r.clearBeforeRender=i.clearBeforeRender,/**
         * The background color as a number.
         *
         * @member {number}
         * @protected
         */r._backgroundColor=0,/**
         * The background color as an [R, G, B] array.
         *
         * @member {number[]}
         * @protected
         */r._backgroundColorRgba=[0,0,0,0],/**
         * The background color as a string.
         *
         * @member {string}
         * @protected
         */r._backgroundColorString="#000000",r.backgroundColor=i.backgroundColor||r._backgroundColor,/**
         * The last root object that the renderer tried to render.
         *
         * @member {PIXI.DisplayObject}
         * @protected
         */r._lastObjectRendered=null,/**
         * Collection of plugins.
         * @readonly
         * @member {object}
         */r.plugins={},r)}return g0(e,t),/**
     * Initialize the plugins.
     *
     * @protected
     * @param {object} staticMap - The dictionary of statically saved plugins.
     */e.prototype.initPlugins=function(t){for(var e in t)this.plugins[e]=new t[e](this)},Object.defineProperty(e.prototype,"width",{/**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         *
         * @member {number}
         * @readonly
         * @default 800
         */get:function(){return this.view.width},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"height",{/**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         *
         * @member {number}
         * @readonly
         * @default 600
         */get:function(){return this.view.height},enumerable:!1,configurable:!0}),/**
     * Resizes the screen and canvas to the specified width and height.
     * Canvas dimensions are multiplied by resolution.
     *
     * @param {number} screenWidth - The new width of the screen.
     * @param {number} screenHeight - The new height of the screen.
     */e.prototype.resize=function(t,e){this.screen.width=t,this.screen.height=e,this.view.width=t*this.resolution,this.view.height=e*this.resolution,this.autoDensity&&(this.view.style.width=t+"px",this.view.style.height=e+"px"),/**
         * Fired after view has been resized.
         *
         * @event PIXI.Renderer#resize
         * @param {number} screenWidth - The new width of the screen.
         * @param {number} screenHeight - The new height of the screen.
         */this.emit("resize",t,e)},/**
     * Useful function that returns a texture of the display object that can then be used to create sprites
     * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
     *
     * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from.
     * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.
     * @param {number} resolution - The resolution / device pixel ratio of the texture being generated.
     * @param {PIXI.Rectangle} [region] - The region of the displayObject, that shall be rendered,
     *        if no region is specified, defaults to the local bounds of the displayObject.
     * @return {PIXI.RenderTexture} A texture of the graphics object.
     */e.prototype.generateTexture=function(t,e,i,r){0===(r=r||t.getLocalBounds(null,!0)).width&&(r.width=1),0===r.height&&(r.height=1);var n=yd.create({width:0|r.width,height:0|r.height,scaleMode:e,resolution:i});return _y.tx=-r.x,_y.ty=-r.y,this.render(t,n,!1,_y,!!t.parent),n},/**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */e.prototype.destroy=function(t){for(var e in this.plugins)this.plugins[e].destroy(),this.plugins[e]=null;t&&this.view.parentNode&&this.view.parentNode.removeChild(this.view),// null-ing all objects, that's a tradition!
this.plugins=null,this.type=En.UNKNOWN,this.view=null,this.screen=null,this._tempDisplayObjectParent=null,this.options=null,this._backgroundColorRgba=null,this._backgroundColorString=null,this._lastObjectRendered=null},Object.defineProperty(e.prototype,"backgroundColor",{/**
         * The background color to fill if not transparent
         *
         * @member {number}
         */get:function(){return this._backgroundColor},set:function(t){var e,i;this._backgroundColor=t,this._backgroundColorString=(e=t.toString(16),"#"+(e="000000".substr(0,6-e.length)+e)),void 0===(i=this._backgroundColorRgba)&&(i=[]),i[0]=(t>>16&255)/255,i[1]=(t>>8&255)/255,i[2]=(255&t)/255},enumerable:!1,configurable:!0}),e}(/*@__PURE__*/tP(gm)));/**
 * Used by the batcher to draw batches.
 * Each one of these contains all information required to draw a bound geometry.
 *
 * @class
 * @memberof PIXI
 */var __=function(){this.texArray=null,this.blend=0,this.type=Ea.TRIANGLES,this.start=0,this.size=0,/**
         * data for uniforms or custom webgl state
         * @member {object}
         */this.data=null},_v=/** @class */function(){function t(){/**
         * inside textures array
         * @member {PIXI.BaseTexture[]}
         */this.elements=[],/**
         * Respective locations for textures
         * @member {number[]}
         */this.ids=[],/**
         * number of filled elements
         * @member {number}
         */this.count=0}return t.prototype.clear=function(){for(var t=0;t<this.count;t++)this.elements[t]=null;this.count=0},t}(),_x=/** @class */function(){/**
     * @param {number} size - The size of the buffer in bytes.
     */function t(t){/**
         * Underlying `ArrayBuffer` that holds all the data
         * and is of capacity `size`.
         *
         * @member {ArrayBuffer}
         */this.rawBinaryData=new ArrayBuffer(t),/**
         * View on the raw binary data as a `Uint32Array`.
         *
         * @member {Uint32Array}
         */this.uint32View=new Uint32Array(this.rawBinaryData),/**
         * View on the raw binary data as a `Float32Array`.
         *
         * @member {Float32Array}
         */this.float32View=new Float32Array(this.rawBinaryData)}return Object.defineProperty(t.prototype,"int8View",{/**
         * View on the raw binary data as a `Int8Array`.
         *
         * @member {Int8Array}
         */get:function(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"uint8View",{/**
         * View on the raw binary data as a `Uint8Array`.
         *
         * @member {Uint8Array}
         */get:function(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"int16View",{/**
         * View on the raw binary data as a `Int16Array`.
         *
         * @member {Int16Array}
         */get:function(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"uint16View",{/**
         * View on the raw binary data as a `Uint16Array`.
         *
         * @member {Uint16Array}
         */get:function(){return this._uint16View||(this._uint16View=new Uint16Array(this.rawBinaryData)),this._uint16View},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"int32View",{/**
         * View on the raw binary data as a `Int32Array`.
         *
         * @member {Int32Array}
         */get:function(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View},enumerable:!1,configurable:!0}),/**
     * Returns the view of the given type.
     *
     * @param {string} type - One of `int8`, `uint8`, `int16`,
     *    `uint16`, `int32`, `uint32`, and `float32`.
     * @return {object} typed array of given type
     */t.prototype.view=function(t){return this[t+"View"]},/**
     * Destroys all buffer references. Do not use after calling
     * this.
     */t.prototype.destroy=function(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null},t.sizeOf=function(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw Error(t+" isn't a valid view type")}},t}(),_b=/** @class */function(t){/**
     * This will hook onto the renderer's `contextChange`
     * and `prerender` signals.
     *
     * @param {PIXI.Renderer} renderer - The renderer this works for.
     */function e(e){var i=t.call(this,e)||this;return(/**
         * This is used to generate a shader that can
         * color each vertex based on a `aTextureId`
         * attribute that points to an texture in `uSampler`.
         *
         * This enables the objects with different textures
         * to be drawn in the same draw call.
         *
         * You can customize your shader by creating your
         * custom shader generator.
         *
         * @member {PIXI.BatchShaderGenerator}
         * @protected
         */i.shaderGenerator=null,/**
         * The class that represents the geometry of objects
         * that are going to be batched with this.
         *
         * @member {object}
         * @default PIXI.BatchGeometry
         * @protected
         */i.geometryClass=null,/**
         * Size of data being buffered per vertex in the
         * attribute buffers (in floats). By default, the
         * batch-renderer plugin uses 6:
         *
         * | aVertexPosition | 2 |
         * |-----------------|---|
         * | aTextureCoords  | 2 |
         * | aColor          | 1 |
         * | aTextureId      | 1 |
         *
         * @member {number}
         * @readonly
         */i.vertexSize=null,/**
         * The WebGL state in which this renderer will work.
         *
         * @member {PIXI.State}
         * @readonly
         */i.state=y4.for2d(),/**
         * The number of bufferable objects before a flush
         * occurs automatically.
         *
         * @member {number}
         * @default settings.SPRITE_BATCH_SIZE * 4
         */i.size=4*gf.SPRITE_BATCH_SIZE,/**
         * Total count of all vertices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */i._vertexCount=0,/**
         * Total count of all indices used by the currently
         * buffered objects.
         *
         * @member {number}
         * @private
         */i._indexCount=0,/**
         * Buffer of objects that are yet to be rendered.
         *
         * @member {PIXI.DisplayObject[]}
         * @private
         */i._bufferedElements=[],/**
         * Data for texture batch builder, helps to save a bit of CPU on a pass.
         * @type {PIXI.BaseTexture[]}
         * @private
         */i._bufferedTextures=[],/**
         * Number of elements that are buffered and are
         * waiting to be flushed.
         *
         * @member {number}
         * @private
         */i._bufferSize=0,/**
         * This shader is generated by `this.shaderGenerator`.
         *
         * It is generated specifically to handle the required
         * number of textures being batched together.
         *
         * @member {PIXI.Shader}
         * @protected
         */i._shader=null,/**
         * Pool of `this.geometryClass` geometry objects
         * that store buffers. They are used to pass data
         * to the shader on each draw call.
         *
         * These are never re-allocated again, unless a
         * context change occurs; however, the pool may
         * be expanded if required.
         *
         * @member {PIXI.Geometry[]}
         * @private
         * @see PIXI.AbstractBatchRenderer.contextChange
         */i._packedGeometries=[],/**
         * Size of `this._packedGeometries`. It can be expanded
         * if more than `this._packedGeometryPoolSize` flushes
         * occur in a single frame.
         *
         * @member {number}
         * @private
         */i._packedGeometryPoolSize=2,/**
         * A flush may occur multiple times in a single
         * frame. On iOS devices or when
         * `settings.CAN_UPLOAD_SAME_BUFFER` is false, the
         * batch renderer does not upload data to the same
         * `WebGLBuffer` for performance reasons.
         *
         * This is the index into `packedGeometries` that points to
         * geometry holding the most recent buffers.
         *
         * @member {number}
         * @private
         */i._flushId=0,/**
         * Pool of `ViewableBuffer` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing attributes.
         *
         * The first buffer has a size of 8; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {PIXI.ViewableBuffer[]}
         * @private
         * @see PIXI.AbstractBatchRenderer#getAttributeBuffer
         */i._aBuffers={},/**
         * Pool of `Uint16Array` objects that are sorted in
         * order of increasing size. The flush method uses
         * the buffer with the least size above the amount
         * it requires. These are used for passing indices.
         *
         * The first buffer has a size of 12; each subsequent
         * buffer has double capacity of its previous.
         *
         * @member {Uint16Array[]}
         * @private
         * @see PIXI.AbstractBatchRenderer#getIndexBuffer
         */i._iBuffers={},/**
         * Maximum number of textures that can be uploaded to
         * the GPU under the current context. It is initialized
         * properly in `this.contextChange`.
         *
         * @member {number}
         * @see PIXI.AbstractBatchRenderer#contextChange
         * @readonly
         */i.MAX_TEXTURES=1,i.renderer.on("prerender",i.onPrerender,i),e.runners.contextChange.add(i),i._dcIndex=0,i._aIndex=0,i._iIndex=0,i._attributeBuffer=null,i._indexBuffer=null,i._tempBoundTextures=[],i)}return g0(e,t),/**
     * Handles the `contextChange` signal.
     *
     * It calculates `this.MAX_TEXTURES` and allocating the
     * packed-geometry object pool.
     */e.prototype.contextChange=function(){var t=this.renderer.gl;gf.PREFER_ENV===Er.WEBGL_LEGACY?this.MAX_TEXTURES=1:(// step 1: first check max textures the GPU can handle.
this.MAX_TEXTURES=Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),gf.SPRITE_MAX_TEXTURES),// step 2: check the maximum number of if statements the shader can have too..
this.MAX_TEXTURES=function(t,e){if(0===t)throw Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");for(var i=e.createShader(e.FRAGMENT_SHADER);;){var r="precision mediump float;\nvoid main(void){\nfloat test = 0.1;\n%forloop%\ngl_FragColor = vec4(0.0);\n}".replace(/%forloop%/gi,function(t){for(var e="",i=0;i<t;++i)i>0&&(e+="\nelse "),i<t-1&&(e+="if(test == "+i+".0){}");return e}(t));if(e.shaderSource(i,r),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS))break;t=t/2|0}return t}(this.MAX_TEXTURES,t)),this._shader=this.shaderGenerator.generateShader(this.MAX_TEXTURES);// we use the second shader as the first one depending on your browser
// may omit aTextureId as it is not used by the shader so is optimized out.
for(var e=0;e<this._packedGeometryPoolSize;e++)/* eslint-disable max-len */this._packedGeometries[e]=new this.geometryClass;this.initFlushBuffers()},/**
     * Makes sure that static and dynamic flush pooled objects have correct dimensions
     */e.prototype.initFlushBuffers=function(){for(var t=e._drawCallPool,i=e._textureArrayPool,r=this.size/4,n=Math.floor(r/this.MAX_TEXTURES)+1;t.length<r;)t.push(new __);for(;i.length<n;)i.push(new _v);for(var s=0;s<this.MAX_TEXTURES;s++)this._tempBoundTextures[s]=null},/**
     * Handles the `prerender` signal.
     *
     * It ensures that flushes start from the first geometry
     * object again.
     */e.prototype.onPrerender=function(){this._flushId=0},/**
     * Buffers the "batchable" object. It need not be rendered
     * immediately.
     *
     * @param {PIXI.DisplayObject} element - the element to render when
     *    using this renderer
     */e.prototype.render=function(t){t._texture.valid&&(this._vertexCount+t.vertexData.length/2>this.size&&this.flush(),this._vertexCount+=t.vertexData.length/2,this._indexCount+=t.indices.length,this._bufferedTextures[this._bufferSize]=t._texture.baseTexture,this._bufferedElements[this._bufferSize++]=t)},e.prototype.buildTexturesAndDrawCalls=function(){var t=this._bufferedTextures,i=this.MAX_TEXTURES,r=e._textureArrayPool,n=this.renderer.batch,s=this._tempBoundTextures,o=this.renderer.textureGC.count,a=++g5._globalBatch,h=0,l=r[0],u=0;n.copyBoundTextures(s,i);for(var c=0;c<this._bufferSize;++c){var d=t[c];t[c]=null,d._batchEnabled!==a&&(l.count>=i&&(n.boundArray(l,s,a,i),this.buildDrawCalls(l,u,c),u=c,l=r[++h],++a),d._batchEnabled=a,d.touched=o,l.elements[l.count++]=d)}l.count>0&&(n.boundArray(l,s,a,i),this.buildDrawCalls(l,u,this._bufferSize),++h,++a);// Clean-up
for(var c=0;c<s.length;c++)s[c]=null;g5._globalBatch=a},/**
     * Populating drawcalls for rendering
     *
     * @param {PIXI.BatchTextureArray} texArray
     * @param {number} start
     * @param {number} finish
     */e.prototype.buildDrawCalls=function(t,i,r){var n=this._bufferedElements,s=this._attributeBuffer,o=this._indexBuffer,a=this.vertexSize,h=e._drawCallPool,l=this._dcIndex,u=this._aIndex,c=this._iIndex,d=h[l];d.start=this._iIndex,d.texArray=t;for(var p=i;p<r;++p){var f=n[p],m=gS[f._texture.baseTexture.alphaMode?1:0][f.blendMode];n[p]=null,i<p&&d.blend!==m&&(d.size=c-d.start,i=p,(d=h[++l]).texArray=t,d.start=c),this.packInterleavedGeometry(f,s,o,u,c),u+=f.vertexData.length/2*a,c+=f.indices.length,d.blend=m}i<r&&(d.size=c-d.start,++l),this._dcIndex=l,this._aIndex=u,this._iIndex=c},/**
     * Bind textures for current rendering
     *
     * @param {PIXI.BatchTextureArray} texArray
     */e.prototype.bindAndClearTexArray=function(t){for(var e=this.renderer.texture,i=0;i<t.count;i++)e.bind(t.elements[i],t.ids[i]),t.elements[i]=null;t.count=0},e.prototype.updateGeometry=function(){var t=this._packedGeometries,e=this._attributeBuffer,i=this._indexBuffer;gf.CAN_UPLOAD_SAME_BUFFER?(// lets use the faster option, always use buffer number 0
t[this._flushId]._buffer.update(e.rawBinaryData),t[this._flushId]._indexBuffer.update(i),this.renderer.geometry.updateBuffers()):(this._packedGeometryPoolSize<=this._flushId&&(this._packedGeometryPoolSize++,t[this._flushId]=new this.geometryClass),t[this._flushId]._buffer.update(e.rawBinaryData),t[this._flushId]._indexBuffer.update(i),this.renderer.geometry.bind(t[this._flushId]),this.renderer.geometry.updateBuffers(),this._flushId++)},e.prototype.drawBatches=function(){// Upload textures and do the draw calls
for(var t=this._dcIndex,i=this.renderer,r=i.gl,n=i.state,s=e._drawCallPool,o=null,a=0;a<t;a++){var h=s[a],l=h.texArray,u=h.type,c=h.size,d=h.start,p=h.blend;o!==l&&(o=l,this.bindAndClearTexArray(l)),this.state.blendMode=p,n.set(this.state),r.drawElements(u,c,r.UNSIGNED_SHORT,2*d)}},/**
     * Renders the content _now_ and empties the current batch.
     */e.prototype.flush=function(){0!==this._vertexCount&&(this._attributeBuffer=this.getAttributeBuffer(this._vertexCount),this._indexBuffer=this.getIndexBuffer(this._indexCount),this._aIndex=0,this._iIndex=0,this._dcIndex=0,this.buildTexturesAndDrawCalls(),this.updateGeometry(),this.drawBatches(),// reset elements buffer for the next flush
this._bufferSize=0,this._vertexCount=0,this._indexCount=0)},/**
     * Starts a new sprite batch.
     */e.prototype.start=function(){this.renderer.state.set(this.state),this.renderer.shader.bind(this._shader),gf.CAN_UPLOAD_SAME_BUFFER&&this.renderer.geometry.bind(this._packedGeometries[this._flushId])},/**
     * Stops and flushes the current batch.
     */e.prototype.stop=function(){this.flush()},/**
     * Destroys this `AbstractBatchRenderer`. It cannot be used again.
     */e.prototype.destroy=function(){for(var e=0;e<this._packedGeometryPoolSize;e++)this._packedGeometries[e]&&this._packedGeometries[e].destroy();this.renderer.off("prerender",this.onPrerender,this),this._aBuffers=null,this._iBuffers=null,this._packedGeometries=null,this._attributeBuffer=null,this._indexBuffer=null,this._shader&&(this._shader.destroy(),this._shader=null),t.prototype.destroy.call(this)},/**
     * Fetches an attribute buffer from `this._aBuffers` that
     * can hold atleast `size` floats.
     *
     * @param {number} size - minimum capacity required
     * @return {ViewableBuffer} - buffer than can hold atleast `size` floats
     * @private
     */e.prototype.getAttributeBuffer=function(t){// 8 vertices is enough for 2 quads
var e=gM(Math.ceil(t/8)),i=gA(e),r=8*e;this._aBuffers.length<=i&&(this._iBuffers.length=i+1);var n=this._aBuffers[r];return n||(this._aBuffers[r]=n=new _x(r*this.vertexSize*4)),n},/**
     * Fetches an index buffer from `this._iBuffers` that can
     * have at least `size` capacity.
     *
     * @param {number} size - minimum required capacity
     * @return {Uint16Array} - buffer that can fit `size`
     *    indices.
     * @private
     */e.prototype.getIndexBuffer=function(t){// 12 indices is enough for 2 quads
var e=gM(Math.ceil(t/12)),i=gA(e),r=12*e;this._iBuffers.length<=i&&(this._iBuffers.length=i+1);var n=this._iBuffers[i];return n||(this._iBuffers[i]=n=new Uint16Array(r)),n},/**
     * Takes the four batching parameters of `element`, interleaves
     * and pushes them into the batching attribute/index buffers given.
     *
     * It uses these properties: `vertexData` `uvs`, `textureId` and
     * `indicies`. It also uses the "tint" of the base-texture, if
     * present.
     *
     * @param {PIXI.Sprite} element - element being rendered
     * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
     * @param {Uint16Array} indexBuffer - index buffer
     * @param {number} aIndex - number of floats already in the attribute buffer
     * @param {number} iIndex - number of indices already in `indexBuffer`
     */e.prototype.packInterleavedGeometry=function(t,e,i,r,n){// lets not worry about tint! for now..
for(var s=e.uint32View,o=e.float32View,a=r/this.vertexSize,h=t.uvs,l=t.indices,u=t.vertexData,c=t._texture.baseTexture._batchLocation,d=Math.min(t.worldAlpha,1),p=d<1&&t._texture.baseTexture.alphaMode?/**
 * premultiplies tint
 *
 * @memberof PIXI.utils
 * @function premultiplyTint
 * @param {number} tint - integer RGB
 * @param {number} alpha - floating point alpha (0.0-1.0)
 * @returns {number} tint multiplied by alpha
 */function(t,e){if(1===e)return(255*e<<24)+t;if(0===e)return 0;var i=t>>16&255,r=t>>8&255,n=255&t;return i=i*e+.5|0,r=r*e+.5|0,n=n*e+.5|0,(255*e<<24)+(i<<16)+(r<<8)+n}(t._tintRGB,d):t._tintRGB+(255*d<<24),f=0;f<u.length;f+=2)o[r++]=u[f],o[r++]=u[f+1],o[r++]=h[f],o[r++]=h[f+1],s[r++]=p,o[r++]=c;for(var f=0;f<l.length;f++)i[n++]=a+l[f]},/**
     * Pool of `BatchDrawCall` objects that `flush` used
     * to create "batches" of the objects being rendered.
     *
     * These are never re-allocated again.
     * Shared between all batch renderers because it can be only one "flush" working at the moment.
     *
     * @static
     * @member {PIXI.BatchDrawCall[]}
     */e._drawCallPool=[],/**
     * Pool of `BatchDrawCall` objects that `flush` used
     * to create "batches" of the objects being rendered.
     *
     * These are never re-allocated again.
     * Shared between all batch renderers because it can be only one "flush" working at the moment.
     *
     * @static
     * @member {PIXI.BatchTextureArray[]}
     */e._textureArrayPool=[],e}(yC),_E=/** @class */function(){/**
     * @param {string} vertexSrc - Vertex shader
     * @param {string} fragTemplate - Fragment shader template
     */function t(t,e){if(/**
         * Reference to the vertex shader source.
         *
         * @member {string}
         */this.vertexSrc=t,/**
         * Reference to the fragement shader template. Must contain "%count%" and "%forloop%".
         *
         * @member {string}
         */this.fragTemplate=e,this.programCache={},this.defaultGroupCache={},0>e.indexOf("%count%"))throw Error('Fragment template must contain "%count%".');if(0>e.indexOf("%forloop%"))throw Error('Fragment template must contain "%forloop%".')}return t.prototype.generateShader=function(t){if(!this.programCache[t]){for(var e=new Int32Array(t),i=0;i<t;i++)e[i]=i;this.defaultGroupCache[t]=yM.from({uSamplers:e},!0);var r=this.fragTemplate;r=(r=r.replace(/%count%/gi,""+t)).replace(/%forloop%/gi,this.generateSampleSrc(t)),this.programCache[t]=new y3(this.vertexSrc,r)}var n={tint:new Float32Array([1,1,1,1]),translationMatrix:new gz,default:this.defaultGroupCache[t]};return new y5(this.programCache[t],n)},t.prototype.generateSampleSrc=function(t){var e="";e+="\n\n";for(var i=0;i<t;i++)i>0&&(e+="\nelse "),i<t-1&&(e+="if(vTextureId < "+i+".5)"),e+="\n{\n	color = texture2D(uSamplers["+i+"], vTextureCoord);\n}";return e+"\n\n"},t}(),_T=/** @class */function(t){/**
     * @param {boolean} [_static=false] - Optimization flag, where `false`
     *        is updated every frame, `true` doesn't change frame-to-frame.
     */function e(e){void 0===e&&(e=!1);var i=t.call(this)||this;return(/**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */i._buffer=new yg(null,e,!1),/**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */i._indexBuffer=new yg(null,e,!0),i.addAttribute("aVertexPosition",i._buffer,2,!1,Eu.FLOAT).addAttribute("aTextureCoord",i._buffer,2,!1,Eu.FLOAT).addAttribute("aColor",i._buffer,4,!0,Eu.UNSIGNED_BYTE).addAttribute("aTextureId",i._buffer,1,!0,Eu.FLOAT).addIndex(i._indexBuffer),i)}return g0(e,t),e}(yE),_w="precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",_S="varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";/** @class */(function(){function t(){}return(/**
     * Create a new BatchRenderer plugin for Renderer. this convenience can provide an easy way
     * to extend BatchRenderer with all the necessary pieces.
     * @example
     * const fragment = `
     * varying vec2 vTextureCoord;
     * varying vec4 vColor;
     * varying float vTextureId;
     * uniform sampler2D uSamplers[%count%];
     *
     * void main(void){
     *     vec4 color;
     *     %forloop%
     *     gl_FragColor = vColor * vec4(color.a - color.rgb, color.a);
     * }
     * `;
     * const InvertBatchRenderer = PIXI.BatchPluginFactory.create({ fragment });
     * PIXI.Renderer.registerPlugin('invert', InvertBatchRenderer);
     * const sprite = new PIXI.Sprite();
     * sprite.pluginName = 'invert';
     *
     * @static
     * @param {object} [options]
     * @param {string} [options.vertex=PIXI.BatchPluginFactory.defaultVertexSrc] - Vertex shader source
     * @param {string} [options.fragment=PIXI.BatchPluginFactory.defaultFragmentTemplate] - Fragment shader template
     * @param {number} [options.vertexSize=6] - Vertex size
     * @param {object} [options.geometryClass=PIXI.BatchGeometry]
     * @return {*} New batch renderer plugin
     */t.create=function(t){var e=Object.assign({vertex:_w,fragment:_S,geometryClass:_T,vertexSize:6},t),i=e.vertex,r=e.fragment,n=e.vertexSize,s=e.geometryClass;return /** @class */function(t){function e(e){var o=t.call(this,e)||this;return o.shaderGenerator=new _E(i,r),o.geometryClass=s,o.vertexSize=n,o}return g0(e,t),e}(_b)},Object.defineProperty(t,"defaultVertexSrc",{/**
         * The default vertex shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return _w},enumerable:!1,configurable:!0}),Object.defineProperty(t,"defaultFragmentTemplate",{/**
         * The default fragment shader source
         *
         * @static
         * @type {string}
         * @constant
         */get:function(){return _S},enumerable:!1,configurable:!0}),t)})().create();/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** *//* global Reflect, Promise */var _M=function(t,e){return(_M=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},_A=/** @class */function(){function t(){}return(/**
     * Called after a resource is loaded.
     * @see PIXI.Loader.loaderMiddleware
     * @param {PIXI.LoaderResource} resource
     * @param {function} next
     */t.use=function(t,e){t.data&&t.type===ga.TYPE.IMAGE&&(t.texture=yu.fromLoader(t.data,t.url,t.name)),e()},t)}(),_R=/** @class */function(t){function e(i,r){for(var n=t.call(this,i,r)||this,s=0;s<e._plugins.length;++s){var o=e._plugins[s],a=o.pre,h=o.use;a&&n.pre(a),h&&n.use(h)}return(/**
         * If this loader cannot be destroyed.
         * @member {boolean}
         * @default false
         * @private
         */n._protected=!1,n)}return!function(t,e){function i(){this.constructor=t}_M(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}(e,t),/**
     * Destroy the loader, removes references.
     * @memberof PIXI.Loader#
     * @method destroy
     * @public
     */e.prototype.destroy=function(){this._protected||this.reset()},Object.defineProperty(e,"shared",{/**
         * A premade instance of the loader that can be used to load resources.
         * @name shared
         * @type {PIXI.Loader}
         * @static
         * @memberof PIXI.Loader
         */get:function(){var t=e._shared;return t||((t=new e)._protected=!0,e._shared=t),t},enumerable:!1,configurable:!0}),/**
     * Adds a Loader plugin for the global shared loader and all
     * new Loader instances created.
     *
     * @static
     * @method registerPlugin
     * @memberof PIXI.Loader
     * @param {PIXI.ILoaderPlugin} plugin - The plugin to add
     * @return {PIXI.Loader} Reference to PIXI.Loader for chaining
     */e.registerPlugin=function(t){return e._plugins.push(t),t.add&&t.add(),e},/**
     * Collection of all installed `use` middleware for Loader.
     *
     * @static
     * @member {Array<PIXI.ILoaderPlugin>} _plugins
     * @memberof PIXI.Loader
     * @private
     */e._plugins=[],e}(gd);// parse any blob into more usable objects (e.g. Image)
_R.registerPlugin({use:{caching:/**
 * A simple in-memory cache for resource.
 *
 * @memberof middleware
 * @function caching
 * @example
 * import { Loader, middleware } from 'resource-loader';
 * const loader = new Loader();
 * loader.use(middleware.caching);
 * @param {Resource} resource - Current Resource
 * @param {function} next - Callback when complete
 */function(t,e){var i=this;ge[t.url]?(t.data=ge[t.url],t.complete()):t.onComplete.once(function(){return ge[i.url]=i.data}),e()},parsing:/**
 * A middleware for transforming XHR loaded Blobs into more useful objects
 *
 * @memberof middleware
 * @function parsing
 * @example
 * import { Loader, middleware } from 'resource-loader';
 * const loader = new Loader();
 * loader.use(middleware.parsing);
 * @param {Resource} resource - Current Resource
 * @param {function} next - Callback when complete
 */function(t,e){if(!t.data){e();return}// if this was an XHR load of a blob
if(t.xhr&&t.xhrType===ga.XHR_RESPONSE_TYPE.BLOB){// if there is no blob support we probably got a binary string back
if(window.Blob&&"string"!=typeof t.data){if(0===t.data.type.indexOf("image")){var i=gu.createObjectURL(t.data);t.blob=t.data,t.data=new Image,t.data.src=i,t.type=ga.TYPE.IMAGE,// TODO: Is this correct? Will the image be invalid after revoking?
t.data.onload=function(){gu.revokeObjectURL(i),t.data.onload=null,e()};return}}else{var r=t.xhr.getResponseHeader("content-type");// this is an image, convert the binary string into a data url
if(r&&0===r.indexOf("image")){t.data=new Image,t.data.src="data:"+r+";base64,"+/**
 * Encodes binary into base64.
 *
 * @function encodeBinary
 * @param {string} input The input data to encode.
 * @returns {string} The encoded base64 string
 */function(t){for(var e="",i=0;i<t.length;){for(var r=[0,0,0],n=[0,0,0,0],s=0;s<r.length;++s)i<t.length?// https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
r[s]=255&t.charCodeAt(i++):r[s]=0;switch(// Get each encoded character, 6 bits at a time
// index 1: first 6 bits
n[0]=r[0]>>2,n[1]=(3&r[0])<<4|r[1]>>4,n[2]=(15&r[1])<<2|r[2]>>6,n[3]=63&r[2],i-(t.length-1)){case 2:// Set last 2 characters to padding char
n[3]=64,n[2]=64;break;case 1:// Set last character to padding char
n[3]=64}// Now we will grab each appropriate character out of our keystring
// based on our index array and append it to the output string
for(var o=0;o<n.length;++o)e+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(n[o])}return e}(t.xhr.responseText),t.type=ga.TYPE.IMAGE,t.data.onload=function(){t.data.onload=null,e()};return}}}e()}}.parsing}),// parse any Image objects into textures
_R.registerPlugin(_A),/** @class */function(){function t(){}/**
     * Called on application constructor
     * @param {object} options
     * @private
     */t.init=function(t){t=Object.assign({sharedLoader:!1},t),/**
         * Loader instance to help with asset loading.
         * @name PIXI.Application#loader
         * @type {PIXI.Loader}
         * @readonly
         */this.loader=t.sharedLoader?_R.shared:new _R},/**
     * Called when application destroyed
     * @private
     */t.destroy=function(){this.loader&&(this.loader.destroy(),this.loader=null)}}();var _C=function(){function t(t,e){this._output=e,this._input=t}return Object.defineProperty(t.prototype,"destination",{get:function(){return this._input},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"filters",{get:function(){return this._filters},set:function(t){var e=this;if(this._filters&&(this._filters.forEach(function(t){t&&t.disconnect()}),this._filters=null,this._input.connect(this._output)),t&&t.length){this._filters=t.slice(0),this._input.disconnect();var i=null;t.forEach(function(t){null===i?e._input.connect(t.destination):i.connect(t.destination),i=t}),i.connect(this._output)}},enumerable:!0,configurable:!0}),t.prototype.destroy=function(){this.filters=null,this._input=null,this._output=null},t}(),_P=function(){function t(t,e){this.init(t,e)}return t.prototype.init=function(t,e){this.destination=t,this.source=e||t},t.prototype.connect=function(t){this.source.connect(t)},t.prototype.disconnect=function(){this.source.disconnect()},t.prototype.destroy=function(){this.disconnect(),this.destination=null,this.source=null},t}(),_I=function(t,e){return(_I=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)};function _O(t,e){function i(){this.constructor=t}_I(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}var _L,_N,_D,_F,_B,_U,_G,_k,_H,_z,_j,_V,_X,_W,_Y,_q,_K,_J,_Z,_$,_Q,_0,_1,_2,_3,_5,_4,_6,_8,_7,_9,vt,ve,vi,vr,vn,vs,vo,va,vh,vl,vu,vc,vd,vp,vf,vm,vg,vy,v_,vv,vx,vb,vE,vT,vw,vS,vM,vA,vR,vC,vP,vI,vO,vL,vN,vD,vF,vB,vU,vG,vk,vH,vz,vj,vV,vX,vW,vY,vq,vK,vJ,vZ,v$,vQ,v0,v1,v2,v3,v5,v4,v6,v8,v7,v9,xt,xe,xi,xr,xn,xs,xo,xa,xh,xl,xu,xc,xd,xp,xf,xm,xg,xy,x_,xv,xx,xb,xE,xT,xw,xS,xM,xA,xR,xC,xP,xI,xO,xL,xN,xD,xF,xB,xU,xG,xk,xH,xz,xj,xV,xX,xW,xY,xq,xK,xJ,xZ,x$,xQ,x0,x1,x2,x3,x5,x4,x6,x8,x7,x9,bt,be,bi,br,bn,bs,bo,ba,bh,bl,bu,bc,bd,bp,bf,bm,bg,by,b_,bv,bx,bb,bE,bT,bw,bS,bM,bA,bR,bC,bP,bI,bO,bL,bN,bD,bF,bB,bU,bG,bk,bH,bz,bj,bV,bX,bW,bY,bq,bK,bJ,bZ,b$,bQ,b0,b1,b2,b3,b5,b4,b6,b8,b7,b9,Et,Ee,Ei,Er,En,Es,Eo,Ea,Eh,El,Eu,Ec,Ed,Ep,Ef,Em,Eg,Ey,E_,Ev,Ex,Eb,EE,ET,Ew,ES,EM,EA,ER,EC,EP,EI=function(){return(EI=Object.assign||function(t){for(var e,i=1,r=arguments.length;i<r;i++)for(var n in e=arguments[i])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}).apply(this,arguments)},EO=function(){function t(){}return t.setParamValue=function(t,e){if(t.setValueAtTime){var i=EM.context;t.setValueAtTime(e,i.audioContext.currentTime)}else t.value=e;return e},t}(),EL=0,EN=function(t){function e(e){var i=t.call(this)||this;return i.id=EL++,i._media=null,i._paused=!1,i._muted=!1,i._elapsed=0,i.init(e),i}return _O(e,t),e.prototype.set=function(t,e){if(void 0===this[t])throw Error("Property with name "+t+" does not exist.");return this[t]=e,this},e.prototype.stop=function(){this._source&&(this._internalStop(),this.emit("stop"))},Object.defineProperty(e.prototype,"speed",{get:function(){return this._speed},set:function(t){this._speed=t,this.refresh(),this._update(!0)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"volume",{get:function(){return this._volume},set:function(t){this._volume=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"muted",{get:function(){return this._muted},set:function(t){this._muted=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"loop",{get:function(){return this._loop},set:function(t){this._loop=t,this.refresh()},enumerable:!0,configurable:!0}),e.prototype.refresh=function(){if(this._source){var t=this._media.context,e=this._media.parent;this._source.loop=this._loop||e.loop;var i=t.volume*(t.muted?0:1),r=e.volume*(e.muted?0:1),n=this._volume*(this._muted?0:1);EO.setParamValue(this._gain.gain,n*r*i),EO.setParamValue(this._source.playbackRate,this._speed*e.speed*t.speed)}},e.prototype.refreshPaused=function(){var t=this._media.context,e=this._media.parent,i=this._paused||e.paused||t.paused;i!==this._pausedReal&&(this._pausedReal=i,i?(this._internalStop(),this.emit("paused")):(this.emit("resumed"),this.play({start:this._elapsed%this._duration,end:this._end,speed:this._speed,loop:this._loop,volume:this._volume})),this.emit("pause",i))},e.prototype.play=function(t){var e=t.start,i=t.end,r=t.speed,n=t.loop,s=t.volume,o=t.muted;this._paused=!1;var a=this._media.nodes.cloneBufferSource(),h=a.source,l=a.gain;this._source=h,this._gain=l,this._speed=r,this._volume=s,this._loop=!!n,this._muted=o,this.refresh();var u=this._source.buffer.duration;this._duration=u,this._end=i,this._lastUpdate=this._now(),this._elapsed=e,this._source.onended=this._onComplete.bind(this),this._loop?(this._source.loopEnd=i,this._source.loopStart=e,this._source.start(0,e)):i?this._source.start(0,e,i-e):this._source.start(0,e),this.emit("start"),this._update(!0),this._enabled=!0},e.prototype._toSec=function(t){return t>10&&(t/=1e3),t||0},Object.defineProperty(e.prototype,"_enabled",{set:function(t){gB.shared.remove(this._updateListener,this),t&&gB.shared.add(this._updateListener,this)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"progress",{get:function(){return this._progress},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"paused",{get:function(){return this._paused},set:function(t){this._paused=t,this.refreshPaused()},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){this.removeAllListeners(),this._internalStop(),this._gain&&(this._gain.disconnect(),this._gain=null),this._media&&(this._media.context.events.off("refresh",this.refresh,this),this._media.context.events.off("refreshPaused",this.refreshPaused,this),this._media=null),this._end=null,this._speed=1,this._volume=1,this._loop=!1,this._elapsed=0,this._duration=0,this._paused=!1,this._muted=!1,this._pausedReal=!1},e.prototype.toString=function(){return"[WebAudioInstance id="+this.id+"]"},e.prototype._now=function(){return this._media.context.audioContext.currentTime},e.prototype._updateListener=function(){this._update()},e.prototype._update=function(t){if(void 0===t&&(t=!1),this._source){var e=this._now(),i=e-this._lastUpdate;if(i>0||t){var r=this._source.playbackRate.value;this._elapsed+=i*r,this._lastUpdate=e;var n=this._duration,s=void 0;if(this._source.loopStart){var o=this._source.loopEnd-this._source.loopStart;s=(this._source.loopStart+this._elapsed%o)/n}else s=this._elapsed%n/n;this._progress=s,this.emit("progress",this._progress,n)}}},e.prototype.init=function(t){this._media=t,t.context.events.on("refresh",this.refresh,this),t.context.events.on("refreshPaused",this.refreshPaused,this)},e.prototype._internalStop=function(){this._source&&(this._enabled=!1,this._source.onended=null,this._source.stop(0),this._source.disconnect(),this._source=null)},e.prototype._onComplete=function(){this._source&&(this._enabled=!1,this._source.onended=null,this._source.disconnect()),this._source=null,this._progress=1,this.emit("progress",1,this._duration),this.emit("end",this)},e}(/*@__PURE__*/tP(gm)),ED=function(t){function e(e){var i=this,r=e.audioContext,n=r.createBufferSource(),s=r.createGain(),o=r.createAnalyser();return n.connect(o),o.connect(s),s.connect(e.destination),(i=t.call(this,o,s)||this).context=e,i.bufferSource=n,i.gain=s,i.analyser=o,i}return _O(e,t),Object.defineProperty(e.prototype,"script",{get:function(){return this._script||(this._script=this.context.audioContext.createScriptProcessor(e.BUFFER_SIZE),this._script.connect(this.context.destination)),this._script},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){t.prototype.destroy.call(this),this.bufferSource.disconnect(),this._script&&this._script.disconnect(),this.gain.disconnect(),this.analyser.disconnect(),this.bufferSource=null,this._script=null,this.gain=null,this.analyser=null,this.context=null},e.prototype.cloneBufferSource=function(){var t=this.bufferSource,e=this.context.audioContext.createBufferSource();e.buffer=t.buffer,EO.setParamValue(e.playbackRate,t.playbackRate.value),e.loop=t.loop;var i=this.context.audioContext.createGain();return e.connect(i),i.connect(this.destination),{source:e,gain:i}},Object.defineProperty(e.prototype,"bufferSize",{get:function(){return this.script.bufferSize},enumerable:!0,configurable:!0}),e.BUFFER_SIZE=0,e}(_C),EF=function(){function t(){}return t.prototype.init=function(t){this.parent=t,this._nodes=new ED(this.context),this._source=this._nodes.bufferSource,this.source=t.options.source},t.prototype.destroy=function(){this.parent=null,this._nodes.destroy(),this._nodes=null,this._source=null,this.source=null},t.prototype.create=function(){return new EN(this)},Object.defineProperty(t.prototype,"context",{get:function(){return this.parent.context},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isPlayable",{get:function(){return!!this._source&&!!this._source.buffer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"filters",{get:function(){return this._nodes.filters},set:function(t){this._nodes.filters=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"duration",{get:function(){return this._source.buffer.duration},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"buffer",{get:function(){return this._source.buffer},set:function(t){this._source.buffer=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nodes",{get:function(){return this._nodes},enumerable:!0,configurable:!0}),t.prototype.load=function(t){this.source?this._decode(this.source,t):this.parent.url?this._loadUrl(t):t&&t(Error("sound.url or sound.source must be set"))},t.prototype._loadUrl=function(t){var e=this,i=new XMLHttpRequest,r=this.parent.url;i.open("GET",r,!0),i.responseType="arraybuffer",i.onload=function(){e.source=i.response,e._decode(i.response,t)},i.send()},t.prototype._decode=function(t,e){var i=this;this.parent.context.decode(t,function(t,r){if(t)e&&e(t);else{i.parent.isLoaded=!0,i.buffer=r;var n=i.parent.autoPlayStart();e&&e(null,i.parent,n)}})},t}(),EB=function(t){function e(){var i=this,r=window,n=new e.AudioContext,s=n.createDynamicsCompressor(),o=n.createAnalyser();return o.connect(s),s.connect(n.destination),(i=t.call(this,o,s)||this)._ctx=n,i._offlineCtx=new e.OfflineAudioContext(1,2,r.OfflineAudioContext?n.sampleRate:44100),i._unlocked=!1,i.compressor=s,i.analyser=o,i.events=new/*@__PURE__*/(tP(gm)),i.volume=1,i.speed=1,i.muted=!1,i.paused=!1,"running"!==n.state&&(i._unlock(),i._unlock=i._unlock.bind(i),document.addEventListener("mousedown",i._unlock,!0),document.addEventListener("touchstart",i._unlock,!0),document.addEventListener("touchend",i._unlock,!0)),i}return _O(e,t),e.prototype._unlock=function(){this._unlocked||(this.playEmptySound(),"running"===this._ctx.state&&(document.removeEventListener("mousedown",this._unlock,!0),document.removeEventListener("touchend",this._unlock,!0),document.removeEventListener("touchstart",this._unlock,!0),this._unlocked=!0))},e.prototype.playEmptySound=function(){var t=this._ctx.createBufferSource();t.buffer=this._ctx.createBuffer(1,1,22050),t.connect(this._ctx.destination),t.start(0,0,0),"suspended"===t.context.state&&t.context.resume()},Object.defineProperty(e,"AudioContext",{get:function(){var t=window;return t.AudioContext||t.webkitAudioContext||null},enumerable:!0,configurable:!0}),Object.defineProperty(e,"OfflineAudioContext",{get:function(){var t=window;return t.OfflineAudioContext||t.webkitOfflineAudioContext||null},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){t.prototype.destroy.call(this);var e=this._ctx;void 0!==e.close&&e.close(),this.events.removeAllListeners(),this.analyser.disconnect(),this.compressor.disconnect(),this.analyser=null,this.compressor=null,this.events=null,this._offlineCtx=null,this._ctx=null},Object.defineProperty(e.prototype,"audioContext",{get:function(){return this._ctx},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"offlineContext",{get:function(){return this._offlineCtx},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"paused",{get:function(){return this._paused},set:function(t){t&&"running"===this._ctx.state?this._ctx.suspend():t||"suspended"!==this._ctx.state||this._ctx.resume(),this._paused=t},enumerable:!0,configurable:!0}),e.prototype.refresh=function(){this.events.emit("refresh")},e.prototype.refreshPaused=function(){this.events.emit("refreshPaused")},e.prototype.toggleMute=function(){return this.muted=!this.muted,this.refresh(),this.muted},e.prototype.togglePause=function(){return this.paused=!this.paused,this.refreshPaused(),this._paused},e.prototype.decode=function(t,e){this._offlineCtx.decodeAudioData(t,function(t){e(null,t)},function(t){e(Error(t.message||"Unable to decode file"))})},e}(_C),EU={WebAudioMedia:EF,WebAudioInstance:EN,WebAudioNodes:ED,WebAudioContext:EB,WebAudioUtils:EO},EG={Filter:_P,EqualizerFilter:function(t){function e(i,r,n,s,o,a,h,l,u,c){void 0===i&&(i=0),void 0===r&&(r=0),void 0===n&&(n=0),void 0===s&&(s=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===h&&(h=0),void 0===l&&(l=0),void 0===u&&(u=0),void 0===c&&(c=0);var d=this;if(!EM.useLegacy){var p=[{f:e.F32,type:"lowshelf",gain:i},{f:e.F64,type:"peaking",gain:r},{f:e.F125,type:"peaking",gain:n},{f:e.F250,type:"peaking",gain:s},{f:e.F500,type:"peaking",gain:o},{f:e.F1K,type:"peaking",gain:a},{f:e.F2K,type:"peaking",gain:h},{f:e.F4K,type:"peaking",gain:l},{f:e.F8K,type:"peaking",gain:u},{f:e.F16K,type:"highshelf",gain:c}].map(function(t){var e=EM.context.audioContext.createBiquadFilter();return e.type=t.type,EO.setParamValue(e.Q,1),e.frequency.value=t.f,EO.setParamValue(e.gain,t.gain),e});(d=t.call(this,p[0],p[p.length-1])||this).bands=p,d.bandsMap={};for(var f=0;f<d.bands.length;f++){var m=d.bands[f];f>0&&d.bands[f-1].connect(m),d.bandsMap[m.frequency.value]=m}return d}t.call(this,null)}return _O(e,t),e.prototype.setGain=function(t,e){if(void 0===e&&(e=0),!this.bandsMap[t])throw Error("No band found for frequency "+t);EO.setParamValue(this.bandsMap[t].gain,e)},e.prototype.getGain=function(t){if(!this.bandsMap[t])throw Error("No band found for frequency "+t);return this.bandsMap[t].gain.value},Object.defineProperty(e.prototype,"f32",{get:function(){return this.getGain(e.F32)},set:function(t){this.setGain(e.F32,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f64",{get:function(){return this.getGain(e.F64)},set:function(t){this.setGain(e.F64,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f125",{get:function(){return this.getGain(e.F125)},set:function(t){this.setGain(e.F125,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f250",{get:function(){return this.getGain(e.F250)},set:function(t){this.setGain(e.F250,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f500",{get:function(){return this.getGain(e.F500)},set:function(t){this.setGain(e.F500,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f1k",{get:function(){return this.getGain(e.F1K)},set:function(t){this.setGain(e.F1K,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f2k",{get:function(){return this.getGain(e.F2K)},set:function(t){this.setGain(e.F2K,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f4k",{get:function(){return this.getGain(e.F4K)},set:function(t){this.setGain(e.F4K,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f8k",{get:function(){return this.getGain(e.F8K)},set:function(t){this.setGain(e.F8K,t)},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"f16k",{get:function(){return this.getGain(e.F16K)},set:function(t){this.setGain(e.F16K,t)},enumerable:!0,configurable:!0}),e.prototype.reset=function(){this.bands.forEach(function(t){EO.setParamValue(t.gain,0)})},e.prototype.destroy=function(){this.bands.forEach(function(t){t.disconnect()}),this.bands=null,this.bandsMap=null},e.F32=32,e.F64=64,e.F125=125,e.F250=250,e.F500=500,e.F1K=1e3,e.F2K=2e3,e.F4K=4e3,e.F8K=8e3,e.F16K=16e3,e}(_P),DistortionFilter:function(t){function e(e){void 0===e&&(e=0);var i=this;if(!EM.useLegacy){var r=EM.context.audioContext.createWaveShaper();return(i=t.call(this,r)||this)._distortion=r,i.amount=e,i}t.call(this,null)}return _O(e,t),Object.defineProperty(e.prototype,"amount",{get:function(){return this._amount},set:function(t){t*=1e3,this._amount=t;for(var e,i=new Float32Array(44100),r=Math.PI/180,n=0;n<44100;++n)e=2*n/44100-1,i[n]=(3+t)*e*20*r/(Math.PI+t*Math.abs(e));this._distortion.curve=i,this._distortion.oversample="4x"},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){this._distortion=null,t.prototype.destroy.call(this)},e}(_P),StereoFilter:function(t){function e(e){void 0===e&&(e=0);var i=this;if(!EM.useLegacy){var r,n,s,o=EM.context.audioContext;return o.createStereoPanner?s=r=o.createStereoPanner():((n=o.createPanner()).panningModel="equalpower",s=n),(i=t.call(this,s)||this)._stereo=r,i._panner=n,i.pan=e,i}t.call(this,null)}return _O(e,t),Object.defineProperty(e.prototype,"pan",{get:function(){return this._pan},set:function(t){this._pan=t,this._stereo?EO.setParamValue(this._stereo.pan,t):this._panner.setPosition(t,0,1-Math.abs(t))},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){t.prototype.destroy.call(this),this._stereo=null,this._panner=null},e}(_P),ReverbFilter:function(t){function e(e,i,r){void 0===e&&(e=3),void 0===i&&(i=2),void 0===r&&(r=!1);var n=this;if(!EM.useLegacy)return(n=t.call(this,null)||this)._seconds=n._clamp(e,1,50),n._decay=n._clamp(i,0,100),n._reverse=r,n._rebuild(),n;t.call(this,null)}return _O(e,t),e.prototype._clamp=function(t,e,i){return Math.min(i,Math.max(e,t))},Object.defineProperty(e.prototype,"seconds",{get:function(){return this._seconds},set:function(t){this._seconds=this._clamp(t,1,50),this._rebuild()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"decay",{get:function(){return this._decay},set:function(t){this._decay=this._clamp(t,0,100),this._rebuild()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"reverse",{get:function(){return this._reverse},set:function(t){this._reverse=t,this._rebuild()},enumerable:!0,configurable:!0}),e.prototype._rebuild=function(){for(var t,e=EM.context.audioContext,i=e.sampleRate,r=i*this._seconds,n=e.createBuffer(2,r,i),s=n.getChannelData(0),o=n.getChannelData(1),a=0;a<r;a++)t=this._reverse?r-a:a,s[a]=(2*Math.random()-1)*Math.pow(1-t/r,this._decay),o[a]=(2*Math.random()-1)*Math.pow(1-t/r,this._decay);var h=EM.context.audioContext.createConvolver();h.buffer=n,this.init(h)},e}(_P),MonoFilter:function(t){function e(){var e=this;if(!EM.useLegacy){var i=EM.context.audioContext,r=i.createChannelSplitter(),n=i.createChannelMerger();return n.connect(r),(e=t.call(this,n,r)||this)._merger=n,e}t.call(this,null)}return _O(e,t),e.prototype.destroy=function(){this._merger.disconnect(),this._merger=null,t.prototype.destroy.call(this)},e}(_P),TelephoneFilter:function(t){function e(){if(!EM.useLegacy){var e=EM.context.audioContext,i=e.createBiquadFilter(),r=e.createBiquadFilter(),n=e.createBiquadFilter(),s=e.createBiquadFilter();return i.type="lowpass",EO.setParamValue(i.frequency,2e3),r.type="lowpass",EO.setParamValue(r.frequency,2e3),n.type="highpass",EO.setParamValue(n.frequency,500),s.type="highpass",EO.setParamValue(s.frequency,500),i.connect(r),r.connect(n),n.connect(s),t.call(this,i,s)||this}t.call(this,null)}return _O(e,t),e}(_P)},Ek=0,EH=function(t){function e(e){var i=t.call(this)||this;return i.id=Ek++,i.init(e),i}return _O(e,t),e.prototype.set=function(t,e){if(void 0===this[t])throw Error("Property with name "+t+" does not exist.");return this[t]=e,this},Object.defineProperty(e.prototype,"progress",{get:function(){return this._source.currentTime/this._duration},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"paused",{get:function(){return this._paused},set:function(t){this._paused=t,this.refreshPaused()},enumerable:!0,configurable:!0}),e.prototype._onPlay=function(){this._playing=!0},e.prototype._onPause=function(){this._playing=!1},e.prototype.init=function(t){this._playing=!1,this._duration=t.source.duration;var e=this._source=t.source.cloneNode(!1);e.src=t.parent.url,e.onplay=this._onPlay.bind(this),e.onpause=this._onPause.bind(this),t.context.on("refresh",this.refresh,this),t.context.on("refreshPaused",this.refreshPaused,this),this._media=t},e.prototype._internalStop=function(){this._source&&this._playing&&(this._source.onended=null,this._source.pause())},e.prototype.stop=function(){this._internalStop(),this._source&&this.emit("stop")},Object.defineProperty(e.prototype,"speed",{get:function(){return this._speed},set:function(t){this._speed=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"volume",{get:function(){return this._volume},set:function(t){this._volume=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"loop",{get:function(){return this._loop},set:function(t){this._loop=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"muted",{get:function(){return this._muted},set:function(t){this._muted=t,this.refresh()},enumerable:!0,configurable:!0}),e.prototype.refresh=function(){var t=this._media.context,e=this._media.parent;this._source.loop=this._loop||e.loop;var i=t.volume*(t.muted?0:1),r=e.volume*(e.muted?0:1),n=this._volume*(this._muted?0:1);this._source.volume=n*i*r,this._source.playbackRate=this._speed*t.speed*e.speed},e.prototype.refreshPaused=function(){var t=this._media.context,e=this._media.parent,i=this._paused||e.paused||t.paused;i!==this._pausedReal&&(this._pausedReal=i,i?(this._internalStop(),this.emit("paused")):(this.emit("resumed"),this.play({start:this._source.currentTime,end:this._end,volume:this._volume,speed:this._speed,loop:this._loop})),this.emit("pause",i))},e.prototype.play=function(t){var i=this,r=t.start,n=t.end,s=t.speed,o=t.loop,a=t.volume,h=t.muted;this._speed=s,this._volume=a,this._loop=!!o,this._muted=h,this.refresh(),this.loop&&null!==n&&(this.loop=!1),this._start=r,this._end=n||this._duration,this._start=Math.max(0,this._start-e.PADDING),this._end=Math.min(this._end+e.PADDING,this._duration),this._source.onloadedmetadata=function(){i._source&&(i._source.currentTime=r,i._source.onloadedmetadata=null,i.emit("progress",r,i._duration),gB.shared.add(i._onUpdate,i))},this._source.onended=this._onComplete.bind(this),this._source.play(),this.emit("start")},e.prototype._onUpdate=function(){this.emit("progress",this.progress,this._duration),this._source.currentTime>=this._end&&!this._source.loop&&this._onComplete()},e.prototype._onComplete=function(){gB.shared.remove(this._onUpdate,this),this._internalStop(),this.emit("progress",1,this._duration),this.emit("end",this)},e.prototype.destroy=function(){gB.shared.remove(this._onUpdate,this),this.removeAllListeners();var t=this._source;t&&(t.onended=null,t.onplay=null,t.onpause=null,this._internalStop()),this._source=null,this._speed=1,this._volume=1,this._loop=!1,this._end=null,this._start=0,this._duration=0,this._playing=!1,this._pausedReal=!1,this._paused=!1,this._muted=!1,this._media&&(this._media.context.off("refresh",this.refresh,this),this._media.context.off("refreshPaused",this.refreshPaused,this),this._media=null)},e.prototype.toString=function(){return"[HTMLAudioInstance id="+this.id+"]"},e.PADDING=.1,e}(/*@__PURE__*/tP(gm)),Ez=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return _O(e,t),e.prototype.init=function(t){this.parent=t,this._source=t.options.source||new Audio,t.url&&(this._source.src=t.url)},e.prototype.create=function(){return new EH(this)},Object.defineProperty(e.prototype,"isPlayable",{get:function(){return!!this._source&&4===this._source.readyState},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"duration",{get:function(){return this._source.duration},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"context",{get:function(){return this.parent.context},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"filters",{get:function(){return null},set:function(t){},enumerable:!0,configurable:!0}),e.prototype.destroy=function(){this.removeAllListeners(),this.parent=null,this._source&&(this._source.src="",this._source.load(),this._source=null)},Object.defineProperty(e.prototype,"source",{get:function(){return this._source},enumerable:!0,configurable:!0}),e.prototype.load=function(t){var e=this._source,i=this.parent;if(4!==e.readyState){if(!i.url)return t(Error("sound.url or sound.source must be set"));e.src=i.url;var r=function(){e.removeEventListener("canplaythrough",n),e.removeEventListener("load",n),e.removeEventListener("abort",s),e.removeEventListener("error",o)},n=function(){r(),i.isLoaded=!0;var e=i.autoPlayStart();t&&t(null,i,e)},s=function(){r(),t&&t(Error("Sound loading has been aborted"))},o=function(){r();var i="Failed to load audio element (code: "+e.error.code+")";t&&t(Error(i))};e.addEventListener("canplaythrough",n,!1),e.addEventListener("load",n,!1),e.addEventListener("abort",s,!1),e.addEventListener("error",o,!1),e.load()}else{i.isLoaded=!0;var a=i.autoPlayStart();t&&setTimeout(function(){t(null,i,a)},0)}},e}(/*@__PURE__*/tP(gm)),Ej=function(t){function e(){var e=t.call(this)||this;return e.speed=1,e.volume=1,e.muted=!1,e.paused=!1,e}return _O(e,t),e.prototype.refresh=function(){this.emit("refresh")},e.prototype.refreshPaused=function(){this.emit("refreshPaused")},Object.defineProperty(e.prototype,"filters",{get:function(){return null},set:function(t){},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"audioContext",{get:function(){return null},enumerable:!0,configurable:!0}),e.prototype.toggleMute=function(){return this.muted=!this.muted,this.refresh(),this.muted},e.prototype.togglePause=function(){return this.paused=!this.paused,this.refreshPaused(),this.paused},e.prototype.destroy=function(){this.removeAllListeners()},e}(/*@__PURE__*/tP(gm)),EV={HTMLAudioMedia:Ez,HTMLAudioInstance:EH,HTMLAudioContext:Ej},EX=["mp3","ogg","oga","opus","mpeg","wav","m4a","aiff","wma","mid"],EW=(EA={m4a:"mp4",oga:"ogg"},ER=document.createElement("audio"),EC={},EP=/^no$/,EX.forEach(function(t){var e=EA[t]||t,i=ER.canPlayType("audio/"+t).replace(EP,""),r=ER.canPlayType("audio/"+e).replace(EP,"");EC[t]=!!i||!!r}),Object.freeze(EC)),EY=/\.(\{([^\}]+)\})(\?.*)?$/;function Eq(t){var e="string"==typeof t?t:t.url;if(EY.test(e)){for(var i=EY.exec(e),r=i[2].split(","),n=r[r.length-1],s=0,o=r.length;s<o;s++){var a=r[s];if(EW[a]){n=a;break}}var h=e.replace(i[1],n);return"string"!=typeof t&&(t.extension=n,t.url=h),h}return e}var EK=function(){function t(){}return t.add=function(){t.legacy=EM.useLegacy},Object.defineProperty(t,"legacy",{set:function(t){t?EX.forEach(function(t){ga.setExtensionXhrType(t,ga.XHR_RESPONSE_TYPE.DEFAULT),ga.setExtensionLoadType(t,ga.LOAD_TYPE.AUDIO)}):EX.forEach(function(t){ga.setExtensionXhrType(t,ga.XHR_RESPONSE_TYPE.BUFFER),ga.setExtensionLoadType(t,ga.LOAD_TYPE.XHR)})},enumerable:!0,configurable:!0}),t.pre=function(t,e){Eq(t),e()},t.use=function(t,e){t.data&&EX.indexOf(t.extension)>-1?t.sound=EM.add(t.name,{loaded:e,preload:!0,url:t.url,source:t.data}):e()},t}(),EJ=function(){function t(t,e){this.parent=t,Object.assign(this,e),this.duration=this.end-this.start}return t.prototype.play=function(t){return this.parent.play({complete:t,speed:this.speed||this.parent.speed,end:this.end,start:this.start,loop:this.loop})},t.prototype.destroy=function(){this.parent=null},t}(),EZ=function(){function t(t,e){this.media=t,this.options=e,this._instances=[],this._sprites={},this.media.init(this);var i=e.complete;this._autoPlayOptions=i?{complete:i}:null,this.isLoaded=!1,this.isPlaying=!1,this.autoPlay=e.autoPlay,this.singleInstance=e.singleInstance,this.preload=e.preload||this.autoPlay,this.url=e.url,this.speed=e.speed,this.volume=e.volume,this.loop=e.loop,e.sprites&&this.addSprites(e.sprites),this.preload&&this._preload(e.loaded)}return t.from=function(e){var i={};return"string"==typeof e?i.url=e:e instanceof ArrayBuffer||e instanceof HTMLAudioElement?i.source=e:i=e,(i=EI({autoPlay:!1,singleInstance:!1,url:null,source:null,preload:!1,volume:1,speed:1,complete:null,loaded:null,loop:!1},i)).url&&(i.url=Eq(i.url)),Object.freeze(i),new t(EM.useLegacy?new Ez:new EF,i)},Object.defineProperty(t.prototype,"context",{get:function(){return EM.context},enumerable:!0,configurable:!0}),t.prototype.pause=function(){return this.isPlaying=!1,this.paused=!0,this},t.prototype.resume=function(){return this.isPlaying=this._instances.length>0,this.paused=!1,this},Object.defineProperty(t.prototype,"paused",{get:function(){return this._paused},set:function(t){this._paused=t,this.refreshPaused()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"speed",{get:function(){return this._speed},set:function(t){this._speed=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"filters",{get:function(){return this.media.filters},set:function(t){this.media.filters=t},enumerable:!0,configurable:!0}),t.prototype.addSprites=function(t,e){if("object"==typeof t){var i={};for(var r in t)i[r]=this.addSprites(r,t[r]);return i}if("string"==typeof t){var n=new EJ(this,e);return this._sprites[t]=n,n}},t.prototype.destroy=function(){this._removeInstances(),this.removeSprites(),this.media.destroy(),this.media=null,this._sprites=null,this._instances=null},t.prototype.removeSprites=function(t){if(t){var e=this._sprites[t];void 0!==e&&(e.destroy(),delete this._sprites[t])}else for(var i in this._sprites)this.removeSprites(i);return this},Object.defineProperty(t.prototype,"isPlayable",{get:function(){return this.isLoaded&&this.media&&this.media.isPlayable},enumerable:!0,configurable:!0}),t.prototype.stop=function(){if(!this.isPlayable)return this.autoPlay=!1,this._autoPlayOptions=null,this;this.isPlaying=!1;for(var t=this._instances.length-1;t>=0;t--)this._instances[t].stop();return this},t.prototype.play=function(t,e){var i,r=this;if("string"==typeof t?i={sprite:s=t,loop:this.loop,complete:e}:"function"==typeof t?(i={}).complete=t:i=t,(i=EI({complete:null,loaded:null,sprite:null,end:null,start:0,volume:1,speed:1,muted:!1,loop:!1},i||{})).sprite){var n=i.sprite,s=this._sprites[n];i.start=s.start,i.end=s.end,i.speed=s.speed||1,i.loop=s.loop||i.loop,delete i.sprite}if(i.offset&&(i.start=i.offset),!this.isLoaded)return new Promise(function(t,e){r.autoPlay=!0,r._autoPlayOptions=i,r._preload(function(r,n,s){r?e(r):(i.loaded&&i.loaded(r,n,s),t(s))})});this.singleInstance&&this._removeInstances();var o=this._createInstance();return this._instances.push(o),this.isPlaying=!0,o.once("end",function(){i.complete&&i.complete(r),r._onComplete(o)}),o.once("stop",function(){r._onComplete(o)}),o.play(i),o},t.prototype.refresh=function(){for(var t=this._instances.length,e=0;e<t;e++)this._instances[e].refresh()},t.prototype.refreshPaused=function(){for(var t=this._instances.length,e=0;e<t;e++)this._instances[e].refreshPaused()},Object.defineProperty(t.prototype,"volume",{get:function(){return this._volume},set:function(t){this._volume=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"muted",{get:function(){return this._muted},set:function(t){this._muted=t,this.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"loop",{get:function(){return this._loop},set:function(t){this._loop=t,this.refresh()},enumerable:!0,configurable:!0}),t.prototype._preload=function(t){this.media.load(t)},Object.defineProperty(t.prototype,"instances",{get:function(){return this._instances},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"sprites",{get:function(){return this._sprites},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"duration",{get:function(){return this.media.duration},enumerable:!0,configurable:!0}),t.prototype.autoPlayStart=function(){var t;return this.autoPlay&&(t=this.play(this._autoPlayOptions)),t},t.prototype._removeInstances=function(){for(var t=this._instances.length-1;t>=0;t--)this._poolInstance(this._instances[t]);this._instances.length=0},t.prototype._onComplete=function(t){if(this._instances){var e=this._instances.indexOf(t);e>-1&&this._instances.splice(e,1),this.isPlaying=this._instances.length>0}this._poolInstance(t)},t.prototype._createInstance=function(){if(t._pool.length>0){var e=t._pool.pop();return e.init(this.media),e}return this.media.create()},t.prototype._poolInstance=function(e){e.destroy(),0>t._pool.indexOf(e)&&t._pool.push(e)},t._pool=[],t}(),E$=function(){function t(){this.init()}return t.prototype.init=function(){return this.supported&&(this._webAudioContext=new EB),this._htmlAudioContext=new Ej,this._sounds={},this.useLegacy=!this.supported,this},Object.defineProperty(t.prototype,"context",{get:function(){return this._context},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"filtersAll",{get:function(){return this.useLegacy?[]:this._context.filters},set:function(t){this.useLegacy||(this._context.filters=t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"supported",{get:function(){return null!==EB.AudioContext},enumerable:!0,configurable:!0}),t.prototype.add=function(t,e){if("object"==typeof t){var i={};for(var r in t){var n=this._getOptions(t[r],e);i[r]=this.add(r,n)}return i}if("string"==typeof t){if(e instanceof EZ)return this._sounds[t]=e,e;n=this._getOptions(e);var s=EZ.from(n);return this._sounds[t]=s,s}},t.prototype._getOptions=function(t,e){var i;return i="string"==typeof t?{url:t}:t instanceof ArrayBuffer||t instanceof HTMLAudioElement?{source:t}:t,i=EI({},i,e||{})},Object.defineProperty(t.prototype,"useLegacy",{get:function(){return this._useLegacy},set:function(t){EK.legacy=t,this._useLegacy=t,this._context=!t&&this.supported?this._webAudioContext:this._htmlAudioContext},enumerable:!0,configurable:!0}),t.prototype.remove=function(t){return this.exists(t,!0),this._sounds[t].destroy(),delete this._sounds[t],this},Object.defineProperty(t.prototype,"volumeAll",{get:function(){return this._context.volume},set:function(t){this._context.volume=t,this._context.refresh()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"speedAll",{get:function(){return this._context.speed},set:function(t){this._context.speed=t,this._context.refresh()},enumerable:!0,configurable:!0}),t.prototype.togglePauseAll=function(){return this._context.togglePause()},t.prototype.pauseAll=function(){return this._context.paused=!0,this._context.refreshPaused(),this},t.prototype.resumeAll=function(){return this._context.paused=!1,this._context.refreshPaused(),this},t.prototype.toggleMuteAll=function(){return this._context.toggleMute()},t.prototype.muteAll=function(){return this._context.muted=!0,this._context.refresh(),this},t.prototype.unmuteAll=function(){return this._context.muted=!1,this._context.refresh(),this},t.prototype.removeAll=function(){for(var t in this._sounds)this._sounds[t].destroy(),delete this._sounds[t];return this},t.prototype.stopAll=function(){for(var t in this._sounds)this._sounds[t].stop();return this},t.prototype.exists=function(t,e){return void 0===e&&(e=!1),!!this._sounds[t]},t.prototype.find=function(t){return this.exists(t,!0),this._sounds[t]},t.prototype.play=function(t,e){return this.find(t).play(e)},t.prototype.stop=function(t){return this.find(t).stop()},t.prototype.pause=function(t){return this.find(t).pause()},t.prototype.resume=function(t){return this.find(t).resume()},t.prototype.volume=function(t,e){var i=this.find(t);return void 0!==e&&(i.volume=e),i.volume},t.prototype.speed=function(t,e){var i=this.find(t);return void 0!==e&&(i.speed=e),i.speed},t.prototype.duration=function(t){return this.find(t).duration},t.prototype.close=function(){return this.removeAll(),this._sounds=null,this._webAudioContext&&(this._webAudioContext.destroy(),this._webAudioContext=null),this._htmlAudioContext&&(this._htmlAudioContext.destroy(),this._htmlAudioContext=null),this._context=null,this},t}(),EQ=0,E0={get PLAY_ID(){return EQ},playOnce:function(t,e){var i="alias"+EQ++;return EM.add(i,{url:t,preload:!0,autoPlay:!0,loaded:function(t){t&&(EM.remove(i),e&&e(t))},complete:function(){EM.remove(i),e&&e(null)}}),i},render:function(t,e){var i=document.createElement("canvas");e=EI({width:512,height:128,fill:"black"},e||{}),i.width=e.width,i.height=e.height;var r=g5.from(i);if(!(t.media instanceof EF))return r;var n=t.media,s=i.getContext("2d");s.fillStyle=e.fill;for(var o=n.buffer.getChannelData(0),a=Math.ceil(o.length/e.width),h=e.height/2,l=0;l<e.width;l++){for(var u=1,c=-1,d=0;d<a;d++){var p=o[l*a+d];p<u&&(u=p),p>c&&(c=p)}s.fillRect(l,(1+u)*h,1,Math.max(1,(c-u)*h))}return r},resolveUrl:Eq,sineTone:function(t,e){void 0===t&&(t=200),void 0===e&&(e=1);var i=EZ.from({singleInstance:!0});if(!(i.media instanceof EF))return i;for(var r=i.media,n=i.context.audioContext.createBuffer(1,48e3*e,48e3),s=n.getChannelData(0),o=0;o<s.length;o++){var a=t*(o/n.sampleRate)*Math.PI;s[o]=2*Math.sin(a)}return r.buffer=n,i.isLoaded=!0,i},extensions:EX,supported:EW},E1=(EM=r=new E$,r);_R.registerPlugin(EK),Object.defineProperties(E1,{Filterable:{get:function(){return _C}},filters:{get:function(){return EG}},htmlaudio:{get:function(){return EV}},Sound:{get:function(){return EZ}},SoundLibrary:{get:function(){return E$}},SoundSprite:{get:function(){return EJ}},utils:{get:function(){return E0}},webaudio:{get:function(){return EU}},sound:{get:function(){return E1}}});const E2=`${mZ()}/assets/02-pixi-intro/warrior/warrior.json`,E3=`${mZ()}/assets/03-components/warrior.png`;class E5 extends hi{onInit(){this.subscribe("ROTATION_FINISHED")}onMessage(t){"ROTATION_FINISHED"===t.action&&this.owner.setFlag(1)}onUpdate(t,e){this.owner.hasFlag(1)&&(this.owner.rotation+=.004*t,this.owner.rotation>=2*Math.PI&&(this.owner.rotation=0,this.sendMessage("ROTATION_FINISHED"),this.owner.resetFlag(1)))}}(k||(k={})).SCENE_STATE="SCENE_STATE",(n=H||(H={}))[n.LEFT=0]="LEFT",n[n.RIGHT=1]="RIGHT",n[n.UP=2]="UP",n[n.DOWN=3]="DOWN",(s=z||(z={})).SCENE_PAUSE="SCENE_PAUSE",s.SCENE_RESUME="SCENE_RESUME",s.CHANGE_DIRECTION="CHANGE_DIRECTION",s.CHANGE_COLOR="CHANGE_COLOR";class E4 extends hi{onInit(){this.modifyState({dir:this.props.dir,running:this.props.running}),this.subscribe(z.SCENE_PAUSE,z.SCENE_RESUME,z.CHANGE_DIRECTION,z.CHANGE_COLOR),this.owner.interactive=!0,this.owner.on("click",()=>{// get tag of the owner
let t;this.owner.hasTag("SQUARE")?t="SQUARE":this.owner.hasTag("CIRCLE")&&(t="CIRCLE"),this.sendMessage(z.CHANGE_COLOR,this.owner.asGraphics().tint,[t])})}onRemove(){this.owner.removeAllListeners()}onMessage(t){if(t.action===z.SCENE_PAUSE)this.modifyState({running:!1});else if(t.action===z.SCENE_RESUME)this.modifyState({running:!0});else if(t.action===z.CHANGE_DIRECTION){let t;switch(this.state.dir){case H.LEFT:t=H.RIGHT;break;case H.RIGHT:t=H.LEFT;break;case H.UP:t=H.DOWN;break;case H.DOWN:t=H.UP}this.modifyState({dir:t})}else if(t.action===z.CHANGE_COLOR){let e=t.data;this.owner.asGraphics().tint=e}}onUpdate(t,e){if(!this.state.running)return;let i=this.state.dir,r=this.owner.position,n=this.scene.app.screen.width,s=this.scene.app.screen.height,o=this.owner.getBounds(),a=.04*t,h=i;switch(i){case H.LEFT:r.x-=a,o.left<=0&&(h=H.RIGHT);break;case H.RIGHT:r.x+=a,o.right>=n&&(h=H.LEFT);break;case H.DOWN:r.y+=a,o.bottom>=s&&(h=H.UP);break;case H.UP:r.y-=a,o.top<=0&&(h=H.DOWN)}i!==h&&this.modifyState({dir:h})}modifyState(t){this.state={...this.state,...t}}constructor(...t){super(...t),// state is of the sam
this.state={dir:H.LEFT,running:!0}}}// factory for new objects
const E6=t=>{let e=new hy,i=(Math.floor(255*Math.random())<<16)+(Math.floor(255*Math.random())<<8)+Math.floor(255*Math.random()),r=Math.random()*(t.app.screen.width-40),n=Math.random()*(t.app.screen.height-40);e.beginFill(16777215),e.tint=i,Math.random()>.5?(e.drawRect(0,0,40,40),e.name="SQUARE",e.addTag("SQUARE")):(e.drawCircle(0,0,20),e.name="CIRCLE",e.addTag("CIRCLE")),e.endFill(),e.position.set(r,n);let s=Math.floor(4*Math.random());return e.addComponent(new E4({dir:s,running:t.getGlobalAttribute(k.SCENE_STATE).isRunning})),e};class E8 extends hi{onInit(){this.keyInput=this.scene.getGlobalAttribute("key_input"),// emit 3 objects
this.emitObject(),this.emitObject(),this.emitObject()}onUpdate(){if(this.keyInput.isKeyPressed(b7.KEY_Q)&&(this.keyInput.handleKey(b7.KEY_Q),this.changeDirection()),this.keyInput.isKeyPressed(b7.KEY_W)){let t;this.keyInput.handleKey(b7.KEY_W);let e=this.scene.getGlobalAttribute(k.SCENE_STATE);e.isRunning?(t=!1,this.pauseScene()):(t=!0,this.resumeScene()),this.scene.assignGlobalAttribute(k.SCENE_STATE,{...e,isRunning:t})}this.keyInput.isKeyPressed(b7.KEY_E)&&(this.keyInput.handleKey(b7.KEY_E),this.emitObject())}emitObject(){let t=E6(this.scene);this.scene.stage.addChild(t)}changeDirection(){this.sendMessage(z.CHANGE_DIRECTION)}pauseScene(){this.sendMessage(z.SCENE_PAUSE)}resumeScene(){this.sendMessage(z.SCENE_RESUME)}}/**
 * Random number generator, period 2^128 - 1
 */class E7{constructor(t){this.x=0,this.y=0,this.z=0,this.w=0,this.x=Math.floor(t)}/**
	 * 32 bits of randomness in float
	 */float(){return(this.next()>>>0)/4294967296}/**
	 * 56 bits of randomness
	 */double(){let t;do t=((this.next()>>>11)+(this.next()>>>0)/4294967296)/2097152;while(0===t)return t}normalRadial(t,e,i=0){let[r,n]=this.nextNormal();// u0 is in range [-3.5, 3.5]
if(1===i)return t+e*r;let s=i/Math.sqrt(1+i*i),o=s*r+Math.sqrt(1-s*s)*n;return t+e*o}/**
	 * Random function with normal distribution by using Box-Muller transform
	 * @param min min value
	 * @param max max value
	 * @param scale transform scale
	 */normal(t,e,i=1){return this.normalRadial((e-t)/2+t,(e-t)/7,i)}uniform(t=0,e=1){return t+(e-t)*this.float()}/**
	 * Generates a uniform integer with exclusive bounds
	 * @param min min number, exclusive
	 * @param max max number, exclusive
	 */uniformInt(t,e){return t+Math.floor((e-t+1)*this.float())}nextNormal(){let t=0,e=0;//Convert [0,1) to (0,1)
for(;0===t;)t=Math.random();for(;0===e;)e=Math.random();let i=Math.sqrt(-2*Math.log(t)),r=2*Math.PI*e;return[i*Math.cos(r),i*Math.sin(r)]}next(){let t=this.x^this.x<<11;return this.x=this.y,this.y=this.z,this.z=this.w,this.w^=this.w>>>19^t^t>>>8}}/**
 * Structure for gradients
 */class E9{constructor(t,e,i){this.x=0,this.y=0,this.z=0,this.x=t,this.y=e,this.z=i}dot2(t,e){return this.x*t+this.y*e}dot3(t,e,i){return this.x*t+this.y*e+this.z*i}}class Tt{constructor(t=0){this.gradients=[new E9(1,1,0),new E9(-1,1,0),new E9(1,-1,0),new E9(-1,-1,0),new E9(1,0,1),new E9(-1,0,1),new E9(1,0,-1),new E9(-1,0,-1),new E9(0,1,1),new E9(0,-1,1),new E9(0,1,-1),new E9(0,-1,-1)],// table of periods
this.periods=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],// To remove the need for index wrapping, double the permutation table length
this.perm=Array(512),this.gradP=Array(512),this.seed(t)}// supports 2^16 different seed values
seed(t){t>0&&t<1&&(t*=65536),(t=Math.floor(t))<256&&(t|=t<<8);for(let e=0;e<256;e++){let i;i=1&e?this.periods[e]^255&t:this.periods[e]^t>>8&255,this.perm[e]=this.perm[e+256]=i,this.gradP[e]=this.gradP[e+256]=this.gradients[i%12]}}fade(t){return t*t*t*(t*(6*t-15)+10)}lerp(t,e,i){return(1-i)*t+i*e}// 2D Perlin Noise
rawNoise(t,e){// Find unit grid cell containing point
let i=Math.floor(t),r=Math.floor(e);// Get relative xy coordinates of point within that cell
t-=i,e-=r,// Wrap the integer cells at 255 (smaller integer period can be introduced here)
i&=255,r&=255;// Calculate noise contributions from each of the four corners
let n=this.gradP[i+this.perm[r]].dot2(t,e),s=this.gradP[i+this.perm[r+1]].dot2(t,e-1),o=this.gradP[i+1+this.perm[r]].dot2(t-1,e),a=this.gradP[i+1+this.perm[r+1]].dot2(t-1,e-1),h=this.fade(t);// Interpolate the four results
return this.lerp(this.lerp(n,o,h),this.lerp(s,a,h),this.fade(e))}// calculates perlin noise at specified coordinates, returns value between -1 and 1
interpolatedNoise(t,e,i,r,n){// total output noise value
let s=0,o=1/n,a=1;// for each octave
for(let n=0;n<r;n++)s+=this.rawNoise(t*o,e*o)*a,// set frequency and amplitude
o*=2,// decrease amplitude
a*=i;return s<-1&&(s=-1),s>1&&(s=1),s}renderNoise(t,e,i,r,n,s,o){// for each pixel, generate its perlin value and write it into RGB channel
for(let a=0;a<e;a++)for(let h=0;h<i;h++){let l=(this.interpolatedNoise(e/o/2-Math.floor(a/o),i/o/2-Math.floor(h/o),r,n,s)+1)*127;// scale to 0-255
// grayscale
t[(a+h*e)*4+3]=255,t[(a+h*e)*4+2]=l,t[(a+h*e)*4+1]=l,t[(a+h*e)*4+0]=l}}}class Te{constructor(t,e=1,i=3,r=0){// children
this.topRight=null,this.topLeft=null,this.bottomLeft=null,this.bottomRight=null,this.objects=[],this.bounds=t,this.maxObjects=e,this.maxLevels=i,this.level=r}insert(t){let e;// check subnodes
if(null!=this.topRight&&-1!==(e=this.getIndex(t))){switch(e){case 0:this.topRight.insert(t);break;case 1:this.topLeft.insert(t);break;case 2:this.bottomLeft.insert(t);break;case 3:this.bottomRight.insert(t)}return}if(// no subnodes
this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){// split if we don't have subnodes anymore
null==this.topRight&&this.split();// add all objects to corresponding nodes
let t=0;for(;t<this.objects.length;){let i=this.objects[t];if(this.objects.splice(t,1),-1!==(e=this.getIndex(i)))switch(e){case 0:this.topRight.insert(i);break;case 1:this.topLeft.insert(i);break;case 2:this.bottomLeft.insert(i);break;case 3:this.bottomRight.insert(i)}else t++}}}clear(){this.objects=[],null!=this.topRight&&(this.topLeft.clear(),this.topRight.clear(),this.bottomLeft.clear(),this.bottomRight.clear()),this.topLeft=this.topRight=this.bottomLeft=this.bottomRight=null}split(){let t=this.level+1,e=Math.round(this.bounds.width/2),i=Math.round(this.bounds.height/2),r=Math.round(this.bounds.x),n=Math.round(this.bounds.y),s=new iU(r+e,n,e,i),o=new iU(r,n,e,i),a=new iU(r,n+i,e,i),h=new iU(r+e,n+i,e,i);this.topRight=new Te(s,this.maxObjects,this.maxLevels,t),this.topLeft=new Te(o,this.maxObjects,this.maxLevels,t),this.bottomLeft=new Te(a,this.maxObjects,this.maxLevels,t),this.bottomRight=new Te(h,this.maxObjects,this.maxLevels,t)}getIndex(t){let e=-1,i=this.bounds.x+this.bounds.width/2,r=this.bounds.y+this.bounds.height/2,n=t.y<r,s=t.y>r;return t.x<i?n?e=1:s&&(e=2):t.x>i&&(n?e=0:s&&(e=3)),e}}class Ti{constructor(){this.currentPointIndex=-1}}class Tr{constructor(t,e){this.start=t,this.end=e,this.length=e.subtract(t).magnitude()}}class Tn{constructor(t=null,e=null){// collection of segments
this.segments=[],null!=t&&null!=e&&this.addFirstSegment(t,e)}addFirstSegment(t,e){// clear all segments
this.segments=[];let i=new Tr(t,e);this.segments.push(i),this.pathLength=i.length}addSegment(t){// connect the segment to the last one
let e=this.segments[this.segments.length-1],i=new Tr(e.end,t);this.segments.push(i),this.pathLength+=i.length}calcTargetPoint(t,e,i){// get current followed segment
let r=this.segments[-1!==i.currentPointIndex?i.currentPointIndex:0];if(-1===i.currentPointIndex&&e.distance(r.start)>t){i.currentPointIndex=-1,i.targetLocation=r.start;return}if(-1===i.currentPointIndex&&(i.currentPointIndex=0),e.distance(r.end)>t){// still not there. Go to the end of the segment
i.targetLocation=r.end;return}i.currentPointIndex===this.segments.length-1?i.targetLocation=e:(// go to the end of the next segment
i.currentPointIndex=i.currentPointIndex+1,i.targetLocation=this.segments[i.currentPointIndex].end)}}Object.prototype.hasOwnProperty;const Ts=(t,e)=>t<e?-1:t===e?0:1,To=(t,e)=>t===e,Ta=t=>"function"==typeof t,Th=t=>void 0===t,Tl=t=>Th(t)||!Ta(t)?(t,e)=>t<e?1:t===e?0:-1:(e,i)=>-1*t(e,i),Tu=t=>(e,i)=>0===t(e,i),Tc=(t,e,i)=>{let r=i||To,n=t.length;for(let i=0;i<n;i++)if(r(t[i],e))return i;return -1},Td=(t,e,i)=>Tc(t,e,i)>=0,Tp=(t,e,i)=>{if(e<0||e>=t.length||i<0||i>=t.length)return!1;let r=t[e];return t[e]=t[i],t[i]=r,!0},Tf=t=>"["+t.toString()+"]",Tm=(t,e)=>{for(let i of t)if(!1===e(i))return};class Tg{/**
	 * Creates an empty Linked List.
	 * @class A linked list is a data structure consisting of a group of nodes
	 * which together represent a sequence.
	 * @constructor
	 */constructor(){/**
	 * First node in the list
	 * @type {Object}
	 * @private
	 */this.firstNode=null,/**
	 * Last node in the list
	 * @type {Object}
	 * @private
	 */this.lastNode=null,/**
	 * Number of elements in the list
	 * @type {number}
	 * @private
	 */this.nElements=0}/**
	 * Adds an element to this list.
	 * @param {Object} item element to be added.
	 * @param {number=} index optional index to add the element. If no index is specified
	 * the element is added to the end of this list.
	 * @return {boolean} true if the element was added or false if the index is invalid
	 * or if the element is undefined.
	 */add(t,e){if(Th(e)&&(e=this.nElements),e<0||e>this.nElements||Th(t))return!1;let i=this.createNode(t);if(0===this.nElements||null===this.lastNode)// First node in the list.
this.firstNode=i,this.lastNode=i;else if(e===this.nElements)// Insert at the end.
this.lastNode.next=i,this.lastNode=i;else if(0===e)// Change first node.
i.next=this.firstNode,this.firstNode=i;else{let t=this.nodeAtIndex(e-1);if(null===t)return!1;i.next=t.next,t.next=i}return this.nElements++,!0}/**
	 * Returns the first element in this list.
	 * @return {*} the first element of the list or undefined if the list is
	 * empty.
	 */first(){if(null!==this.firstNode)return this.firstNode.element}/**
	 * Returns the last element in this list.
	 * @return {*} the last element in the list or undefined if the list is
	 * empty.
	 */last(){if(null!==this.lastNode)return this.lastNode.element}/**
	 * Returns the element at the specified position in this list.
	 * @param {number} index desired index.
	 * @return {*} the element at the given index or undefined if the index is
	 * out of bounds.
	 */elementAtIndex(t){let e=this.nodeAtIndex(t);if(null!==e)return e.element}/**
	 * Returns the index in this list of the first occurrence of the
	 * specified element, or -1 if the List does not contain this element.
	 * <p>If the elements inside this list are
	 * not comparable with the === operator a custom equals function should be
	 * provided to perform searches, the function must receive two arguments and
	 * return true if they are equal, false otherwise. Example:</p>
	 *
	 * <pre>
	 * const petsAreEqualByName = function(pet1, pet2) {
	 *  return pet1.name === pet2.name;
	 * }
	 * </pre>
	 * @param {Object} item element to search for.
	 * @param {function(Object,Object):boolean=} equalsFunction Optional
	 * function used to check if two elements are equal.
	 * @return {number} the index in this list of the first occurrence
	 * of the specified element, or -1 if this list does not contain the
	 * element.
	 */indexOf(t,e){let i=e||To;if(Th(t))return -1;let r=this.firstNode,n=0;for(;null!==r;){if(i(r.element,t))return n;n++,r=r.next}return -1}/**
	 * Returns true if this list contains the specified element.
	 * <p>If the elements inside the list are
	 * not comparable with the === operator a custom equals function should be
	 * provided to perform searches, the function must receive two arguments and
	 * return true if they are equal, false otherwise. Example:</p>
	 *
	 * <pre>
	 * const petsAreEqualByName = function(pet1, pet2) {
	 *  return pet1.name === pet2.name;
	 * }
	 * </pre>
	 * @param {Object} item element to search for.
	 * @param {function(Object,Object):boolean=} equalsFunction Optional
	 * function used to check if two elements are equal.
	 * @return {boolean} true if this list contains the specified element, false
	 * otherwise.
	 */contains(t,e){return this.indexOf(t,e)>=0}/**
	 * Removes the first occurrence of the specified element in this list.
	 * <p>If the elements inside the list are
	 * not comparable with the === operator a custom equals function should be
	 * provided to perform searches, the function must receive two arguments and
	 * return true if they are equal, false otherwise. Example:</p>
	 *
	 * <pre>
	 * const petsAreEqualByName = function(pet1, pet2) {
	 *  return pet1.name === pet2.name;
	 * }
	 * </pre>
	 * @param {Object} item element to be removed from this list, if present.
	 * @return {boolean} true if the list contained the specified element.
	 */remove(t,e){let i=e||To;if(this.nElements<1||Th(t))return!1;let r=null,n=this.firstNode;for(;null!==n;){if(i(n.element,t))return null===r?(this.firstNode=n.next,n===this.lastNode&&(this.lastNode=null)):(n===this.lastNode&&(this.lastNode=r),r.next=n.next,n.next=null),this.nElements--,!0;r=n,n=n.next}return!1}/**
	 * Removes all of the elements from this list.
	 */clear(){this.firstNode=null,this.lastNode=null,this.nElements=0}/**
	 * Returns true if this list is equal to the given list.
	 * Two lists are equal if they have the same elements in the same order.
	 * @param {LinkedList} other the other list.
	 * @param {function(Object,Object):boolean=} equalsFunction optional
	 * function used to check if two elements are equal. If the elements in the lists
	 * are custom objects you should provide a function, otherwise
	 * the === operator is used to check equality between elements.
	 * @return {boolean} true if this list is equal to the given list.
	 */equals(t,e){let i=e||To;return t instanceof Tg&&this.size()===t.size()&&this.equalsAux(this.firstNode,t.firstNode,i)}/**
	 * Removes the element at the specified position in this list.
	 * @param {number} index given index.
	 * @return {*} removed element or undefined if the index is out of bounds.
	 */removeElementAtIndex(t){let e;if(!(t<0)&&!(t>=this.nElements)&&null!==this.firstNode&&null!==this.lastNode){if(1===this.nElements)//First node in the list.
e=this.firstNode.element,this.firstNode=null,this.lastNode=null;else{let i=this.nodeAtIndex(t-1);null===i?(e=this.firstNode.element,this.firstNode=this.firstNode.next):i.next===this.lastNode&&(e=this.lastNode.element,this.lastNode=i),null!==i&&null!==i.next&&(e=i.next.element,i.next=i.next.next)}return this.nElements--,e}}/**
	 * Executes the provided function once for each element present in this list in order.
	 * @param {function(Object):*} callback function to execute, it is
	 * invoked with one argument: the element value, to break the iteration you can
	 * optionally return false.
	 */forEach(t){let e=this.firstNode;for(;null!==e&&!1!==t(e.element);)e=e.next}/**
	 * Reverses the order of the elements in this linked list (makes the last
	 * element first, and the first element last).
	 */reverse(){let t=null,e=this.firstNode,i=null;for(;null!==e;)i=e.next,e.next=t,t=e,e=i;i=this.firstNode,this.firstNode=this.lastNode,this.lastNode=i}/**
	 * Returns an array containing all of the elements in this list in proper
	 * sequence.
	 * @return {Array.<*>} an array containing all of the elements in this list,
	 * in proper sequence.
	 */toArray(){let t=[],e=this.firstNode;for(;null!==e;)t.push(e.element),e=e.next;return t}/**
	 * Returns the number of elements in this list.
	 * @return {number} the number of elements in this list.
	 */size(){return this.nElements}/**
	 * Returns true if this list contains no elements.
	 * @return {boolean} true if this list contains no elements.
	 */isEmpty(){return this.nElements<=0}toString(){return Tf(this.toArray())}/**
	 * @private
	 */equalsAux(t,e,i){for(;null!==t&&null!==e;){if(!i(t.element,e.element))return!1;t=t.next,e=e.next}return!0}/**
	 * @private
	 */nodeAtIndex(t){if(t<0||t>=this.nElements)return null;if(t===this.nElements-1)return this.lastNode;let e=this.firstNode;for(let i=0;i<t&&null!==e;i++)e=e.next;return e}/**
	 * @private
	 */createNode(t){return{element:t,next:null}}}class Ty{/**
	 * Creates an empty queue.
	 * @class A queue is a First-In-First-Out (FIFO) data structure, the first
	 * element added to the queue will be the first one to be removed. This
	 * implementation uses a linked list as a container.
	 * @constructor
	 */constructor(){this.list=new Tg}/**
	 * Inserts the specified element into the end of this queue.
	 * @param {Object} elem the element to insert.
	 * @return {boolean} true if the element was inserted, or false if it is undefined.
	 */enqueue(t){return this.list.add(t)}/**
	 * Inserts the specified element into the end of this queue.
	 * @param {Object} elem the element to insert.
	 * @return {boolean} true if the element was inserted, or false if it is undefined.
	 */add(t){return this.list.add(t)}/**
	 * Retrieves and removes the head of this queue.
	 * @return {*} the head of this queue, or undefined if this queue is empty.
	 */dequeue(){if(0!==this.list.size()){let t=this.list.first();return this.list.removeElementAtIndex(0),t}}/**
	 * Retrieves, but does not remove, the head of this queue.
	 * @return {*} the head of this queue, or undefined if this queue is empty.
	 */peek(){if(0!==this.list.size())return this.list.first()}/**
	 * Returns the number of elements in this queue.
	 * @return {number} the number of elements in this queue.
	 */size(){return this.list.size()}/**
	 * Returns true if this queue contains the specified element.
	 * <p>If the elements inside this stack are
	 * not comparable with the === operator, a custom equals function should be
	 * provided to perform searches, the function must receive two arguments and
	 * return true if they are equal, false otherwise. Example:</p>
	 *
	 * <pre>
	 * const petsAreEqualByName (pet1, pet2) {
	 *  return pet1.name === pet2.name;
	 * }
	 * </pre>
	 * @param {Object} elem element to search for.
	 * @param {function(Object,Object):boolean=} equalsFunction optional
	 * function to check if two elements are equal.
	 * @return {boolean} true if this queue contains the specified element,
	 * false otherwise.
	 */contains(t,e){return this.list.contains(t,e)}/**
	 * Checks if this queue is empty.
	 * @return {boolean} true if and only if this queue contains no items; false
	 * otherwise.
	 */isEmpty(){return 0>=this.list.size()}/**
	 * Removes all of the elements from this queue.
	 */clear(){this.list.clear()}/**
	 * Executes the provided function once for each element present in this queue in
	 * FIFO order.
	 * @param {function(Object):*} callback function to execute, it is
	 * invoked with one argument: the element value, to break the iteration you can
	 * optionally return false.
	 */forEach(t){this.list.forEach(t)}}class T_{/**
	 * Creates an empty Heap.
	 * @class
	 * <p>A heap is a binary tree, where the nodes maintain the heap property:
	 * each node is smaller than each of its children and therefore a MinHeap
	 * This implementation uses an array to store elements.</p>
	 * <p>If the inserted elements are custom objects a compare function must be provided,
	 *  at construction time, otherwise the <=, === and >= operators are
	 * used to compare elements. Example:</p>
	 *
	 * <pre>
	 * function compare(a, b) {
	 *  if (a is less than b by some ordering criterion) {
	 *     return -1;
	 *  } if (a is greater than b by the ordering criterion) {
	 *     return 1;
	 *  }
	 *  // a must be equal to b
	 *  return 0;
	 * }
	 * </pre>
	 *
	 * <p>If a Max-Heap is wanted (greater elements on top) you can a provide a
	 * reverse compare function to accomplish that behavior. Example:</p>
	 *
	 * <pre>
	 * function reverseCompare(a, b) {
	 *  if (a is less than b by some ordering criterion) {
	 *     return 1;
	 *  } if (a is greater than b by the ordering criterion) {
	 *     return -1;
	 *  }
	 *  // a must be equal to b
	 *  return 0;
	 * }
	 * </pre>
	 *
	 * @constructor
	 * @param {function(Object,Object):number=} compareFunction optional
	 * function used to compare two elements. Must return a negative integer,
	 * zero, or a positive integer as the first argument is less than, equal to,
	 * or greater than the second.
	 */constructor(t){/**
	 * Array used to store the elements of the heap.
	 * @type {Array.<Object>}
	 * @private
	 */this.data=[],this.compare=t||Ts}/**
	 * Retrieves but does not remove the root element of this heap.
	 * @return {*} The value at the root of the heap. Returns undefined if the
	 * heap is empty.
	 */peek(){return this.data.length>0?this.data[0]:void 0}/**
	 * Adds the given element into the heap.
	 * @param {*} element the element.
	 * @return true if the element was added or fals if it is undefined.
	 */add(t){return!Th(t)&&(this.data.push(t),this.siftUp(this.data.length-1),!0)}/**
	 * Retrieves and removes the root element of this heap.
	 * @return {*} The value removed from the root of the heap. Returns
	 * undefined if the heap is empty.
	 */removeRoot(){if(this.data.length>0){let t=this.data[0];return this.data[0]=this.data[this.data.length-1],this.data.splice(this.data.length-1,1),this.data.length>0&&this.siftDown(0),t}}/**
	 * Returns true if this heap contains the specified element.
	 * @param {Object} element element to search for.
	 * @return {boolean} true if this Heap contains the specified element, false
	 * otherwise.
	 */contains(t){let e=Tu(this.compare);return Td(this.data,t,e)}/**
	 * Returns the number of elements in this heap.
	 * @return {number} the number of elements in this heap.
	 */size(){return this.data.length}/**
	 * Checks if this heap is empty.
	 * @return {boolean} true if and only if this heap contains no items; false
	 * otherwise.
	 */isEmpty(){return this.data.length<=0}/**
	 * Removes all of the elements from this heap.
	 */clear(){this.data.length=0}/**
	 * Executes the provided function once for each element present in this heap in
	 * no particular order.
	 * @param {function(Object):*} callback function to execute, it is
	 * invoked with one argument: the element value, to break the iteration you can
	 * optionally return false.
	 */forEach(t){Tm(this.data,t)}/**
	 * Returns the index of the left child of the node at the given index.
	 * @param {number} nodeIndex The index of the node to get the left child
	 * for.
	 * @return {number} The index of the left child.
	 * @private
	 */leftChildIndex(t){return 2*t+1}/**
	 * Returns the index of the right child of the node at the given index.
	 * @param {number} nodeIndex The index of the node to get the right child
	 * for.
	 * @return {number} The index of the right child.
	 * @private
	 */rightChildIndex(t){return 2*t+2}/**
	 * Returns the index of the parent of the node at the given index.
	 * @param {number} nodeIndex The index of the node to get the parent for.
	 * @return {number} The index of the parent.
	 * @private
	 */parentIndex(t){return Math.floor((t-1)/2)}/**
	 * Returns the index of the smaller child node (if it exists).
	 * @param {number} leftChild left child index.
	 * @param {number} rightChild right child index.
	 * @return {number} the index with the minimum value or -1 if it doesn't
	 * exists.
	 * @private
	 */minIndex(t,e){return e>=this.data.length?t>=this.data.length?-1:t:0>=this.compare(this.data[t],this.data[e])?t:e}/**
	 * Moves the node at the given index up to its proper place in the heap.
	 * @param {number} index The index of the node to move up.
	 * @private
	 */siftUp(t){let e=this.parentIndex(t);for(;t>0&&this.compare(this.data[e],this.data[t])>0;)Tp(this.data,e,t),t=e,e=this.parentIndex(t)}/**
	 * Moves the node at the given index down to its proper place in the heap.
	 * @param {number} nodeIndex The index of the node to move down.
	 * @private
	 */siftDown(t){//smaller child index
let e=this.minIndex(this.leftChildIndex(t),this.rightChildIndex(t));for(;e>=0&&this.compare(this.data[t],this.data[e])>0;)Tp(this.data,e,t),t=e,e=this.minIndex(this.leftChildIndex(t),this.rightChildIndex(t))}}class Tv{/**
	 * Creates an empty priority queue.
	 * @class <p>In a priority queue each element is associated with a "priority",
	 * elements are dequeued in highest-priority-first order (the elements with the
	 * highest priority are dequeued first). Priority Queues are implemented as heaps.
	 * If the inserted elements are custom objects a compare function must be provided,
	 * otherwise the <=, === and >= operators are used to compare object priority.</p>
	 * <pre>
	 * function compare(a, b) {
	 *  if (a is less than b by some ordering criterion) {
	 *     return -1;
	 *  } if (a is greater than b by the ordering criterion) {
	 *     return 1;
	 *  }
	 *  // a must be equal to b
	 *  return 0;
	 * }
	 * </pre>
	 * @constructor
	 * @param {function(Object,Object):number=} compareFunction optional
	 * function used to compare two element priorities. Must return a negative integer,
	 * zero, or a positive integer as the first argument is less than, equal to,
	 * or greater than the second.
	 */constructor(t){this.heap=new T_(Tl(t))}/**
	 * Inserts the specified element into this priority queue.
	 * @param {Object} element the element to insert.
	 * @return {boolean} true if the element was inserted, or false if it is undefined.
	 */enqueue(t){return this.heap.add(t)}/**
	 * Inserts the specified element into this priority queue.
	 * @param {Object} element the element to insert.
	 * @return {boolean} true if the element was inserted, or false if it is undefined.
	 */add(t){return this.heap.add(t)}/**
	 * Retrieves and removes the highest priority element of this queue.
	 * @return {*} the the highest priority element of this queue,
	 *  or undefined if this queue is empty.
	 */dequeue(){if(0!==this.heap.size()){let t=this.heap.peek();return this.heap.removeRoot(),t}}/**
	 * Retrieves, but does not remove, the highest priority element of this queue.
	 * @return {*} the highest priority element of this queue, or undefined if this queue is empty.
	 */peek(){return this.heap.peek()}/**
	 * Returns true if this priority queue contains the specified element.
	 * @param {Object} element element to search for.
	 * @return {boolean} true if this priority queue contains the specified element,
	 * false otherwise.
	 */contains(t){return this.heap.contains(t)}/**
	 * Checks if this priority queue is empty.
	 * @return {boolean} true if and only if this priority queue contains no items; false
	 * otherwise.
	 */isEmpty(){return this.heap.isEmpty()}/**
	 * Returns the number of elements in this priority queue.
	 * @return {number} the number of elements in this priority queue.
	 */size(){return this.heap.size()}/**
	 * Removes all of the elements from this priority queue.
	 */clear(){this.heap.clear()}/**
	 * Executes the provided function once for each element present in this queue in
	 * no particular order.
	 * @param {function(Object):*} callback function to execute, it is
	 * invoked with one argument: the element value, to break the iteration you can
	 * optionally return false.
	 */forEach(t){this.heap.forEach(t)}}class Tx{constructor(){// map with steps from start to goal
this.cameFrom=new Map,// set of all visited nodes
this.visited=new Set,// output entity
this.pathFound=[]}}class Tb{constructor(t,e){this.first=t,this.second=e}}class TE{calcPathFromSteps(t,e,i,r){let n=e,s=[];for(s.push(n);!n.equals(t);)s.push(n=i.get(this.indexMapper(n,r)));return s.reverse()}constructor(){/**
	 * Transforms vector to a unique number, must know the width of the map
	 */this.indexMapper=(t,e)=>t.y*e+t.x}}class TT extends TE{search(t,e,i,r){let n=new Ty;for(n.add(e),r.cameFrom.set(this.indexMapper(e,t.width),e);!n.isEmpty();){let s=n.peek();if(r.visited.add(this.indexMapper(s,t.width)),n.dequeue(),s.equals(i))return(// the goal was achieved
r.pathFound=this.calcPathFromSteps(e,i,r.cameFrom,t.width),!0);for(let e of t.getNeighbors(s))r.cameFrom.has(this.indexMapper(e,t.width))||(n.enqueue(e),r.cameFrom.set(this.indexMapper(e,t.width),s))}return!1}}class Tw extends TE{search(t,e,i,r){// initialize priority queue, using GREATER comparator
let n=new Tv((t,e)=>t.second===e.second?0:t.second<e.second?1:-1),s=new Map;for(// start with the first position
n.enqueue(new Tb(e,0)),r.cameFrom.set(this.indexMapper(e,t.width),e),s.set(this.indexMapper(e,t.width),0);!n.isEmpty();){let o=n.dequeue();if(r.visited.add(this.indexMapper(o.first,t.width)),o.first.equals(i))return(// the goal was achieved
r.pathFound=this.calcPathFromSteps(e,i,r.cameFrom,t.width),!0);for(let e of t.getNeighbors(o.first)){let i=s.get(this.indexMapper(o.first,t.width))+t.getCost(o.first,e);(!s.has(this.indexMapper(e,t.width))||i<s.get(this.indexMapper(e,t.width)))&&(s.set(this.indexMapper(e,t.width),i),r.cameFrom.set(this.indexMapper(e,t.width),o.first),n.add(new Tb(e,i)))}}return!1}}class TS extends TE{search(t,e,i,r,n="manhattan",s){// initialize priority queue, using GREATER comparator
let o=new Tv((t,e)=>t.second===e.second?0:t.second<e.second?1:-1),a=new Map;for(// start with the first position
o.enqueue(new Tb(e,0)),r.cameFrom.set(this.indexMapper(e,t.width),e),a.set(this.indexMapper(e,t.width),0);!o.isEmpty();){let h=o.dequeue();if(r.visited.add(this.indexMapper(h.first,t.width)),h.first.equals(i))return(// the goal was achieved
r.pathFound=this.calcPathFromSteps(e,i,r.cameFrom,t.width),!0);// explore neighbors
for(let e of t.getNeighbors(h.first)){// calculate the increment of the cost on the current path
let l=a.get(this.indexMapper(h.first,t.width))+t.getCost(h.first,e);// verify if there was a better way
if(!a.has(this.indexMapper(e,t.width))||l<a.get(this.indexMapper(e,t.width))){a.set(this.indexMapper(e,t.width),l);// priority is price + distance between next position and the target
let u="manhattan"===n?e.manhattanDistance(i):e.distance(i),c=s?s(l,u):l+u;r.cameFrom.set(this.indexMapper(e,t.width),h.first),o.add(new Tb(e,c))}}}return!1}}class TM{constructor(t,e,i,r){// grid size
this.width=0,this.height=0,// places that can't be crossed
this.obstructions=new Set,// elevations of map blocks
this.elevations=new Map,this.mapType=1,this.maxElevation=1,this.defaultElevation=1,/**
	 * We can't use Vector structure for hashmaps - this mapper only maps Vector into indices based on
	 * the size of the map
	 */this.indexMapper=t=>t.y*this.width+t.x,this.vectorMapper=t=>new hD(t%this.width,Math.floor(t/this.width)),this.mapType=t,this.maxElevation=e,this.width=i,this.height=r}/**
	 * Returns true, if there is an obstruction in given location
	 */hasObstruction(t){return this.obstructions.has(this.indexMapper(t))}notInside(t){return t.x<0||t.x>=this.width||t.y<0||t.y>=this.height}/**
	 * Gets elevation by given location
	 */getElevation(t){let e=this.indexMapper(t);return this.elevations.has(e)?this.elevations.get(this.indexMapper(t)):this.defaultElevation}/**
	 * Sets elevation
	 * @param pos location of the elevation (target block)
	 * @param cost cost of "approaching that block"
	 */setElevation(t,e){this.elevations.set(this.indexMapper(t),e)}addObstruction(t){this.obstructions.add(this.indexMapper(t))}removeObstruction(t){this.obstructions.delete(this.indexMapper(t))}getCost(t,e){// gets cost from point A to point B
// let's assume the cost is the same for all blocks that surround given block (described by 'from')
return this.elevations.has(this.indexMapper(t))?this.elevations.get(this.indexMapper(t)):this.defaultElevation;// uncomment those lines to get elevation relative to the direction
//let elevationFrom = this.elevations.has(this.indexMapper(from)) ? this.elevations.get(this.indexMapper(from)) : this.defaultElevation;
//let elevationTo = this.elevations.has(this.indexMapper(to)) ? this.elevations.get(this.indexMapper(to)) : this.defaultElevation;
//return elevationTo - elevationFrom;
}/**
	 * Gets all surrounding blocks
	 */getNeighbors(t){let e=[];if(1===this.mapType){let i=new hD(t.x-1,t.y),r=new hD(t.x+1,t.y),n=new hD(t.x,t.y-1),s=new hD(t.x,t.y+1);this.isInside(i)&&!this.obstructions.has(this.indexMapper(i))&&e.push(i),this.isInside(r)&&!this.obstructions.has(this.indexMapper(r))&&e.push(r),this.isInside(n)&&!this.obstructions.has(this.indexMapper(n))&&e.push(n),this.isInside(s)&&!this.obstructions.has(this.indexMapper(s))&&e.push(s)}else if(2===this.mapType){let i=new hD(t.x-1,t.y),r=new hD(t.x+1,t.y),n=new hD(t.x,t.y-1),s=new hD(t.x,t.y+1),o=new hD(t.x-1,t.y-1),a=new hD(t.x+1,t.y+1),h=new hD(t.x+1,t.y-1),l=new hD(t.x-1,t.y+1);this.isInside(i)&&!this.obstructions.has(this.indexMapper(i))&&e.push(i),this.isInside(r)&&!this.obstructions.has(this.indexMapper(r))&&e.push(r),this.isInside(n)&&!this.obstructions.has(this.indexMapper(n))&&e.push(n),this.isInside(s)&&!this.obstructions.has(this.indexMapper(s))&&e.push(s),this.isInside(o)&&!this.obstructions.has(this.indexMapper(o))&&e.push(o),this.isInside(a)&&!this.obstructions.has(this.indexMapper(a))&&e.push(a),this.isInside(h)&&!this.obstructions.has(this.indexMapper(h))&&e.push(h),this.isInside(l)&&!this.obstructions.has(this.indexMapper(l))&&e.push(l)}return e}isInside(t){return 0<=t.x&&t.x<this.width&&0<=t.y&&t.y<this.height}}var TA={};tC(TA,"seek",()=>TR),tC(TA,"flee",()=>TC),tC(TA,"evade",()=>TP),tC(TA,"pursuit",()=>TI),tC(TA,"wander",()=>TO),tC(TA,"follow",()=>TL);const TR=(t,e,i,r,n)=>{let s=t.subtract(e),o=s.magnitude();return s=s.normalize(),(s=n&&o<=n?s.multiply(r*(o/n)):s.multiply(r)).subtract(i)},TC=(t,e,i,r)=>{let n=e.subtract(t);return(n=(n=n.normalize()).multiply(r)).subtract(i)},TP=(t,e,i,r,n)=>{let s=t.subtract(e).magnitude()/i,o=n.multiply(s);return TC(t.add(o),e,r,i)},TI=(t,e,i,r,n)=>{let s=t.subtract(e).magnitude()/i,o=n.multiply(s);return TR(t.add(o),e,r,i,0)},TO=(t,e,i,r,n,s)=>{let o=new hD(2*Math.random()-1,2*Math.random()-1),a=e.clone();a=(a=(a=a.add(o.multiply(s*n))).normalize()).multiply(i);let h=t.normalize();return[e.add(h.multiply(r)),a]},TL=(t,e,i,r,n,s,o,a)=>{let h=r.currentPointIndex===i.segments.length-1?s:n;return(i.calcTargetPoint(h,t,r),t.distance(r.targetLocation)<=s)?null:r.currentPointIndex===i.segments.length-1?TR(r.targetLocation,t,e,o,a):TR(r.targetLocation,t,e,o,0)// nowhere to go to
};var TN={};tC(TN,"linear",()=>TD),tC(TN,"easeinout",()=>TF),tC(TN,"quadraticEaseIn",()=>TB),tC(TN,"quadraticEaseOut",()=>TU),tC(TN,"quadraticEaseInOut",()=>TG),tC(TN,"sineIn",()=>Tk),tC(TN,"sineOut",()=>TH),tC(TN,"expoIn",()=>Tz);const TD=(t,e,i)=>Math.min(1,Math.max(0,(t-e)/i)),TF=(t,e,i)=>{let r=TD(t,e,i);return Math.min(1,Math.max(0,r<.5?2*r*r:-1+(4-2*r)*r))},TB=(t,e,i)=>{let r=TD(t,e,i);return Math.min(1,Math.max(0,r*r))},TU=(t,e,i)=>{let r=TD(t,e,i);return Math.min(1,Math.max(0,1-(1-r)*(1-r)))},TG=(t,e,i)=>{let r=TD(t,e,i);return r<.5?.5*TB(2*r,0,1):1-.5*TB(2-2*r,0,1)},Tk=(t,e,i)=>Math.min(1,Math.max(0,Math.sin(TD(t,e,i)*Math.PI/2))),TH=(t,e,i)=>Math.min(1,Math.max(0,Math.sin((1-TD(t,e,i))*Math.PI/2))),Tz=(t,e,i)=>Math.min(1,Math.max(0,Math.pow(2,10*(TD(t,e,i)-1))));class Tj extends m0{load(){this.random=new E7(135061),this.render=new hy("");let t=this.engine.app.screen.width,e=this.engine.app.screen.height,i=t/3,r=new hy;this.engine.app.stage.addChild(r),r.beginFill(10923704),r.drawCircle(t/2,e/2,i),r.endFill(),this.engine.app.stage.addChild(this.render);let n=0;this.render.addComponent(new hO("").doOnUpdate((r,s,o)=>{let a=Math.floor(this.generateNumber(-i,i)),h=Math.floor(this.generateNumber(-i,i));this.render.beginFill(0),new hD(a,h).magnitude()<=i&&this.render.drawCircle(t/2+a,e/2+h,6),this.render.endFill(),n++>=1e3&&r.finish()}))}}// static map
// 0 = passable
// 1 = obstruction
// 2 = passable but higher cost (mud, forest, sand, whatever...)
let TV=[[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0],[0,0,1,0,0,0,1,0,0,2,0,0,1,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,1,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,1,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,1,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,1,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,0,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,2,2,2,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,1,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,1,1,1,2,0,0,0,0,0,0,2,2,2,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,2,2,1,0,0,0,0,0]];(o=j||(j={})).TILE="TILE",o.OCTILE="OCTILE",(a=V||(V={})).BREADTH_FIRST="BREADTH_FIRST",a.DIJKSTRA="DIJKSTRA",a.ASTAR="ASTAR",(h=X||(X={})).MANHATTAN="MANHATTAN",h.EUCLIDEAN="EUCLIDEAN",(l=W||(W={})).DEFAULT="DEFAULT",l.VERY_OPTIMISTIC="VERY_OPTIMISTIC",l.OPTIMISTIC="OPTIMISTIC",l.PESSIMISTIC="PESSIMISTIC",l.VERY_PESSIMISTIC="VERY_PESSIMISTIC";const TX={tomatoLight:"#ff867f",lemon:"#e9e56f",emerald:"#47d58a",royal:"#6f8ce9",rhino80:"#535e70",rhino40:"#a6aeb8"};(u=Y||(Y={}))[u.EULER_EXPLICIT=0]="EULER_EXPLICIT",u[u.EULER_IMPROVED=1]="EULER_IMPROVED",u[u.EULER_IMPLICIT=2]="EULER_IMPLICIT";/**
 * Component for numeric integration
 */class TW extends hi{onInit(){this.state={...this.props,color:this.props.color||16777215,position:new hD(this.owner.position.x,this.owner.position.y)}}onFixedUpdate(t,e){this.updateDynamics(.003*t),this.owner.position.set(this.state.position.x,this.state.position.y);let i="number"==typeof this.state.color?this.state.color:t1.string2hex(this.state.color),r=this.owner.asGraphics();r.clear(),r.beginFill(i),r.drawCircle(0,0,5),r.lineStyle(1,i),r.lineTo(this.state.velocity.x,this.state.velocity.y),r.endFill(),r.lineStyle(1,t1.string2hex(TX.rhino40));// draw history of last X steps
let n=this.fixedFrequency;for(let t=this.positionMemory.length-1;t>=Math.max(this.positionMemory.length-1-n,0);t--){let e=this.positionMemory[t];r.lineTo(e.x-this.owner.position.x,e.y-this.owner.position.y)}this.positionMemory.push(new hD(r.position.x,r.position.y)),this.owner.getBounds().bottom>=3*this.scene.app.screen.height&&(this.owner.destroy(),this.finish())}constructor(...t){super(...t),this.positionMemory=[]}}class TY extends TW{updateDynamics(t){let e=this.state.velocity.clone();this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(e.multiply(t))}}class Tq extends TW{updateDynamics(t){let e=this.state.velocity.clone();this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(e.add(this.state.velocity).multiply(.5*t))}}class TK extends TW{updateDynamics(t){this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(this.state.velocity.multiply(t))}}class TJ extends hi{constructor(t){super(),this.fixedFrequency=.5,this.particleFreq=t}onFixedUpdate(t,e){this.createProjectile(TX.lemon,1,Y.EULER_EXPLICIT),this.createProjectile(TX.royal,1,Y.EULER_IMPROVED),this.createProjectile(TX.tomatoLight,1,Y.EULER_IMPLICIT)}createProjectile(t,e,i){// initial velocity
let r,n=Math.sqrt(this.scene.app.screen.width)*Math.cos(this.owner.rotation)*4,s=Math.sqrt(this.scene.app.screen.width)*Math.sin(this.owner.rotation)*4,o=new hD(n,s),a=new hD(0,.75*Math.sqrt(this.scene.app.screen.height)),h=new hy;switch(h.pivot.set(1,1),h.alpha=e,i){case Y.EULER_EXPLICIT:r=new TY({color:t,velocity:o,acceleration:a});break;case Y.EULER_IMPLICIT:r=new TK({color:t,velocity:o,acceleration:a});break;case Y.EULER_IMPROVED:r=new Tq({color:t,velocity:o,acceleration:a})}r.fixedFrequency=this.particleFreq,new hR(this.scene).localPos(this.owner.position.x,this.owner.position.y).withComponent(r).withParent(this.scene.stage).buildInto(h)}}(c=q||(q={}))[c.EULER_EXPLICIT=0]="EULER_EXPLICIT",c[c.EULER_IMPROVED=1]="EULER_IMPROVED",c[c.EULER_IMPLICIT=2]="EULER_IMPLICIT";/**
* Component for numeric integration
*/class TZ extends hi{onInit(){this.state={...this.props,position:new hD(this.owner.position.x,this.owner.position.y),acceleration:new hD(0)},// init position
this.state.position=new hD(this.owner.position.x,this.owner.position.y)}onFixedUpdate(t,e){// update acceleration
this.state.acceleration=this.state.origin.subtract(this.state.position),this.updateDynamics(.001*t),this.owner.position.set(this.state.position.x,this.state.position.y);let i="number"==typeof this.state.color?this.state.color:t1.string2hex(this.state.color),r=this.owner.asGraphics();r.clear(),r.beginFill(i),r.drawCircle(0,0,10),r.lineStyle(1,i),r.lineTo(this.state.velocity.x,this.state.velocity.y)}}class T$ extends TZ{updateDynamics(t){let e=this.state.velocity.clone();this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(e.multiply(t))}}class TQ extends TZ{updateDynamics(t){let e=this.state.velocity.clone();this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(e.add(this.state.velocity).multiply(.5*t))}}class T0 extends TZ{updateDynamics(t){this.state.velocity=this.state.velocity.add(this.state.acceleration.multiply(t)),this.state.position=this.state.position.add(this.state.velocity.multiply(t))}}class T1 extends hi{/**
	 * Max steering angle in radians
	 */get steerLock(){// 30 is the maximum
return 30/180*Math.PI}move(t){this.speed=t}/**
	 * Will steer the car
	 * @param steering: a relative value from -1 to 1, limited by steerlock
	 */steer(t){this.steering=t,this.phi=this.steerLock*this.steering,// atan2(2l*sin(phi), 2l*cos(phi) - w*sin(phi))
this.phiI=Math.atan2(2*this.props.wheelBase*Math.sin(this.phi),2*this.props.wheelBase*Math.cos(this.phi)-this.props.trackWidth*Math.sin(this.phi)),// atan2(2l*sin(phi), 2l*cos(phi) + w*sin(phi))
this.phiO=Math.atan2(2*this.props.wheelBase*Math.sin(this.phi),2*this.props.wheelBase*Math.cos(this.phi)+this.props.trackWidth*Math.sin(this.phi))}onUpdate(t,e){let i=this.speed*t*.25;// slow it down a little bit
this.owner.position.x+=i*Math.cos(this.theta),this.owner.position.y+=i*Math.sin(this.theta),this.theta+=i/this.props.wheelBase*Math.tan(this.phi),this.owner.rotation=this.theta-Math.PI/2}constructor(...t){super(...t),this.speed=0,// current steering value, from -1 (-30) to 1 (30)
this.steering=0,// rotation of the car
this.theta=-Math.PI/2,// steering speed, in degrees per second
this.steerSpeed=0,// center angle (radians)
this.phi=0,// front left (radians)
this.phiI=0,// front right (radians)
this.phiO=0}}const T2={wheelColor:2906079,trackColor:7902186,frontWheelWidth:10,frontWheelHeight:30,backWheelWidth:15,backWheelHeight:30};class T3 extends hi{constructor(t,e){super({...T2,...t}),this.carEngine=e}onInit(){this.frontLeft=new hy,this.owner.addChild(this.frontLeft),this.frontRight=new hy,this.owner.addChild(this.frontRight)}onUpdate(t,e){let i=this.carEngine.props.wheelBase,r=this.carEngine.props.trackWidth,{wheelColor:n,trackColor:s,frontWheelWidth:o,frontWheelHeight:a,backWheelWidth:h,backWheelHeight:l}=this.props,u=this.owner.asGraphics();u.clear(),u.lineStyle({width:8,color:s}),// Middle axis
u.moveTo(0,0),u.lineTo(0,i),u.lineStyle({width:3,color:s}),// Back axis
u.moveTo(-r/2,0),u.lineTo(r/2,0),// Front axis
u.moveTo(-r/2,i),u.lineTo(r/2,i),// Backwheels
u.lineStyle(),u.beginFill(n),u.drawRect(-r/2-h/2,-l/2,h,l),u.drawRect(r/2-h/2,-l/2,h,l),// Front wheels
this.frontLeft.position.set(-r/2,i),this.frontLeft.rotation=this.carEngine.phiI,this.frontLeft.beginFill(n),this.frontLeft.drawRect(-o/2,-a/2,o,a),this.frontLeft.endFill(),this.frontRight.position.set(r/2,i),this.frontRight.rotation=this.carEngine.phiO,this.frontRight.beginFill(n),this.frontRight.drawRect(-o/2,-a/2,o,a),this.frontRight.endFill()}}class T5 extends hi{constructor(t,e){super(),this.car=t,this.keyInput=e}onUpdate(){this.keyInput.isKeyPressed(b7.KEY_UP)?this.car.move(1):this.keyInput.isKeyPressed(b7.KEY_DOWN)?this.car.move(-1):this.car.move(0),this.keyInput.isKeyPressed(b7.KEY_LEFT)?this.car.steer(-1):this.keyInput.isKeyPressed(b7.KEY_RIGHT)?this.car.steer(1):this.car.steer(0)}}/**
 * A helper class that keeps car engine parameters
 */class T4{constructor(t=1,e=.2,i=.95){this.power=0,this.trottle=0,this.friction=0,this.reverse=!1,// current braking power
this.brakingPower=0,this.velocity=0,this.maxPower=t,this.maxPowerInReverse=e,this.friction=i}setTrottle(t){this.trottle=t,this.updatePower()}updatePower(){this.trottle>=0?this.power=this.maxPower*this.trottle:this.power=this.maxPowerInReverse*this.trottle}/**
	 * Brake while reverse gear is on
 	*/brakeReverse(t){this.reverse?this.trottleDown(t):(this.trottleDownToZero(.1),this.brakingPower=t,this.velocity<.01&&(this.reverse=!0))}brake(t){this.trottleDownToZero(.3),this.brakingPower=t,this.velocity<.001&&(this.velocity=0)}trottleUp(t){this.trottle+t<=1?this.trottle+=t:this.trottle=1,this.updatePower()}trottleDown(t){this.trottle-t>=0?this.trottle-=t:this.trottle-t>-1&&(this.trottle-=t),this.updatePower()}trottleDownToZero(t){this.trottle-t>=0?this.trottle-=t:this.trottle=0,this.updatePower()}update(t){this.trottle>0?this.trottleDownToZero(.0016):this.trottle<0&&this.trottleUp(.0016),this.reverse&&this.velocity>.01&&(this.reverse=!1),this.brakingPower>0&&(// slow down a little bit
this.velocity*=.95,this.brakingPower-=1),this.velocity+=this.power,this.velocity*=this.friction}}class T6{constructor(t,e,i){this.radius=0,// current rotation
this.rotation=0,this.xOffset=e,this.yOffset=i,this.radius=t}}const T8=(t,e,i,r,n)=>new hD(t+n*Math.cos(-i)-r*Math.sin(-i),e+n*Math.sin(-i)+r*Math.cos(-i)),T7={minSteeringRadius:80,maxSteeringRadius:1e3,rotation:0};class T9 extends hi{constructor(t){// merge with defaults
super({...T7,...t}),this.rotation=0,this.wheels={frontLeft:null,frontRight:null,backLeft:null,backRight:null},// precalculated center of back wheels along x axis
this.centerOfBackWheelsX=0,// current steering radius
this.steerRadius=0,// current steering angle
this.steerAngle=.5*Math.PI,this.engine=new T4,this.newSteerAngle=0,this._name="CarComponent",this.rotation=this.props.rotation}onInit(){this.wheels.frontLeft=new T6(this.props.wheelSize,this.props.wheelBase/2,-(this.props.trackWidth/2)),this.wheels.frontRight=new T6(this.props.wheelSize,this.props.wheelBase/2,this.props.trackWidth/2),this.wheels.backLeft=new T6(this.props.wheelSize,-(this.props.wheelBase/2),-(this.props.trackWidth/2)),this.wheels.backRight=new T6(this.props.wheelSize,-(this.props.wheelBase/2),this.props.trackWidth/2),this.centerOfBackWheelsX=(this.wheels.backLeft.xOffset+this.wheels.backRight.xOffset)/2}trottleUp(t){this.engine.trottleUp(t)}/**
	 * Brake while reverse gear is on
	 */brakeReverse(t){this.engine.brakeReverse(t)}brake(t){this.engine.brake(t)}/**
	 * Applies steering
	 * @angleDelta delta angle in radians
	 */steer(t){this.steerAngle+t>Math.PI?this.newSteerAngle=-this.steerAngle+t:this.newSteerAngle=this.steerAngle+t;// calculate ackermann rotation
let e=Math.tan(this.newSteerAngle)*this.props.wheelBase;if(Math.abs(e)>this.props.minSteeringRadius)// every front wheel will have a slightly different angle
for(let t of(this.steerAngle=this.newSteerAngle,this.steerRadius=e,[this.wheels.frontLeft,this.wheels.frontRight])){let i=Math.atan((this.centerOfBackWheelsX-t.xOffset)/(t.yOffset-e));t.rotation=i}}onUpdate(t,e){if(this.engine.update(t),Math.abs(this.steerRadius)>0&&Math.abs(this.steerRadius)<this.props.maxSteeringRadius){// the car is rotating around a circle -> we need to use Ackermann equations
let t=T8(this.owner.position.x,this.owner.position.y,this.rotation,this.centerOfBackWheelsX,this.steerRadius),e=Math.sqrt(this.centerOfBackWheelsX*this.centerOfBackWheelsX+this.steerRadius*this.steerRadius),i=Math.atan2(this.owner.position.x-t.x,this.owner.position.y-t.y),r=this.engine.velocity,n=Math.sign(this.steerRadius)*r/e,s=t.x+e*Math.sin(i+n),o=t.y+e*Math.cos(i+n);this.owner.position.set(s,o),this.rotation+=n}else // the car is going straight ahead
this.owner.position.x+=this.engine.velocity*Math.sin(this.rotation),this.owner.position.y+=this.engine.velocity*Math.cos(this.rotation)}}class wt extends hi{onUpdate(t,e){let i=this.owner.position.x,r=this.owner.position.y,n=this.owner.asGraphics();for(let t of(n.clear(),this.renderAxis(n,i,r),Object.keys(this.props.car.wheels))){let e=this.props.car.wheels[t];this.renderWheel(e,n,i,r)}this.renderSteeringCircle(n,i,r)}renderAxis(t,e,i){let r=this.props.car;t.lineStyle({width:2,color:11184810});let n=.5*Math.sin(r.rotation)*r.props.wheelBase,s=.5*Math.cos(r.rotation)*r.props.wheelBase,o=new hD(n+r.owner.position.x,s+r.owner.position.y),a=new hD(r.owner.position.x-n,r.owner.position.y-s);t.moveTo(o.x-e,o.y-i),t.lineTo(a.x-e,a.y-i)}renderWheel(t,e,i,r){let n=t.rotation+this.props.car.rotation,s=Math.sin(n)*t.radius,o=Math.cos(n)*t.radius,a=this.calcAbsPosToCar(t.xOffset,t.yOffset),h=new hD(s+a.x,o+a.y),l=new hD(a.x-s,a.y-o);e.lineStyle({width:5,color:11184810}),e.moveTo(h.x-i,h.y-r),e.lineTo(l.x-i,l.y-r),e.lineStyle({width:2,color:11184810}),e.moveTo(a.x-i,a.y-r),e.lineTo(l.x-i,l.y-r);// draw center
let u=this.calcAbsPosToCar(t.xOffset,0);e.lineStyle({width:2,color:11184810}),e.moveTo(a.x-i,a.y-r),e.lineTo(u.x-i,u.y-r)}renderSteeringCircle(t,e,i){let r=this.props.car,n=this.calcAbsPosToCar(r.centerOfBackWheelsX,r.steerRadius),s=Math.abs(r.steerRadius);if(s>1&&s<r.props.maxSteeringRadius){// draw a line from the center to both front wheels
for(let s of(t.drawCircle(n.x-e,n.y-i,2),t.lineStyle({width:3,color:13578021}),[r.wheels.frontLeft,r.wheels.frontRight])){let r=this.calcAbsPosToCar(s.xOffset,s.yOffset);t.moveTo(r.x-e,r.y-i),t.lineTo(n.x-e,n.y-i)}t.drawCircle(n.x-e,n.y-i,s)}}calcAbsPosToCar(t,e){return T8(this.props.car.owner.position.x,this.props.car.owner.position.y,this.props.car.rotation,t,e)}}class we extends hi{onInit(){this.car=this.scene.findObjectByTag("car")}onUpdate(t,e){let i=this.scene.width/2,r=this.scene.height/2,n=this.car.position.x+this.scene.stage.position.x,s=this.car.position.y+this.scene.stage.position.y,o=Math.abs(n-i);if(o>4){let e=4e-5*t*(o*o)*Math.sign(i-n);this.scene.stage.position.x+=e}let a=Math.abs(s-r);if(a>4){let e=4e-5*(this.scene.height/this.scene.width),i=t*e*Math.pow(a,2),n=i*Math.sign(r-s);this.scene.stage.position.y+=n}}}class wi extends hi{constructor(t){super(),this.vehicle=t}onInit(){this.keyInput=new ha,this.owner.addComponent(this.keyInput)}onUpdate(){this.keyInput.isKeyPressed(b7.KEY_UP)&&this.vehicle.trottleUp(.003),this.keyInput.isKeyPressed(b7.KEY_DOWN)&&this.vehicle.brakeReverse(.002),this.keyInput.isKeyPressed(b7.KEY_LEFT)&&this.vehicle.steer(-.015),this.keyInput.isKeyPressed(b7.KEY_RIGHT)&&this.vehicle.steer(.015)}}class wr extends hi{onUpdate(){let t=this.owner.asGraphics();t.clear();let e=this.scene.stage.position,i=-e.x,r=-e.x+this.scene.width,n=-e.y,s=-e.y+this.scene.height;// draw background (Grid)
t.beginFill(2236962),t.drawRect(i-50,n-50,this.scene.width+100,this.scene.height+100),t.endFill(),t.lineStyle(1,8947848);// horizontal lines
for(let e=n-n%50;e<s;e+=50)t.moveTo(i,e),t.lineTo(r,e);// vertical lines
for(let e=i-i%50;e<r;e+=50)t.moveTo(e,n),t.lineTo(e,s)}}const wn="velocity",ws="acceleration";class wo extends hi{onInit(){super.onInit();let t=this.props.initialVelocity||new hD(0);this.owner.assignAttribute(wn,t),this.owner.assignAttribute(ws,new hD(0,0))}get velocity(){return this.owner.getAttribute(wn)}set velocity(t){this.owner.assignAttribute(wn,t)}get acceleration(){return this.owner.getAttribute(ws)}set acceleration(t){this.owner.assignAttribute(ws,t)}onUpdate(t,e){// update dynamics and set new position
let i=this.calcForce(t);if(null==i)return;// algorithm has finished
this.acceleration=i,// limit acceleration and velocity
this.acceleration=this.acceleration.limit(30),this.velocity=this.velocity.limit(1e3),this.applyVelocity(t,this.props.speed),this.applyPosition(t,this.props.speed);// change rotation based on the velocity
let r=Math.atan2(this.velocity.y,this.velocity.x);this.owner.rotation=r;// check borders - object will be moved to the opposite side of the scene
let n=this.owner.getBounds(),s=new iU(0,0,this.scene.app.screen.width,this.scene.app.screen.height);n.right<s.left&&this.velocity.x<0&&(this.owner.position.x+=s.width+n.width),n.left>s.right&&this.velocity.x>0&&(this.owner.position.x-=s.width+n.width),n.bottom<s.top&&this.velocity.y<0&&(this.owner.position.y+=s.height+n.height),n.top>s.bottom&&this.velocity.y>0&&(this.owner.position.y-=s.height+n.height)}applyVelocity(t,e){this.velocity=this.velocity.add(this.acceleration.multiply(.001*t*e))}applyPosition(t,e){let i=this.velocity.multiply(.001*t*e);this.owner.position.x+=i.x,this.owner.position.y+=i.y}}class wa extends wo{calcForce(t){let e=new hD(this.props.target.position.x,this.props.target.position.y),i=new hD(this.owner.position.x,this.owner.position.y),r=TA.seek(e,i,this.velocity,1e3,null).limit(5);return 1>e.distance(i)?(this.finish(),null):r}}class wh extends wo{calcForce(t){let e=new hD(this.props.target.position.x,this.props.target.position.y),i=new hD(this.owner.position.x,this.owner.position.y),r=this.props.target.getAttribute(wn);return TA.evade(e,i,30,this.velocity,r)}}class wl extends wo{calcForce(t){let e=new hD(this.props.target.position.x,this.props.target.position.y),i=new hD(this.owner.position.x,this.owner.position.y),r=this.props.target.getAttribute(wn);return TA.pursuit(e,i,300,this.velocity,r)}}class wu extends wo{onUpdate(t,e){super.onUpdate(t,e);let i=Math.atan2(this.acceleration.y,this.acceleration.x),r=Math.atan2(this.velocity.y,this.velocity.x);this.props.dot||(this.props.boid.rotation=r),this.props.dot&&this.props.dot.position.set(this.props.distance+Math.cos(i-r)*this.props.radius,Math.sin(i-r)*this.props.radius),this.props.circle&&this.props.circle.position.set(this.props.distance,0)}calcForce(t){let e=TA.wander(this.velocity,this.wanderTarget,this.props.radius,this.props.distance,this.props.jittering,t);return this.wanderTarget=e[1],e[0]}constructor(...t){super(...t),this.wanderTarget=new hD(0,0)}}var wc={};wc=/******/function(t){/******/// The module cache
/******/var e={};/******//******/// The require function
/******/function i(r){/******//******/// Check if module is in cache
/******/if(e[r])/******/return e[r].exports;/******/// Create a new module (and put it into the cache)
/******/var n=e[r]={/******/i:r,/******/l:!1,/******/exports:{}};/******//******/// Return the exports of the module
/******/return(/******//******/// Execute the module function
/******/t[r].call(n.exports,n,n.exports,i),/******//******/// Flag the module as loaded
/******/n.l=!0,n.exports);/******/}/******//******//******/// Load entry module and return exports
/******/return(/******//******//******/// expose the modules object (__webpack_modules__)
/******/i.m=t,/******//******/// expose the module cache
/******/i.c=e,/******//******/// define getter function for harmony exports
/******/i.d=function(t,e,r){/******/i.o(t,e)||/******/Object.defineProperty(t,e,{enumerable:!0,get:r});/******/},/******//******/// define __esModule on exports
/******/i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&/******/Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),/******/Object.defineProperty(t,"__esModule",{value:!0});/******/},/******//******/// create a fake namespace object
/******/// mode & 1: value is a module id, require it
/******/// mode & 2: merge all properties of value into the ns
/******/// mode & 4: return value when already ns object
/******/// mode & 8|1: behave like require
/******/i.t=function(t,e){/******/if(1&e&&(t=i(t)),8&e||4&e&&"object"==typeof t&&t&&t.__esModule)return t;/******/var r=Object.create(null);/******/if(/******/i.r(r),/******/Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(r,n,(function(e){return t[e]}).bind(null,n));/******/return r;/******/},/******//******/// getDefaultExport function for compatibility with non-harmony modules
/******/i.n=function(t){/******/var e=t&&t.__esModule?/******/function(){return t.default}:/******/function(){return t};/******/return /******/i.d(e,"a",e),e;/******/},/******//******/// Object.prototype.hasOwnProperty.call
/******/i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},/******//******/// __webpack_public_path__
/******/i.p="",i(i.s=22));/******/}([/* 0 *//***/function(t,e){/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/var i,r={};t.exports=r,r._nextId=0,r._seed=0,r._nowStartTime=+new Date,r._warnedOnce={},r._decomp=null,/**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */r.extend=function(t,e){var i,n;"boolean"==typeof e?(i=2,n=e):(i=1,n=!0);for(var s=i;s<arguments.length;s++){var o=arguments[s];if(o)for(var a in o)n&&o[a]&&o[a].constructor===Object?t[a]&&t[a].constructor!==Object?t[a]=o[a]:(t[a]=t[a]||{},r.extend(t[a],n,o[a])):t[a]=o[a]}return t},/**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */r.clone=function(t,e){return r.extend({},e,t)},/**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */r.keys=function(t){if(Object.keys)return Object.keys(t);// avoid hasOwnProperty for performance
var e=[];for(var i in t)e.push(i);return e},/**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */r.values=function(t){var e=[];if(Object.keys){for(var i=Object.keys(t),r=0;r<i.length;r++)e.push(t[i[r]]);return e}// avoid hasOwnProperty for performance
for(var n in t)e.push(t[n]);return e},/**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */r.get=function(t,e,i,r){e=e.split(".").slice(i,r);for(var n=0;n<e.length;n+=1)t=t[e[n]];return t},/**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */r.set=function(t,e,i,n,s){var o=e.split(".").slice(n,s);return r.get(t,e,0,-1)[o[o.length-1]]=i,i},/**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */r.shuffle=function(t){for(var e=t.length-1;e>0;e--){var i=Math.floor(r.random()*(e+1)),n=t[e];t[e]=t[i],t[i]=n}return t},/**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */r.choose=function(t){return t[Math.floor(r.random()*t.length)]},/**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */r.isElement=function(t){return"undefined"!=typeof HTMLElement?t instanceof HTMLElement:!!(t&&t.nodeType&&t.nodeName)},/**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */r.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)},/**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */r.isFunction=function(t){return"function"==typeof t},/**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */r.isPlainObject=function(t){return"object"==typeof t&&t.constructor===Object},/**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */r.isString=function(t){return"[object String]"===toString.call(t)},/**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */r.clamp=function(t,e,i){return t<e?e:t>i?i:t},/**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */r.sign=function(t){return t<0?-1:1},/**
     * Returns the current timestamp since the time origin (e.g. from page load).
     * The result is in milliseconds and will use high-resolution timing if available.
     * @method now
     * @return {number} the current timestamp in milliseconds
     */r.now=function(){if("undefined"!=typeof window&&window.performance){if(window.performance.now)return window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return Date.now?Date.now():new Date-r._nowStartTime},/**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */r.random=function(t,e){return e=void 0!==e?e:1,(t=void 0!==t?t:0)+i()*(e-t)},i=function(){return(// https://en.wikipedia.org/wiki/Linear_congruential_generator
r._seed=(9301*r._seed+49297)%233280,r._seed/233280)},/**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */r.colorToNumber=function(t){return 3==(t=t.replace("#","")).length&&(t=t.charAt(0)+t.charAt(0)+t.charAt(1)+t.charAt(1)+t.charAt(2)+t.charAt(2)),parseInt(t,16)},/**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */r.logLevel=1,/**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */r.log=function(){console&&r.logLevel>0&&r.logLevel<=3&&console.log.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */r.info=function(){console&&r.logLevel>0&&r.logLevel<=2&&console.info.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */r.warn=function(){console&&r.logLevel>0&&r.logLevel<=3&&console.warn.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},/**
     * Uses `Common.warn` to log the given message one time only.
     * @method warnOnce
     * @param ...objs {} The objects to log.
     */r.warnOnce=function(){var t=Array.prototype.slice.call(arguments).join(" ");r._warnedOnce[t]||(r.warn(t),r._warnedOnce[t]=!0)},/**
     * Shows a deprecated console warning when the function on the given object is called.
     * The target function will be replaced with a new function that first shows the warning
     * and then calls the original function.
     * @method deprecated
     * @param {object} obj The object or module
     * @param {string} name The property name of the function on obj
     * @param {string} warning The one-time message to show if the function is called
     */r.deprecated=function(t,e,i){t[e]=r.chain(function(){r.warnOnce("\uD83D\uDD05 deprecated \uD83D\uDD05",i)},t[e])},/**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */r.nextId=function(){return r._nextId++},/**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */r.indexOf=function(t,e){if(t.indexOf)return t.indexOf(e);for(var i=0;i<t.length;i++)if(t[i]===e)return i;return -1},/**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */r.map=function(t,e){if(t.map)return t.map(e);for(var i=[],r=0;r<t.length;r+=1)i.push(e(t[r]));return i},/**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */r.topologicalSort=function(t){// https://github.com/mgechev/javascript-algorithms
// Copyright (c) Minko Gechev (MIT license)
// Modifications: tidy formatting and naming
var e=[],i=[],n=[];for(var s in t)i[s]||n[s]||r._topologicalSort(s,i,n,t,e);return e},r._topologicalSort=function(t,e,i,n,s){var o=n[t]||[];i[t]=!0;for(var a=0;a<o.length;a+=1){var h=o[a];i[h]||e[h]||r._topologicalSort(h,e,i,n,s)}i[t]=!1,e[t]=!0,s.push(t)},/**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */r.chain=function(){for(var t=[],e=0;e<arguments.length;e+=1){var i=arguments[e];i._chained?t.push.apply(t,i._chained):t.push(i)}var r=function(){for(var e,i=Array(arguments.length),r=0,n=arguments.length;r<n;r++)i[r]=arguments[r];for(r=0;r<t.length;r+=1){var s=t[r].apply(e,i);void 0!==s&&(e=s)}return e};return r._chained=t,r},/**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */r.chainPathBefore=function(t,e,i){return r.set(t,e,r.chain(i,r.get(t,e)))},/**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */r.chainPathAfter=function(t,e,i){return r.set(t,e,r.chain(r.get(t,e),i))},/**
     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable
     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.
     * @method setDecomp
     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.
     */r.setDecomp=function(t){r._decomp=t},/**
     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,
     * otherwise returns the global `decomp` if set.
     * @method getDecomp
     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.
     */r.getDecomp=function(){// get user provided decomp if set
var t=r._decomp;try{t||"undefined"==typeof window||(t=window.decomp),t||void 0===tA||(t=tA.decomp)}catch(e){// decomp not available
t=null}return t};/***/},/* 1 *//***/function(t,e){/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/var i={};t.exports=i,/**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */i.create=function(t){var e={min:{x:0,y:0},max:{x:0,y:0}};return t&&i.update(e,t),e},/**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */i.update=function(t,e,i){t.min.x=1/0,t.max.x=-1/0,t.min.y=1/0,t.max.y=-1/0;for(var r=0;r<e.length;r++){var n=e[r];n.x>t.max.x&&(t.max.x=n.x),n.x<t.min.x&&(t.min.x=n.x),n.y>t.max.y&&(t.max.y=n.y),n.y<t.min.y&&(t.min.y=n.y)}i&&(i.x>0?t.max.x+=i.x:t.min.x+=i.x,i.y>0?t.max.y+=i.y:t.min.y+=i.y)},/**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */i.contains=function(t,e){return e.x>=t.min.x&&e.x<=t.max.x&&e.y>=t.min.y&&e.y<=t.max.y},/**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */i.overlaps=function(t,e){return t.min.x<=e.max.x&&t.max.x>=e.min.x&&t.max.y>=e.min.y&&t.min.y<=e.max.y},/**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */i.translate=function(t,e){t.min.x+=e.x,t.max.x+=e.x,t.min.y+=e.y,t.max.y+=e.y},/**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */i.shift=function(t,e){var i=t.max.x-t.min.x,r=t.max.y-t.min.y;t.min.x=e.x,t.max.x=e.x+i,t.min.y=e.y,t.max.y=e.y+r};/***/},/* 2 *//***/function(t,e){/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/// TODO: consider params for reusing vector objects
var i={};t.exports=i,/**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */i.create=function(t,e){return{x:t||0,y:e||0}},/**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */i.clone=function(t){return{x:t.x,y:t.y}},/**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */i.magnitude=function(t){return Math.sqrt(t.x*t.x+t.y*t.y)},/**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */i.magnitudeSquared=function(t){return t.x*t.x+t.y*t.y},/**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} [output]
     * @return {vector} The vector rotated about (0, 0)
     */i.rotate=function(t,e,i){var r=Math.cos(e),n=Math.sin(e);i||(i={});var s=t.x*r-t.y*n;return i.y=t.x*n+t.y*r,i.x=s,i},/**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */i.rotateAbout=function(t,e,i,r){var n=Math.cos(e),s=Math.sin(e);r||(r={});var o=i.x+((t.x-i.x)*n-(t.y-i.y)*s);return r.y=i.y+((t.x-i.x)*s+(t.y-i.y)*n),r.x=o,r},/**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */i.normalise=function(t){var e=i.magnitude(t);return 0===e?{x:0,y:0}:{x:t.x/e,y:t.y/e}},/**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */i.dot=function(t,e){return t.x*e.x+t.y*e.y},/**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */i.cross=function(t,e){return t.x*e.y-t.y*e.x},/**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */i.cross3=function(t,e,i){return(e.x-t.x)*(i.y-t.y)-(e.y-t.y)*(i.x-t.x)},/**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */i.add=function(t,e,i){return i||(i={}),i.x=t.x+e.x,i.y=t.y+e.y,i},/**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */i.sub=function(t,e,i){return i||(i={}),i.x=t.x-e.x,i.y=t.y-e.y,i},/**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */i.mult=function(t,e){return{x:t.x*e,y:t.y*e}},/**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */i.div=function(t,e){return{x:t.x/e,y:t.y/e}},/**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */i.perp=function(t,e){return{x:-((e=!0===e?-1:1)*t.y),y:e*t.x}},/**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */i.neg=function(t){return{x:-t.x,y:-t.y}},/**
     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */i.angle=function(t,e){return Math.atan2(e.y-t.y,e.x-t.x)},/**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */i._temp=[i.create(),i.create(),i.create(),i.create(),i.create(),i.create()];/***/},/* 3 *//***/function(t,e,i){/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/var r={};t.exports=r;var n=i(2),s=i(0);/**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */r.create=function(t,e){for(var i=[],r=0;r<t.length;r++){var n=t[r],s={x:n.x,y:n.y,index:r,body:e,isInternal:!1};i.push(s)}return i},/**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */r.fromPath=function(t,e){var i=[];return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig,function(t,e,r){i.push({x:parseFloat(e),y:parseFloat(r)})}),r.create(i,e)},/**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */r.centre=function(t){for(var e,i,s,o=r.area(t,!0),a={x:0,y:0},h=0;h<t.length;h++)s=(h+1)%t.length,e=n.cross(t[h],t[s]),i=n.mult(n.add(t[h],t[s]),e),a=n.add(a,i);return n.div(a,6*o)},/**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */r.mean=function(t){for(var e={x:0,y:0},i=0;i<t.length;i++)e.x+=t[i].x,e.y+=t[i].y;return n.div(e,t.length)},/**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */r.area=function(t,e){for(var i=0,r=t.length-1,n=0;n<t.length;n++)i+=(t[r].x-t[n].x)*(t[r].y+t[n].y),r=n;return e?i/2:Math.abs(i)/2},/**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */r.inertia=function(t,e){// find the polygon's moment of inertia, using second moment of area
// from equations at http://www.physicsforums.com/showthread.php?t=25293
for(var i,r,s=0,o=0,a=0;a<t.length;a++)r=(a+1)%t.length,s+=(i=Math.abs(n.cross(t[r],t[a])))*(n.dot(t[r],t[r])+n.dot(t[r],t[a])+n.dot(t[a],t[a])),o+=i;return e/6*(s/o)},/**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */r.translate=function(t,e,i){var r;if(i)for(r=0;r<t.length;r++)t[r].x+=e.x*i,t[r].y+=e.y*i;else for(r=0;r<t.length;r++)t[r].x+=e.x,t[r].y+=e.y;return t},/**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */r.rotate=function(t,e,i){if(0!==e){for(var r=Math.cos(e),n=Math.sin(e),s=0;s<t.length;s++){var o=t[s],a=o.x-i.x,h=o.y-i.y;o.x=i.x+(a*r-h*n),o.y=i.y+(a*n+h*r)}return t}},/**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */r.contains=function(t,e){for(var i=0;i<t.length;i++){var r=t[i],n=t[(i+1)%t.length];if((e.x-r.x)*(n.y-r.y)+(e.y-r.y)*(r.x-n.x)>0)return!1}return!0},/**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */r.scale=function(t,e,i,s){if(1===e&&1===i)return t;s=s||r.centre(t);for(var o,a,h=0;h<t.length;h++)o=t[h],a=n.sub(o,s),t[h].x=s.x+a.x*e,t[h].y=s.y+a.y*i;return t},/**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */r.chamfer=function(t,e,i,r,o){e="number"==typeof e?[e]:e||[8],// quality defaults to -1, which is auto
i=void 0!==i?i:-1,r=r||2,o=o||14;for(var a=[],h=0;h<t.length;h++){var l=t[h-1>=0?h-1:t.length-1],u=t[h],c=t[(h+1)%t.length],d=e[h<e.length?h:e.length-1];if(0===d){a.push(u);continue}var p=n.normalise({x:u.y-l.y,y:l.x-u.x}),f=n.normalise({x:c.y-u.y,y:u.x-c.x}),m=Math.sqrt(2*Math.pow(d,2)),g=n.mult(s.clone(p),d),y=n.normalise(n.mult(n.add(p,f),.5)),_=n.sub(u,n.mult(y,m)),v=i;-1===i&&(v=1.75*Math.pow(d,.32)),(v=s.clamp(v,r,o))%2==1&&(v+=1);for(var x=Math.acos(n.dot(p,f))/v,b=0;b<v;b++)a.push(n.add(n.rotate(g,x*b),_))}return a},/**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */r.clockwiseSort=function(t){var e=r.mean(t);return t.sort(function(t,i){return n.angle(e,t)-n.angle(e,i)}),t},/**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */r.isConvex=function(t){// http://paulbourke.net/geometry/polygonmesh/
// Copyright (c) Paul Bourke (use permitted)
var e,i,r,n,s=0,o=t.length;if(o<3)return null;for(e=0;e<o;e++)if(i=(e+1)%o,r=(e+2)%o,(n=(t[i].x-t[e].x)*(t[r].y-t[i].y)-(t[i].y-t[e].y)*(t[r].x-t[i].x))<0?s|=1:n>0&&(s|=2),3===s)return!1;return 0!==s||null},/**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */r.hull=function(t){// http://geomalgorithms.com/a10-_hull-1.html
var e,i,r=[],s=[];// build lower hull
for(// sort vertices on x-axis (y-axis for ties)
(t=t.slice(0)).sort(function(t,e){var i=t.x-e.x;return 0!==i?i:t.y-e.y}),i=0;i<t.length;i+=1){for(e=t[i];s.length>=2&&0>=n.cross3(s[s.length-2],s[s.length-1],e);)s.pop();s.push(e)}// build upper hull
for(i=t.length-1;i>=0;i-=1){for(e=t[i];r.length>=2&&0>=n.cross3(r[r.length-2],r[r.length-1],e);)r.pop();r.push(e)}return(// concatenation of the lower and upper hulls gives the convex hull
// omit last points because they are repeated at the beginning of the other list
r.pop(),s.pop(),r.concat(s))};/***/},/* 4 *//***/function(t,e,i){/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/var r={};t.exports=r;var n=i(0);/**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */r.on=function(t,e,i){for(var r,n=e.split(" "),s=0;s<n.length;s++)r=n[s],t.events=t.events||{},t.events[r]=t.events[r]||[],t.events[r].push(i);return i},/**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */r.off=function(t,e,i){if(!e){t.events={};return}// handle Events.off(object, callback)
"function"==typeof e&&(i=e,e=n.keys(t.events).join(" "));for(var r=e.split(" "),s=0;s<r.length;s++){var o=t.events[r[s]],a=[];if(i&&o)for(var h=0;h<o.length;h++)o[h]!==i&&a.push(o[h]);t.events[r[s]]=a}},/**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */r.trigger=function(t,e,i){var r,s,o,a,h=t.events;if(h&&n.keys(h).length>0){i||(i={}),r=e.split(" ");for(var l=0;l<r.length;l++)if(o=h[s=r[l]]){(a=n.clone(i,!1)).name=s,a.source=t;for(var u=0;u<o.length;u++)o[u].apply(t,[a])}}};/***/},/* 5 *//***/function(t,e,i){/**
* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.
*
* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.
* A composite could contain anything from a single body all the way up to a whole world.
* 
* When making any changes to composites, use the included functions rather than changing their properties directly.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/var r={};t.exports=r;var n=i(4),s=i(0),o=i(1),a=i(6);/**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */r.create=function(t){return s.extend({id:s.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{}},t)},/**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */r.setModified=function(t,e,i,n){if(t.isModified=e,i&&t.parent&&r.setModified(t.parent,e,i,n),n)for(var s=0;s<t.composites.length;s++){var o=t.composites[s];r.setModified(o,e,i,n)}},/**
     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)
     * @return {composite} The original composite with the objects added
     */r.add=function(t,e){var i=[].concat(e);n.trigger(t,"beforeAdd",{object:e});for(var o=0;o<i.length;o++){var a=i[o];switch(a.type){case"body":// skip adding compound parts
if(a.parent!==a){s.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");break}r.addBody(t,a);break;case"constraint":r.addConstraint(t,a);break;case"composite":r.addComposite(t,a);break;case"mouseConstraint":r.addConstraint(t,a.constraint)}}return n.trigger(t,"afterAdd",{object:e}),t},/**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {object|array} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */r.remove=function(t,e,i){var s=[].concat(e);n.trigger(t,"beforeRemove",{object:e});for(var o=0;o<s.length;o++){var a=s[o];switch(a.type){case"body":r.removeBody(t,a,i);break;case"constraint":r.removeConstraint(t,a,i);break;case"composite":r.removeComposite(t,a,i);break;case"mouseConstraint":r.removeConstraint(t,a.constraint)}}return n.trigger(t,"afterRemove",{object:e}),t},/**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */r.addComposite=function(t,e){return t.composites.push(e),e.parent=t,r.setModified(t,!0,!0,!1),t},/**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */r.removeComposite=function(t,e,i){var n=s.indexOf(t.composites,e);if(-1!==n&&(r.removeCompositeAt(t,n),r.setModified(t,!0,!0,!1)),i)for(var o=0;o<t.composites.length;o++)r.removeComposite(t.composites[o],e,!0);return t},/**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */r.removeCompositeAt=function(t,e){return t.composites.splice(e,1),r.setModified(t,!0,!0,!1),t},/**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */r.addBody=function(t,e){return t.bodies.push(e),r.setModified(t,!0,!0,!1),t},/**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */r.removeBody=function(t,e,i){var n=s.indexOf(t.bodies,e);if(-1!==n&&(r.removeBodyAt(t,n),r.setModified(t,!0,!0,!1)),i)for(var o=0;o<t.composites.length;o++)r.removeBody(t.composites[o],e,!0);return t},/**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */r.removeBodyAt=function(t,e){return t.bodies.splice(e,1),r.setModified(t,!0,!0,!1),t},/**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */r.addConstraint=function(t,e){return t.constraints.push(e),r.setModified(t,!0,!0,!1),t},/**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */r.removeConstraint=function(t,e,i){var n=s.indexOf(t.constraints,e);if(-1!==n&&r.removeConstraintAt(t,n),i)for(var o=0;o<t.composites.length;o++)r.removeConstraint(t.composites[o],e,!0);return t},/**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */r.removeConstraintAt=function(t,e){return t.constraints.splice(e,1),r.setModified(t,!0,!0,!1),t},/**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */r.clear=function(t,e,i){if(i)for(var n=0;n<t.composites.length;n++)r.clear(t.composites[n],e,!0);return e?t.bodies=t.bodies.filter(function(t){return t.isStatic}):t.bodies.length=0,t.constraints.length=0,t.composites.length=0,r.setModified(t,!0,!0,!1),t},/**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */r.allBodies=function(t){for(var e=[].concat(t.bodies),i=0;i<t.composites.length;i++)e=e.concat(r.allBodies(t.composites[i]));return e},/**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */r.allConstraints=function(t){for(var e=[].concat(t.constraints),i=0;i<t.composites.length;i++)e=e.concat(r.allConstraints(t.composites[i]));return e},/**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */r.allComposites=function(t){for(var e=[].concat(t.composites),i=0;i<t.composites.length;i++)e=e.concat(r.allComposites(t.composites[i]));return e},/**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */r.get=function(t,e,i){var n,s;switch(i){case"body":n=r.allBodies(t);break;case"constraint":n=r.allConstraints(t);break;case"composite":n=r.allComposites(t).concat(t)}return n?0===(s=n.filter(function(t){return t.id.toString()===e.toString()})).length?null:s[0]:null},/**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */r.move=function(t,e,i){return r.remove(t,e),r.add(i,e),t},/**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */r.rebase=function(t){for(var e=r.allBodies(t).concat(r.allConstraints(t)).concat(r.allComposites(t)),i=0;i<e.length;i++)e[i].id=s.nextId();return r.setModified(t,!0,!0,!1),t},/**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */r.translate=function(t,e,i){for(var n=i?r.allBodies(t):t.bodies,s=0;s<n.length;s++)a.translate(n[s],e);return r.setModified(t,!0,!0,!1),t},/**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */r.rotate=function(t,e,i,n){for(var s=Math.cos(e),o=Math.sin(e),h=n?r.allBodies(t):t.bodies,l=0;l<h.length;l++){var u=h[l],c=u.position.x-i.x,d=u.position.y-i.y;a.setPosition(u,{x:i.x+(c*s-d*o),y:i.y+(c*o+d*s)}),a.rotate(u,e)}return r.setModified(t,!0,!0,!1),t},/**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */r.scale=function(t,e,i,n,s){for(var o=s?r.allBodies(t):t.bodies,h=0;h<o.length;h++){var l=o[h],u=l.position.x-n.x,c=l.position.y-n.y;a.setPosition(l,{x:n.x+u*e,y:n.y+c*i}),a.scale(l,e,i)}return r.setModified(t,!0,!0,!1),t},/**
     * Returns the union of the bounds of all of the composite's bodies.
     * @method bounds
     * @param {composite} composite The composite.
     * @returns {bounds} The composite bounds.
     */r.bounds=function(t){for(var e=r.allBodies(t),i=[],n=0;n<e.length;n+=1){var s=e[n];i.push(s.bounds.min,s.bounds.max)}return o.create(i)};/***/},/* 6 *//***/function(t,e,i){/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/var r,n={};t.exports=n;var s=i(3),o=i(2),a=i(7);i(16);var h=i(0),l=i(1),u=i(10);n._inertiaScale=4,n._nextCollidingGroupId=1,n._nextNonCollidingGroupId=-1,n._nextCategory=1,/**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */n.create=function(t){var e={id:h.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:s.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,render:{visible:!0,opacity:1,strokeStyle:null,fillStyle:null,lineWidth:null,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0}},events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inertia:0,_original:null},i=h.extend(e,t);return r(i,t),i},/**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */n.nextGroup=function(t){return t?n._nextNonCollidingGroupId--:n._nextCollidingGroupId++},/**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */n.nextCategory=function(){return n._nextCategory=n._nextCategory<<1,n._nextCategory},r=function(t,e){e=e||{},// init required properties (order is important)
n.set(t,{bounds:t.bounds||l.create(t.vertices),positionPrev:t.positionPrev||o.clone(t.position),anglePrev:t.anglePrev||t.angle,vertices:t.vertices,parts:t.parts||[t],isStatic:t.isStatic,isSleeping:t.isSleeping,parent:t.parent||t}),s.rotate(t.vertices,t.angle,t.position),u.rotate(t.axes,t.angle),l.update(t.bounds,t.vertices,t.velocity),// allow options to override the automatically calculated properties
n.set(t,{axes:e.axes||t.axes,area:e.area||t.area,mass:e.mass||t.mass,inertia:e.inertia||t.inertia});// render properties
var i=t.isStatic?"#14151f":h.choose(["#f19648","#f5d259","#f55a3c","#063e7b","#ececd1"]),r=t.isStatic?"#555":"#ccc",a=t.isStatic&&null===t.render.fillStyle?1:0;t.render.fillStyle=t.render.fillStyle||i,t.render.strokeStyle=t.render.strokeStyle||r,t.render.lineWidth=t.render.lineWidth||a,t.render.sprite.xOffset+=-(t.bounds.min.x-t.position.x)/(t.bounds.max.x-t.bounds.min.x),t.render.sprite.yOffset+=-(t.bounds.min.y-t.position.y)/(t.bounds.max.y-t.bounds.min.y)},/**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */n.set=function(t,e,i){var r;for(r in"string"==typeof e&&(r=e,(e={})[r]=i),e)if(Object.prototype.hasOwnProperty.call(e,r))switch(i=e[r],r){case"isStatic":n.setStatic(t,i);break;case"isSleeping":a.set(t,i);break;case"mass":n.setMass(t,i);break;case"density":n.setDensity(t,i);break;case"inertia":n.setInertia(t,i);break;case"vertices":n.setVertices(t,i);break;case"position":n.setPosition(t,i);break;case"angle":n.setAngle(t,i);break;case"velocity":n.setVelocity(t,i);break;case"angularVelocity":n.setAngularVelocity(t,i);break;case"parts":n.setParts(t,i);break;case"centre":n.setCentre(t,i);break;default:t[r]=i}},/**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */n.setStatic=function(t,e){for(var i=0;i<t.parts.length;i++){var r=t.parts[i];r.isStatic=e,e?(r._original={restitution:r.restitution,friction:r.friction,mass:r.mass,inertia:r.inertia,density:r.density,inverseMass:r.inverseMass,inverseInertia:r.inverseInertia},r.restitution=0,r.friction=1,r.mass=r.inertia=r.density=1/0,r.inverseMass=r.inverseInertia=0,r.positionPrev.x=r.position.x,r.positionPrev.y=r.position.y,r.anglePrev=r.angle,r.angularVelocity=0,r.speed=0,r.angularSpeed=0,r.motion=0):r._original&&(r.restitution=r._original.restitution,r.friction=r._original.friction,r.mass=r._original.mass,r.inertia=r._original.inertia,r.density=r._original.density,r.inverseMass=r._original.inverseMass,r.inverseInertia=r._original.inverseInertia,r._original=null)}},/**
     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */n.setMass=function(t,e){var i=t.inertia/(t.mass/6);t.inertia=i*(e/6),t.inverseInertia=1/t.inertia,t.mass=e,t.inverseMass=1/t.mass,t.density=t.mass/t.area},/**
     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */n.setDensity=function(t,e){n.setMass(t,e*t.area),t.density=e},/**
     * Sets the moment of inertia (i.e. second moment of area) of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */n.setInertia=function(t,e){t.inertia=e,t.inverseInertia=1/t.inertia},/**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */n.setVertices=function(t,e){e[0].body===t?t.vertices=e:t.vertices=s.create(e,t),// update properties
t.axes=u.fromVertices(t.vertices),t.area=s.area(t.vertices),n.setMass(t,t.density*t.area);// orient vertices around the centre of mass at origin (0, 0)
var i=s.centre(t.vertices);s.translate(t.vertices,i,-1),// update inertia while vertices are at origin (0, 0)
n.setInertia(t,n._inertiaScale*s.inertia(t.vertices,t.mass)),// update geometry
s.translate(t.vertices,t.position),l.update(t.bounds,t.vertices,t.velocity)},/**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */n.setParts=function(t,e,i){for(// add all the parts, ensuring that the first part is always the parent body
e=e.slice(0),t.parts.length=0,t.parts.push(t),t.parent=t,r=0;r<e.length;r++){var r,o=e[r];o!==t&&(o.parent=t,t.parts.push(o))}if(1!==t.parts.length){// find the convex hull of all parts to set on the parent body
if(i=void 0===i||i){var a=[];for(r=0;r<e.length;r++)a=a.concat(e[r].vertices);s.clockwiseSort(a);var h=s.hull(a),l=s.centre(h);n.setVertices(t,h),s.translate(t.vertices,l)}// sum the properties of all compound parts of the parent body
var u=n._totalProperties(t);t.area=u.area,t.parent=t,t.position.x=u.centre.x,t.position.y=u.centre.y,t.positionPrev.x=u.centre.x,t.positionPrev.y=u.centre.y,n.setMass(t,u.mass),n.setInertia(t,u.inertia),n.setPosition(t,u.centre)}},/**
     * Set the centre of mass of the body. 
     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.
     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.
     * This is equal to moving `body.position` but not the `body.vertices`.
     * Invalid if the `centre` falls outside the body's convex hull.
     * @method setCentre
     * @param {body} body
     * @param {vector} centre
     * @param {bool} relative
     */n.setCentre=function(t,e,i){i?(t.positionPrev.x+=e.x,t.positionPrev.y+=e.y,t.position.x+=e.x,t.position.y+=e.y):(t.positionPrev.x=e.x-(t.position.x-t.positionPrev.x),t.positionPrev.y=e.y-(t.position.y-t.positionPrev.y),t.position.x=e.x,t.position.y=e.y)},/**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */n.setPosition=function(t,e){var i=o.sub(e,t.position);t.positionPrev.x+=i.x,t.positionPrev.y+=i.y;for(var r=0;r<t.parts.length;r++){var n=t.parts[r];n.position.x+=i.x,n.position.y+=i.y,s.translate(n.vertices,i),l.update(n.bounds,n.vertices,t.velocity)}},/**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */n.setAngle=function(t,e){var i=e-t.angle;t.anglePrev+=i;for(var r=0;r<t.parts.length;r++){var n=t.parts[r];n.angle+=i,s.rotate(n.vertices,i,t.position),u.rotate(n.axes,i),l.update(n.bounds,n.vertices,t.velocity),r>0&&o.rotateAbout(n.position,i,t.position,n.position)}},/**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */n.setVelocity=function(t,e){t.positionPrev.x=t.position.x-e.x,t.positionPrev.y=t.position.y-e.y,t.velocity.x=e.x,t.velocity.y=e.y,t.speed=o.magnitude(t.velocity)},/**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */n.setAngularVelocity=function(t,e){t.anglePrev=t.angle-e,t.angularVelocity=e,t.angularSpeed=Math.abs(t.angularVelocity)},/**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */n.translate=function(t,e){n.setPosition(t,o.add(t.position,e))},/**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     * @param {vector} [point]
     */n.rotate=function(t,e,i){if(i){var r=Math.cos(e),s=Math.sin(e),o=t.position.x-i.x,a=t.position.y-i.y;n.setPosition(t,{x:i.x+(o*r-a*s),y:i.y+(o*s+a*r)}),n.setAngle(t,t.angle+e)}else n.setAngle(t,t.angle+e)},/**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */n.scale=function(t,e,i,r){var o=0,a=0;r=r||t.position;for(var h=0;h<t.parts.length;h++){var c=t.parts[h];// scale vertices
s.scale(c.vertices,e,i,r),// update properties
c.axes=u.fromVertices(c.vertices),c.area=s.area(c.vertices),n.setMass(c,t.density*c.area),// update inertia (requires vertices to be at origin)
s.translate(c.vertices,{x:-c.position.x,y:-c.position.y}),n.setInertia(c,n._inertiaScale*s.inertia(c.vertices,c.mass)),s.translate(c.vertices,{x:c.position.x,y:c.position.y}),h>0&&(o+=c.area,a+=c.inertia),// scale position
c.position.x=r.x+(c.position.x-r.x)*e,c.position.y=r.y+(c.position.y-r.y)*i,// update bounds
l.update(c.bounds,c.vertices,t.velocity)}t.parts.length>1&&(t.area=o,t.isStatic||(n.setMass(t,t.density*o),n.setInertia(t,a))),t.circleRadius&&(e===i?t.circleRadius*=e:t.circleRadius=null)},/**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */n.update=function(t,e,i,r){var n=Math.pow(e*i*t.timeScale,2),a=1-t.frictionAir*i*t.timeScale,h=t.position.x-t.positionPrev.x,c=t.position.y-t.positionPrev.y;// update velocity with Verlet integration
t.velocity.x=h*a*r+t.force.x/t.mass*n,t.velocity.y=c*a*r+t.force.y/t.mass*n,t.positionPrev.x=t.position.x,t.positionPrev.y=t.position.y,t.position.x+=t.velocity.x,t.position.y+=t.velocity.y,// update angular velocity with Verlet integration
t.angularVelocity=(t.angle-t.anglePrev)*a*r+t.torque/t.inertia*n,t.anglePrev=t.angle,t.angle+=t.angularVelocity,// track speed and acceleration
t.speed=o.magnitude(t.velocity),t.angularSpeed=Math.abs(t.angularVelocity);// transform the body geometry
for(var d=0;d<t.parts.length;d++){var p=t.parts[d];s.translate(p.vertices,t.velocity),d>0&&(p.position.x+=t.velocity.x,p.position.y+=t.velocity.y),0!==t.angularVelocity&&(s.rotate(p.vertices,t.angularVelocity,t.position),u.rotate(p.axes,t.angularVelocity),d>0&&o.rotateAbout(p.position,t.angularVelocity,t.position,p.position)),l.update(p.bounds,p.vertices,t.velocity)}},/**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */n.applyForce=function(t,e,i){t.force.x+=i.x,t.force.y+=i.y;var r={x:e.x-t.position.x,y:e.y-t.position.y};t.torque+=r.x*i.y-r.y*i.x},/**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */n._totalProperties=function(t){// sum the properties of all compound parts of the parent body
for(var e={mass:0,area:0,inertia:0,centre:{x:0,y:0}},i=1===t.parts.length?0:1;i<t.parts.length;i++){var r=t.parts[i],n=r.mass!==1/0?r.mass:1;e.mass+=n,e.area+=r.area,e.inertia+=r.inertia,e.centre=o.add(e.centre,o.mult(r.position,n))}return e.centre=o.div(e.centre,e.mass),e};/***/},/* 7 *//***/function(t,e,i){/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/var r={};t.exports=r;var n=i(4);r._motionWakeThreshold=.18,r._motionSleepThreshold=.08,r._minBias=.9,/**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */r.update=function(t,e){// update bodies sleeping status
for(var i=e*e*e,n=0;n<t.length;n++){var s=t[n],o=s.speed*s.speed+s.angularSpeed*s.angularSpeed;// wake up bodies if they have a force applied
if(0!==s.force.x||0!==s.force.y){r.set(s,!1);continue}var a=Math.min(s.motion,o),h=Math.max(s.motion,o);// biased average motion estimation between frames
s.motion=r._minBias*a+(1-r._minBias)*h,s.sleepThreshold>0&&s.motion<r._motionSleepThreshold*i?(s.sleepCounter+=1,s.sleepCounter>=s.sleepThreshold&&r.set(s,!0)):s.sleepCounter>0&&(s.sleepCounter-=1)}},/**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */r.afterCollisions=function(t,e){// wake up bodies involved in collisions
for(var i=e*e*e,n=0;n<t.length;n++){var s=t[n];// don't wake inactive pairs
if(s.isActive){var o=s.collision,a=o.bodyA.parent,h=o.bodyB.parent;// don't wake if at least one body is static
if((!a.isSleeping||!h.isSleeping)&&!a.isStatic&&!h.isStatic&&(a.isSleeping||h.isSleeping)){var l=a.isSleeping&&!a.isStatic?a:h,u=l===a?h:a;!l.isStatic&&u.motion>r._motionWakeThreshold*i&&r.set(l,!1)}}}},/**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */r.set=function(t,e){var i=t.isSleeping;e?(t.isSleeping=!0,t.sleepCounter=t.sleepThreshold,t.positionImpulse.x=0,t.positionImpulse.y=0,t.positionPrev.x=t.position.x,t.positionPrev.y=t.position.y,t.anglePrev=t.angle,t.speed=0,t.angularSpeed=0,t.motion=0,i||n.trigger(t,"sleepStart")):(t.isSleeping=!1,t.sleepCounter=0,i&&n.trigger(t,"sleepEnd"))};/***/},/* 8 *//***/function(t,e,i){/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/var r={};t.exports=r;var n=i(3),s=i(2),o=i(7),a=i(1),h=i(10),l=i(0);r._warming=.4,r._torqueDampen=1,r._minLength=1e-6,/**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
     * For compound bodies, constraints must be applied to the parent body (not one of its parts).
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */r.create=function(t){t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0}),t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});// calculate static length using initial world space points
var e=t.bodyA?s.add(t.bodyA.position,t.pointA):t.pointA,i=t.bodyB?s.add(t.bodyB.position,t.pointB):t.pointB,r=s.magnitude(s.sub(e,i));t.length=void 0!==t.length?t.length:r,// option defaults
t.id=t.id||l.nextId(),t.label=t.label||"Constraint",t.type="constraint",t.stiffness=t.stiffness||(t.length>0?1:.7),t.damping=t.damping||0,t.angularStiffness=t.angularStiffness||0,t.angleA=t.bodyA?t.bodyA.angle:t.angleA,t.angleB=t.bodyB?t.bodyB.angle:t.angleB,t.plugin={};// render
var n={visible:!0,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:!0};return 0===t.length&&t.stiffness>.1?(n.type="pin",n.anchors=!1):t.stiffness<.9&&(n.type="spring"),t.render=l.extend(n,t.render),t},/**
     * Prepares for solving by constraint warming.
     * @private
     * @method preSolveAll
     * @param {body[]} bodies
     */r.preSolveAll=function(t){for(var e=0;e<t.length;e+=1){var i=t[e],r=i.constraintImpulse;i.isStatic||0===r.x&&0===r.y&&0===r.angle||(i.position.x+=r.x,i.position.y+=r.y,i.angle+=r.angle)}},/**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */r.solveAll=function(t,e){// Solve fixed constraints first.
for(var i=0;i<t.length;i+=1){var n=t[i],s=!n.bodyA||n.bodyA&&n.bodyA.isStatic,o=!n.bodyB||n.bodyB&&n.bodyB.isStatic;(s||o)&&r.solve(t[i],e)}// Solve free constraints last.
for(i=0;i<t.length;i+=1)s=!(n=t[i]).bodyA||n.bodyA&&n.bodyA.isStatic,o=!n.bodyB||n.bodyB&&n.bodyB.isStatic,s||o||r.solve(t[i],e)},/**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */r.solve=function(t,e){var i=t.bodyA,n=t.bodyB,o=t.pointA,a=t.pointB;if(i||n){i&&!i.isStatic&&(s.rotate(o,i.angle-t.angleA,o),t.angleA=i.angle),n&&!n.isStatic&&(s.rotate(a,n.angle-t.angleB,a),t.angleB=n.angle);var h=o,l=a;if(i&&(h=s.add(i.position,o)),n&&(l=s.add(n.position,a)),h&&l){var u=s.sub(h,l),c=s.magnitude(u);c<r._minLength&&(c=r._minLength);// solve distance constraint with Gauss-Siedel method
var d,p,f,m,g,y=(c-t.length)/c,_=t.stiffness<1?t.stiffness*e:t.stiffness,v=s.mult(u,y*_),x=(i?i.inverseMass:0)+(n?n.inverseMass:0),b=x+((i?i.inverseInertia:0)+(n?n.inverseInertia:0));if(t.damping){var E=s.create();f=s.div(u,c),g=s.sub(n&&s.sub(n.position,n.positionPrev)||E,i&&s.sub(i.position,i.positionPrev)||E),m=s.dot(f,g)}i&&!i.isStatic&&(p=i.inverseMass/x,// keep track of applied impulses for post solving
i.constraintImpulse.x-=v.x*p,i.constraintImpulse.y-=v.y*p,// apply forces
i.position.x-=v.x*p,i.position.y-=v.y*p,t.damping&&(i.positionPrev.x-=t.damping*f.x*m*p,i.positionPrev.y-=t.damping*f.y*m*p),// apply torque
d=s.cross(o,v)/b*r._torqueDampen*i.inverseInertia*(1-t.angularStiffness),i.constraintImpulse.angle-=d,i.angle-=d),n&&!n.isStatic&&(p=n.inverseMass/x,// keep track of applied impulses for post solving
n.constraintImpulse.x+=v.x*p,n.constraintImpulse.y+=v.y*p,// apply forces
n.position.x+=v.x*p,n.position.y+=v.y*p,t.damping&&(n.positionPrev.x+=t.damping*f.x*m*p,n.positionPrev.y+=t.damping*f.y*m*p),// apply torque
d=s.cross(a,v)/b*r._torqueDampen*n.inverseInertia*(1-t.angularStiffness),n.constraintImpulse.angle+=d,n.angle+=d)}}},/**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */r.postSolveAll=function(t){for(var e=0;e<t.length;e++){var i=t[e],l=i.constraintImpulse;if(!i.isStatic&&(0!==l.x||0!==l.y||0!==l.angle)){o.set(i,!1);// update geometry and reset
for(var u=0;u<i.parts.length;u++){var c=i.parts[u];n.translate(c.vertices,l),u>0&&(c.position.x+=l.x,c.position.y+=l.y),0!==l.angle&&(n.rotate(c.vertices,l.angle,i.position),h.rotate(c.axes,l.angle),u>0&&s.rotateAbout(c.position,l.angle,i.position,c.position)),a.update(c.bounds,c.vertices,i.velocity)}// dampen the cached impulse for warming next step
l.angle*=r._warming,l.x*=r._warming,l.y*=r._warming}}},/**
     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.
     * @method pointAWorld
     * @param {constraint} constraint
     * @returns {vector} the world-space position
     */r.pointAWorld=function(t){return{x:(t.bodyA?t.bodyA.position.x:0)+t.pointA.x,y:(t.bodyA?t.bodyA.position.y:0)+t.pointA.y}},/**
     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.
     * @method pointBWorld
     * @param {constraint} constraint
     * @returns {vector} the world-space position
     */r.pointBWorld=function(t){return{x:(t.bodyB?t.bodyB.position.x:0)+t.pointB.x,y:(t.bodyB?t.bodyB.position.y:0)+t.pointB.y}};/***/},/* 9 *//***/function(t,e,i){/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/var r={};t.exports=r;var n=i(17);/**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */r.create=function(t,e){var i=t.bodyA,n=t.bodyB,s=t.parentA,o=t.parentB,a={id:r.id(i,n),bodyA:i,bodyB:n,contacts:{},activeContacts:[],separation:0,isActive:!0,confirmedActive:!0,isSensor:i.isSensor||n.isSensor,timeCreated:e,timeUpdated:e,inverseMass:s.inverseMass+o.inverseMass,friction:Math.min(s.friction,o.friction),frictionStatic:Math.max(s.frictionStatic,o.frictionStatic),restitution:Math.max(s.restitution,o.restitution),slop:Math.max(s.slop,o.slop)};return r.update(a,t,e),a},/**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */r.update=function(t,e,i){var s=t.contacts,o=e.supports,a=t.activeContacts,h=e.parentA,l=e.parentB;if(t.collision=e,t.inverseMass=h.inverseMass+l.inverseMass,t.friction=Math.min(h.friction,l.friction),t.frictionStatic=Math.max(h.frictionStatic,l.frictionStatic),t.restitution=Math.max(h.restitution,l.restitution),t.slop=Math.max(h.slop,l.slop),a.length=0,e.collided){for(var u=0;u<o.length;u++){var c=o[u],d=n.id(c),p=s[d];p?a.push(p):a.push(s[d]=n.create(c))}t.separation=e.depth,r.setActive(t,!0,i)}else!0===t.isActive&&r.setActive(t,!1,i)},/**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */r.setActive=function(t,e,i){e?(t.isActive=!0,t.timeUpdated=i):(t.isActive=!1,t.activeContacts.length=0)},/**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */r.id=function(t,e){return t.id<e.id?"A"+t.id+"B"+e.id:"A"+e.id+"B"+t.id};/***/},/* 10 *//***/function(t,e,i){/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/var r={};t.exports=r;var n=i(2),s=i(0);/**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */r.fromVertices=function(t){// find the unique axes, using edge normal gradients
for(var e={},i=0;i<t.length;i++){var r=(i+1)%t.length,o=n.normalise({x:t[r].y-t[i].y,y:t[i].x-t[r].x}),a=0===o.y?1/0:o.x/o.y;e[// limit precision
a=a.toFixed(3).toString()]=o}return s.values(e)},/**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */r.rotate=function(t,e){if(0!==e)for(var i=Math.cos(e),r=Math.sin(e),n=0;n<t.length;n++){var s,o=t[n];s=o.x*i-o.y*r,o.y=o.x*r+o.y*i,o.x=s}};/***/},/* 11 *//***/function(t,e,i){/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/// TODO: true circle bodies
var r={};t.exports=r;var n=i(3),s=i(0),o=i(6),a=i(1),h=i(2);/**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */r.rectangle=function(t,e,i,r,a){a=a||{};var h={label:"Rectangle Body",position:{x:t,y:e},vertices:n.fromPath("L 0 0 L "+i+" 0 L "+i+" "+r+" L 0 "+r)};if(a.chamfer){var l=a.chamfer;h.vertices=n.chamfer(h.vertices,l.radius,l.quality,l.qualityMin,l.qualityMax),delete a.chamfer}return o.create(s.extend({},h,a))},/**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */r.trapezoid=function(t,e,i,r,a,h){h=h||{};var l,u=(1-2*(a*=.5))*i,c=i*a,d=c+u,p=d+c;l=a<.5?"L 0 0 L "+c+" "+-r+" L "+d+" "+-r+" L "+p+" 0":"L 0 0 L "+d+" "+-r+" L "+p+" 0";var f={label:"Trapezoid Body",position:{x:t,y:e},vertices:n.fromPath(l)};if(h.chamfer){var m=h.chamfer;f.vertices=n.chamfer(f.vertices,m.radius,m.quality,m.qualityMin,m.qualityMax),delete h.chamfer}return o.create(s.extend({},f,h))},/**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */r.circle=function(t,e,i,n,o){n=n||{};var a=Math.ceil(Math.max(10,Math.min(// approximate circles with polygons until true circles implemented in SAT
o=o||25,i)));return a%2==1&&(a+=1),r.polygon(t,e,a,i,s.extend({},{label:"Circle Body",circleRadius:i},n))},/**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */r.polygon=function(t,e,i,a,h){if(h=h||{},i<3)return r.circle(t,e,a,h);for(var l=2*Math.PI/i,u="",c=.5*l,d=0;d<i;d+=1){var p=c+d*l,f=Math.cos(p)*a,m=Math.sin(p)*a;u+="L "+f.toFixed(3)+" "+m.toFixed(3)+" "}var g={label:"Polygon Body",position:{x:t,y:e},vertices:n.fromPath(u)};if(h.chamfer){var y=h.chamfer;g.vertices=n.chamfer(g.vertices,y.radius,y.quality,y.qualityMin,y.qualityMax),delete h.chamfer}return o.create(s.extend({},g,h))},/**
     * Utility to create a compound body based on set(s) of vertices.
     * 
     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) 
     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.
     * 
     * The resulting vertices are reorientated about their centre of mass,
     * and offset such that `body.position` corresponds to this point.
     * 
     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.
     * To later move the centre of mass see `Body.setCentre`.
     * 
     * Note that automatic conconcave decomposition results are not always optimal. 
     * For best results, simplify the input vertices as much as possible first.
     * By default this function applies some addtional simplification to help.
     * 
     * Some outputs may also require further manual processing afterwards to be robust.
     * In particular some parts may need to be overlapped to avoid collision gaps.
     * Thin parts and sharp points should be avoided or removed where possible.
     *
     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.
     * 
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.
     * @param {object} [options] The body options.
     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.
     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.
     * @param {number} [minimumArea=10] Threshold when removing small parts.
     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.
     * @return {body}
     */r.fromVertices=function(t,e,i,r,l,u,c,d){var p,f,m,g,y,_,v,x,b,E,T=s.getDecomp();for(// check decomp is as expected
p=!!(T&&T.quickDecomp),r=r||{},m=[],l=void 0!==l&&l,u=void 0!==u?u:.01,c=void 0!==c?c:10,d=void 0!==d?d:.01,s.isArray(i[0])||(i=[i]),b=0;b<i.length;b+=1)if(y=i[b],(g=n.isConvex(y))||p||s.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."),g||!p)y=g?n.clockwiseSort(y):n.hull(y),m.push({position:{x:t,y:e},vertices:y});else{// initialise a decomposition
var w=y.map(function(t){return[t.x,t.y]});// vertices are concave and simple, we can decompose into parts
T.makeCCW(w),!1!==u&&T.removeCollinearPoints(w,u),!1!==d&&T.removeDuplicatePoints&&T.removeDuplicatePoints(w,d);// use the quick decomposition algorithm (Bayazit)
var S=T.quickDecomp(w);// for each decomposed chunk
for(_=0;_<S.length;_++){// convert vertices into the correct structure
var M=S[_].map(function(t){return{x:t[0],y:t[1]}});// skip small chunks
c>0&&n.area(M)<c||// create a compound part
m.push({position:n.centre(M),vertices:M})}}// create body parts
for(_=0;_<m.length;_++)m[_]=o.create(s.extend(m[_],r));// flag internal edges (coincident part edges)
if(l)for(_=0;_<m.length;_++){var A=m[_];for(v=_+1;v<m.length;v++){var R=m[v];if(a.overlaps(A.bounds,R.bounds)){var C=A.vertices,P=R.vertices;// iterate vertices of both parts
for(x=0;x<A.vertices.length;x++)for(E=0;E<R.vertices.length;E++){// find distances between the vertices
var I=h.magnitudeSquared(h.sub(C[(x+1)%C.length],P[E])),O=h.magnitudeSquared(h.sub(C[x],P[(E+1)%P.length]));// if both vertices are very close, consider the edge concident (internal)
I<5&&O<5&&(C[x].isInternal=!0,P[E].isInternal=!0)}}}}return m.length>1?(// create the parent body to be returned, that contains generated compound parts
f=o.create(s.extend({parts:m.slice(0)},r)),// offset such that body.position is at the centre off mass
o.setPosition(f,{x:t,y:e}),f):m[0]};/***/},/* 12 *//***/function(t,e,i){/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/var r={};t.exports=r;var n=i(0);/**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */r.create=function(t){var e={};return t||n.log("Mouse.create: element was undefined, defaulting to document.body","warn"),e.element=t||document.body,e.absolute={x:0,y:0},e.position={x:0,y:0},e.mousedownPosition={x:0,y:0},e.mouseupPosition={x:0,y:0},e.offset={x:0,y:0},e.scale={x:1,y:1},e.wheelDelta=0,e.button=-1,e.pixelRatio=parseInt(e.element.getAttribute("data-pixel-ratio"),10)||1,e.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null},e.mousemove=function(t){var i=r._getRelativeMousePosition(t,e.element,e.pixelRatio);t.changedTouches&&(e.button=0,t.preventDefault()),e.absolute.x=i.x,e.absolute.y=i.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y,e.sourceEvents.mousemove=t},e.mousedown=function(t){var i=r._getRelativeMousePosition(t,e.element,e.pixelRatio);t.changedTouches?(e.button=0,t.preventDefault()):e.button=t.button,e.absolute.x=i.x,e.absolute.y=i.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y,e.mousedownPosition.x=e.position.x,e.mousedownPosition.y=e.position.y,e.sourceEvents.mousedown=t},e.mouseup=function(t){var i=r._getRelativeMousePosition(t,e.element,e.pixelRatio);t.changedTouches&&t.preventDefault(),e.button=-1,e.absolute.x=i.x,e.absolute.y=i.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y,e.mouseupPosition.x=e.position.x,e.mouseupPosition.y=e.position.y,e.sourceEvents.mouseup=t},e.mousewheel=function(t){e.wheelDelta=Math.max(-1,Math.min(1,t.wheelDelta||-t.detail)),t.preventDefault()},r.setElement(e,e.element),e},/**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */r.setElement=function(t,e){t.element=e,e.addEventListener("mousemove",t.mousemove),e.addEventListener("mousedown",t.mousedown),e.addEventListener("mouseup",t.mouseup),e.addEventListener("mousewheel",t.mousewheel),e.addEventListener("DOMMouseScroll",t.mousewheel),e.addEventListener("touchmove",t.mousemove),e.addEventListener("touchstart",t.mousedown),e.addEventListener("touchend",t.mouseup)},/**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */r.clearSourceEvents=function(t){t.sourceEvents.mousemove=null,t.sourceEvents.mousedown=null,t.sourceEvents.mouseup=null,t.sourceEvents.mousewheel=null,t.wheelDelta=0},/**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */r.setOffset=function(t,e){t.offset.x=e.x,t.offset.y=e.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y},/**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */r.setScale=function(t,e){t.scale.x=e.x,t.scale.y=e.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y},/**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */r._getRelativeMousePosition=function(t,e,i){var r,n,s=e.getBoundingClientRect(),o=document.documentElement||document.body.parentNode||document.body,a=void 0!==window.pageXOffset?window.pageXOffset:o.scrollLeft,h=void 0!==window.pageYOffset?window.pageYOffset:o.scrollTop,l=t.changedTouches;return l?(r=l[0].pageX-s.left-a,n=l[0].pageY-s.top-h):(r=t.pageX-s.left-a,n=t.pageY-s.top-h),{x:r/(e.clientWidth/(e.width||e.clientWidth)*i),y:n/(e.clientHeight/(e.height||e.clientHeight)*i)}};/***/},/* 13 *//***/function(t,e,i){/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/// TODO: speculative contacts
var r={};t.exports=r;var n=i(14),s=i(9),o=i(1);/**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */r.collisions=function(t,e){for(var i=[],a=e.pairs.table,h=0;h<t.length;h++){var l=t[h][0],u=t[h][1];if((!l.isStatic&&!l.isSleeping||!u.isStatic&&!u.isSleeping)&&r.canCollide(l.collisionFilter,u.collisionFilter)&&o.overlaps(l.bounds,u.bounds))for(var c=l.parts.length>1?1:0;c<l.parts.length;c++)for(var d=l.parts[c],p=u.parts.length>1?1:0;p<u.parts.length;p++){var f=u.parts[p];if(d===l&&f===u||o.overlaps(d.bounds,f.bounds)){// find a previous collision we could reuse
var m,g=a[s.id(d,f)];m=g&&g.isActive?g.collision:null;// narrow phase
var y=n.collides(d,f,m);y.collided&&i.push(y)}}}return i},/**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */r.canCollide=function(t,e){return t.group===e.group&&0!==t.group?t.group>0:(t.mask&e.category)!=0&&(e.mask&t.category)!=0};/***/},/* 14 *//***/function(t,e,i){/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/// TODO: true circles and curves
var r={};t.exports=r;var n=i(3),s=i(2);/**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */r.collides=function(t,e,i){var o,a,h,l,u=!1;if(i){// estimate total motion
var c=t.parent,d=e.parent,p=c.speed*c.speed+c.angularSpeed*c.angularSpeed+d.speed*d.speed+d.angularSpeed*d.angularSpeed;// we may be able to (partially) reuse collision result 
// but only safe if collision was resting
u=i&&i.collided&&p<.2,// reuse collision object
l=i}else l={collided:!1,bodyA:t,bodyB:e};if(i&&u){// if we can reuse the collision result
// we only need to test the previously found axis
var f=l.axisBody,m=f===t?e:t,g=[f.axes[i.axisNumber]];if(h=r._overlapAxes(f.vertices,m.vertices,g),l.reused=!0,h.overlap<=0)return l.collided=!1,l}else{if(// if we can't reuse a result, perform a full SAT test
(o=r._overlapAxes(t.vertices,e.vertices,t.axes)).overlap<=0||(a=r._overlapAxes(e.vertices,t.vertices,e.axes)).overlap<=0)return l.collided=!1,l;o.overlap<a.overlap?(h=o,l.axisBody=t):(h=a,l.axisBody=e),// important for reuse later
l.axisNumber=h.axisNumber}l.bodyA=t.id<e.id?t:e,l.bodyB=t.id<e.id?e:t,l.collided=!0,l.depth=h.overlap,l.parentA=l.bodyA.parent,l.parentB=l.bodyB.parent,t=l.bodyA,e=l.bodyB,0>s.dot(h.axis,s.sub(e.position,t.position))?l.normal={x:h.axis.x,y:h.axis.y}:l.normal={x:-h.axis.x,y:-h.axis.y},l.tangent=s.perp(l.normal),l.penetration=l.penetration||{},l.penetration.x=l.normal.x*l.depth,l.penetration.y=l.normal.y*l.depth;// find support points, there is always either exactly one or two
var y=r._findSupports(t,e,l.normal),_=[];// find the supports from bodyA that are inside bodyB
if(n.contains(t.vertices,y[0])&&_.push(y[0]),n.contains(t.vertices,y[1])&&_.push(y[1]),_.length<2){var v=r._findSupports(e,t,s.neg(l.normal));n.contains(e.vertices,v[0])&&_.push(v[0]),_.length<2&&n.contains(e.vertices,v[1])&&_.push(v[1])}return _.length<1&&(_=[y[0]]),l.supports=_,l},/**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */r._overlapAxes=function(t,e,i){for(var n,o,a=s._temp[0],h=s._temp[1],l={overlap:Number.MAX_VALUE},u=0;u<i.length;u++){if(o=i[u],r._projectToAxis(a,t,o),r._projectToAxis(h,e,o),(n=Math.min(a.max-h.min,h.max-a.min))<=0){l.overlap=n;break}n<l.overlap&&(l.overlap=n,l.axis=o,l.axisNumber=u)}return l},/**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */r._projectToAxis=function(t,e,i){for(var r=s.dot(e[0],i),n=r,o=1;o<e.length;o+=1){var a=s.dot(e[o],i);a>n?n=a:a<r&&(r=a)}t.min=r,t.max=n},/**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */r._findSupports=function(t,e,i){// find closest vertex on bodyB
for(var r,n,o,a,h=Number.MAX_VALUE,l=s._temp[0],u=e.vertices,c=t.position,d=0;d<u.length;d++)n=u[d],l.x=n.x-c.x,l.y=n.y-c.y,(r=-s.dot(i,l))<h&&(h=r,o=n);var p=o.index-1>=0?o.index-1:u.length-1;n=u[p],l.x=n.x-c.x,l.y=n.y-c.y,h=-s.dot(i,l),a=n;var f=(o.index+1)%u.length;return n=u[f],l.x=n.x-c.x,l.y=n.y-c.y,(r=-s.dot(i,l))<h&&(a=n),[o,a]};/***/},/* 15 *//***/function(t,e,i){/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/var r={};t.exports=r;var n=i(0);r._registry={},/**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */r.register=function(t){if(r.isPlugin(t)||n.warn("Plugin.register:",r.toString(t),"does not implement all required fields."),t.name in r._registry){var e=r._registry[t.name],i=r.versionParse(t.version).number,s=r.versionParse(e.version).number;i>s?(n.warn("Plugin.register:",r.toString(e),"was upgraded to",r.toString(t)),r._registry[t.name]=t):i<s?n.warn("Plugin.register:",r.toString(e),"can not be downgraded to",r.toString(t)):t!==e&&n.warn("Plugin.register:",r.toString(t),"is already registered to different plugin object")}else r._registry[t.name]=t;return t},/**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */r.resolve=function(t){return r._registry[r.dependencyParse(t).name]},/**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */r.toString=function(t){return"string"==typeof t?t:(t.name||"anonymous")+"@"+(t.version||t.range||"0.0.0")},/**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */r.isPlugin=function(t){return t&&t.name&&t.version&&t.install},/**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */r.isUsed=function(t,e){return t.used.indexOf(e)>-1},/**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */r.isFor=function(t,e){var i=t.for&&r.dependencyParse(t.for);return!t.for||e.name===i.name&&r.versionSatisfies(e.version,i.range)},/**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick  indicates a dependency was resolved and installed.
     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross  indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */r.use=function(t,e){if(t.uses=(t.uses||[]).concat(e||[]),0===t.uses.length){n.warn("Plugin.use:",r.toString(t),"does not specify any dependencies to install.");return}for(var i=r.dependencies(t),s=n.topologicalSort(i),o=[],a=0;a<s.length;a+=1)if(s[a]!==t.name){var h=r.resolve(s[a]);if(!h){o.push(" "+s[a]);continue}r.isUsed(t,h.name)||(r.isFor(h,t)||(n.warn("Plugin.use:",r.toString(h),"is for",h.for,"but installed on",r.toString(t)+"."),h._warned=!0),h.install?h.install(t):(n.warn("Plugin.use:",r.toString(h),"does not specify an install function."),h._warned=!0),h._warned?(o.push("\uD83D\uDD36 "+r.toString(h)),delete h._warned):o.push(" "+r.toString(h)),t.used.push(h.name))}o.length>0&&n.info(o.join("  "))},/**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */r.dependencies=function(t,e){var i=r.dependencyParse(t),s=i.name;if(!(s in(e=e||{}))){t=r.resolve(t)||t,e[s]=n.map(t.uses||[],function(e){r.isPlugin(e)&&r.register(e);var s=r.dependencyParse(e),o=r.resolve(e);return o&&!r.versionSatisfies(o.version,s.range)?(n.warn("Plugin.dependencies:",r.toString(o),"does not satisfy",r.toString(s),"used by",r.toString(i)+"."),o._warned=!0,t._warned=!0):o||(n.warn("Plugin.dependencies:",r.toString(e),"used by",r.toString(i),"could not be resolved."),t._warned=!0),s.name});for(var o=0;o<e[s].length;o+=1)r.dependencies(e[s][o],e);return e}},/**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */r.dependencyParse=function(t){return n.isString(t)?(/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t)||n.warn("Plugin.dependencyParse:",t,"is not a valid dependency string."),{name:t.split("@")[0],range:t.split("@")[1]||"*"}):{name:t.name,range:t.range||t.version}},/**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Greater than ranges e.g. `>1.2.3`
     * - Greater than or equal ranges e.g. `>=1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */r.versionParse=function(t){var e=/^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-]+)?$/;e.test(t)||n.warn("Plugin.versionParse:",t,"is not a valid version or range.");var i=e.exec(t),r=Number(i[4]),s=Number(i[5]),o=Number(i[6]);return{isRange:!!(i[1]||i[2]),version:i[3],range:t,operator:i[1]||i[2]||"",major:r,minor:s,patch:o,parts:[r,s,o],prerelease:i[7],number:1e8*r+1e4*s+o}},/**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */r.versionSatisfies=function(t,e){e=e||"*";var i=r.versionParse(e),n=r.versionParse(t);if(i.isRange){if("*"===i.operator||"*"===t)return!0;if(">"===i.operator)return n.number>i.number;if(">="===i.operator)return n.number>=i.number;if("~"===i.operator)return n.major===i.major&&n.minor===i.minor&&n.patch>=i.patch;if("^"===i.operator)return i.major>0?n.major===i.major&&n.number>=i.number:i.minor>0?n.minor===i.minor&&n.patch>=i.patch:n.patch===i.patch}return t===e||"*"===t};/***/},/* 16 *//***/function(t,e,i){/**
* The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/var r,n,s,o,a,h,l,u,c={};t.exports=c;var d=i(0),p=i(5),f=i(1),m=i(4),g=i(2),y=i(12);"undefined"!=typeof window&&(r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(t){window.setTimeout(function(){t(d.now())},1e3/60)},n=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),c._goodFps=30,c._goodDelta=1e3/60,/**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */c.create=function(t){var e={controller:c,engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,timing:{historySize:60,delta:0,deltaHistory:[],lastTime:0,lastTimestamp:0,lastElapsed:0,timestampElapsed:0,timestampElapsedHistory:[],engineDeltaHistory:[],engineElapsedHistory:[],elapsedHistory:[]},options:{width:800,height:600,pixelRatio:1,background:"#14151f",wireframeBackground:"#14151f",hasBounds:!!t.bounds,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showStats:!1,showPerformance:!1,showBroadphase:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showSeparations:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showVertexNumbers:!1,showConvexHulls:!1,showInternalEdges:!1,showMousePosition:!1}},i=d.extend(e,t);return i.canvas&&(i.canvas.width=i.options.width||i.canvas.width,i.canvas.height=i.options.height||i.canvas.height),i.mouse=t.mouse,i.engine=t.engine,i.canvas=i.canvas||a(i.options.width,i.options.height),i.context=i.canvas.getContext("2d"),i.textures={},i.bounds=i.bounds||{min:{x:0,y:0},max:{x:i.canvas.width,y:i.canvas.height}},1!==i.options.pixelRatio&&c.setPixelRatio(i,i.options.pixelRatio),d.isElement(i.element)?i.element.appendChild(i.canvas):i.canvas.parentNode||d.log("Render.create: options.element was undefined, render.canvas was created but not appended","warn"),i},/**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */c.run=function(t){!function e(i){t.frameRequestId=r(e),s(t,i),c.world(t,i),(t.options.showStats||t.options.showDebug)&&c.stats(t,t.context,i),(t.options.showPerformance||t.options.showDebug)&&c.performance(t,t.context,i)}()},/**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */c.stop=function(t){n(t.frameRequestId)},/**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */c.setPixelRatio=function(t,e){var i=t.options,r=t.canvas;"auto"===e&&(e=h(r)),i.pixelRatio=e,r.setAttribute("data-pixel-ratio",e),r.width=i.width*e,r.height=i.height*e,r.style.width=i.width+"px",r.style.height=i.height+"px"},/**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */c.lookAt=function(t,e,i,r){r=void 0===r||r,e=d.isArray(e)?e:[e],i=i||{x:0,y:0};for(var n={min:{x:1/0,y:1/0},max:{x:-1/0,y:-1/0}},s=0;s<e.length;s+=1){var o=e[s],a=o.bounds?o.bounds.min:o.min||o.position||o,h=o.bounds?o.bounds.max:o.max||o.position||o;a&&h&&(a.x<n.min.x&&(n.min.x=a.x),h.x>n.max.x&&(n.max.x=h.x),a.y<n.min.y&&(n.min.y=a.y),h.y>n.max.y&&(n.max.y=h.y))}// find bounds of all objects
var l=n.max.x-n.min.x+2*i.x,u=n.max.y-n.min.y+2*i.y,c=t.canvas.height,p=t.canvas.width/c,f=l/u,m=1,g=1;f>p?g=f/p:m=p/f,// enable bounds
t.options.hasBounds=!0,// position and size
t.bounds.min.x=n.min.x,t.bounds.max.x=n.min.x+l*m,t.bounds.min.y=n.min.y,t.bounds.max.y=n.min.y+u*g,r&&(t.bounds.min.x+=.5*l-l*m*.5,t.bounds.max.x+=.5*l-l*m*.5,t.bounds.min.y+=.5*u-u*g*.5,t.bounds.max.y+=.5*u-u*g*.5),// padding
t.bounds.min.x-=i.x,t.bounds.max.x-=i.x,t.bounds.min.y-=i.y,t.bounds.max.y-=i.y,t.mouse&&(y.setScale(t.mouse,{x:(t.bounds.max.x-t.bounds.min.x)/t.canvas.width,y:(t.bounds.max.y-t.bounds.min.y)/t.canvas.height}),y.setOffset(t.mouse,t.bounds.min))},/**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */c.startViewTransform=function(t){var e=t.bounds.max.x-t.bounds.min.x,i=t.bounds.max.y-t.bounds.min.y,r=e/t.options.width,n=i/t.options.height;t.context.setTransform(t.options.pixelRatio/r,0,0,t.options.pixelRatio/n,0,0),t.context.translate(-t.bounds.min.x,-t.bounds.min.y)},/**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */c.endViewTransform=function(t){t.context.setTransform(t.options.pixelRatio,0,0,t.options.pixelRatio,0,0)},/**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */c.world=function(t,e){var i,r=d.now(),n=t.engine,s=n.world,o=t.canvas,a=t.context,h=t.options,l=t.timing,_=p.allBodies(s),v=p.allConstraints(s),x=h.wireframes?h.wireframeBackground:h.background,b=[],E=[],T={timestamp:n.timing.timestamp};// handle bounds
if(m.trigger(t,"beforeRender",T),t.currentBackground!==x&&u(t,x),// clear the canvas with a transparent fill, to allow the canvas background to show
a.globalCompositeOperation="source-in",a.fillStyle="transparent",a.fillRect(0,0,o.width,o.height),a.globalCompositeOperation="source-over",h.hasBounds){// filter out bodies that are not in view
for(i=0;i<_.length;i++){var w=_[i];f.overlaps(w.bounds,t.bounds)&&b.push(w)}// filter out constraints that are not in view
for(i=0;i<v.length;i++){var S=v[i],M=S.bodyA,A=S.bodyB,R=S.pointA,C=S.pointB;M&&(R=g.add(M.position,S.pointA)),A&&(C=g.add(A.position,S.pointB)),R&&C&&(f.contains(t.bounds,R)||f.contains(t.bounds,C))&&E.push(S)}// transform the view
c.startViewTransform(t),t.mouse&&(y.setScale(t.mouse,{x:(t.bounds.max.x-t.bounds.min.x)/t.options.width,y:(t.bounds.max.y-t.bounds.min.y)/t.options.height}),y.setOffset(t.mouse,t.bounds.min))}else E=v,b=_,1!==t.options.pixelRatio&&t.context.setTransform(t.options.pixelRatio,0,0,t.options.pixelRatio,0,0);!h.wireframes||n.enableSleeping&&h.showSleeping?c.bodies(t,b,a):(h.showConvexHulls&&c.bodyConvexHulls(t,b,a),// optimised method for wireframes only
c.bodyWireframes(t,b,a)),h.showBounds&&c.bodyBounds(t,b,a),(h.showAxes||h.showAngleIndicator)&&c.bodyAxes(t,b,a),h.showPositions&&c.bodyPositions(t,b,a),h.showVelocity&&c.bodyVelocity(t,b,a),h.showIds&&c.bodyIds(t,b,a),h.showSeparations&&c.separations(t,n.pairs.list,a),h.showCollisions&&c.collisions(t,n.pairs.list,a),h.showVertexNumbers&&c.vertexNumbers(t,b,a),h.showMousePosition&&c.mousePosition(t,t.mouse,a),c.constraints(E,a),h.showBroadphase&&c.grid(t,n.grid,a),h.hasBounds&&c.endViewTransform(t),m.trigger(t,"afterRender",T),// log the time elapsed computing this update
l.lastElapsed=d.now()-r},/**
     * Renders statistics about the engine and world useful for debugging.
     * @private
     * @method stats
     * @param {render} render
     * @param {RenderingContext} context
     * @param {Number} time
     */c.stats=function(t,e,i){// count parts
for(var r=t.engine,n=r.world,s=p.allBodies(n),o=0,a=0,h=0;h<s.length;h+=1)o+=s[h].parts.length;var l={Part:o,Body:s.length,Cons:p.allConstraints(n).length,Comp:p.allComposites(n).length,Pair:r.pairs.list.length};// sections
for(var u in // background
e.fillStyle="#0e0f19",e.fillRect(a,0,302.5,44),e.font="12px Arial",e.textBaseline="top",e.textAlign="right",l){var c=l[u];// label
e.fillStyle="#aaa",e.fillText(u,a+55,8),// value
e.fillStyle="#eee",e.fillText(c,a+55,26),a+=55}},/**
     * Renders engine and render performance information.
     * @private
     * @method performance
     * @param {render} render
     * @param {RenderingContext} context
     */c.performance=function(t,e){var i=t.engine,r=t.timing,n=r.deltaHistory,s=r.elapsedHistory,a=r.timestampElapsedHistory,h=r.engineDeltaHistory,l=r.engineElapsedHistory,u=i.timing.lastDelta,d=o(n),p=o(s),f=o(h),m=o(l),g=o(a)/d||0,y=1e3/d||0;// background
e.fillStyle="#0e0f19",e.fillRect(0,50,370,34),// show FPS
c.status(e,10,69,60,4,n.length,Math.round(y)+" fps",y/c._goodFps,function(t){return n[t]/d-1}),// show engine delta
c.status(e,82,69,60,4,h.length,u.toFixed(2)+" dt",c._goodDelta/u,function(t){return h[t]/f-1}),// show engine update time
c.status(e,154,69,60,4,l.length,m.toFixed(2)+" ut",1-m/c._goodFps,function(t){return l[t]/m-1}),// show render time
c.status(e,226,69,60,4,s.length,p.toFixed(2)+" rt",1-p/c._goodFps,function(t){return s[t]/p-1}),// show effective speed
c.status(e,298,69,60,4,a.length,g.toFixed(2)+" x",g*g*g,function(t){return(a[t]/n[t]/g||0)-1})},/**
     * Renders a label, indicator and a chart.
     * @private
     * @method status
     * @param {RenderingContext} context
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} count
     * @param {string} label
     * @param {string} indicator
     * @param {function} plotY
     */c.status=function(t,e,i,r,n,s,o,a,h){// background
t.strokeStyle="#888",t.fillStyle="#444",t.lineWidth=1,t.fillRect(e,i+7,r,1),// chart
t.beginPath(),t.moveTo(e,i+7-n*d.clamp(.4*h(0),-2,2));for(var l=0;l<r;l+=1)t.lineTo(e+l,i+7-(l<s?n*d.clamp(.4*h(l),-2,2):0));t.stroke(),// indicator
t.fillStyle="hsl("+d.clamp(25+95*a,0,120)+",100%,60%)",t.fillRect(e,i-7,4,4),// label
t.font="12px Arial",t.textBaseline="middle",t.textAlign="right",t.fillStyle="#eee",t.fillText(o,e+r,i-5)},/**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */c.constraints=function(t,e){for(var i=0;i<t.length;i++){var r=t[i];if(r.render.visible&&r.pointA&&r.pointB){var n,s,o=r.bodyA,a=r.bodyB;if(n=o?g.add(o.position,r.pointA):r.pointA,"pin"===r.render.type)e.beginPath(),e.arc(n.x,n.y,3,0,2*Math.PI),e.closePath();else{if(s=a?g.add(a.position,r.pointB):r.pointB,e.beginPath(),e.moveTo(n.x,n.y),"spring"===r.render.type)for(var h,l=g.sub(s,n),u=g.perp(g.normalise(l)),c=Math.ceil(d.clamp(r.length/5,12,20)),p=1;p<c;p+=1)h=p%2==0?1:-1,e.lineTo(n.x+l.x*(p/c)+u.x*h*4,n.y+l.y*(p/c)+u.y*h*4);e.lineTo(s.x,s.y)}r.render.lineWidth&&(e.lineWidth=r.render.lineWidth,e.strokeStyle=r.render.strokeStyle,e.stroke()),r.render.anchors&&(e.fillStyle=r.render.strokeStyle,e.beginPath(),e.arc(n.x,n.y,3,0,2*Math.PI),e.arc(s.x,s.y,3,0,2*Math.PI),e.closePath(),e.fill())}}},/**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodies=function(t,e,i){t.engine;var r,n,s,o,a=t.options,h=a.showInternalEdges||!a.wireframes;for(s=0;s<e.length;s++)if((r=e[s]).render.visible)// handle compound parts
{for(o=r.parts.length>1?1:0;o<r.parts.length;o++)if((n=r.parts[o]).render.visible){if(a.showSleeping&&r.isSleeping?i.globalAlpha=.5*n.render.opacity:1!==n.render.opacity&&(i.globalAlpha=n.render.opacity),n.render.sprite&&n.render.sprite.texture&&!a.wireframes){// part sprite
var u=n.render.sprite,c=l(t,u.texture);i.translate(n.position.x,n.position.y),i.rotate(n.angle),i.drawImage(c,-(c.width*u.xOffset)*u.xScale,-(c.height*u.yOffset)*u.yScale,c.width*u.xScale,c.height*u.yScale),// revert translation, hopefully faster than save / restore
i.rotate(-n.angle),i.translate(-n.position.x,-n.position.y)}else{// part polygon
if(n.circleRadius)i.beginPath(),i.arc(n.position.x,n.position.y,n.circleRadius,0,2*Math.PI);else{i.beginPath(),i.moveTo(n.vertices[0].x,n.vertices[0].y);for(var d=1;d<n.vertices.length;d++)!n.vertices[d-1].isInternal||h?i.lineTo(n.vertices[d].x,n.vertices[d].y):i.moveTo(n.vertices[d].x,n.vertices[d].y),n.vertices[d].isInternal&&!h&&i.moveTo(n.vertices[(d+1)%n.vertices.length].x,n.vertices[(d+1)%n.vertices.length].y);i.lineTo(n.vertices[0].x,n.vertices[0].y),i.closePath()}a.wireframes?(i.lineWidth=1,i.strokeStyle="#bbb",i.stroke()):(i.fillStyle=n.render.fillStyle,n.render.lineWidth&&(i.lineWidth=n.render.lineWidth,i.strokeStyle=n.render.strokeStyle,i.stroke()),i.fill())}i.globalAlpha=1}}},/**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyWireframes=function(t,e,i){var r,n,s,o,a,h=t.options.showInternalEdges;// render all bodies
for(i.beginPath(),s=0;s<e.length;s++)if((r=e[s]).render.visible)// handle compound parts
for(a=r.parts.length>1?1:0;a<r.parts.length;a++){for(n=r.parts[a],i.moveTo(n.vertices[0].x,n.vertices[0].y),o=1;o<n.vertices.length;o++)!n.vertices[o-1].isInternal||h?i.lineTo(n.vertices[o].x,n.vertices[o].y):i.moveTo(n.vertices[o].x,n.vertices[o].y),n.vertices[o].isInternal&&!h&&i.moveTo(n.vertices[(o+1)%n.vertices.length].x,n.vertices[(o+1)%n.vertices.length].y);i.lineTo(n.vertices[0].x,n.vertices[0].y)}i.lineWidth=1,i.strokeStyle="#bbb",i.stroke()},/**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyConvexHulls=function(t,e,i){var r,n,s;// render convex hulls
for(i.beginPath(),n=0;n<e.length;n++)if((r=e[n]).render.visible&&1!==r.parts.length){for(i.moveTo(r.vertices[0].x,r.vertices[0].y),s=1;s<r.vertices.length;s++)i.lineTo(r.vertices[s].x,r.vertices[s].y);i.lineTo(r.vertices[0].x,r.vertices[0].y)}i.lineWidth=1,i.strokeStyle="rgba(255,255,255,0.2)",i.stroke()},/**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.vertexNumbers=function(t,e,i){var r,n,s;for(r=0;r<e.length;r++){var o=e[r].parts;for(s=o.length>1?1:0;s<o.length;s++){var a=o[s];for(n=0;n<a.vertices.length;n++)i.fillStyle="rgba(255,255,255,0.2)",i.fillText(r+"_"+n,a.position.x+(a.vertices[n].x-a.position.x)*.8,a.position.y+(a.vertices[n].y-a.position.y)*.8)}}},/**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */c.mousePosition=function(t,e,i){i.fillStyle="rgba(255,255,255,0.8)",i.fillText(e.position.x+"  "+e.position.y,e.position.x+5,e.position.y-5)},/**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyBounds=function(t,e,i){t.engine;var r=t.options;i.beginPath();for(var n=0;n<e.length;n++)if(e[n].render.visible)for(var s=e[n].parts,o=s.length>1?1:0;o<s.length;o++){var a=s[o];i.rect(a.bounds.min.x,a.bounds.min.y,a.bounds.max.x-a.bounds.min.x,a.bounds.max.y-a.bounds.min.y)}r.wireframes?i.strokeStyle="rgba(255,255,255,0.08)":i.strokeStyle="rgba(0,0,0,0.1)",i.lineWidth=1,i.stroke()},/**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyAxes=function(t,e,i){t.engine;var r,n,s,o,a=t.options;for(i.beginPath(),n=0;n<e.length;n++){var h=e[n],l=h.parts;if(h.render.visible){if(a.showAxes)for(s=l.length>1?1:0;s<l.length;s++)for(o=0,r=l[s];o<r.axes.length;o++){var u=r.axes[o];i.moveTo(r.position.x,r.position.y),i.lineTo(r.position.x+20*u.x,r.position.y+20*u.y)}else for(s=l.length>1?1:0;s<l.length;s++)for(o=0,r=l[s];o<r.axes.length;o++)// render a single axis indicator
i.moveTo(r.position.x,r.position.y),i.lineTo((r.vertices[0].x+r.vertices[r.vertices.length-1].x)/2,(r.vertices[0].y+r.vertices[r.vertices.length-1].y)/2)}}a.wireframes?(i.strokeStyle="indianred",i.lineWidth=1):(i.strokeStyle="rgba(255, 255, 255, 0.4)",i.globalCompositeOperation="overlay",i.lineWidth=2),i.stroke(),i.globalCompositeOperation="source-over"},/**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyPositions=function(t,e,i){t.engine;var r,n,s,o,a=t.options;// render current positions
for(i.beginPath(),s=0;s<e.length;s++)if((r=e[s]).render.visible)// handle compound parts
for(o=0;o<r.parts.length;o++)n=r.parts[o],i.arc(n.position.x,n.position.y,3,0,2*Math.PI,!1),i.closePath();// render previous positions
for(a.wireframes?i.fillStyle="indianred":i.fillStyle="rgba(0,0,0,0.5)",i.fill(),i.beginPath(),s=0;s<e.length;s++)(r=e[s]).render.visible&&(i.arc(r.positionPrev.x,r.positionPrev.y,2,0,2*Math.PI,!1),i.closePath());i.fillStyle="rgba(255,165,0,0.8)",i.fill()},/**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyVelocity=function(t,e,i){i.beginPath();for(var r=0;r<e.length;r++){var n=e[r];n.render.visible&&(i.moveTo(n.position.x,n.position.y),i.lineTo(n.position.x+(n.position.x-n.positionPrev.x)*2,n.position.y+(n.position.y-n.positionPrev.y)*2))}i.lineWidth=3,i.strokeStyle="cornflowerblue",i.stroke()},/**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */c.bodyIds=function(t,e,i){var r,n;for(r=0;r<e.length;r++)if(e[r].render.visible){var s=e[r].parts;for(n=s.length>1?1:0;n<s.length;n++){var o=s[n];i.font="12px Arial",i.fillStyle="rgba(255,255,255,0.5)",i.fillText(o.id,o.position.x+10,o.position.y-10)}}},/**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */c.collisions=function(t,e,i){var r,n,s,o,a=t.options;// render collision positions
for(i.beginPath(),s=0;s<e.length;s++)if((r=e[s]).isActive)for(o=0,n=r.collision;o<r.activeContacts.length;o++){var h=r.activeContacts[o].vertex;i.rect(h.x-1.5,h.y-1.5,3.5,3.5)}// render collision normals
for(a.wireframes?i.fillStyle="rgba(255,255,255,0.7)":i.fillStyle="orange",i.fill(),i.beginPath(),s=0;s<e.length;s++)if((r=e[s]).isActive&&(n=r.collision,r.activeContacts.length>0)){var l=r.activeContacts[0].vertex.x,u=r.activeContacts[0].vertex.y;2===r.activeContacts.length&&(l=(r.activeContacts[0].vertex.x+r.activeContacts[1].vertex.x)/2,u=(r.activeContacts[0].vertex.y+r.activeContacts[1].vertex.y)/2),n.bodyB===n.supports[0].body||!0===n.bodyA.isStatic?i.moveTo(l-8*n.normal.x,u-8*n.normal.y):i.moveTo(l+8*n.normal.x,u+8*n.normal.y),i.lineTo(l,u)}a.wireframes?i.strokeStyle="rgba(255,165,0,0.7)":i.strokeStyle="orange",i.lineWidth=1,i.stroke()},/**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */c.separations=function(t,e,i){var r,n,s,o,a,h=t.options;// render separations
for(i.beginPath(),a=0;a<e.length;a++)if((r=e[a]).isActive){s=(n=r.collision).bodyA;var l=1;(o=n.bodyB).isStatic||s.isStatic||(l=.5),o.isStatic&&(l=0),i.moveTo(o.position.x,o.position.y),i.lineTo(o.position.x-n.penetration.x*l,o.position.y-n.penetration.y*l),l=1,o.isStatic||s.isStatic||(l=.5),s.isStatic&&(l=0),i.moveTo(s.position.x,s.position.y),i.lineTo(s.position.x+n.penetration.x*l,s.position.y+n.penetration.y*l)}h.wireframes?i.strokeStyle="rgba(255,165,0,0.5)":i.strokeStyle="orange",i.stroke()},/**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */c.grid=function(t,e,i){t.options.wireframes?i.strokeStyle="rgba(255,180,0,0.1)":i.strokeStyle="rgba(255,180,0,0.5)",i.beginPath();for(var r=d.keys(e.buckets),n=0;n<r.length;n++){var s=r[n];if(!(e.buckets[s].length<2)){var o=s.split(/C|R/);i.rect(.5+parseInt(o[1],10)*e.bucketWidth,.5+parseInt(o[2],10)*e.bucketHeight,e.bucketWidth,e.bucketHeight)}}i.lineWidth=1,i.stroke()},/**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */c.inspector=function(t,e){t.engine;var i,r=t.selected,n=t.render,s=n.options;if(s.hasBounds){var o=n.bounds.max.x-n.bounds.min.x,a=n.bounds.max.y-n.bounds.min.y,h=o/n.options.width,l=a/n.options.height;e.scale(1/h,1/l),e.translate(-n.bounds.min.x,-n.bounds.min.y)}for(var u=0;u<r.length;u++){var c=r[u].data;switch(e.translate(.5,.5),e.lineWidth=1,e.strokeStyle="rgba(255,165,0,0.9)",e.setLineDash([1,2]),c.type){case"body":// render body selections
i=c.bounds,e.beginPath(),e.rect(Math.floor(i.min.x-3),Math.floor(i.min.y-3),Math.floor(i.max.x-i.min.x+6),Math.floor(i.max.y-i.min.y+6)),e.closePath(),e.stroke();break;case"constraint":// render constraint selections
var d=c.pointA;c.bodyA&&(d=c.pointB),e.beginPath(),e.arc(d.x,d.y,10,0,2*Math.PI),e.closePath(),e.stroke()}e.setLineDash([]),e.translate(-.5,-.5)}null!==t.selectStart&&(e.translate(.5,.5),e.lineWidth=1,e.strokeStyle="rgba(255,165,0,0.6)",e.fillStyle="rgba(255,165,0,0.1)",i=t.selectBounds,e.beginPath(),e.rect(Math.floor(i.min.x),Math.floor(i.min.y),Math.floor(i.max.x-i.min.x),Math.floor(i.max.y-i.min.y)),e.closePath(),e.stroke(),e.fill(),e.translate(-.5,-.5)),s.hasBounds&&e.setTransform(1,0,0,1,0,0)},s=function(t,e){var i=t.engine,r=t.timing,n=r.historySize,s=i.timing.timestamp;r.delta=e-r.lastTime||c._goodDelta,r.lastTime=e,r.timestampElapsed=s-r.lastTimestamp||0,r.lastTimestamp=s,r.deltaHistory.unshift(r.delta),r.deltaHistory.length=Math.min(r.deltaHistory.length,n),r.engineDeltaHistory.unshift(i.timing.lastDelta),r.engineDeltaHistory.length=Math.min(r.engineDeltaHistory.length,n),r.timestampElapsedHistory.unshift(r.timestampElapsed),r.timestampElapsedHistory.length=Math.min(r.timestampElapsedHistory.length,n),r.engineElapsedHistory.unshift(i.timing.lastElapsed),r.engineElapsedHistory.length=Math.min(r.engineElapsedHistory.length,n),r.elapsedHistory.unshift(r.lastElapsed),r.elapsedHistory.length=Math.min(r.elapsedHistory.length,n)},o=function(t){for(var e=0,i=0;i<t.length;i+=1)e+=t[i];return e/t.length||0},a=function(t,e){var i=document.createElement("canvas");return i.width=t,i.height=e,i.oncontextmenu=function(){return!1},i.onselectstart=function(){return!1},i},h=function(t){var e=t.getContext("2d");return(window.devicePixelRatio||1)/(e.webkitBackingStorePixelRatio||e.mozBackingStorePixelRatio||e.msBackingStorePixelRatio||e.oBackingStorePixelRatio||e.backingStorePixelRatio||1)},l=function(t,e){var i=t.textures[e];return i||((i=t.textures[e]=new Image).src=e),i},u=function(t,e){var i=e;/(jpg|gif|png)$/.test(e)&&(i="url("+e+")"),t.canvas.style.background=i,t.canvas.style.backgroundSize="contain",t.currentBackground=e};/***/},/* 17 *//***/function(t,e){/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/var i={};t.exports=i,/**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */i.create=function(t){return{id:i.id(t),vertex:t,normalImpulse:0,tangentImpulse:0}},/**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */i.id=function(t){return t.body.id+"_"+t.index};/***/},/* 18 *//***/function(t,e,i){/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/var r={};t.exports=r;var n=i(7),s=i(19),o=i(13),a=i(20),h=i(21),l=i(4),u=i(5),c=i(8),d=i(0),p=i(6);/**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */r.create=function(t){t=t||{};var e=d.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},grid:null,gravity:{x:0,y:1,scale:.001},timing:{timestamp:0,timeScale:1,lastDelta:0,lastElapsed:0}},t);return e.world=t.world||u.create({label:"World"}),e.grid=h.create(t.grid||t.broadphase),e.pairs=a.create(),// temporary back compatibility
e.world.gravity=e.gravity,e.broadphase=e.grid,e.metrics={},e},/**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */r.update=function(t,e,i){var p=d.now();e=e||1e3/60,i=i||1;var f,m=t.world,g=t.timing,y=t.grid,_=[];// increment timestamp
g.timestamp+=e*g.timeScale,g.lastDelta=e*g.timeScale;// create an event object
var v={timestamp:g.timestamp};l.trigger(t,"beforeUpdate",v);// get lists of all bodies and constraints, no matter what composites they are in
var x=u.allBodies(m),b=u.allConstraints(m);for(t.enableSleeping&&n.update(x,g.timeScale),// applies gravity to all bodies
r._bodiesApplyGravity(x,t.gravity),// update all body position and rotation by integration
r._bodiesUpdate(x,e,g.timeScale,i,m.bounds),// update all constraints (first pass)
c.preSolveAll(x),f=0;f<t.constraintIterations;f++)c.solveAll(b,g.timeScale);c.postSolveAll(x),m.isModified&&h.clear(y),// update the grid buckets based on current bodies
h.update(y,x,t,m.isModified),_=y.pairsList,m.isModified&&u.setModified(m,!1,!1,!0);// narrowphase pass: find actual collisions, then create or update collision pairs
var E=o.collisions(_,t),T=t.pairs,w=g.timestamp;for(a.update(T,E,w),a.removeOld(T,w),t.enableSleeping&&n.afterCollisions(T.list,g.timeScale),T.collisionStart.length>0&&l.trigger(t,"collisionStart",{pairs:T.collisionStart}),// iteratively resolve position between collisions
s.preSolvePosition(T.list),f=0;f<t.positionIterations;f++)s.solvePosition(T.list,g.timeScale);for(s.postSolvePosition(x),// update all constraints (second pass)
c.preSolveAll(x),f=0;f<t.constraintIterations;f++)c.solveAll(b,g.timeScale);for(c.postSolveAll(x),// iteratively resolve velocity between collisions
s.preSolveVelocity(T.list),f=0;f<t.velocityIterations;f++)s.solveVelocity(T.list,g.timeScale);return T.collisionActive.length>0&&l.trigger(t,"collisionActive",{pairs:T.collisionActive}),T.collisionEnd.length>0&&l.trigger(t,"collisionEnd",{pairs:T.collisionEnd}),// clear force buffers
r._bodiesClearForces(x),l.trigger(t,"afterUpdate",v),// log the time elapsed computing this update
t.timing.lastElapsed=d.now()-p,t},/**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */r.merge=function(t,e){if(d.extend(t,e),e.world){t.world=e.world,r.clear(t);for(var i=u.allBodies(t.world),s=0;s<i.length;s++){var o=i[s];n.set(o,!1),o.id=d.nextId()}}},/**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */r.clear=function(t){var e=t.world,i=u.allBodies(e);a.clear(t.pairs),h.clear(t.grid),h.update(t.grid,i,t,!0)},/**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method _bodiesClearForces
     * @private
     * @param {body[]} bodies
     */r._bodiesClearForces=function(t){for(var e=0;e<t.length;e++){var i=t[e];// reset force buffers
i.force.x=0,i.force.y=0,i.torque=0}},/**
     * Applys a mass dependant force to all given bodies.
     * @method _bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */r._bodiesApplyGravity=function(t,e){var i=void 0!==e.scale?e.scale:.001;if((0!==e.x||0!==e.y)&&0!==i)for(var r=0;r<t.length;r++){var n=t[r];n.isStatic||n.isSleeping||(// apply gravity
n.force.y+=n.mass*e.y*i,n.force.x+=n.mass*e.x*i)}},/**
     * Applys `Body.update` to all given `bodies`.
     * @method _bodiesUpdate
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */r._bodiesUpdate=function(t,e,i,r,n){for(var s=0;s<t.length;s++){var o=t[s];o.isStatic||o.isSleeping||p.update(o,e,i,r)}};/***/},/* 19 *//***/function(t,e,i){/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/var r={};t.exports=r;var n=i(3),s=i(2),o=i(0),a=i(1);r._restingThresh=4,r._restingThreshTangent=6,r._positionDampen=.9,r._positionWarming=.8,r._frictionNormalMultiplier=5,/**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */r.preSolvePosition=function(t){var e,i,r;// find total contacts on each body
for(e=0;e<t.length;e++)(i=t[e]).isActive&&(r=i.activeContacts.length,i.collision.parentA.totalContacts+=r,i.collision.parentB.totalContacts+=r)},/**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */r.solvePosition=function(t,e){var i,n,o,a,h,l,u,c,d,p=s._temp[0],f=s._temp[1],m=s._temp[2],g=s._temp[3];// find impulses required to resolve penetration
for(i=0;i<t.length;i++)(n=t[i]).isActive&&!n.isSensor&&(a=(o=n.collision).parentA,h=o.parentB,l=o.normal,// get current separation between body edges involved in collision
u=s.sub(s.add(h.positionImpulse,h.position,p),s.add(a.positionImpulse,s.sub(h.position,o.penetration,f),m),g),n.separation=s.dot(l,u));for(i=0;i<t.length;i++)!(n=t[i]).isActive||n.isSensor||(a=(o=n.collision).parentA,h=o.parentB,l=o.normal,d=(n.separation-n.slop)*e,(a.isStatic||h.isStatic)&&(d*=2),a.isStatic||a.isSleeping||(c=r._positionDampen/a.totalContacts,a.positionImpulse.x+=l.x*d*c,a.positionImpulse.y+=l.y*d*c),h.isStatic||h.isSleeping||(c=r._positionDampen/h.totalContacts,h.positionImpulse.x-=l.x*d*c,h.positionImpulse.y-=l.y*d*c))},/**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */r.postSolvePosition=function(t){for(var e=0;e<t.length;e++){var i=t[e];if(// reset contact count
i.totalContacts=0,0!==i.positionImpulse.x||0!==i.positionImpulse.y){// update body geometry
for(var o=0;o<i.parts.length;o++){var h=i.parts[o];n.translate(h.vertices,i.positionImpulse),a.update(h.bounds,h.vertices,i.velocity),h.position.x+=i.positionImpulse.x,h.position.y+=i.positionImpulse.y}// move the body without changing velocity
i.positionPrev.x+=i.positionImpulse.x,i.positionPrev.y+=i.positionImpulse.y,0>s.dot(i.positionImpulse,i.velocity)?(// reset cached impulse if the body has velocity along it
i.positionImpulse.x=0,i.positionImpulse.y=0):(// warm the next iteration
i.positionImpulse.x*=r._positionWarming,i.positionImpulse.y*=r._positionWarming)}}},/**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */r.preSolveVelocity=function(t){var e,i,r,n,o,a,h,l,u,c,d,p,f,m,g=s._temp[0],y=s._temp[1];for(e=0;e<t.length;e++)if((r=t[e]).isActive&&!r.isSensor)// resolve each contact
for(i=0,n=r.activeContacts,a=(o=r.collision).parentA,h=o.parentB,l=o.normal,u=o.tangent;i<n.length;i++)d=(c=n[i]).vertex,p=c.normalImpulse,f=c.tangentImpulse,0===p&&0===f||(// total impulse from contact
g.x=l.x*p+u.x*f,g.y=l.y*p+u.y*f,a.isStatic||a.isSleeping||(m=s.sub(d,a.position,y),a.positionPrev.x+=g.x*a.inverseMass,a.positionPrev.y+=g.y*a.inverseMass,a.anglePrev+=s.cross(m,g)*a.inverseInertia),h.isStatic||h.isSleeping||(m=s.sub(d,h.position,y),h.positionPrev.x-=g.x*h.inverseMass,h.positionPrev.y-=g.y*h.inverseMass,h.anglePrev-=s.cross(m,g)*h.inverseInertia))},/**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */r.solveVelocity=function(t,e){for(var i=e*e,n=s._temp[0],a=s._temp[1],h=s._temp[2],l=s._temp[3],u=s._temp[4],c=s._temp[5],d=0;d<t.length;d++){var p=t[d];if(p.isActive&&!p.isSensor){var f=p.collision,m=f.parentA,g=f.parentB,y=f.normal,_=f.tangent,v=p.activeContacts,x=1/v.length;// update body velocities
m.velocity.x=m.position.x-m.positionPrev.x,m.velocity.y=m.position.y-m.positionPrev.y,g.velocity.x=g.position.x-g.positionPrev.x,g.velocity.y=g.position.y-g.positionPrev.y,m.angularVelocity=m.angle-m.anglePrev,g.angularVelocity=g.angle-g.anglePrev;// resolve each contact
for(var b=0;b<v.length;b++){var E=v[b],T=E.vertex,w=s.sub(T,m.position,a),S=s.sub(T,g.position,h),M=s.add(m.velocity,s.mult(s.perp(w),m.angularVelocity),l),A=s.add(g.velocity,s.mult(s.perp(S),g.angularVelocity),u),R=s.sub(M,A,c),C=s.dot(y,R),P=s.dot(_,R),I=Math.abs(P),O=o.sign(P),L=(1+p.restitution)*C,N=o.clamp(p.separation+C,0,1)*r._frictionNormalMultiplier,D=P,F=1/0;I>p.friction*p.frictionStatic*N*i&&(F=I,D=o.clamp(p.friction*O*i,-F,F));// modify impulses accounting for mass, inertia and offset
var B=s.cross(w,y),U=s.cross(S,y),G=x/(m.inverseMass+g.inverseMass+m.inverseInertia*B*B+g.inverseInertia*U*U);// handle high velocity and resting collisions separately
if(L*=G,D*=G,C<0&&C*C>r._restingThresh*i)E.normalImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// impulse constraint tends to 0
var k=E.normalImpulse;E.normalImpulse=Math.min(E.normalImpulse+L,0),L=E.normalImpulse-k}// handle high velocity and resting collisions separately
if(P*P>r._restingThreshTangent*i)E.tangentImpulse=0;else{// solve resting collision constraints using Erin Catto's method (GDC08)
// tangent impulse tends to -tangentSpeed or +tangentSpeed
var H=E.tangentImpulse;E.tangentImpulse=o.clamp(E.tangentImpulse+D,-F,F),D=E.tangentImpulse-H}// total impulse from contact
n.x=y.x*L+_.x*D,n.y=y.y*L+_.y*D,m.isStatic||m.isSleeping||(m.positionPrev.x+=n.x*m.inverseMass,m.positionPrev.y+=n.y*m.inverseMass,m.anglePrev+=s.cross(w,n)*m.inverseInertia),g.isStatic||g.isSleeping||(g.positionPrev.x-=n.x*g.inverseMass,g.positionPrev.y-=n.y*g.inverseMass,g.anglePrev-=s.cross(S,n)*g.inverseInertia)}}}};/***/},/* 20 *//***/function(t,e,i){/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/var r={};t.exports=r;var n=i(9),s=i(0);r._pairMaxIdleLife=1e3,/**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */r.create=function(t){return s.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},t)},/**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */r.update=function(t,e,i){var r,s,o,a,h=t.list,l=t.table,u=t.collisionStart,c=t.collisionEnd,d=t.collisionActive;for(a=0,// clear collision state arrays, but maintain old reference
u.length=0,c.length=0,d.length=0;a<h.length;a++)h[a].confirmedActive=!1;for(a=0;a<e.length;a++)(r=e[a]).collided&&((o=l[s=n.id(r.bodyA,r.bodyB)])?(o.isActive?d.push(o):u.push(o),// update the pair
n.update(o,r,i),o.confirmedActive=!0):(// pair did not exist, create a new pair
o=n.create(r,i),l[s]=o,// push the new pair
u.push(o),h.push(o)));// deactivate previously active pairs that are now inactive
for(a=0;a<h.length;a++)(o=h[a]).isActive&&!o.confirmedActive&&(n.setActive(o,!1,i),c.push(o))},/**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */r.removeOld=function(t,e){var i,n,s,o,a=t.list,h=t.table,l=[];for(o=0;o<a.length;o++){// never remove sleeping pairs
if((n=(i=a[o]).collision).bodyA.isSleeping||n.bodyB.isSleeping){i.timeUpdated=e;continue}// if pair is inactive for too long, mark it to be removed
e-i.timeUpdated>r._pairMaxIdleLife&&l.push(o)}// remove marked pairs
for(o=0;o<l.length;o++)i=a[s=l[o]-o],delete h[i.id],a.splice(s,1)},/**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */r.clear=function(t){return t.table={},t.list.length=0,t.collisionStart.length=0,t.collisionActive.length=0,t.collisionEnd.length=0,t};/***/},/* 21 *//***/function(t,e,i){/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/var r={};t.exports=r;var n=i(9),s=i(0);/**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */r.create=function(t){return s.extend({buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48},t)},/**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     *//**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     *//**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */r.update=function(t,e,i,n){var s,o,a,h,l,u=i.world,c=t.buckets,d=!1;for(s=0;s<e.length;s++){var p=e[s];if((!p.isSleeping||n)&&(!u.bounds||!(p.bounds.max.x<u.bounds.min.x)&&!(p.bounds.min.x>u.bounds.max.x)&&!(p.bounds.max.y<u.bounds.min.y)&&!(p.bounds.min.y>u.bounds.max.y))){var f=r._getRegion(t,p);// if the body has changed grid region
if(!p.region||f.id!==p.region.id||n){(!p.region||n)&&(p.region=f);var m=r._regionUnion(f,p.region);// update grid buckets affected by region change
// iterate over the union of both regions
for(o=m.startCol;o<=m.endCol;o++)for(a=m.startRow;a<=m.endRow;a++){h=c[l=r._getBucketId(o,a)];var g=o>=f.startCol&&o<=f.endCol&&a>=f.startRow&&a<=f.endRow,y=o>=p.region.startCol&&o<=p.region.endCol&&a>=p.region.startRow&&a<=p.region.endRow;!g&&y&&y&&h&&r._bucketRemoveBody(t,h,p),(p.region===f||g&&!y||n)&&(h||(h=r._createBucket(c,l)),r._bucketAddBody(t,h,p))}// set the new region
p.region=f,// flag changes so we can update pairs
d=!0}}}// update pairs list only if pairs changed (i.e. a body changed region)
d&&(t.pairsList=r._createActivePairsList(t))},/**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */r.clear=function(t){t.buckets={},t.pairs={},t.pairsList=[]},/**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */r._regionUnion=function(t,e){var i=Math.min(t.startCol,e.startCol),n=Math.max(t.endCol,e.endCol),s=Math.min(t.startRow,e.startRow),o=Math.max(t.endRow,e.endRow);return r._createRegion(i,n,s,o)},/**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */r._getRegion=function(t,e){var i=e.bounds,n=Math.floor(i.min.x/t.bucketWidth),s=Math.floor(i.max.x/t.bucketWidth),o=Math.floor(i.min.y/t.bucketHeight),a=Math.floor(i.max.y/t.bucketHeight);return r._createRegion(n,s,o,a)},/**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */r._createRegion=function(t,e,i,r){return{id:t+","+e+","+i+","+r,startCol:t,endCol:e,startRow:i,endRow:r}},/**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */r._getBucketId=function(t,e){return"C"+t+"R"+e},/**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */r._createBucket=function(t,e){return t[e]=[]},/**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */r._bucketAddBody=function(t,e,i){// add new pairs
for(var r=0;r<e.length;r++){var s=e[r];if(i.id!==s.id&&(!i.isStatic||!s.isStatic)){// keep track of the number of buckets the pair exists in
// important for Grid.update to work
var o=n.id(i,s),a=t.pairs[o];a?a[2]+=1:t.pairs[o]=[i,s,1]}}// add to bodies (after pairs, otherwise pairs with self)
e.push(i)},/**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */r._bucketRemoveBody=function(t,e,i){// remove from bucket
e.splice(s.indexOf(e,i),1);// update pair counts
for(var r=0;r<e.length;r++){// keep track of the number of buckets the pair exists in
// important for _createActivePairsList to work
var o=e[r],a=n.id(i,o),h=t.pairs[a];h&&(h[2]-=1)}},/**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */r._createActivePairsList=function(t){var e,i,r=[];// grid.pairs is used as a hashmap
e=s.keys(t.pairs);// iterate over grid.pairs
for(var n=0;n<e.length;n++)// if pair exists in at least one bucket
// it is a pair that needs further collision testing so push it
(i=t.pairs[e[n]])[2]>0?r.push(i):delete t.pairs[e[n]];return r};/***/},/* 22 *//***/function(t,e,i){var r=t.exports=i(23);r.Axes=i(10),r.Bodies=i(11),r.Body=i(6),r.Bounds=i(1),r.Common=i(0),r.Composite=i(5),r.Composites=i(24),r.Constraint=i(8),r.Contact=i(17),r.Detector=i(13),r.Engine=i(18),r.Events=i(4),r.Grid=i(21),r.Mouse=i(12),r.MouseConstraint=i(25),r.Pair=i(9),r.Pairs=i(20),r.Plugin=i(15),r.Query=i(26),r.Render=i(16),r.Resolver=i(19),r.Runner=i(27),r.SAT=i(14),r.Sleeping=i(7),r.Svg=i(28),r.Vector=i(2),r.Vertices=i(3),r.World=i(29),// temporary back compatibility
r.Engine.run=r.Runner.run,r.Common.deprecated(r.Engine,"run","Engine.run  use Matter.Runner.run(engine) instead");/***/},/* 23 *//***/function(t,e,i){/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/var r={};t.exports=r;var n=i(15),s=i(0);/**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */r.name="matter-js",/**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */r.version="0.17.1",/**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */r.uses=[],/**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */r.used=[],/**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */r.use=function(){n.use(r,Array.prototype.slice.call(arguments))},/**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */r.before=function(t,e){return t=t.replace(/^Matter./,""),s.chainPathBefore(r,t,e)},/**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */r.after=function(t,e){return t=t.replace(/^Matter./,""),s.chainPathAfter(r,t,e)};/***/},/* 24 *//***/function(t,e,i){/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/var r={};t.exports=r;var n=i(5),s=i(8),o=i(0),a=i(6),h=i(11),l=o.deprecated;/**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */r.stack=function(t,e,i,r,s,o,h){for(var l,u=n.create({label:"Stack"}),c=t,d=e,p=0,f=0;f<r;f++){for(var m=0,g=0;g<i;g++){var y=h(c,d,g,f,l,p);if(y){var _=y.bounds.max.y-y.bounds.min.y,v=y.bounds.max.x-y.bounds.min.x;_>m&&(m=_),a.translate(y,{x:.5*v,y:.5*_}),c=y.bounds.max.x+s,n.addBody(u,y),l=y,p+=1}else c+=s}d+=m+o,c=t}return u},/**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */r.chain=function(t,e,i,r,a,h){for(var l=t.bodies,u=1;u<l.length;u++){var c=l[u-1],d=l[u],p=c.bounds.max.y-c.bounds.min.y,f=c.bounds.max.x-c.bounds.min.x,m=d.bounds.max.y-d.bounds.min.y,g=d.bounds.max.x-d.bounds.min.x,y={bodyA:c,pointA:{x:f*e,y:p*i},bodyB:d,pointB:{x:g*r,y:m*a}},_=o.extend(y,h);n.addConstraint(t,s.create(_))}return t.label+=" Chain",t},/**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */r.mesh=function(t,e,i,r,a){var h,l,u,c,d,p=t.bodies;for(h=0;h<i;h++){for(l=1;l<e;l++)u=p[l-1+h*e],c=p[l+h*e],n.addConstraint(t,s.create(o.extend({bodyA:u,bodyB:c},a)));if(h>0)for(l=0;l<e;l++)u=p[l+(h-1)*e],c=p[l+h*e],n.addConstraint(t,s.create(o.extend({bodyA:u,bodyB:c},a))),r&&l>0&&(d=p[l-1+(h-1)*e],n.addConstraint(t,s.create(o.extend({bodyA:d,bodyB:c},a)))),r&&l<e-1&&(d=p[l+1+(h-1)*e],n.addConstraint(t,s.create(o.extend({bodyA:d,bodyB:c},a))))}return t.label+=" Mesh",t},/**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */r.pyramid=function(t,e,i,n,s,o,h){return r.stack(t,e,i,n,s,o,function(e,r,o,l,u,c){var d=Math.min(n,Math.ceil(i/2)),p=u?u.bounds.max.x-u.bounds.min.x:0;if(!(l>d)){var f=// reverse row order
l=d-l,m=i-1-l;if(!(o<f)&&!(o>m))return 1===c&&a.translate(u,{x:(o+(i%2==1?1:-1))*p,y:0}),h(t+(u?o*p:0)+o*s,r,o,l,u,c)}})},/**
     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.
     * @deprecated moved to newtonsCradle example
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */r.newtonsCradle=function(t,e,i,r,o){for(var a=n.create({label:"Newtons Cradle"}),l=0;l<i;l++){var u=h.circle(t+l*(1.9*r),e+o,r,{inertia:1/0,restitution:1,friction:0,frictionAir:1e-4,slop:1}),c=s.create({pointA:{x:t+l*(1.9*r),y:e},bodyB:u});n.addBody(a,u),n.addConstraint(a,c)}return a},l(r,"newtonsCradle","Composites.newtonsCradle  moved to newtonsCradle example"),/**
     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.
     * @deprecated moved to car example
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */r.car=function(t,e,i,r,o){var l=a.nextGroup(!0),u=-(.5*i)+20,c=.5*i-20,d=n.create({label:"Car"}),p=h.rectangle(t,e,i,r,{collisionFilter:{group:l},chamfer:{radius:.5*r},density:2e-4}),f=h.circle(t+u,e+0,o,{collisionFilter:{group:l},friction:.8}),m=h.circle(t+c,e+0,o,{collisionFilter:{group:l},friction:.8}),g=s.create({bodyB:p,pointB:{x:u,y:0},bodyA:f,stiffness:1,length:0}),y=s.create({bodyB:p,pointB:{x:c,y:0},bodyA:m,stiffness:1,length:0});return n.addBody(d,p),n.addBody(d,f),n.addBody(d,m),n.addConstraint(d,g),n.addConstraint(d,y),d},l(r,"car","Composites.car  moved to car example"),/**
     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)
     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.
     * @deprecated moved to softBody and cloth examples
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */r.softBody=function(t,e,i,n,s,a,l,u,c,d){c=o.extend({inertia:1/0},c),d=o.extend({stiffness:.2,render:{type:"line",anchors:!1}},d);var p=r.stack(t,e,i,n,s,a,function(t,e){return h.circle(t,e,u,c)});return r.mesh(p,i,n,l,d),p.label="Soft Body",p},l(r,"softBody","Composites.softBody  moved to softBody and cloth examples");/***/},/* 25 *//***/function(t,e,i){/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/var r={};t.exports=r;var n=i(3),s=i(7),o=i(12),a=i(4),h=i(13),l=i(8),u=i(5),c=i(0),d=i(1);/**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */r.create=function(t,e){var i=(t?t.mouse:null)||(e?e.mouse:null);i||(t&&t.render&&t.render.canvas?i=o.create(t.render.canvas):e&&e.element?i=o.create(e.element):(i=o.create(),c.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));var n=l.create({label:"Mouse Constraint",pointA:i.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}}),s={type:"mouseConstraint",mouse:i,element:null,body:null,constraint:n,collisionFilter:{category:1,mask:4294967295,group:0}},h=c.extend(s,e);return a.on(t,"beforeUpdate",function(){var e=u.allBodies(t.world);r.update(h,e),r._triggerEvents(h)}),h},/**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */r.update=function(t,e){var i=t.mouse,r=t.constraint,o=t.body;if(0===i.button){if(r.bodyB)s.set(r.bodyB,!1),r.pointA=i.position;else for(var l=0;l<e.length;l++)if(o=e[l],d.contains(o.bounds,i.position)&&h.canCollide(o.collisionFilter,t.collisionFilter))for(var u=o.parts.length>1?1:0;u<o.parts.length;u++){var c=o.parts[u];if(n.contains(c.vertices,i.position)){r.pointA=i.position,r.bodyB=t.body=o,r.pointB={x:i.position.x-o.position.x,y:i.position.y-o.position.y},r.angleB=o.angle,s.set(o,!1),a.trigger(t,"startdrag",{mouse:i,body:o});break}}}else r.bodyB=t.body=null,r.pointB=null,o&&a.trigger(t,"enddrag",{mouse:i,body:o})},/**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */r._triggerEvents=function(t){var e=t.mouse,i=e.sourceEvents;i.mousemove&&a.trigger(t,"mousemove",{mouse:e}),i.mousedown&&a.trigger(t,"mousedown",{mouse:e}),i.mouseup&&a.trigger(t,"mouseup",{mouse:e}),// reset the mouse state ready for the next step
o.clearSourceEvents(e)};/***/},/* 26 *//***/function(t,e,i){/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/var r={};t.exports=r;var n=i(2),s=i(14),o=i(1),a=i(11),h=i(3);/**
     * Returns a list of collisions between `body` and `bodies`.
     * @method collides
     * @param {body} body
     * @param {body[]} bodies
     * @return {object[]} Collisions
     */r.collides=function(t,e){for(var i=[],r=0;r<e.length;r++){var n=e[r];if(o.overlaps(n.bounds,t.bounds))for(var a=1===n.parts.length?0:1;a<n.parts.length;a++){var h=n.parts[a];if(o.overlaps(h.bounds,t.bounds)){var l=s.collides(h,t);if(l.collided){i.push(l);break}}}}return i},/**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */r.ray=function(t,e,i,s){s=s||1e-100;for(var o=n.angle(e,i),h=n.magnitude(n.sub(e,i)),l=(i.x+e.x)*.5,u=(i.y+e.y)*.5,c=a.rectangle(l,u,h,s,{angle:o}),d=r.collides(c,t),p=0;p<d.length;p+=1){var f=d[p];f.body=f.bodyB=f.bodyA}return d},/**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */r.region=function(t,e,i){for(var r=[],n=0;n<t.length;n++){var s=t[n],a=o.overlaps(s.bounds,e);(a&&!i||!a&&i)&&r.push(s)}return r},/**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */r.point=function(t,e){for(var i=[],r=0;r<t.length;r++){var n=t[r];if(o.contains(n.bounds,e))for(var s=1===n.parts.length?0:1;s<n.parts.length;s++){var a=n.parts[s];if(o.contains(a.bounds,e)&&h.contains(a.vertices,e)){i.push(n);break}}}return i};/***/},/* 27 *//***/function(t,e,i){/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/var r,n,s,o={};t.exports=o;var a=i(4),h=i(18),l=i(0);"undefined"!=typeof window&&(r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame,n=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),r||(r=function(t){s=setTimeout(function(){t(l.now())},1e3/60)},n=function(){clearTimeout(s)}),/**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */o.create=function(t){var e=l.extend({fps:60,correction:1,deltaSampleSize:60,counterTimestamp:0,frameCounter:0,deltaHistory:[],timePrev:null,timeScalePrev:1,frameRequestId:null,isFixed:!1,enabled:!0},t);return e.delta=e.delta||1e3/e.fps,e.deltaMin=e.deltaMin||1e3/e.fps,e.deltaMax=e.deltaMax||1e3/(.5*e.fps),e.fps=1e3/e.delta,e},/**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */o.run=function(t,e){return void 0!==t.positionIterations&&(e=t,t=o.create()),function i(n){t.frameRequestId=r(i),n&&t.enabled&&o.tick(t,e,n)}(),t},/**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */o.tick=function(t,e,i){var r,n=e.timing,s=1,o={timestamp:n.timestamp};a.trigger(t,"beforeTick",o),t.isFixed?r=t.delta:(// dynamic timestep based on wall clock between calls
r=i-t.timePrev||t.delta,t.timePrev=i,// optimistically filter delta over a few frames, to improve stability
t.deltaHistory.push(r),t.deltaHistory=t.deltaHistory.slice(-t.deltaSampleSize),// correction for delta
s=(r=// limit delta
(r=(r=Math.min.apply(null,t.deltaHistory))<t.deltaMin?t.deltaMin:r)>t.deltaMax?t.deltaMax:r)/t.delta,// update engine timing object
t.delta=r),0!==t.timeScalePrev&&(s*=n.timeScale/t.timeScalePrev),0===n.timeScale&&(s=0),t.timeScalePrev=n.timeScale,t.correction=s,// fps counter
t.frameCounter+=1,i-t.counterTimestamp>=1e3&&(t.fps=t.frameCounter*((i-t.counterTimestamp)/1e3),t.counterTimestamp=i,t.frameCounter=0),a.trigger(t,"tick",o),// update
a.trigger(t,"beforeUpdate",o),h.update(e,r,s),a.trigger(t,"afterUpdate",o),a.trigger(t,"afterTick",o)},/**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */o.stop=function(t){n(t.frameRequestId)},/**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */o.start=function(t,e){o.run(t,e)};/***/},/* 28 *//***/function(t,e,i){/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/var r={};t.exports=r,i(1);var n=i(0);/**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * You must load the `pathseg.js` polyfill on newer browsers.
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */r.pathToVertices=function(t,e){"undefined"==typeof window||"SVGPathSeg"in window||n.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");// https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
var i,s,o,a,h,l,u,c,d,p,f,m=[],g=0,y=0,_=0;e=e||15;var v=function(t,e,i){// all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
var r=i%2==1&&i>1;// when the last point doesn't equal the current point add the current point
if(!d||t!=d.x||e!=d.y){d&&r?(p=d.x,f=d.y):(p=0,f=0);var n={x:p+t,y:f+e};(r||!d)&&(d=n),m.push(n),y=p+t,_=f+e}},x=function(t){var e=t.pathSegTypeAsLetter.toUpperCase();// skip path ends
if("Z"!==e){// map segment to x and y
switch(e){case"M":case"L":case"T":case"C":case"S":case"Q":y=t.x,_=t.y;break;case"H":y=t.x;break;case"V":_=t.y}v(y,_,t.pathSegType)}};for(// ensure path is absolute
r._svgPathToAbsolute(t),// get total length
o=t.getTotalLength(),// queue segments
l=[],i=0;i<t.pathSegList.numberOfItems;i+=1)l.push(t.pathSegList.getItem(i));// sample through path
for(u=l.concat();g<o;){// new segment
if((h=l[t.getPathSegAtLength(g)])!=c){for(;u.length&&u[0]!=h;)x(u.shift());c=h}// add points in between when curving
// TODO: adaptive sampling
switch(h.pathSegTypeAsLetter.toUpperCase()){case"C":case"T":case"S":case"Q":case"A":v((a=t.getPointAtLength(g)).x,a.y,0)}// increment by sample value
g+=e}// add remaining segments not passed by sampling
for(i=0,s=u.length;i<s;++i)x(u[i]);return m},r._svgPathToAbsolute=function(t){for(var e,i,r,n,s,o,a=t.pathSegList,h=0,l=0,u=a.numberOfItems,c=0;c<u;++c){var d=a.getItem(c),p=d.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(p))"x"in d&&(h=d.x),"y"in d&&(l=d.y);else switch("x1"in d&&(r=h+d.x1),"x2"in d&&(s=h+d.x2),"y1"in d&&(n=l+d.y1),"y2"in d&&(o=l+d.y2),"x"in d&&(h+=d.x),"y"in d&&(l+=d.y),p){case"m":a.replaceItem(t.createSVGPathSegMovetoAbs(h,l),c);break;case"l":a.replaceItem(t.createSVGPathSegLinetoAbs(h,l),c);break;case"h":a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h),c);break;case"v":a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l),c);break;case"c":a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h,l,r,n,s,o),c);break;case"s":a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h,l,s,o),c);break;case"q":a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h,l,r,n),c);break;case"t":a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h,l),c);break;case"a":a.replaceItem(t.createSVGPathSegArcAbs(h,l,d.r1,d.r2,d.angle,d.largeArcFlag,d.sweepFlag),c);break;case"z":case"Z":h=e,l=i}("M"==p||"m"==p)&&(e=h,i=l)}};/***/},/* 29 *//***/function(t,e,i){/**
* This module has now been replaced by `Matter.Composite`.
*
* All usage should be migrated to the equivalent functions found on `Matter.Composite`.
* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.
*
* The property `world.gravity` has been moved to `engine.gravity`.
*
* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.
* Eventually this alias module will be marked as deprecated and then later removed in a future release.
*
* @class World
*/var r={};t.exports=r;var n=i(5);i(0),/**
     * See above, aliases for back compatibility only
     */r.create=n.create,r.add=n.add,r.remove=n.remove,r.clear=n.clear,r.addComposite=n.addComposite,r.addBody=n.addBody,r.addConstraint=n.addConstraint;/***/}]);class wd extends hy{constructor(t="",e,i,r){if(super(t),!e.parts)throw Error("Body.parts is undefined");this.body=e,this.world=i,this.options={fillStyle:r&&r.fillStyle?r.fillStyle:437914367,strokeStyle:r&&r.strokeStyle?r.strokeStyle:15328879,strokeStyleWireframe:r&&r.strokeStyleWireframe?r.strokeStyleWireframe:11316396,strokeStyleAngle:r&&r.showAngleIndicator?r&&r.strokeStyleAngle?r.strokeStyleAngle:13978951:void 0,lineWidth:r&&r.lineWidth?r.lineWidth:1,showWireframes:!r||!r.showWireframes||r.showWireframes,showAngleIndicator:!r||!r.showAngleIndicator||r.showAngleIndicator,showAxes:!!r&&!!r.showAxes&&r.showAxes},this.createBodyPrimitive(),this.addComponent(new hO("MatterSync").doOnUpdate((t,e,i)=>{this.body.isStatic||(this.rotation=this.body.angle),this.position.x=this.body.position.x,this.position.y=this.body.position.y}))}// render body
createBodyPrimitive(){let t=this.options.fillStyle,e=this.options.strokeStyle,i=this.options.strokeStyleAngle,r=this.options.strokeStyleWireframe,n;// clear the primitive
this.clear();// handle compound parts
for(let s=this.body.parts.length>1?1:0;s<this.body.parts.length;s++){n=this.body.parts[s],this.options.showWireframes?this.lineStyle(this.options.lineWidth,r,1):(this.beginFill(t,1),this.lineStyle(this.options.lineWidth,e,1)),this.moveTo(n.vertices[0].x-this.body.position.x,n.vertices[0].y-this.body.position.y);for(let t=1;t<n.vertices.length;t++)this.lineTo(n.vertices[t].x-this.body.position.x,n.vertices[t].y-this.body.position.y);this.lineTo(n.vertices[0].x-this.body.position.x,n.vertices[0].y-this.body.position.y),this.endFill(),(this.options.showAngleIndicator||this.options.showAxes)&&(this.beginFill(0,0),this.lineStyle(1,i,1),this.moveTo(n.position.x-this.body.position.x,n.position.y-this.body.position.y),this.lineTo((n.vertices[0].x+n.vertices[n.vertices.length-1].x)/2-this.body.position.x,(n.vertices[0].y+n.vertices[n.vertices.length-1].y)/2-this.body.position.y),this.endFill())}}}class wp{constructor(){this.strokeStyle="0x00FF00",this.lineWidth=1}}class wf extends hy{constructor(t="",e,i,r){super(t),this.constraint=e,this.world=i,this.options=r||new wp,this.renderPrimitive(),this.addComponent(new hO("MatterSync").doOnUpdate((t,e,i)=>{this.renderPrimitive();// re-render at each udpate
}))}// render constraint
renderPrimitive(){let t=t1.string2hex(this.options.strokeStyle);// clear the primitive
this.clear();let e=this.constraint.bodyA,i=this.constraint.bodyB,r=this.constraint.pointA,n=this.constraint.pointB;// render the constraint on every update, since they can change dynamically
this.beginFill(0,0),this.lineStyle(this.options.lineWidth,t,1),e?this.moveTo(e.position.x+r.x,e.position.y+r.y):this.moveTo(r.x,r.y),i?this.lineTo(i.position.x+n.x,i.position.y+n.y):n&&this.lineTo(n.x,n.y),this.endFill()}}class wm{init(t,e){// add mouse control
if(// create matterJS engine
this.mEngine=wc.Engine.create(),this.mWorld=this.mEngine.world,this.scene=t,this.config={mouseControl:!0,renderConstraints:!0,renderAngles:!0,...e},// create runner
this.runner=wc.Runner.create(null),// add a new PIXI object when given event is invoked
wc.Events.on(this.mWorld,"afterAdd",e=>{this.addNewObject(e,t)}),this.config.mouseControl){let e=wc.Mouse.create(t.app.view),i=wc.MouseConstraint.create(this.mEngine,{mouse:e});e.scale.x=e.scale.y=t.app.view.width/t.app.view.getBoundingClientRect().width,wc.World.add(this.mWorld,i)}// update runner during the ECSA game loop
t.addGlobalComponent(new hO("").doOnUpdate((t,e)=>wc.Runner.tick(this.runner,this.mEngine,e)))}/**
	 * Adds a new body to the matter world and returns sync PIXI-ECS object
	 * @param body body to add
	 */addBody(t){return wc.World.add(this.mWorld,[t]),this.findSyncObjectForBody(t)}/**
	 * Adds a new contraint to the matter world and returns sync PIXI-ECS object
	 * @param constraint constraint to add
	 */addConstraint(t){return wc.World.add(this.mWorld,[t]),this.findSyncObjectForConstraint(t)}/**
	 * Finds a PIXI-ECS sync object for given MatterJS object
	 */findSyncObjectForBody(t){return this.scene.findObjectByName(`matter_body_${t.id}`)}/**
	 * Finds a PIXI-ECS sync object for given MatterJS constraint
	 */findSyncObjectForConstraint(t){return this.scene.findObjectByName(`matter_constraint_${t.id}`)}addNewObject(t,e){if("body"===t.type)e.stage.addChild(new wd("matter_body_"+t.id,t,this.mWorld,{showAngleIndicator:this.config.renderAngles}));else if("constraint"===t.type&&this.config.renderConstraints)e.stage.addChild(new wf("matter_constraint_"+t.id,t,this.mWorld));else if(t.object){if(t.object.length)for(let i of t.object)this.addNewObject(i,e);else{// MatterJS can put the objects to any collection...
if(t.object.body&&e.stage.addChild(new wd("matter_body_"+t.object.body.id,t.object.body,this.mWorld,{showAngleIndicator:this.config.renderAngles})),t.object.constraint&&this.config.renderConstraints&&e.stage.addChild(new wf("matter_constraint_"+t.object.constraint.id,t.object.constraint,this.mWorld)),t.object.bodies)for(let i of t.object.bodies)this.addNewObject(i,e);if(t.object.constraints&&this.config.renderConstraints)for(let i of t.object.constraints)this.addNewObject(i,e);if(t.object.composites)for(let i of t.object.composites)this.addNewObject(i,e)}}// inner bodies
if(t.bodies)for(let i of t.bodies)this.addNewObject(i,e);// inner constraints
if(t.constraints&&this.config.renderConstraints)for(let i of t.constraints)this.addNewObject(i,e)}}class wg{constructor(t){this.pos=t,this.previousPos=t.clone()}draw(t){t.lineStyle(0),t.beginFill(13977415),t.drawCircle(this.pos.x,this.pos.y,4),t.endFill()}}class wy{constructor(t,e){this.particle=t,this.pos=e}relax(){this.particle.pos=this.pos.clone()}draw(t){t.beginFill(16777215,.55),t.drawCircle(this.pos.x,this.pos.y,12),t.endFill()}}class w_{constructor(t,e,i){this.particleA=t,this.particleB=e,this.stiffness=i,this.distance=t.pos.distance(e.pos)}relax(){let t=this.particleA.pos.subtract(this.particleB.pos),e=t.magnitudeSquared(),i=t.multiply((this.distance*this.distance-e)/e*this.stiffness);this.particleA.pos=this.particleA.pos.add(i),this.particleB.pos=this.particleB.pos.subtract(i)}draw(t){t.lineStyle(1,13977415),t.moveTo(this.particleA.pos.x,this.particleA.pos.y),t.lineTo(this.particleB.pos.x,this.particleB.pos.y),t.endFill()}}class wv{constructor(t){this.particles=[],this.constraints=[],this.gravity=t}update(){for(let t of this.particles){let e=t.pos.subtract(t.previousPos);t.previousPos=t.pos,t.pos=t.pos.add(this.gravity),t.pos=t.pos.add(e)}for(let t of this.constraints)t.relax()}draw(t){for(let e of this.constraints)e.draw(t);for(let e of this.particles)e.draw(t)}}class wx extends hi{onUpdate(t,e){let i=this.owner;i.body.position.y-1>=-this.props.platformHeight?wc.Body.setPosition(i.body,{x:i.body.position.x,y:i.body.position.y-1}):wc.Body.setPosition(i.body,{x:i.body.position.x,y:i.body.position.y+this.props.shift})}}class wb extends hi{onUpdate(t,e){let i=this.scene.getGlobalAttribute("key_input"),r=this.owner;i.isKeyPressed(b7.KEY_LEFT)?wc.Body.applyForce(r.body,{x:r.position.x,y:r.body.position.y},{x:-.03,y:0}):i.isKeyPressed(b7.KEY_RIGHT)&&wc.Body.applyForce(r.body,{x:r.position.x,y:r.body.position.y},{x:.03,y:0})}}(K||(K={})).DIRECTION="direction",(d=J||(J={})).SPRITESHEET="spritesheet",d.LEVEL_BACKGROUND="level background",(Z||(Z={})).COLLIDABLE="collidable",(p=$||($={})).EMPTY="EMPTY",p.WALL="WALL",p.PLAYER="PLAYER",p.BOX="BOX";const wE={[$.EMPTY]:null,[$.PLAYER]:{x:0,y:32,w:32,h:32},[$.WALL]:{x:0,y:0,w:32,h:32},[$.BOX]:{x:32,y:0,w:32,h:32}};class wT extends hi{onInit(){this.direction=this.owner.getAttribute(K.DIRECTION),this.leftTexture=this.owner.asSprite().texture,this.rightTexture=new rH(this.leftTexture.baseTexture,this.leftTexture.frame,null,null,12),1===this.direction&&(this.owner.asSprite().texture=this.rightTexture)}onUpdate(){let t=this.direction;this.direction=this.owner.getAttribute(K.DIRECTION),t!==this.direction&&(this.owner.asSprite().texture=-1===this.direction?this.leftTexture:this.rightTexture)}}const ww=Math.floor(25/3),wS=Math.floor(25/3);class wM extends hi{onUpdate(){let t=this.props.container,e=this.scene.stage.width,i=this.scene.stage.height,r=this.owner,n=r.x+t.x,s=r.y+t.y,o=0;n<ww?o=ww-n:n+r.width>this.scene.width-ww&&(o=this.scene.width-ww-n-r.width),t.x+=o;let a=0;s<wS?a=wS-s:s+r.width>this.scene.height-wS&&(a=this.scene.height-wS-s-r.width),t.y+=a,//edge cases
t.x=Math.min(0,Math.max(this.scene.width-e,t.x)),t.y=Math.min(0,Math.max(this.scene.height-i,t.y))}}(f=Q||(Q={})).STAND="STAND",f.WALK="WALK",f.JUMP="JUMP",f.FALL="FALL",(m=tt||(tt={})).LEFT="LEFT",m.RIGHT="RIGHT",m.JUMP="JUMP",m.MOVE="MOVE";class wA extends hi{onUpdate(t,e){this.direction=this.owner.getAttribute(K.DIRECTION);let i=.01*t*1;this.handlePlayerMoveStates(i),this.applyDynamics(i),this.updatePlayerMoveStates(),this.handleCollidables(),this.owner.assignAttribute(K.DIRECTION,this.direction)}handleCollidables(){let t=this.scene.findObjectsByTag(Z.COLLIDABLE),e=this.owner.getBounds();for(let i of t){let t=i.getBounds(),r=this.horizIntersection(e,t),n=this.vertIntersection(e,t),s=r>0&&n>0;s&&i.destroy()}}handlePlayerMoveStates(t){switch(this.PlayerMoveStates){case Q.STAND:this.handleStandState(t);break;case Q.WALK:this.handleWalkState(t);break;case Q.JUMP:this.handleJumpState(t);break;case Q.FALL:this.handleFallState(t)}}handleStandState(t){this.isActionOn(tt.MOVE)?(this.PlayerMoveStates=Q.WALK,this.handleWalkState(t)):this.isActionOn(tt.JUMP)&&(this.PlayerMoveStates=Q.JUMP,this.handleJumpState(t))}handleWalkState(t){this.isActionOn(tt.JUMP)?(this.PlayerMoveStates=Q.JUMP,this.handleJumpState(t)):this.isActionOn(tt.MOVE)?this.updateHorizontalSpeed(t):(this.PlayerMoveStates=Q.STAND,this.handleStandState(t))}handleJumpState(t){this.updateHorizontalSpeed(t),this.isActionOn(tt.JUMP)&&(null===this.jumpPrevY?(this.jumpPrevY=this.owner.y,this.speed.y=-.5,this.isTouchingGround=!1):this.jumpPrevY>=this.owner.y&&(// measure length of the jump
this.jumpDistance+=this.jumpPrevY-this.owner.y,this.jumpPrevY=this.owner.y)),(this.jumpDistance>3.5||!this.isActionOn(tt.JUMP))&&this.finishJump()}handleFallState(t){this.updateHorizontalSpeed(t),this.isTouchingGround&&(this.PlayerMoveStates=Q.STAND,this.handleStandState(t))}updateHorizontalSpeed(t){this.isActionOn(tt.LEFT)?(this.direction=-1,this.speed.x=this.direction*Math.min(.8*t,.8)):this.isActionOn(tt.RIGHT)&&(this.direction=1,this.speed.x=this.direction*Math.min(.8*t,.8))}finishJump(){let t=this.props.keyInput;t.isKeyPressed(b7.KEY_SPACE)&&t.handleKey(b7.KEY_SPACE),this.jumpDistance=0,this.jumpPrevY=null,this.PlayerMoveStates=Q.FALL}isActionOn(t){switch(t){case tt.JUMP:return this.props.keyInput.isKeyPressed(b7.KEY_SPACE);case tt.LEFT:return this.props.keyInput.isKeyPressed(b7.KEY_LEFT)&&!this.props.keyInput.isKeyPressed(b7.KEY_RIGHT);case tt.RIGHT:return!this.props.keyInput.isKeyPressed(b7.KEY_LEFT)&&this.props.keyInput.isKeyPressed(b7.KEY_RIGHT);case tt.MOVE:return(Number(this.props.keyInput.isKeyPressed(b7.KEY_LEFT))^Number(this.props.keyInput.isKeyPressed(b7.KEY_RIGHT)))==1}}isHorizBlockFree(t,e){let i=this.props.level.platforms;return 0===i[Math.floor(e)][Math.floor(t)]&&0===i[Math.ceil(e)][Math.floor(t)]}isVertBlockFree(t,e){let i=this.props.level.platforms;return 0===i[Math.floor(e)][Math.floor(t)]&&0===i[Math.floor(e)][Math.ceil(t)]}//this apply movement/speed to player coord and solve collisions with ground
applyDynamics(t){let e=this.owner.position.x,i=this.owner.position.y,r=this.isVertBlockFree(this.hardRound(e),i+1);r&&this.PlayerMoveStates!==Q.JUMP&&(this.speed.y=Math.min(this.speed.y+this.gravity*t,this.gravity),this.isTouchingGround=!1),(0!==this.speed.x||0!==this.speed.y)&&(// update position
this.owner.position.x+=this.speed.x,this.owner.position.y+=this.speed.y,//solve horizontal collision (x-axis)
e=this.owner.position.x,i=this.owner.position.y-this.speed.y,this.speed.x>0&&!this.isHorizBlockFree(e+1,i)?(// collision right - relaxation
this.owner.position.x=Math.floor(e),this.speed.x=0):this.speed.x<0&&!this.isHorizBlockFree(e,i)&&(// collision left - relaxation
this.owner.position.x=Math.floor(e)+1,this.speed.x=0),//solve vertical collision (y-axis)
e=this.owner.position.x-this.speed.x,i=this.owner.position.y,this.speed.y>0&&!this.isVertBlockFree(this.hardRound(e,.05),i+1)?(//collision down
this.owner.position.y=Math.floor(i),this.isTouchingGround=!0,this.speed.y=0):this.speed.y<0&&!this.isVertBlockFree(this.hardRound(e,.05),i)&&(//collision up
this.owner.position.y=Math.floor(i)+1,this.isTouchingCeiling=!0),//reduce speed
this.speed.x*=.7,this.speed.y*=.9,.01>Math.abs(this.speed.x)&&(this.speed.x=0),.01>Math.abs(this.speed.y)&&(this.speed.y=0))}updatePlayerMoveStates(){this.isTouchingCeiling&&(this.isTouchingCeiling=!1,this.PlayerMoveStates=Q.FALL,this.finishJump()),this.isTouchingGround&&this.PlayerMoveStates===Q.FALL&&(this.PlayerMoveStates=Q.STAND)}constructor(...t){super(...t),this.PlayerMoveStates=Q.STAND,this.speed={x:0,y:0},this.direction=1,this.isTouchingGround=!1,this.isTouchingCeiling=!1,this.jumpPrevY=null,this.jumpDistance=0,this.gravity=.5,this.horizIntersection=(t,e)=>Math.min(t.right,e.right)-Math.max(t.left,e.left),this.vertIntersection=(t,e)=>Math.min(t.bottom,e.bottom)-Math.max(t.top,e.top),this.hardRound=(t,e=.2)=>Math.abs(t-Math.round(t))<=e?Math.round(t):t}}class wR{loadLevel(t,e){e.clearScene();let i=new ha;e.addGlobalComponent(i);//create map layer
let r=new hs("mapLayer");e.stage.addChild(r),//add background
this.buildBackground(r);//load tiles
for(let n=0;n<t.height;n++)for(let s=0;s<t.width;s++){let o=t.tiles[n][s];switch(o){case $.PLAYER:this.buildPlayer(s,n,e,i,t,r);break;case $.WALL:this.buildSprite(s,n,o,r);break;case $.BOX:this.buildCollidable(s,n,o,e,r)}}}buildSprite(t,e,i,r){let n=wE[i],s=new hb("sprite",this.createTexture(n.x,n.y,n.w,n.h));s.scale.set(.03125),s.position.x=t,s.position.y=e,r.addChild(s)}buildCollidable(t,e,i,r,n){let s=wE[i];new hR(r).withTag(Z.COLLIDABLE).anchor(0,0).localPos(t,e).asSprite(this.createTexture(s.x,s.y,s.w,s.h)).withParent(n).scale(.03125).build()}buildPlayer(t,e,i,r,n,s){let o=wE[$.PLAYER];new hR(i).anchor(0,0).localPos(t,e).withName($.PLAYER).asSprite(this.createTexture(o.x,o.y,o.w,o.h)).withParent(s).withComponent(new wA({keyInput:r,level:n})).withComponent(new wM({container:s})).withComponent(new wT).withAttribute(K.DIRECTION,1).scale(.03125).build()}createTexture(t,e,i,r){let n=rH.from(J.SPRITESHEET).clone();return n.frame=new iU(t,e,i,r),n}buildBackground(t){let e=rH.from(J.LEVEL_BACKGROUND).clone(),i=new hb("background",e);i.scale.set(.03125),t.addChild(i)}}const wC=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,2,0,0,2,2,2,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];class wP{buildLevel(t,e,i){let r=e.length/i,n=[[]],s=[[]],o={0:$.EMPTY,5:$.PLAYER,1:$.WALL,2:$.BOX};for(let t=0;t<e.length;t++){let r=e[t],a=o[r],h=t%i,l=Math.floor(t/i);n[l]||(n[l]=[],s[l]=[]),n[l][h]=a,1===r?s[l][h]=1:s[l][h]=0}return{name:t,width:i,height:r,tiles:n,platforms:s}}}/* eslint-disable no-use-before-define *//**
 * Player element (position, keybindings and update function)
 */class wI{constructor(t,e){// position
this.posX=0,this.posY=0,// direction
this.dirX=1,this.dirY=0,// camera
this.camX=0,this.camY=.66// FOV: 66
,// player and rotation speed
this.speed=.12,this.rotspeed=.1,this.up=!1,this.down=!1,this.right=!1,this.left=!1,this.allowUpdate=!0,// WSAD
this.keyDown=t=>{65===t.keyCode&&(this.left=!0),68===t.keyCode&&(this.right=!0),87===t.keyCode&&(this.up=!0),83===t.keyCode&&(this.down=!0)},this.keyUp=t=>{65===t.keyCode&&(this.left=!1),68===t.keyCode&&(this.right=!1),87===t.keyCode&&(this.up=!1),83===t.keyCode&&(this.down=!1)},// place the player to the center
this.posX=t+.5,this.posY=e+.5}init(){document.addEventListener("keydown",this.keyDown,!1),document.addEventListener("keyup",this.keyUp,!1)}update(t){if(!this.allowUpdate)return;let e=this.dirX*this.speed,i=this.dirY*this.speed;this.up&&(t.isFree(Math.floor(this.posX+e),Math.floor(this.posY))&&(this.posX+=e),t.isFree(Math.floor(this.posX),Math.floor(this.posY+i))&&(this.posY+=i)),this.down&&(t.isFree(Math.floor(this.posX-e),Math.floor(this.posY))&&(this.posX-=e),t.isFree(Math.floor(this.posX),Math.floor(this.posY-i))&&(this.posY-=i));// update camera orientation based on rotation
let r=Math.cos(this.rotspeed),n=Math.cos(-this.rotspeed),s=Math.sin(this.rotspeed),o=Math.sin(-this.rotspeed);if(this.left){let t=this.dirX;this.dirX=t*n-this.dirY*o,this.dirY=t*o+this.dirY*n;let e=this.camX;this.camX=e*n-this.camY*o,this.camY=e*o+this.camY*n}if(this.right){let t=this.dirX;this.dirX=t*r-this.dirY*s,this.dirY=t*s+this.dirY*r;let e=this.camX;this.camX=e*r-this.camY*s,this.camY=e*s+this.camY*r}}destroy(){document.removeEventListener("keydown",this.keyDown),document.removeEventListener("keyup",this.keyUp)}}/**
 * Map item (sprite)
 */class wO{constructor(t,e,i,r,n){this.name=t,this.posX=e,this.posY=i,this.size=r,this.texture=n}/**
	 * Gets squared distance from point [x,y]
	 */distance(t,e){return Math.pow(t-this.posX,2)+Math.pow(e-this.posY,2)}}/**
 * Structure of map elements
 */class wL{constructor(){// texture for every object type
this.textures=[],// collection of objects
this.items=[],// so far only one object type is supported
this.textures[0]=new Image,this.textures[0].src=`${mZ()}/assets/07-graphics/raycaster/object.png`}/**
	 * Adds a new object
	 * @param name name of the object
	 * @param x position along x-axis
	 * @param y position along y-axis
	 * @param size size [0..1] for 256x256 tex
	 * @param texture link to the texture
	 */add(t,e,i,r,n){this.items[this.items.length]=new wO(t,e,i,r,n)}remove(t){delete this.items[t]}/**
	 * Returns collection of all objects sorted by their distance to [x,y]
	 * Used to sort sprites based on their distance to the player
	 */sorted(t,e){let i=[];// store objects and their distance
for(let r of this.items)i[i.length]=r,r.dist=r.distance(t,e);// return objects sorted by their distance
return i.sort((t,e)=>e.dist-t.dist)}getTexture(t){return this.textures[t]}}/**
 * Structure of the map
 */class wN{constructor(){// FREE = 0
// BLOCK = 1
this.data=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],this.width=20,this.height=20,this.wallTextures=[],// gradients for floor and ceilings
this.floor0="rgb(0, 0, 0)",this.floor1="rgb(20, 20, 20)",this.ceiling0="rgb(0, 0, 0)",this.ceiling1="rgb(80, 20, 20)",this.items=new wL,// so far only one wall texture is supported
this.wallTextures[0]=new Image,this.wallTextures[0].src=`${mZ()}/assets/07-graphics/raycaster/wall.jpg`,this.items.add("item",3.5,1.5,.2,0),this.items.add("item",7.5,2.25,.2,0),this.items.add("item",7.5,2.75,.2,0)}getTextureByIndex(t){return this.wallTextures[t]}getTextureByPosition(t,e){return this.getTextureByIndex(this.data[e*this.width+t]-1)}/**
	 * Returns true if the path is free at selected coordinate
	 */isFree(t,e){return!(t<0)&&!(t>=this.width)&&!(e<0)&&!(e>=this.height)&&0===this.data[e*this.width+t]}}const wD=t=>{switch(t){case"linear":return TN.linear;case"easeinout":return TN.easeinout;case"quadraticEaseIn":return TN.quadraticEaseIn;case"quadraticEaseOut":return TN.quadraticEaseOut;case"quadraticEaseInOut":return TN.quadraticEaseInOut;case"sineIn":return TN.sineIn;case"sineOut":return TN.sineOut;case"expoIn":return TN.expoIn}};class wF extends hi{// loops = 0 for infinite!
constructor(t,e=!1,i=1){super(),// TODO move into props object
this.interpolation=null,this.duration=0,this.goBack=!1,this.goingBack=!1,this.loops=0,this.currentLoop=0,this.startTime=0,this.duration=t,this.goBack=e,this.loops=i,this.interpolation=TN.linear}onUpdate(t,e){if(0===this.startTime&&(this.startTime=e),this.goingBack){// going back (only if goBack == true)
let t=this.interpolation(e,this.startTime,this.duration);this.applyAnim(t,!0),t>=1&&(++this.currentLoop!==this.loops?(this.goingBack=!this.goingBack,this.startTime=e):this.finish())}else{// going forward
let t=this.interpolation(e,this.startTime,this.duration);this.applyAnim(t,!1),t>=1&&(this.goBack?(this.goingBack=!0,this.startTime=e):this.finish())}}applyAnim(t,e){// override in child classes
}}class wB extends wF{// TODO move into props object
constructor(t,e,i,r,n,s=!1,o=1){super(n,s,o),this.srcPosX=0,this.srcPosY=0,this.targetPosX=0,this.targetPosY=0,this.srcPosX=t,this.srcPosY=e,this.targetPosX=i,this.targetPosY=r}onInit(){super.onInit(),this.owner.position.x=this.srcPosX,this.owner.position.y=this.srcPosY}applyAnim(t,e){e?(this.owner.position.x=this.targetPosX+t*(this.srcPosX-this.targetPosX),this.owner.position.y=this.targetPosY+t*(this.srcPosY-this.targetPosY)):(this.owner.position.x=this.srcPosX+t*(this.targetPosX-this.srcPosX),this.owner.position.y=this.srcPosY+t*(this.targetPosY-this.srcPosY))}}class wU extends wF{// TODO move into props object
constructor(t,e,i,r=!1,n=1){super(i,r,n),this.srcRot=0,this.targetRot=0,this.srcRot=t,this.targetRot=e}onInit(){super.onInit(),this.owner.rotation=this.srcRot}applyAnim(t,e){e?this.owner.rotation=this.targetRot+t*(this.srcRot-this.targetRot):this.owner.rotation=this.srcRot+t*(this.targetRot-this.srcRot)}}/* eslint-disable no-use-before-define */let wG=[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]];const wk="velocity",wH="acceleration";class wz extends hi{constructor(t=1,e=new hD(0,0)){super(),this.gameSpeed=t,this.initialVelocity=e}onInit(){super.onInit(),this.owner.assignAttribute(wk,this.initialVelocity),this.owner.assignAttribute(wH,new hD(0,0))}get velocity(){return this.owner.getAttribute(wk)}set velocity(t){this.owner.assignAttribute(wk,t)}get acceleration(){return this.owner.getAttribute(wH)}set acceleration(t){this.owner.assignAttribute(wH,t)}onUpdate(t,e){// update dynamics and set new position
let i=this.calcForce(t);if(null==i)return;// algorithm has finished
this.acceleration=i,// limit acceleration and velocity
this.acceleration=this.acceleration.limit(30),this.velocity=this.velocity.limit(30),this.applyVelocity(t,this.gameSpeed),this.applyPosition(t,this.gameSpeed);// change rotation based on the velocity
let r=Math.atan2(this.velocity.y,this.velocity.x);this.owner.rotation=r+Math.PI/2}applyVelocity(t,e){this.velocity=this.velocity.add(this.acceleration.multiply(.001*t*e))}applyPosition(t,e){let i=this.velocity.multiply(.001*t*e);this.owner.position.x+=i.x,this.owner.position.y+=i.y}}class wj extends wz{constructor(t,e,i,r){super(10,new hD(1,1)),this.wanderTarget=new hD(0,0),this.angle=0,this.game=t,this.wanderDistance=e,this.wanderRadius=i,this.wanderJittering=r}calcForce(t){let e=TA.wander(this.velocity,this.wanderTarget,this.wanderRadius,this.wanderDistance,this.wanderJittering,t);this.wanderTarget=e[1];let i=this.owner.getBounds(),r=this.game.worldToMap(i.x+i.width/2,i.y+i.height/2),n=this.owner.getAttribute(wk),s=n.normalize(),o=r.add(s),a=new hD(Math.round(o.x),Math.round(o.y));// simple collision avoidance by using repulsive forces
if(this.game.grid.notInside(a)||this.game.grid.hasObstruction(a)){// repulsive force
let t=a.x!==r.x&&a.y!==r.y,e=a.y===r.y,i=a.x===r.x,s=Math.random()*n.magnitudeSquared();t?this.wanderTarget=new hD(-(10*n.x)+s,-(10*n.y)+s):e?this.wanderTarget=new hD(-(10*n.x)+s,10*n.y+s):i&&(this.wanderTarget=new hD(10*n.x+s,-(10*n.y)+s))}return e[0];// no repulsive force
}}class wV extends hi{onInit(){this.texture=this.owner.asSprite().texture,// no animation
this.texture.frame=new iU(0,64,32,32)}onUpdate(t,e){1>this.owner.getAttribute(wk).magnitude()?this.texture.frame=new iU(0,64,32,32):(this.currentFrame=(this.currentFrame+1)%3,// switch animation
this.texture.frame=new iU(32*(this.currentFrame+1),64,32,32))}constructor(...t){super(...t),this.changeFrequency=10,this.lastSwitchTime=0,this.currentFrame=0}}class wX extends hi{constructor(t,e,i){super(),this.fieldOfView=60,this.coneColor=i,this.bot=e,this.game=t}checkPosition(t){let e=this.game.worldToMap(Math.floor(t.x),Math.floor(t.y));return!(this.game.grid.notInside(e)||this.game.grid.hasObstruction(e))}onUpdate(t,e){let i=new hD(this.bot.position.x,this.bot.position.y),r=this.bot.getAttribute(wk).normalize(),n=this.owner.asGraphics();n.clear(),n.beginFill(this.coneColor,.2);let s=this.fieldOfView/180*Math.PI,o=Math.ceil(2*Math.max(this.game.grid.width,this.game.grid.height)/(Math.PI/2)*s),a=this.game.mapCellSize/8;a=32;let h=new Set;for(let t=0;t<o;t++){let e=s/2-s*(t/o),l=Math.cos(e)*r.x-Math.sin(e)*r.y,u=Math.sin(e)*r.x+Math.cos(e)*r.y,c=new hD(l,u),d=i,p=0;for(;p++<50;){let t=this.game.worldToMap(Math.floor(d.x),Math.floor(d.y));if(!this.game.grid.notInside(t)&&!this.game.grid.hasObstruction(t)){if(!h.has(this.game.grid.indexMapper(t))){let e=this.game.mapToWorld(t.x,t.y);n.drawRect(e.x,e.y,this.game.mapCellSize,this.game.mapCellSize),h.add(this.game.grid.indexMapper(t))}let e=c.multiply(a);d=d.add(new hD(e.x,e.y))}}}n.endFill()}}const wW=()=>[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],wY=(t,e,i,r)=>{let n=1/Math.tan(.5*e),s=wW();return s[0][0]=t*n,s[1][1]=n,s[2][2]=r/(r-i),s[3][2]=-r*i/(r-i),s[2][3]=1,s[3][3]=0,s},wq=t=>{let e=wW();return e[0][0]=1,e[1][1]=Math.cos(.5*t),e[1][2]=Math.sin(.5*t),e[2][1]=-Math.sin(.5*t),e[2][2]=Math.cos(.5*t),e[3][3]=1,e},wK=t=>{let e=wW();return e[0][0]=Math.cos(t),e[0][1]=Math.sin(t),e[1][0]=-Math.sin(t),e[1][1]=Math.cos(t),e[2][2]=1,e[3][3]=1,e},wJ=()=>({tris:[// south
    [{x:0,y:0,z:0},{x:0,y:1,z:0},{x:1,y:1,z:0}],[{x:0,y:0,z:0},{x:1,y:1,z:0},{x:1,y:0,z:0}],// east
    [{x:1,y:0,z:0},{x:1,y:1,z:0},{x:1,y:1,z:1}],[{x:1,y:0,z:0},{x:1,y:1,z:1},{x:1,y:0,z:1}],// north
    [{x:1,y:0,z:1},{x:1,y:1,z:1},{x:0,y:1,z:1}],[{x:1,y:0,z:1},{x:0,y:1,z:1},{x:0,y:0,z:1}],// west
    [{x:0,y:0,z:1},{x:0,y:1,z:1},{x:0,y:1,z:0}],[{x:0,y:0,z:1},{x:0,y:1,z:0},{x:0,y:0,z:0}],// top
    [{x:0,y:1,z:0},{x:0,y:1,z:1},{x:1,y:1,z:1}],[{x:0,y:1,z:0},{x:1,y:1,z:1},{x:1,y:1,z:0}],// bottom
    [{x:1,y:0,z:1},{x:0,y:0,z:1},{x:0,y:0,z:0}],[{x:1,y:0,z:1},{x:0,y:0,z:0},{x:1,y:0,z:0}]]}),wZ=(t,e)=>{let i={x:0,y:0,z:0};i.x=t.x*e[0][0]+t.y*e[1][0]+t.z*e[2][0]+e[3][0],i.y=t.x*e[0][1]+t.y*e[1][1]+t.z*e[2][1]+e[3][1],i.z=t.x*e[0][2]+t.y*e[1][2]+t.z*e[2][2]+e[3][2];// perspective distortion
let r=t.x*e[0][3]+t.y*e[1][3]+t.z*e[2][3]+e[3][3];return 0!==r&&(i.x/=r,i.y/=r,i.z/=r),i},w$=(t,e)=>{let i=[wZ(t[0],e),wZ(t[1],e),wZ(t[2],e)];return i};(g=te||(te={})).DYNAMICS="DYNAMICS",g.GAME_MODEL="GAME_MODEL",g.FACTORY="FACTORY",g.BOT_MODEL="BOT_MODEL",(y=ti||(ti={}))[y.IDLE=0]="IDLE",y[y.GOING_TO_LOAD=1]="GOING_TO_LOAD",y[y.GOING_TO_UNLOAD=2]="GOING_TO_UNLOAD",y[y.LOADING=3]="LOADING",y[y.UNLOADING=4]="UNLOADING",(_=tr||(tr={}))[_.RED=1]="RED",_[_.BLUE=2]="BLUE",(v=tn||(tn={}))[v.NONE=0]="NONE",v[v.ORE=1]="ORE",v[v.PETROL=2]="PETROL",(ts||(ts={})).TEXTURE="TEXTURE",(x=to||(to={}))[x.PATH=0]="PATH",x[x.WALL=1]="WALL",x[x.WAREHOUSE=2]="WAREHOUSE",x[x.ORE=3]="ORE",x[x.PETROL=4]="PETROL",x[x.FACTORY=5]="FACTORY";class wQ extends hi{onInit(){this.model=this.scene.getGlobalAttribute(te.GAME_MODEL),this.factory=this.scene.getGlobalAttribute(te.FACTORY)}}class w0{constructor(t=new hD(0,0),e=new hD(0,0)){this.velocity=t,this.aceleration=e}applyVelocity(t,e){this.velocity=this.velocity.add(this.aceleration.multiply(.001*t*e))}calcPositionChange(t,e){return this.velocity.multiply(.001*t*e)}}class w1 extends hi{constructor(t,e=1){super(),this.attrName=t,this.gameSpeed=e}onInit(){this.dynamics=this.owner.getAttribute(this.attrName),null==this.dynamics&&(// add an initial one
this.dynamics=new w0,this.owner.assignAttribute(this.attrName,this.dynamics))}onUpdate(t,e){this.dynamics.applyVelocity(t,this.gameSpeed);// calculate delta position
let i=this.dynamics.calcPositionChange(t,this.gameSpeed);this.owner.pixiObj.position.x+=i.x,this.owner.pixiObj.position.y+=i.y}}class w2{constructor(){this.x=0// left offset
,this.y=0// top offset
,this.type=0// map type
,this.state=0}}class w3{getBlock(t,e){return this.blocks.get(e*this.width+t)}setBlock(t,e,i){this.blocks.set(e*this.width+t,i)}/**
	* Initializes grid map for pathfinding
	*/initGridMap(){for(let[,t]of(this.gridMap=new TM(this.type,10,this.width,this.height),this.blocks))t.type===to.WALL&&this.gridMap.addObstruction(new hD(t.x,t.y))}/*
		* Finds nearest map block by type
		*/findNearestMapBlock(t,e){let i,r=this.findAllMapBlocks(e),n=1e6;for(let e of r){let r=t.manhattanDistance(new hD(e.x,e.y));r<n&&(i=e,n=r)}return i}/**
		* Finds all map blocks by given type
		*/findAllMapBlocks(t){let e=[];for(let[,i]of this.blocks)i.type===t&&e.push(i);return e}/**
		* Transforms map-location into world-location
		*/mapBlockToLocation(t,e){return new hD(128*t,128*e)}/**
		* Transforms list of map-locations into list of world-locations
		*/mapBlockToLocations(t){let e=[];for(let i of t)e.push(this.mapBlockToLocation(i.x,i.y));return e}/**
		* Transforms world-location into map-location
		*/locationToMapBlock(t){let e=Math.floor(t.x),i=Math.floor(t.y);return new hD(Math.floor(e/128),Math.floor(i/128))}getDirection(t,e){return t.x+1===e.x&&t.y===e.y?1:t.x===e.x&&t.y+1===e.y?4:t.x-1===e.x&&t.y===e.y?2:t.x===e.x&&t.y-1===e.y?3:void 0}/**
		* Finds a path between two points
		* @param start start point
		* @param goal target point
		* @param outputPath output entity that will contain found path
		* @param directionPath output entity that will contain changes in direction
		*/findPath(t,e,i,r){let n=new Tx;this.astar.search(this.gridMap,t,e,n);let s=n.pathFound,o=new hD(-1),a=new hD(-1),h=0;// use only direction changes
for(let t of s){// add the last one
if(i.push(t),++h===s.length){r[r.length-1].equals(a)||r.push(a),r.push(t);continue}if(-1===o.x){o=t,r.push(t);continue}if(-1===a.x){a=t,r.push(t);continue}this.getDirection(o,a)===this.getDirection(a,t)||r[r.length-1].equals(a)||r.push(a),o=a,a=t}}constructor(){// all map blocks, mapped by their indices
this.blocks=new Map,this.astar=new TS,// size of the map
this.width=0,this.height=0,this.type=1}}class w5{constructor(){// current amount of ore
this.ironOre=60,// current amount of petrol
this.petrol=40,// how much iron does one agent take
this.agentIronCost=30,// how much petrol does one agent take
this.agentPetrolCost=10,// warehouse position
this.position=new hD(0)}}class w4{constructor(){this.position=new hD(0)}}class w6{constructor(t,e,i){this.type=t,this.position=e,this.currentAmount=i}get exhausted(){return this.currentAmount<=0}}class w8{get isLoaded(){return 0!==this.amount&&this.currentState!==ti.LOADING}constructor(){this.currentState=ti.IDLE,this.currentCargo=tn.NONE,// loaded amount of cargo
this.amount=0,// max capacity of cargo
this.capacity=10,// max speed
this.speed=0}}class w7{constructor(){this.warehouseModel=new w5,this.factoryModel=new w4,/**
	 * 0: passable path
	 * 1: wall
	 * 2: warehouse
	 * 3: iron ore
	 * 4: petrol
	 */this.mapData=[[0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,4],[0,3,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,2,0,5,0,0,0,0,0,1,0,0,0,0,4],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0],[1,1,0,0,0,0,1,4,1,0,0,0,1,0,0,0,1,0],[3,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0],[0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1],[0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,3],[0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,3],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,3]],this._botsNum=0// number of agents in total
,this._goingToLoadOre=0// number of agents going to load ore
,this._goingToLoadPetrol=0// numbe of agents going to load petrol
,this._cargoSources=new Map,this._bots=[],// initialize all structures from mapData
this.map=new w3,this.map.width=this.mapData[0].length,this.map.height=this.mapData.length;for(let t=0;t<this.map.width;t++)for(let e=0;e<this.map.height;e++){let i=this.mapData[e][t],r=new w2;if(r.x=t,r.y=e,r.type=i,i===to.WAREHOUSE)this.warehouseModel.position=new hD(t,e);else if(i===to.FACTORY)this.factoryModel.position=new hD(t,e);else if(i===to.ORE){let i=Math.floor(20+50*Math.random());this._cargoSources.set(e*this.map.width+t,new w6(tn.ORE,new hD(t,e),i))}else if(i===to.PETROL){let i=Math.floor(20+50*Math.random());this._cargoSources.set(e*this.map.width+t,new w6(tn.PETROL,new hD(t,e),i))}this.map.setBlock(t,e,r)}// init grid in order to be able to search via AStar algorithm
this.map.initGridMap()}get botsNum(){return this._botsNum}get goingToLoadOre(){return this._goingToLoadOre}get goingToLoadPetrol(){return this._goingToLoadPetrol}get allBots(){return this._bots}getCargoSourcesByType(t,e=!1){let i=[];for(let[,r]of this._cargoSources)r.type===t&&(e||!r.exhausted)&&i.push(r);return i}getCargoSourceAtLocation(t){let e=this.map.gridMap.indexMapper(t);return this._cargoSources.has(e)?this._cargoSources.get(e):null}loadCargo(t,e){e.currentCargo=t.type;let i=Math.min(t.currentAmount,e.capacity);e.amount=i,t.currentAmount-=i,e.currentCargo=t.type,t.type===tn.ORE?this._goingToLoadOre--:t.type===tn.PETROL&&this._goingToLoadPetrol--}unloadCargo(t){t.currentCargo===tn.ORE?this.warehouseModel.ironOre+=t.amount:t.currentCargo===tn.PETROL&&(this.warehouseModel.petrol+=t.amount),t.amount=0}notifyGoingToLoad(t,e){t.type===tn.ORE?this._goingToLoadOre++:t.type===tn.PETROL&&this._goingToLoadPetrol++}addBot(t){this._bots.push(t),this._botsNum++}}class w9 extends hi{onInit(){this.model=this.scene.getGlobalAttribute(te.GAME_MODEL),this.owner.asText().style=new oH({fill:"0xcf4512",fontWeight:"bold",fontSize:"62pt"})}onUpdate(t,e){this.owner.asText().text="IRON: "+this.model.warehouseModel.ironOre+" \nPETROL: "+this.model.warehouseModel.petrol+"\nBOTS:"+this.model.botsNum}}/**
 * Base class for all steering components
 */class St extends w1{onUpdate(t,e){// update dynamics and set new position
let i=this.calcForce(t);if(null==i)return;this.dynamics.aceleration=i,this.dynamics.aceleration=this.dynamics.aceleration.limit(30),this.dynamics.velocity=this.dynamics.velocity.limit(30),super.onUpdate(t,e);// change rotation based on the velocity
let r=Math.atan2(this.dynamics.velocity.y,this.dynamics.velocity.x),n=this.owner.rotation,s=r+Math.PI/2;s+2*Math.PI-n<n-s&&(s+=2*Math.PI),.1>Math.abs(n-s)||(this.owner.rotation=n+.2*Math.sign(s-n))}}/**
 * Component for Follow
 */class Se extends St{constructor(t,e,i,r,n){super(te.DYNAMICS,30),this.pointTolerance=20,this.finalPointTolerance=3,this.maxVelocity=8,this.slowingRadius=30,this.pathFinished=!1,this.path=t,this.pointTolerance=e,this.finalPointTolerance=i,this.maxVelocity=r,this.slowingRadius=n,this.context=new Ti}calcForce(t){let e=new hD(this.owner.position.x,this.owner.position.y),i=TA.follow(e,this.dynamics.velocity,this.path,this.context,this.pointTolerance,this.finalPointTolerance,this.maxVelocity,this.slowingRadius);return this.pathFinished=null==i,i}resetPath(t){this.pathFinished=!1,this.path=t,this.context.currentPointIndex=-1}}class Si extends Se{constructor(){super(new Tn,15,15,5,3),this._name="BotMove"}onInit(){this.gameModel=this.scene.getGlobalAttribute(te.GAME_MODEL),this.botModel=this.owner.getAttribute(te.BOT_MODEL),this.gameSpeed=this.botModel.speed,super.onInit()}onUpdate(t,e){!this.pathFinished&&this.path.segments.length>2?super.onUpdate(t,e):(this.dynamics.aceleration=new hD(0,0),this.dynamics.velocity=new hD(0,0))}goToPoint(t,e,i){let r=[];// 1) find path from start to goal
this.gameModel.map.findPath(t,i,r,[]);// 2) transform path from map-coords into world-coords
let n=this.gameModel.map.mapBlockToLocations(r);// set all points to the center of each block
for(let t=0;t<n.length;t++){let e=n[t];n[t]=new hD(e.x+64,e.y+64)}// 3) add segments into followPath object
this.path.addFirstSegment(n[0],n[1]);for(let t=2;t<n.length;t++)this.path.addSegment(n[t]);// 4) start followBehavior
this.resetPath(this.path)}}class Sr extends hi{onInit(){this.texture=this.owner.asSprite().texture,this.owner.getAttribute(te.BOT_MODEL).agentType===tr.BLUE?this.texture.frame=new iU(0,0,128,128):this.texture.frame=new iU(0,128,128,128)}onUpdate(t,e){let i=this.owner.getAttribute(te.BOT_MODEL);if(1>this.owner.getAttribute(te.DYNAMICS).velocity.magnitude())// no animation
i.agentType===tr.BLUE?this.texture.frame=new iU(0,0,128,128):this.texture.frame=new iU(0,128,128,128);else if(this.checkTime(this.lastSwitchTime,e,this.changeFrequency)){let t=this.texture.frame.x/128;0==(t=(t+1)%4)&&(t=1),i.agentType===tr.BLUE?this.texture.frame=new iU(128*t,0,128,128):this.texture.frame=new iU(128*t,128,128,128)}}checkTime(t,e,i){return e-t>1e3/i}constructor(...t){super(...t),this.changeFrequency=10,this.lastSwitchTime=0}}class Sn extends hi{onInit(){this.gameModel=this.scene.getGlobalAttribute(te.GAME_MODEL),this.botModel=this.owner.getAttribute(te.BOT_MODEL),this.moveComponent=this.owner.findComponentByName("BotMove")}onUpdate(t,e){let i=this.botModel.currentState,r=i!==this.lastState;switch(i){case ti.IDLE:i=this.processIdleState(r,t,e);break;case ti.GOING_TO_UNLOAD:i=this.processGoingToUnloadState(r,t,e);break;case ti.GOING_TO_LOAD:i=this.processGoingToLoadState(r,t,e);break;case ti.LOADING:i=this.processLoadingState(r,t,e);break;case ti.UNLOADING:i=this.processUnloadingState(r,t,e)}this.lastState=this.botModel.currentState,// update current state
this.botModel.currentState=i}processIdleState(t,e,i){return(// check botModel.isLoaded to assign a goal
this.botModel.isLoaded?ti.GOING_TO_UNLOAD:ti.GOING_TO_LOAD)}processGoingToLoadState(t,e,i){return(// check moveComponent.pathFinished - if true, the bot has finished the movement
this.botModel.isLoaded?ti.GOING_TO_UNLOAD:t?(this.goLoad(),ti.GOING_TO_LOAD):this.arrivedToTarget?ti.LOADING:ti.GOING_TO_LOAD)}processGoingToUnloadState(t,e,i){return(// check moveComponent.pathFinished - if true, the bot has finished the movement
this.botModel.isLoaded?t?(this.goUnload(),ti.GOING_TO_UNLOAD):this.arrivedToTarget?ti.UNLOADING:ti.GOING_TO_UNLOAD:ti.GOING_TO_LOAD)}processLoadingState(t,e,i){return this.currentLoadingTime>this.loadingDelay?(this.currentLoadingTime=0,this.currentTarget&&this.gameModel.loadCargo(this.currentTarget,this.botModel),ti.IDLE):(this.currentLoadingTime+=e,ti.LOADING)}processUnloadingState(t,e,i){return this.currentLoadingTime>this.loadingDelay?(this.currentLoadingTime=0,this.gameModel.unloadCargo(this.botModel),this.currentTarget=null,ti.IDLE):(this.currentLoadingTime+=e,ti.UNLOADING)}// ============================================================================
/**
		* Selects a random loading target and executes follow behavior
		*/goLoad(){let t=this.gameModel.getCargoSourcesByType(tn.ORE),e=this.gameModel.getCargoSourcesByType(tn.PETROL),i=this.gameModel.warehouseModel.petrol,r=this.gameModel.warehouseModel.ironOre;i+this.gameModel.goingToLoadPetrol*this.botModel.capacity>r+this.gameModel.goingToLoadOre*this.botModel.capacity?this.currentTarget=t[Math.floor(Math.random()*t.length)]:this.currentTarget=e[Math.floor(Math.random()*e.length)],this.currentTarget&&(// notify others and move to the location
this.gameModel.notifyGoingToLoad(this.currentTarget,this.botModel),this.moveToTarget(this.currentTarget.position))}/**
		* Selects an unloading target and executes follow behavior
		*/goUnload(){let t=this.gameModel.warehouseModel.position;this.moveToTarget(new hD(t.x,t.y))}get arrivedToTarget(){return this.moveComponent.pathFinished}get isBotLoaded(){return this.botModel.isLoaded}moveToTarget(t){let e=new hD(this.owner.position.x,this.owner.position.y),i=this.worldToMap(e);this.moveComponent.goToPoint(i,e,t)}worldToMap(t){return this.gameModel.map.locationToMapBlock(t)}constructor(...t){super(...t),this.lastState=ti.IDLE,// un/loading time in ms
this.currentLoadingTime=0,// how long does it take to load a cargo
this.loadingDelay=3e3}}class Ss extends hi{constructor(t){super(),this.currentProgress=t}onUpdate(t,e){let i=this.currentProgress();if(i<=0)this.owner.visible=!1;else{this.owner.visible=!0;let t=this.owner.asGraphics();t.clear(),t.beginFill(0,.8),t.drawRect(0,0,this.owner.parent.width,20),t.beginFill(2080283),t.drawRect(2,2,i*(this.owner.parent.width-4),16),t.endFill()}}}class So extends hi{onInit(){this.model=this.scene.getGlobalAttribute(te.GAME_MODEL),this.factory=this.scene.getGlobalAttribute(te.FACTORY)}onUpdate(t,e){if(this.isBuilding){if(// continoue with building procedure
this.currentBuildTime+=t,this.currentBuildTime>=this.buildDelay){// spawn a new agent
this.currentBuildTime=0,this.isBuilding=!1,this.model.warehouseModel.ironOre-=this.model.warehouseModel.agentIronCost,this.model.warehouseModel.petrol-=this.model.warehouseModel.agentPetrolCost;let t=this.factory.createBot(this.scene.stage,this.model,this.model.factoryModel.position);this.model.addBot(t)}}else this.model.warehouseModel.ironOre>=this.model.warehouseModel.agentIronCost&&this.model.warehouseModel.petrol>=this.model.warehouseModel.agentPetrolCost&&(this.isBuilding=!0)}constructor(...t){super(...t),// indicator whether the warehouse is building any agent
this.isBuilding=!0,// building time of current agent
this.currentBuildTime=6e3,// bot building time in ms
this.buildDelay=7e3}}class Sa extends hi{constructor(t){super(),this.model=t}onInit(){this.gameModel=this.scene.getGlobalAttribute(te.GAME_MODEL),// inject graphics renderer
this.renderer=new hE("",""),this.renderer.style=new oH({fill:"0x000000",fontWeight:"bold",fontSize:"30pt"}),this.owner.addChild(this.renderer)}onUpdate(t,e){// draw status
this.renderer.text=`${this.model.currentAmount}`,this.owner.alpha=this.model.currentAmount>20?1:this.model.currentAmount>0?.5:.1}}class Sh{initializeGame(t,e){t.assignAttribute(te.GAME_MODEL,e),t.assignAttribute(te.FACTORY,this),t.asContainer().scale.set(4.7/e.map.height);let i=new rH(rS.from(ts.TEXTURE));// add sprites
for(let r=0;r<e.map.width;r++)for(let n=0;n<e.map.height;n++){let s,o=e.map.getBlock(r,n).type;// transform block index to sprite index
switch(o){case to.PATH:s=new iU(0,256,128,128);break;case to.WALL:s=new iU(128,256,128,128);break;case to.WAREHOUSE:s=new iU(256,256,128,128);break;case to.ORE:s=new iU(384,256,128,128);break;case to.PETROL:s=new iU(0,384,128,128);break;case to.FACTORY:s=new iU(384,384,128,128);break;default:throw Error("Undefined block type")}let a=i.clone();a.frame=s;let h=new hb("",a);if(h.position.set(128*r,128*n),t.addChild(h),o===to.ORE||o===to.PETROL)h.addComponent(new Sa(e.getCargoSourceAtLocation(new hD(r,n))));else if(o===to.WAREHOUSE)h.addComponent(new wQ);else if(o===to.FACTORY){let t=new So;h.addComponent(t);let e=new hy("factory_progress");e.addComponent(new Ss(()=>1*t.currentBuildTime/t.buildDelay)),h.addChild(e)}}// place the status next to the map
new hR(t.scene).relativePos(1,0).anchor(1,0).withComponent(new w9).withParent(t).asText("").build()}createBot(t,e,i){let r=tr.BLUE,n=new rH(rS.from(ts.TEXTURE)).clone(),s=new hb("Bot",n);t.addChild(s);// create movement attribute for dynamics
let o=new w0;s.assignAttribute(te.DYNAMICS,o);// create model with random speed
let a=new w8;a.speed=30*Math.random()+15,a.agentType=r,s.assignAttribute(te.BOT_MODEL,a),s.addComponent(new w1(te.DYNAMICS)),s.addComponent(new Si),s.addComponent(new Sr),s.addComponent(new Sn),s.anchor.set(.5);let h=e.map.mapBlockToLocation(i.x+.5,i.y+.5);return(// place the agent next to the warehouse
s.position.set(h.x,h.y),a)}}const Sl=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,1],[1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,1],[1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,1],[1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1],[1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],Su="velocity",Sc="acceleration",Sd="scene_model",Sp="bot_model";class Sf{constructor(t){this.bots=[],this.map=t}/**
 * Transforms map coordinates into world coordinates
 */mapToWorld(t,e){return new hD(32*t,32*e)}/**
	 * Transforms world coordinates into map coordinates
	 */worldToMap(t,e){return new hD(Math.floor(t/32),Math.floor(e/32))}}class Sm extends hi{constructor(t=1,e=new hD(0,0)){super(),this.gameSpeed=t,this.initialVelocity=e}onInit(){super.onInit(),this.owner.assignAttribute(Su,this.initialVelocity),this.owner.assignAttribute(Sc,new hD(0,0)),this.sceneModel=this.scene.getGlobalAttribute(Sd)}get velocity(){return this.owner.getAttribute(Su)}set velocity(t){this.owner.assignAttribute(Su,t)}get acceleration(){return this.owner.getAttribute(Sc)}set acceleration(t){this.owner.assignAttribute(Sc,t)}onUpdate(t,e){// update dynamics and set new position
let i=this.calcForce(t);if(null==i){this.finish();return}this.acceleration=i,// limit acceleration and velocity
this.acceleration=this.acceleration.limit(30),this.velocity=this.velocity.limit(30),this.applyVelocity(t,this.gameSpeed),this.applyPosition(t,this.gameSpeed);// change rotation based on the velocity
let r=Math.atan2(this.velocity.y,this.velocity.x);this.owner.rotation=r+Math.PI/2}applyVelocity(t,e){this.velocity=this.velocity.add(this.acceleration.multiply(.001*t*e))}applyPosition(t,e){let i=this.velocity.multiply(.001*t*e);this.owner.position.x+=i.x,this.owner.position.y+=i.y}}class Sg extends Sm{constructor(t,e,i){super(10,new hD(1,1)),this.wanderTarget=new hD(0,0),this.angle=0,this.wanderDistance=t,this.wanderRadius=e,this.wanderJittering=i}calcForce(t){let e=TA.wander(this.velocity,this.wanderTarget,this.wanderRadius,this.wanderDistance,this.wanderJittering,t);this.wanderTarget=e[1];let i=this.owner.getBounds(),r=this.sceneModel.worldToMap(i.x+i.width/2,i.y+i.height/2),n=this.owner.getAttribute(Su),s=n.normalize(),o=r.add(s),a=new hD(Math.round(o.x),Math.round(o.y));// simple collision avoidance by using repulsive forces
if(this.sceneModel.map.notInside(a)||this.sceneModel.map.hasObstruction(a)){// repulsive force
let t=a.x!==r.x&&a.y!==r.y,e=a.y===r.y,i=a.x===r.x,s=Math.random()*n.magnitudeSquared();t?this.wanderTarget=new hD(-(10*n.x)+s,-(10*n.y)+s):e?this.wanderTarget=new hD(-(10*n.x)+s,10*n.y+s):i&&(this.wanderTarget=new hD(10*n.x+s,-(10*n.y)+s))}return e[0];// no repulsive force
}}class Sy extends Sm{constructor(t,e){super(10,t),this.target=e}calcForce(t){let e=TA.seek(this.target,new hD(this.owner.position.x,this.owner.position.y),this.velocity,20,64);return 1e-4>e.magnitudeSquared()?null:e}}class S_ extends Sm{constructor(){super(20,new hD(10,0))}calcForce(t){let e=this.scene.getGlobalAttribute("key_input"),i=new hD(0);e.isKeyPressed(b7.KEY_LEFT)&&(i=i.add(TA.seek(new hD(-1,0),new hD(0,0),this.velocity,200,16))),e.isKeyPressed(b7.KEY_RIGHT)&&(i=i.add(TA.seek(new hD(1,0),new hD(0,0),this.velocity,200,16))),e.isKeyPressed(b7.KEY_UP)&&(i=i.add(TA.seek(new hD(0,-1),new hD(0,0),this.velocity,200,16))),e.isKeyPressed(b7.KEY_DOWN)&&(i=i.add(TA.seek(new hD(0,1),new hD(0,0),this.velocity,200,16)));let r=this.owner.getBounds(),n=this.sceneModel.worldToMap(r.x+r.width/2,r.y+r.height/2),s=this.velocity.normalize(),o=n.add(s.multiply(.75)),a=new hD(Math.round(o.x),Math.round(o.y));return(// collision avoidance - stop if the force has the same direction as velocity
(this.sceneModel.map.notInside(a)||this.sceneModel.map.hasObstruction(a))&&(0===i.magnitudeSquared()||s.dot(i.normalize())>=0)?new hD(-this.velocity.x,-this.velocity.y):i)}}class Sv extends Sm{constructor(t,e,i){super(15),this.pointTolerance=20,this.finalPointTolerance=3,this.maxVelocity=15,this.slowingRadius=10,this.pathFinished=!1,this.path=new Tn,this.context=new Ti,this.map=t,this.fromPos=e,this.toPos=i}onInit(){super.onInit(),this.goToPoint(this.fromPos,this.toPos)}onUpdate(t,e){this.pathFinished?(this.acceleration=new hD(0,0),this.velocity=new hD(0,0),this.finish()):super.onUpdate(t,e)}getDirection(t,e){return t.x+1===e.x&&t.y===e.y?1:t.x===e.x&&t.y+1===e.y?4:t.x-1===e.x&&t.y===e.y?2:t.x===e.x&&t.y-1===e.y?3:void 0}goToPoint(t,e){let i=[];// 1) find path from start to goal
this.findPath(t,e,i,[]);// 2) transform path from map-coords into world-coords
let r=i.map(t=>this.sceneModel.mapToWorld(t.x,t.y).add(new hD(16,16)));// 3) add segments into followPath object
this.path.addFirstSegment(r[0],r[1]);for(let t=2;t<r.length;t++)this.path.addSegment(r[t]);// 4) start followBehavior
this.resetPath(this.path)}calcForce(t){let e=new hD(this.owner.position.x,this.owner.position.y),i=TA.follow(e,this.velocity,this.path,this.context,this.pointTolerance,this.finalPointTolerance,this.maxVelocity,this.slowingRadius);return this.pathFinished=null==i,i}resetPath(t){this.pathFinished=!1,this.path=t,this.context.currentPointIndex=-1}findPath(t,e,i,r){let n=new Tx,s=new TS;s.search(this.map,t,e,n);let o=n.pathFound,a=new hD(-1),h=new hD(-1),l=0;// use only direction changes
for(let t of o){// add the last one
if(i.push(t),++l===o.length){r[r.length-1].equals(h)||r.push(h),r.push(t);continue}if(-1===a.x){a=t,r.push(t);continue}if(-1===h.x){h=t,r.push(t);continue}this.getDirection(a,h)===this.getDirection(h,t)||r[r.length-1].equals(h)||r.push(h),a=h,h=t}}}class Sx{constructor(t,e){this.fieldOfView=60,// blocks the bot can see
this.visibleBlocks=new Set,this.searchingAttempt=0,this.map=t,this.particleMap=new TM(t.mapType,10,t.width,t.height),this.id=e}pursueBot(t){this.pursuedBot=t}isPursuing(){return void 0!==this.pursueBot}targetBotInSight(){let t=this.pursuedBot&&this.visibleBlocks.has(this.map.indexMapper(this.pursuedBot.position));return t&&(this.pursuedPosition=this.pursuedBot.position,this.particleMap.elevations.clear(),this.searchingAttempt=0),t}targetSpotInSight(){return this.visibleBlocks.has(this.map.indexMapper(this.pursuedPosition))}updateAttributes(t,e){this.position=t,this.direction=e}findNextHotSpot(){let t=this.particleMap.elevations.keys(),e=0,i=null;for(let r of t){let t=this.particleMap.vectorMapper(r),n=this.particleMap.getElevation(t);n>e&&(e=n,i=t)}return i}lookForBotsInSight(t){for(let e of t){let t=this.map.indexMapper(e.position);if(this.visibleBlocks.has(t))return e}}searchForBot(){this.searchingAttempt++,this.updateParticleFilter(this.pursuedPosition,10-Math.max(this.searchingAttempt,3),Math.max(2*this.searchingAttempt,6))}updateParticleFilter(t,e,i=3){// we will use the elevation attribute for particle weight
this.particleMap.setElevation(t,e);let r=(t,e,i,n)=>{if(0===i)return;let s=this.particleMap.getNeighbors(t);for(let t of s){let s=this.particleMap.indexMapper(t);// ignoring obstructions from the real map
this.map.hasObstruction(t)||e.has(s)||(e.add(s),this.particleMap.setElevation(t,i),i>n&&r(t,e,i-1,n))}};// always 3 iterations
r(t,new Set,e,e-i)}updateViewCone(){this.visibleBlocks.clear();let t=this.fieldOfView/180*Math.PI,e=Math.max(this.map.width,this.map.height),i=Math.ceil(2*e/(Math.PI/2)*t);// not very optimal algorithm - it iterates over every grid you can see within the radius of map size * 2 (diagonal is the maximum)
for(let r=0;r<i;r++){let n=t/2-t*(r/i),s=Math.cos(n)*this.direction.x-Math.sin(n)*this.direction.y,o=Math.sin(n)*this.direction.x+Math.cos(n)*this.direction.y,a=new hD(s,o),h=this.position,l=0;for(;l++<2*e;){let t=new hD(Math.round(h.x),Math.round(h.y));if(!this.map.notInside(t)&&!this.map.hasObstruction(t)){let e=this.map.indexMapper(t);this.visibleBlocks.has(e)||(this.visibleBlocks.add(e),// update particle filter -> blocks we can see at this moment can be removed
this.particleMap.setElevation(t,0)),h=h.add(new hD(a.x,a.y))}}}}}/* eslint-disable no-use-before-define */class Sb extends hi{onInit(){this.texture=this.owner.asSprite().texture,// no animation
this.texture.frame=new iU(0,64,32,32)}onUpdate(t,e){1>this.owner.getAttribute(Su).magnitude()?this.texture.frame=new iU(0,64,32,32):(this.currentFrame=(this.currentFrame+1)%3,// switch animation
this.texture.frame=new iU(32*(this.currentFrame+1),64,32,32))}constructor(...t){super(...t),this.changeFrequency=10,this.lastSwitchTime=0,this.currentFrame=0}}/* eslint-disable no-use-before-define */class SE extends hi{constructor(t,e){super(),this.coneColor=e,this.bot=t}onUpdate(t,e){let i=this.scene.getGlobalAttribute(Sd),r=this.bot.getAttribute(Sp),n=this.owner.asGraphics();for(let t of(n.clear(),r.targetBotInSight()?n.beginFill(16738338,.2):n.beginFill(this.coneColor,.2),r.visibleBlocks)){let e=i.map.vectorMapper(t),r=i.mapToWorld(e.x,e.y);n.drawRect(r.x,r.y,32,32)}n.endFill()}}/* eslint-disable no-use-before-define */class ST extends hi{onInit(){this.sceneModel=this.scene.getGlobalAttribute(Sd),this.botModel=this.owner.getAttribute(Sp),this.wander()}clearSteering(){this.currentSteering&&!this.currentSteering.isCompleted&&this.currentSteering.finish()}wander(){this.clearSteering(),this.currentSteering=new Sg(0,10,.1),this.owner.addComponent(this.currentSteering)}pursueBot(t){let e=this.scene.findObjectById(t.id),i=new hD(e.position.x,e.position.y);if(this.currentSteering&&this.currentSteering.name!==Sy.name&&this.clearSteering(),this.currentSteering&&this.currentSteering.name===Sy.name)this.currentSteering.target=i;else{let e=this.owner.getAttribute(Su);this.currentSteering=new Sy(e,i),this.owner.addComponent(this.currentSteering),this.botModel.pursueBot(t)}}checkSpot(t){this.currentSteering&&this.clearSteering(),this.currentSteering=new Sv(this.sceneModel.map,this.botModel.position,t),this.owner.addComponent(this.currentSteering),this.botModel.pursuedPosition=t}onUpdate(t,e){let i=this.owner.getAttribute(Su),r=i.normalize(),n=new hD(this.owner.position.x,this.owner.position.y),s=this.sceneModel.worldToMap(n.x,n.y);if(this.botModel.updateAttributes(s,r),this.botModel.updateViewCone(),this.botModel.pursuedBot){if(this.botModel.targetBotInSight())// update pursuing pos
this.isInSight=!0,this.pursueBot(this.botModel.pursuedBot);else if(this.isInSight&&this.botModel.searchForBot(),this.isInSight=!1,this.currentSteering.isCompleted||this.currentSteering.name!==Sg.name&&this.botModel.targetSpotInSight()){let t=this.botModel.findNextHotSpot();t?this.checkSpot(t):this.botModel.searchingAttempt<5?this.botModel.searchForBot():this.wander()}}else{// look for a bot to pursue
let t=this.botModel.lookForBotsInSight(this.sceneModel.bots.filter(t=>t.id!==this.botModel.id));t&&(this.isInSight=!0,this.pursueBot(t))}}constructor(...t){super(...t),this.isInSight=!1}}/* eslint-disable no-use-before-define */class Sw extends hi{onInit(){this.sceneModel=this.scene.getGlobalAttribute(Sd),this.botModel=this.owner.getAttribute(Sp)}onUpdate(t,e){let i=this.owner.getAttribute(Su).normalize(),r=new hD(this.owner.position.x,this.owner.position.y),n=this.sceneModel.worldToMap(r.x,r.y);this.botModel.updateAttributes(n,i),this.botModel.updateViewCone()}}/* eslint-disable no-use-before-define */class SS extends hi{constructor(t){super(),this.bot=t}onUpdate(t,e){let i=this.scene.getGlobalAttribute(Sd),r=this.bot.getAttribute(Sp),n=this.owner.asGraphics();for(let t of(n.clear(),r.particleMap.elevations.keys())){let e=r.particleMap.vectorMapper(t),s=r.particleMap.getElevation(e),o=i.mapToWorld(e.x,e.y);0!==s&&(s<1?n.beginFill(7185404,.2):s<3?n.beginFill(222207,.2):s<5?n.beginFill(16776140,.2):s<8?n.beginFill(14387511,.2):n.beginFill(14363192,.2),n.drawRect(o.x,o.y,32,32),n.endFill())}}}class SM{loadScene(t,e){let i=e[0].length,r=e.length,n=new TM(2,10,i,r);for(let t=0;t<r;t++)for(let e=0;e<i;e++)0!==Sl[t][e]&&n.addObstruction(new hD(e,t));let s=new Sf(n);// recreate view model
this.recreateMap(s,t);let o=new ha;t.addGlobalComponentAndRun(o),// todo fix this in ECSLite library
t.assignGlobalAttribute("key_input",o),t.assignGlobalAttribute(Sd,s),this.addBot(t,s,new hD(15,15),65280,!0),this.addBot(t,s,new hD(10,10),15459636,!1)}addBot(t,e,i,r,n){let s=new hb("",new rH(rS.from("pathfinding")));s.scale.set(1);let o=new Sx(e.map,s.id);if(s.assignAttribute(Sp,o),e.bots.push(o),n)s.addComponent(new S_),s.addComponent(new Sw);else{s.addComponent(new ST);let e=new hy("");e.addComponent(new SE(s,r)),t.stage.addChild(e);let i=new hy("");i.addComponent(new SS(s)),t.stage.addChild(i)}s.anchor.set(.5),s.addComponent(new Sb);let a=e.mapToWorld(i.x,i.y);s.position.set(a.x,a.y),t.stage.addChild(s)}/**
	 * Recreates view-model
	 */recreateMap(t,e){let i=new rH(rS.from("pathfinding"));e.clearScene();// create sprites
for(let r=0;r<t.map.width;r++)for(let n=0;n<t.map.height;n++){let s=i.clone(),o=new hb("",s),a=t.mapToWorld(r,n);o.position.set(a.x,a.y),o.scale.set(1),s.frame=this.getSpriteFrame(t,new hD(r,n)),e.stage.addChild(o)}}/**
	 * Sets sprite index according to the type of the block of the map
	 */getSpriteFrame(t,e){let i=t.map.getElevation(e);return t.map.hasObstruction(e)?new iU(32,0,32,32):1===i?new iU(0,0,32,32):void 0}}/**
 * Sprite for pixel-perfect hit test
 */class SA extends oB{constructor(t){super(t)}containsPoint(t){let e=new ij;// get global coordinates
this.worldTransform.applyInverse(t,e);// _texture is private
let i=this._texture.orig.width,r=this._texture.orig.height,n=-i*this.anchor.x,s=-r*this.anchor.y,o=!1;if(e.x>=n&&e.x<n+i&&e.y>=s&&e.y<s+r&&(o=!0),!o)return!1;// bitmap check
let a=this.texture,h=this.texture.baseTexture;if(!h.hitmap&&!this.genHitMap(h,127))return!0;let l=h.hitmap,u=h.resolution,c=Math.round((e.x-n+a.frame.x)*u)+Math.round((e.y-s+a.frame.y)*u)*h.hitmapWidth,d=c/32|0,p=c-32*d;return 31===p?(l[d]&1<<p)>0||(l[d]&1<<p-1)>0:(l[d]&1<<p)>0}genHitMap(t,e){if(!t.resource)return!1;let i=t.resource.source,r=null;if(!i)return!1;let n=null;if(i.getContext)n=(r=i).getContext("2d");else{if(!(i instanceof Image))return!1;(r=document.createElement("canvas")).width=i.width,r.height=i.height,(n=r.getContext("2d")).drawImage(i,0,0)}let s=r.width,o=r.height,a=n.getImageData(0,0,s,o),h=new Uint32Array(Math.ceil(s*o/32));// generate hitmap. For 320x320 the size will be sqrt(3200)xsqrt(3200) -> 56x56
for(let t=0;t<o;t++)for(let i=0;i<s;i++){let r=t*s+i,n=r/32|0,o=r-32*n;// cell number
a.data[4*r+3]>=e&&(h[n]|=1<<o);// set 0-31st bit
}return t.hitmap=h,t.hitmapWidth=s,!0}}class SR{constructor(t,e,i,r,n){this.name=t,this.blockWidth=e,this.blockHeight=i,this.chars=r,this.texture=n}getCharData(t){return this.chars.get(t)||this.chars.get("?")}getCharFrame(t){let e=this.getCharData(t),i=Math.floor(this.texture.width/this.blockWidth);return new iU(e.index%i*this.blockWidth+1,Math.floor(e.index/i)*this.blockHeight,e.width,e.height)}}class SC{parseFont(t,e){let i=new Map;for(let e of Object.keys(t.chars)){let r=t.chars[e];i.set(e,{offsetY:0,width:t.blockWidth,height:t.blockHeight,...r})}return new SR(t.name,t.blockWidth,t.blockHeight,i,e)}}class SP{constructor(t){this.props=t,this.dividedText=this.divideText(this.props.text,this.props.lineWidth,this.props.letterSpacing),this.rowsNum=this.dividedText.length,this.currentRow=-1,this.gotoNextLine()}canGetNextLetters(){// index is shifted by 1 -> 0 means that we are just before 0
return this.currentLineIndex<=this.currentLine.length}getNextLetters(t){if(this.canGetNextLetters()){let e=Math.min(t,this.currentLine.length+1-this.currentLineIndex),i=this.currentLine.substring(this.currentLineIndex-1,this.currentLineIndex+e-1);return this.currentLineIndex+=e,i}return null}canGotoNextLine(){return this.currentRow+this.props.visibleRows<this.rowsNum}gotoNextLine(){if(-1===this.currentRow||this.canGotoNextLine()){-1===this.currentRow?this.currentRow=0:this.currentRow+=this.props.visibleRows,this.currentLineIndex=0;let t=Math.max(this.props.visibleRows,this.currentRow+this.props.visibleRows-this.dividedText.length);return this.currentLine=this.dividedText.slice(this.currentRow,this.currentRow+t).join("\n"),!0}return!1}divideText(t,e,i){let r=[],n=t.split(" "),s=this.props.font.getCharData(" ").width,o="",a=0;// we need to get the width of each letter as it may vary
for(let t of n){// word.length - 1 because we consider letterspacing for a whitespace just below
let n=this.calcWordLength(t)+(t.length-1)*i;a+n>e&&(// append new line
r.push(o),o="",a=0),0===o.length?o+=t:o+=" "+t,a+=n+(s+i)}return(// append last line
r.push(o),r)}calcWordLength(t){let e=0;for(let i of t)e+=this.props.font.getCharData(i).width;return e}}(b=ta||(ta={})).FONT="font",b.FONT_TEXTURE="font_texture",b.DIALOG_TEXTURE="dialog_texture",b.MARKER_TEXTURE="marker_texture",(th||(th={})).FONT="font";class SI extends hi{onInit(){super.onInit(),this.state={currentOffsetX:0,currentRow:0,waitingForInput:!1},this.font=this.scene.getGlobalAttribute(th.FONT),this.fontTexture=rH.from(ta.FONT_TEXTURE),this.dialogTexture=rH.from(ta.DIALOG_TEXTURE),this.markerTexture=rH.from(ta.MARKER_TEXTURE),this.dialog=new hv("dialog_plane",this.dialogTexture,18,10,18,10),// cover whole scene
this.dialog.width=this.scene.width/this.scale,this.dialog.height=this.props.dialogHeight,this.dialog.position.y=this.scene.height-this.dialog.height*this.scale-5,this.dialog.scale.set(this.scale),this.scene.stage.addChild(this.dialog);let t=Math.floor((this.props.dialogHeight-2*this.textMargin)/this.font.blockHeight),e=this.scene.width/this.scale-2*this.textMargin;if(t<=0)throw Error("Dialog size doesn't allow to display any row");this.model=new SP({font:this.font,text:this.props.text,letterSpacing:this.letterSpacing,lineWidth:e,visibleRows:t})}onUpdate(){if(this.state.waitingForInput&&this.props.keyInput.isKeyPressed(b7.KEY_SPACE)&&(this.props.keyInput.handleKey(b7.KEY_SPACE),this.model.canGotoNextLine()?this.gotoNextLine():(// nothing more to display
this.dialog.destroy(),this.finish())),!this.state.waitingForInput){let t=this.model.getNextLetters(this.lettersPerFrame);this.displayNewLetters(t),this.model.canGetNextLetters()||this.updateState({waitingForInput:!0})}}displayNewLetters(t){for(let e of t){if("\n"===e){this.updateState({currentOffsetX:0,currentRow:this.state.currentRow+1});continue}let t=this.font.getCharData(e),i=this.fontTexture.clone(),r=new oB(i);r.position.x=this.textMargin+this.state.currentOffsetX,// +1 is for vertical spacing
r.position.y=this.textMargin+this.state.currentRow*(this.font.blockHeight+1)+t.offsetY,i.frame=this.font.getCharFrame(e),this.dialog.addChild(r),this.updateState({currentOffsetX:this.state.currentOffsetX+(t.width+this.letterSpacing)})}!this.model.canGetNextLetters()&&this.model.canGotoNextLine()&&this.displayMarker()}gotoNextLine(){this.model.gotoNextLine(),this.dialog.destroyChildren(),this.updateState({waitingForInput:!1,currentOffsetX:0,currentRow:0})}updateState(t){this.state={...this.state,...t}}displayMarker(){let t=new hb("marker",this.markerTexture.clone());t.position.x=this.textMargin+this.state.currentOffsetX+2,t.position.y=this.textMargin+this.state.currentRow*(this.font.blockHeight+1),this.dialog.addChild(t);let e=t.position.y;// add flickering animation
t.addComponent(new hO("animator").setFixedFrequency(10).doOnFixedUpdate(()=>{t.position.y=e+(t.position.y-e+1)%5}))}constructor(...t){super(...t),this.textMargin=10,this.letterSpacing=0,this.scale=4,this.lettersPerFrame=1}}/**
 * Mocked loader, that will load all files in parallel
 * The duration of the loading is the amount of MBs (1 MB/s)
 */class SO{constructor(t){this.data=t}add(t,e,i){let r=this.data.find(e=>e.alias===t);if(r)setTimeout(()=>i(),r.size/1024/1024*1e3);else throw Error("File not found in the array that was initialized with this object!")}}class SL{constructor(t,e){this.allLoaded=!1,this.progress=0,this.files=[],this.running=!1,this.loadedFiles=0,this.loadedAmount=0,this.totalAmount=0,this.loader=t,this.onComplete=e}add(t,e,i){if(this.running)throw Error("This loader is already running");this.files.push({alias:t,url:e,size:i})}/**
	 * Loads files in parallel
	 * The number of parallel loading depends on the internal loader
	 */loadParallel(){this.reset(),this.loadParallelInternal()}/**
	 * Loads files sequentially
	 */loadSequentially(){this.reset(),this.loadSequentiallyInternal(0)}reset(){this.loadedFiles=0,this.loadedAmount=0,this.running=!0,this.totalAmount=this.files.reduce((t,e)=>t+e.size,0)}loadParallelInternal(){for(let t of this.files)this.loader.add(t.alias,t.url,()=>{this.loadedFiles++,this.loadedAmount+=t.size,this.progress=Math.floor(this.loadedAmount/this.totalAmount*100),this.loadedFiles===this.files.length&&(this.onComplete?.(),this.running=!1)})}loadSequentiallyInternal(t){let e=this.files[t];this.loader.add(e.alias,e.url,()=>{this.loadedFiles++,this.loadedAmount+=e.size,this.progress=Math.floor(this.loadedAmount/this.totalAmount*100),this.loadedFiles===this.files.length?(this.onComplete?.(),this.running=!1):this.loadSequentiallyInternal(t+1)})}}class SN extends m0{generateFiles(t,e,i){let r=[];for(let n=0;n<t;n++){let t=0,s=i-(i-e)*.2;t=.1>Math.random()?Math.floor(Math.random()*(i-s)+s):Math.floor(Math.random()*(s-e)+e),r.push({url:`file_${n}`,alias:`file_${n}`,size:t})}return r}/**
	 * A little lame, will be refactored with new approach on how to configure
	 * the examples
	 */isSequential(){return!0}load(){// init the scene and run your game
let t=this.engine.scene,e=this.generateFiles(100,102400,4194304),i=new SO(e),r=new SL(i,()=>{});for(let t of e)r.add(t.alias,t.url,t.size);let n=0,s=0;new hR(t).asGraphics().localPos(t.width/2-300,t.height/2-50).withParent(t.stage).withComponent(new hO("").doOnUpdate((t,e,i)=>{// main loop -> draw the progress bar from the 'progress' attribute taken from the loader
let o=t.owner.asGraphics();// a sleek animation that will try to catch up with the current value
if(o.clear(),o.lineStyle({width:10,color:15658734}),o.drawRect(0,0,600,100),o.lineStyle({width:0}),n=r.progress/100,s<n){let t=Math.max(.001,(n-s)/10);s=Math.min(s+t,n)}o.beginFill(2634223),o.drawRect(5,5,590*s,90),o.endFill()})).build(),this.isSequential()?r.loadSequentially():r.loadParallel()}}(E=tl||(tl={})).BALL_ATTACH="BALL_ATTACH",E.BALL_RELEASE="BALL_RELEASE",E.BALL_COLLIDED="BALL_COLLIDED",(T=tu||(tu={}))[T.ATTACHED=1]="ATTACHED",T[T.RELEASED=2]="RELEASED",(w=tc||(tc={})).BRICK="brick",w.BALL="ball",w.PADDLE="paddle",(S=td||(td={})).VELOCITY="velocity",S.SCENE_HEIGHT="scene_height",(M=tp||(tp={})).SPRITESHEET="spritesheet",M.LEVELS="levels";class SD{constructor(t,e,i,r){this._name=t,this._columns=e,this._rows=i,this._bricks=r}get name(){return this._name}get columns(){return this._columns}get rows(){return this._rows}get bricks(){return this._bricks}getIndex(t,e){return this.columns*e+t}getBrick(t,e){if(t>=this.columns||e>=this.rows||t<0||e<0)throw Error(`Coordinates outside bounds: [${t}, ${e}]`);let i=this.getIndex(t,e);return this._bricks[i]}}class SF{build(){if(this.rows*this.columns!==this.bricks.length)throw Error(`Number of rows (${this.rows}) or columns (${this.columns}) doesn't match the number of bricks (${this.bricks.length})`);return new SD(this.name,this.columns,this.rows,this.bricks)}constructor(){this.columns=0,this.rows=0,this.bricks=[]}}class SB extends hi{moveLeft(t){let e=this.owner.getBounds();e.left>=0&&(this.owner.position.x-=Math.min(t,e.left))}moveRight(t){let e=this.owner.getBounds();e.right<=16&&(this.owner.position.x+=Math.min(t,16-e.right))}}class SU extends SB{onInit(){super.onInit(),this.keyInputCmp=this.scene.getGlobalAttribute("key_input")}onUpdate(t,e){this.keyInputCmp.isKeyPressed(b7.KEY_LEFT)&&this.moveLeft(.01*t),this.keyInputCmp.isKeyPressed(b7.KEY_RIGHT)&&this.moveRight(.01*t),this.keyInputCmp.isKeyPressed(b7.KEY_SPACE)&&(this.keyInputCmp.handleKey(b7.KEY_SPACE),this.sendMessage(tl.BALL_RELEASE))}}class SG extends hi{get velocity(){return this.owner.getAttribute(td.VELOCITY)}set velocity(t){this.owner.assignAttribute(td.VELOCITY,t)}onInit(){this.subscribe(tl.BALL_ATTACH,tl.BALL_RELEASE),this.paddle=this.scene.findObjectByTag(tc.PADDLE),this.velocity=new hD(0)}onMessage(t){t.action===tl.BALL_ATTACH?this.owner.stateId!==tu.ATTACHED&&this.attachBall():t.action===tl.BALL_RELEASE&&this.owner.stateId!==tu.RELEASED&&this.releaseBall()}attachBall(){this.owner.stateId=tu.ATTACHED,this.updateBallAttached()}releaseBall(){this.owner.stateId=tu.RELEASED;let t=this.owner.position.x-this.lastAttachPositionX;this.velocity=new hD(t/2,-.1).normalize().multiply(.1),this.lastAttachPositionX=null}updateBallAttached(){let t=this.paddle.getBounds(),e=this.owner.getBounds(),i=t.left-e.left+t.width/2-e.width/2,r=t.top-e.bottom;this.lastAttachPositionX=this.owner.position.x,this.owner.position.x+=i,this.owner.position.y+=r}updateBallMovement(t){this.owner.position.x+=t*this.velocity.x*.04,this.owner.position.y+=t*this.velocity.y*.04}onUpdate(t,e){switch(this.owner.stateId){case tu.ATTACHED:this.updateBallAttached();break;case tu.RELEASED:this.updateBallMovement(t)}}}(A=tf||(tf={})).SOLID_OBJECT="SOLID_OBJECT",A.BORDER="BORDER",A.BOTTOM="BOTTOM";class Sk extends hi{onUpdate(t,e){let i=this.scene.findObjectByTag(tc.BALL),r=this.scene.findObjectsByTag(tc.BRICK),n=this.scene.findObjectByTag(tc.PADDLE),s=[...r,n],o=i.getBounds();for(let t of s){let e=t.getBounds(),r=this.horizIntersection(o,e),n=this.vertIntersection(o,e),s=r>0&&n>0;if(s){this.sendMessage(tl.BALL_COLLIDED,{ball:i,collider:t,ballBox:o,cBox:e,horizIntersection:r,vertIntersection:n,type:tf.SOLID_OBJECT});return}}(o.left<0||o.right>16)&&this.sendMessage(tl.BALL_COLLIDED,{ball:i,ballBox:o,vertIntersection:1,type:tf.BORDER}),o.top<0&&this.sendMessage(tl.BALL_COLLIDED,{ball:i,ballBox:o,horizIntersection:1,type:tf.BORDER}),o.top>this.scene.getGlobalAttribute(td.SCENE_HEIGHT)&&this.sendMessage(tl.BALL_COLLIDED,{ball:i,ballBox:o,type:tf.BOTTOM})}horizIntersection(t,e){return Math.min(t.right,e.right)-Math.max(t.left,e.left)}vertIntersection(t,e){return Math.min(t.bottom,e.bottom)-Math.max(t.top,e.top)}}class SH extends hi{onInit(){this.subscribe(tl.BALL_COLLIDED)}onMessage(t){if(t.action===tl.BALL_COLLIDED){let e;let i=t.data,{ball:r,collider:n,cBox:s,ballBox:o,type:a}=i,h=r.getAttribute(td.VELOCITY);if(a===tf.SOLID_OBJECT){if(n.hasTag(tc.BRICK))e=i.horizIntersection<i.vertIntersection?new hD(-h.x,h.y):new hD(h.x,-h.y);else if(n.hasTag(tc.PADDLE)){let t=h.magnitude();e=o.left+o.width/2>s.left+s.width/2?new hD(h.x+t/5,-h.y).normalize().multiply(t):new hD(h.x-t/5,-h.y).normalize().multiply(t)}}else a===tf.BORDER&&(i.horizIntersection>0?e=new hD(h.x,-h.y):i.vertIntersection>0&&(e=new hD(-h.x,h.y)));r.assignAttribute(td.VELOCITY,e)}}}class Sz extends hi{onInit(){this.subscribe(tl.BALL_COLLIDED)}onMessage(t){if(t.action===tl.BALL_COLLIDED){let e=t.data;e.type===tf.SOLID_OBJECT&&e.collider.hasTag(tc.BRICK)&&e.collider.destroy(),e.type===tf.BOTTOM&&this.sendMessage(tl.BALL_ATTACH)}}}class Sj{loadLevel(t,e){let i=new hs("bricksLayer");e.stage.addChild(i);let r=new ha;e.addGlobalComponentAndRun(r),// todo refactor this in ECSLite library
e.assignGlobalAttribute("key_input",r);for(let e=0;e<t.columns;e++)for(let r=0;r<t.rows;r++){let n=t.getBrick(e,r);if(-1!==n){let t=new hb("",this.createBrickTexture(n));t.scale.set(.01),t.position.x=e,t.position.y=.5*r,t.addTag(tc.BRICK),i.addChild(t)}}let n=16/(e.app.view.width/e.app.view.height);e.assignGlobalAttribute(td.SCENE_HEIGHT,n),new hR(e).anchor(.5).localPos(8,n-1).withTag(tc.PADDLE).asSprite(this.createTexture(0,125,100,25)).withParent(e.stage).withComponent(new SU).scale(.01).build(),new hR(e).anchor(.5).withTag(tc.BALL).asSprite(this.createTexture(0,100,20,20)).withParent(e.stage).withComponent(new SG).scale(.01).build(),e.addGlobalComponent(new Sk),e.addGlobalComponent(new SH),e.addGlobalComponent(new Sz),e.sendMessage(new he(tl.BALL_ATTACH))}createBrickTexture(t){if(t>=0&&t<=4)return this.createTexture(100*t,0,100,50);if(t>=5&&t<=9)return this.createTexture(100*(t-5),50,100,50);throw Error(`Wrong brick texture index: ${t}`)}createTexture(t,e,i,r){let n=rH.from(tp.SPRITESHEET);return(n=n.clone()).frame=new iU(t,e,i,r),n}}class SV{parse(t){let e=[],i=t.split("\n").filter(t=>""!==t&&-1===t.indexOf("#")),r=null;return i.forEach(t=>{if(t.startsWith(":")){r&&e.push(r.build()),(r=new SF).name=t.substr(1);return}let i=0;for(let e of t){let t="-"===e?-1:parseInt(e);if(isNaN(t))continue;let n=r.columns*r.rows+i;r.bricks[n]=t,0===r.rows&&(r.columns=i+1),i++}0!==i&&r.rows++}),r&&e.push(r.build()),e}}const SX="DOSSenior";(R=tm||(tm={})).SPRITESHEET="spritesheet",R.LEVELS="levels",R.SOUND_CRASH="snd_crash",R.SOUND_LEVEL_COMPLETD="snd_level_completed",R.SOUND_PICK="snd_pick",R.SOUND_MOVE="snd_move",(C=tg||(tg={})).GAMEOBJECT="gameobject",C.DOOR="door",C.TRAIN="train",C.PASSWORD="password",(P=ty||(ty={})).GAME_DATA="GAME_DATA",P.GAME_STATE="GAME_STATE",(I=t_||(t_={})).LEVEL_COMPLETED="level_completed",I.STATE_CHANGE_LEVEL="state_change_level",I.STATE_CHANGE_INIT_SCORE="state_change_init_score",I.STATE_CHANGE_CURRENT_SCORE="state_change_current_score",I.STATE_CHANGE_PAUSED="state_change_paused",I.STATE_CHANGE_TRAIN_CRASHED="state_change_train_crashed",I.STATE_CHANGE_TRAIN_POSITION="state_change_train_position",I.STATE_CHANGE_TRAIN_DIRECTION="state_change_direction",I.STATE_CHANGE_ITEM_PICKED="state_change_item_picked",I.STATE_CHANGE_DOOR_OPEN="state_change_door_open",(O=tv||(tv={}))[O.EMPTY=0]="EMPTY",O[O.WALL=1]="WALL",O[O.DOOR=2]="DOOR",O[O.DIAMOND=3]="DIAMOND",O[O.CROWN=4]="CROWN",O[O.TREE=5]="TREE",O[O.APPLE=6]="APPLE",O[O.COW=7]="COW",O[O.CHERRY=8]="CHERRY",O[O.POND=9]="POND",O[O.GIRAFFE=10]="GIRAFFE",O[O.ICECREAM=11]="ICECREAM",O[O.CAKE=12]="CAKE",O[O.PC=13]="PC",O[O.CAR=14]="CAR",O[O.BALOON=15]="BALOON",O[O.CLOCK=16]="CLOCK",O[O.ELEPHANT=17]="ELEPHANT",O[O.DRINK=18]="DRINK",O[O.MONEY=19]="MONEY",O[O.PLANE=20]="PLANE",O[O.LEMMING=21]="LEMMING";const SW=[tv.DIAMOND,tv.CROWN,tv.TREE,tv.APPLE,tv.COW,tv.CHERRY,tv.POND,tv.GIRAFFE,tv.ICECREAM,tv.CAKE,tv.PC,tv.CAR,tv.BALOON,tv.CLOCK,tv.CLOCK,tv.ELEPHANT,tv.DRINK,tv.MONEY,tv.PLANE,tv.LEMMING];class SY{/**
	 *
	 * @param type type of sprite
	 * @param column column on the map
	 * @param row row on the map
	 */constructor(t,e,i){this.type=t,this.isItem=-1!==SW.indexOf(t),this.column=e,this.row=i}}class Sq{parseLevels(t){let e=[],i=t.split("\n").filter(t=>""!==t&&-1===t.indexOf("#")),r=null,n=0;return i.forEach(t=>{if(t.startsWith(":")){r&&e.push({name:r.name,allObjects:r.bricks,trainInitPos:r.trainInitPos}),n=0,r={name:t.substr(1),bricks:[],trainInitPos:{column:0,row:0,direction:"r"}};return}for(let e of t){let t=this.parseCharacter(e);if(void 0!==t){let i=n%20,s=Math.floor(n/20);r.bricks[n++]=new SY(t,i,s),"V"===e&&(r.trainInitPos={column:i,row:s,direction:"r"})}}}),r&&e.push({name:r.name,allObjects:r.bricks,trainInitPos:r.trainInitPos}),e}parseCharacter(t){switch(t){case"0":case"V":return tv.EMPTY;case"1":return tv.WALL;case"2":return tv.DOOR;case"A":return tv.DIAMOND;case"B":return tv.CROWN;case"C":return tv.TREE;case"D":return tv.APPLE;case"E":return tv.COW;case"F":return tv.CHERRY;case"G":return tv.POND;case"H":return tv.GIRAFFE;case"I":return tv.ICECREAM;case"J":return tv.CAKE;case"K":return tv.PC;case"L":return tv.CAR;case"M":return tv.BALOON;case"N":return tv.CLOCK;case"O":return tv.ELEPHANT;case"P":return tv.DRINK;case"Q":return tv.MONEY;case"R":return tv.PLANE;case"S":return tv.LEMMING;default:return}}}const SK=(t,e)=>20*e+t,SJ=t=>{switch(t){case"l":return{x:-1,y:0};case"r":return{x:1,y:0};case"u":return{x:0,y:-1};case"d":return{x:0,y:1}}return{x:0,y:0}},SZ=(t,e)=>`${t}_${e}`,S$=t=>{switch(t){case tv.DIAMOND:return{x:0,y:3};case tv.CROWN:return{x:1,y:3};case tv.TREE:return{x:2,y:3};case tv.APPLE:return{x:3,y:3};case tv.COW:return{x:4,y:3};case tv.CHERRY:return{x:5,y:3};case tv.POND:return{x:6,y:3};case tv.GIRAFFE:return{x:7,y:3};case tv.ICECREAM:return{x:8,y:3};case tv.CAKE:return{x:9,y:3};case tv.PC:return{x:10,y:3};case tv.CAR:return{x:11,y:3};case tv.BALOON:return{x:12,y:3};case tv.CLOCK:return{x:13,y:3};case tv.ELEPHANT:return{x:14,y:3};case tv.DRINK:return{x:15,y:3};case tv.MONEY:return{x:16,y:3};case tv.PLANE:return{x:17,y:3};case tv.LEMMING:return{x:18,y:3};default:throw Error("No such train car!")}},SQ=(t,e)=>"l"===t&&"r"===e||"r"===t&&"l"===e||"d"===t&&"u"===e||"u"===t&&"d"===e,S0=t=>{switch(t){case tv.DIAMOND:return{x:0,y:0};case tv.CROWN:return{x:1,y:0};case tv.TREE:return{x:2,y:0};case tv.APPLE:return{x:3,y:0};case tv.COW:return{x:4,y:0};case tv.CHERRY:return{x:5,y:0};case tv.POND:return{x:6,y:0};case tv.GIRAFFE:return{x:7,y:0};case tv.ICECREAM:return{x:8,y:0};case tv.CAKE:return{x:9,y:0};case tv.PC:return{x:10,y:0};case tv.CAR:return{x:11,y:0};case tv.BALOON:return{x:12,y:0};case tv.CLOCK:return{x:13,y:0};case tv.ELEPHANT:return{x:14,y:0};case tv.DRINK:return{x:15,y:0};case tv.MONEY:return{x:16,y:0};case tv.PLANE:return{x:17,y:0};case tv.LEMMING:return{x:18,y:0};case tv.WALL:return{x:18,y:7};case tv.DOOR:return{x:12,y:7}}};/**
 * Base class for a mutable state that can send notification upon modification
 */class S1{constructor(t){this.scene=t}sendMessage(t,e){this.scene.sendMessage(new he(t,null,null,e))}}class S2 extends S1{constructor(t,e){super(t),// current loaded cars
this._cars=[],// crash indicator, set immediately before the crash animation even starts
this._crashed=!1,this._position=e}get cars(){return this._cars}get position(){return this._position}get crashed(){return this._crashed}changeDirection(t){this._position={...this._position,direction:t},this.sendMessage(t_.STATE_CHANGE_TRAIN_DIRECTION,t)}/**
	 * Will apply the movement and reorders all cars
	 * Doesn't check for collisions, this is handled by the controlling component
	 */applyMovement(){let t=this._position,{x:e,y:i}=SJ(t.direction);// move the cars
for(let e=this._cars.length-1;e>=0;e--){this._cars[e];// get new position (and direction)
let i=0===e?t:this._cars[e-1].position;// since the car state is immutable, we need to replace it completely
this._cars[e].position=i}// move the train
this._position={...t,column:t.column+e,row:t.row+i},this.sendMessage(t_.STATE_CHANGE_TRAIN_POSITION,this._position)}crashTrain(){this._crashed=!0,this.sendMessage(t_.STATE_CHANGE_TRAIN_CRASHED)}addItemToTail(t){let e=0===this.cars.length?this.position:this.cars[this.cars.length-1].position,i={position:{...e// clone it
},type:t};return this.cars.push(i),i}}class S3 extends S1{constructor(t,e){super(t),// all items yet to be picked up
this._itemsToPick=new Map,this._allObjects=[],this._doorOpen=!1,this._levelData=e,// place all items
this._allObjects=[...e.allObjects],this._allObjects.forEach((t,e)=>{// put pickable items in a separate collection
t.isItem&&this._itemsToPick.set(e,t)}),this._trainState=new S2(t,e.trainInitPos)}// ================================================================
// It is important to state here that the following functions do not
// contain any business logic, apart from simple assertions.
// State can only contain helper functions that make modifying it easier (+ notification facility)
// ================================================================
get levelData(){return this._levelData}get doorOpen(){return this._doorOpen}get trainState(){return this._trainState}pickItem(t,e){let i=SK(t,e),r=this.allItemsPicked[i];// replace it with an empty object
this._allObjects[i]=new SY(tv.EMPTY,t,e),this._itemsToPick.delete(i),this.sendMessage(t_.STATE_CHANGE_ITEM_PICKED,r)}openDoor(){this._doorOpen=!0,this.sendMessage(t_.STATE_CHANGE_DOOR_OPEN,!0)}allItemsPicked(){return 0===this._itemsToPick.size}getMapObject(t,e){if(t>=20||e>=12||t<0||e<0)throw Error(`Coordinates outside bounds: [${t}, ${e}]`);let i=SK(t,e);return this._allObjects[i]}}class S5 extends S1{constructor(t,e){super(t),// score in the beginning of the level
this._initScore=0,// current score (is reset whenever we lose)
this._currentScore=0,this._gameData=e}get currentLevel(){return this._currentLevel}get currentLevelIndex(){return this.gameData.levels.findIndex(t=>t.name===this.currentLevel.levelData.name)}get gameData(){return this._gameData}get initScore(){return this._initScore}set initScore(t){this._initScore=t,this.sendMessage(t_.STATE_CHANGE_INIT_SCORE,t)}get currentScore(){return this._currentScore}set currentScore(t){this._currentScore=t,this.sendMessage(t_.STATE_CHANGE_CURRENT_SCORE,t)}get paused(){return this._paused}set paused(t){this._paused=t,this.sendMessage(t_.STATE_CHANGE_PAUSED,t)}changeLevel(t){this._currentLevel=new S3(this.scene,t),this._initScore=this._currentScore,this._paused=!1,this.sendMessage(t_.STATE_CHANGE_LEVEL,t)}reloadLevel(){this._currentScore=this._initScore,this._paused=!1,this._currentLevel=new S3(this.scene,this._currentLevel.levelData)}}class S4 extends hi{onInit(){// wall animation is faster
this.fixedFrequency=30,this.animate()}onFixedUpdate(){this.animate()}animate(){this.progress=Math.min(this.progress+1,12),"fadein"===this.props.type?this.owner.height=16*this.progress:this.owner.height=(12-this.progress)*16,12===this.progress&&("fadeout"===this.props.type&&this.owner.destroy(),this.finish())}constructor(...t){super(...t),this.currentFrame=0,this.progress=-1}}class S6 extends hi{onInit(){// this will call onFixedUpdate with given frequence and we can ignore the main update loop
this.fixedFrequency=10,this.syncFrame()}onFixedUpdate(){this.syncFrame()}syncFrame(){this.currentFrame=Math.min(this.currentFrame+1,5);let t=this.owner.asSprite().texture;// the offset is 12 sprites from the left (that's where the first door sprite begins)
t.frame=new iU((this.currentFrame+12)*16,t.frame.y,t.frame.width,t.frame.height),5===this.currentFrame&&this.finish()}constructor(...t){super(...t),this.currentFrame=-1}}class S8 extends hi{onInit(){this.fixedFrequency=10;// set the initial sprite
let t=this.owner.asSprite().texture.frame;this.owner.asSprite().texture.frame=new iU(0,128,t.width,t.height)}onFixedUpdate(){let t=this.owner.asSprite().texture.frame;this.currentFrame>=7?this.currentFrame=7+(this.currentFrame-7+1)%3:this.currentFrame++,this.owner.asSprite().texture.frame=new iU(16*this.currentFrame,t.y,t.width,t.height)}constructor(...t){super(...t),this.currentFrame=0}}class S7{static #t=(()=>{this.gameStateSelector=t=>t.getGlobalAttribute(ty.GAME_STATE)})();static #e=(()=>{this.gameDataSelector=t=>t.getGlobalAttribute(ty.GAME_DATA)})()}class S9 extends hi{onInit(){this.subscribe(t_.STATE_CHANGE_TRAIN_CRASHED),this.fixedFrequency=10,this.syncState()}onMessage(t){t.action===t_.STATE_CHANGE_TRAIN_CRASHED&&this.finish()}onFixedUpdate(){this.switchWheelFrame()}onUpdate(){this.syncState()}switchWheelFrame(){this.currentFrame=(this.currentFrame+1)%3}syncState(){let t=this.owner.asSprite().texture.frame,e=0;switch(this.props.position.direction){case"u":e=1;break;case"d":e=3;break;case"l":e=0;break;case"r":e=2}this.owner.asSprite().texture.frame=new iU((e+4*this.currentFrame)*16,t.y,t.width,t.height)}constructor(...t){super(...t),this.currentFrame=0}}class Mt extends hi{onInit(){this.subscribe(t_.LEVEL_COMPLETED,t_.STATE_CHANGE_TRAIN_CRASHED),// by default, 3 movements per second
this.fixedFrequency=3}onFixedUpdate(){this.isActive&&(this.directionQueue.isEmpty()||this.changeDirection(this.directionQueue.dequeue()),this.moveForward())}onMessage(t){(t.action===t_.LEVEL_COMPLETED||t.action===t_.STATE_CHANGE_TRAIN_CRASHED)&&this.finish()}changeDirection(t){let e=S7.gameStateSelector(this.scene);if(!e||!e.paused){if(this.props.crashed)throw Error("Can't move! The train has crashed");// the train can't go the opposite direction, if there already are some cars
this.props.cars.length&&SQ(t,this.props.position.direction)||// copy the position and add a new direction
this.props.changeDirection(t)}}moveForward(){let t=S7.gameStateSelector(this.scene);if(!t||!t.paused){if(this.props.crashed)throw Error("Can't move! The train has crashed");this.scene.addGlobalComponentAndRun(Mh.moveTrain(this.scene,this.props))}}constructor(...t){super(...t),// direction queue for stashing future directions
this.directionQueue=new Ty,// by default, the controller is inactive; we need to
// explicitly switch it -> the train is waiting for the first input
this.isActive=!1}}class Me extends Mt{onFixedUpdate(){let t="rrrrrrrrrrrrrrrrrrruuuuuuuullllllllllllllllllldrrrrrrrrrrrrrrrrrrrdllllllllllllllllllldrrrrrrrrrrrrrrrrrrrdllllllllllllllllllldrrrrrrrrrrrrrrrrrrrdllllllllllllllllllldddrrrrrrrrrd"[this.currentPointer++];this.changeDirection(t),9===this.props.position.row&&this.props.position.column>=2&&this.props.position.column<=18&&Mo.introTextBuilder(this.scene,this.props.position.column,this.owner.position.x,this.owner.position.y).build(),this.moveForward()}constructor(...t){super(...t),this.currentPointer=0}}class Mi extends hi{onInit(){this.fixedFrequency=10,this.switchFrame()}onFixedUpdate(){this.switchFrame()}switchFrame(){this.currentFrame=(this.currentFrame+1)%3;let t=this.owner.asSprite().texture.frame;this.owner.asSprite().texture.frame=new iU(t.x,16*this.currentFrame,t.width,t.height)}constructor(...t){super(...t),this.currentFrame=-1}}class Mr extends hi{onInit(){this.subscribe(t_.STATE_CHANGE_ITEM_PICKED)}onMessage(t){t.action===t_.STATE_CHANGE_ITEM_PICKED&&(S7.gameStateSelector(this.scene).currentScore+=10)}onUpdate(){// okay - we don't actually need to set this text every single time, but
// it's better to do it this way in case we'd decide to introduce some
// other components that could modify the score,
let t=S7.gameStateSelector(this.scene);this.owner.asBitmapText().text=`${t.currentScore}`}}class Mn extends hi{onInit(){this.subscribe(t_.STATE_CHANGE_TRAIN_POSITION)}onMessage(t){t.action===t_.STATE_CHANGE_TRAIN_POSITION&&// technically, if the train would move every single frame, we would run the sync() function in the regular update() loop
this.sync()}sync(){let t;switch(this.owner.position.set(16*this.props.position.column,16*this.props.position.row),this.props.position.direction){case"u":t=4;break;case"d":t=6;break;case"l":t=3;break;case"r":t=5}let e=this.owner.asSprite().texture;e.frame=new iU(e.frame.x,16*t,e.frame.width,e.frame.height)}}class Ms extends Mt{onInit(){super.onInit(),this.keyInputCmp=this.scene.getGlobalAttribute("key_input")}onUpdate(){this.keyInputCmp.isKeyPressed(b7.KEY_LEFT)&&"l"!==this.directionQueue.peek()?(this.keyInputCmp.handleKey(b7.KEY_LEFT),this.directionQueue.enqueue("l"),this.isActive=!0):this.keyInputCmp.isKeyPressed(b7.KEY_DOWN)&&"d"!==this.directionQueue.peek()?(this.keyInputCmp.handleKey(b7.KEY_DOWN),this.directionQueue.enqueue("d"),this.isActive=!0):this.keyInputCmp.isKeyPressed(b7.KEY_UP)&&"u"!==this.directionQueue.peek()?(this.keyInputCmp.handleKey(b7.KEY_UP),this.directionQueue.enqueue("u"),this.isActive=!0):this.keyInputCmp.isKeyPressed(b7.KEY_RIGHT)&&"r"!==this.directionQueue.peek()&&(this.keyInputCmp.handleKey(b7.KEY_RIGHT),this.directionQueue.enqueue("r"),this.isActive=!0)}}class Mo{static #t=(()=>{this.keyboardBuilder=()=>hd()||new URLSearchParams(window.location.search).has("mobile")?new hL({KEY_UP:b7.KEY_UP,KEY_DOWN:b7.KEY_DOWN,KEY_LEFT:b7.KEY_LEFT,KEY_RIGHT:b7.KEY_RIGHT,KEY_X:8,KEY_Y:b7.KEY_SPACE}):new ha})();static #e=(()=>{this.trainBuilder=(t,e,i)=>{let r=S7.gameStateSelector(t),n=new hR(t).withName("train").withTag(tg.TRAIN).asSprite(Md.createTexture(0,7)).localPos(16*e.column,16*e.row).withComponent(new S9(r.currentLevel.trainState)).withParent(t.stage);return i?n.withComponent(new Me(r.currentLevel.trainState)):n.withComponent(new Ms(r.currentLevel.trainState)),n}})();static #i=(()=>{this.trainCarBuilder=(t,e)=>{let{x:i,y:r}=S$(e.type);return new hR(t).asSprite(Md.createTexture(i,r)).localPos(16*e.position.column,16*e.position.row).withParent(t.stage).withComponent(new Mn(e))}})();static #r=(()=>{this.tilesBuilder=(t,e)=>{let i=new hR(t).asContainer().withName("tilesLayer").withParent(t.stage);for(let r of e.allObjects)if(r.type!==tv.EMPTY){let{x:e,y:n}=S0(r.type),s=new hR(t).asSprite(Md.createTexture(e,n)).localPos(16*r.column,16*r.row).withTag(tg.GAMEOBJECT).withTag(SZ(r.column,r.row));r.type===tv.DOOR&&s.withTag(tg.DOOR),r.isItem&&s.withComponent(new Mi),// append the builder to the hierarchy
i.withChild(s)}return i}})();static #n=(()=>{this.wallTileBuilder=t=>{let{x:e,y:i}=S0(tv.WALL);return new hR(t).asTilingSprite(Md.createTexture(e,i),320,192).withComponent(new hO("").doOnInit(t=>{// a small hack to set zIndex in the ECS.Builder
t.owner.zIndex=10,t.finish()})).withParent(t.stage)}})();static #s=(()=>{this.levelTextsBuilder=t=>{let e=S7.gameStateSelector(t);return new hR(t).withParent(t.stage).withChild(new hR(t).asBitmapText("SKORE",SX,8,5503827).localPos(0,193)).withChild(new hR(t).asBitmapText("0",SX,8,16513875).localPos(56,193)// there is a weird bug for which adding ScoreCounter directly does accept messages
.withComponent(new Mr)).withChild(new hR(t).asBitmapText("H HESLO",SX,8,16536660).withTag(tg.PASSWORD).localPos(128,193)).withChild(new hR(t).asBitmapText("SCENA",SX,8,5503827).localPos(256,193)).withChild(new hR(t).asBitmapText(e.currentLevelIndex+1+"",SX,8,16513875).localPos(304,193))}})();static #o=(()=>{this.levelNameTextBuilder=t=>{let e=S7.gameStateSelector(t),i="SCENA",r=`${e.currentLevelIndex+1}`,n="heslo",s=`${e.currentLevel.levelData.name.toUpperCase()}`;return new hR(t).withParent(t.stage)// this is a little hack - ECS.Builder doesn't have zIndex option, thus we will add a dummy func component
// that would set it up during the onInit function
.withComponent(new hO("").doOnInit(t=>t.owner.zIndex=18)).withChild(new hR(t).asBitmapText(i,SX,8,5503827).withName("scnTextA").localPos(8*(20-Math.ceil((i.length+r.length+1)/2)),96)).withChild(new hR(t).asBitmapText(r,SX,8,16513875).withName("scnTextB").localPos(8*(20-Math.ceil((i.length+r.length+1)/2)+i.length+1),96)).withChild(new hR(t).asBitmapText(n,SX,8,5503827).withName("scnTextC").localPos(8*(20-Math.ceil((n.length+s.length+1)/2)),112)).withChild(new hR(t).asBitmapText(s,SX,8,16513875).withName("scnTextD").localPos(8*(20-Math.ceil((n.length+s.length+1)/2)+n.length+1),112)).withChild(new hR(t).asGraphics().withComponent(new hO("").doOnInit(t=>{let e=t.scene.findObjectByName("scnTextA"),i=t.scene.findObjectByName("scnTextB"),r=t.scene.findObjectByName("scnTextC"),n=t.scene.findObjectByName("scnTextD"),s=t.owner.asGraphics();s.beginFill(0);let o=Math.min(e.position.x,r.position.x),a=Math.min(e.position.y,r.position.y);s.drawRect(o,a,Math.max(i.getBounds().right,n.getBounds().right)-o,Math.max(i.getBounds().bottom,n.getBounds().bottom)-a),s.endFill(),s.zIndex=10,e.zIndex=i.zIndex=r.zIndex=n.zIndex=12,e.parent.sortableChildren=!0})))}})();static #a=(()=>{this.endInfoBuilder=t=>{let e="B L A H O P R E J I  !",i="Stal jste se absolutnim",r="vitezem teto hry !";return new hR(t).withParent(t.stage)// this is a little hack - ECS.Builder doesn't have zIndex option, thus we will add a dummy func component
// that would set it up during the onInit function
.withComponent(new hO("").doOnInit(t=>t.owner.zIndex=18)).withChild(new hR(t).asBitmapText(e,SX,8,16513875).withName("endTextA").localPos(8*(20-Math.ceil(e.length/2)),80)).withChild(new hR(t).asBitmapText(i,SX,8,5503827).withName("endTextB").localPos(8*(20-Math.ceil(i.length/2)),96)).withChild(new hR(t).asBitmapText(r,SX,8,5503827).withName("endTextC").localPos(8*(20-Math.ceil(r.length/2)),104)).withChild(new hR(t).asGraphics().withComponent(new hO("").doOnInit(t=>{let e=t.scene.findObjectByName("endTextA"),i=t.scene.findObjectByName("endTextB"),r=t.scene.findObjectByName("endTextC"),n=t.owner.asGraphics();n.beginFill(0);let s=i.position.x,o=e.position.y;n.drawRect(s,o,i.getBounds().right-s,r.getBounds().bottom-o),n.endFill(),n.zIndex=10,e.zIndex=i.zIndex=r.zIndex=12,e.parent.sortableChildren=!0})))}})();static #h=(()=>{this.introTextBuilder=(t,e,i,r)=>new hR(t).asSprite(Md.createTexture(e-2,11)).withParent(t.stage).localPos(i,r)})()}class Ma extends hi{onInit(){this.keyCmp=this.scene.getGlobalAttribute("key_input")}onUpdate(){(this.keyCmp.isKeyPressed(b7.KEY_SPACE)||this.keyCmp.isKeyPressed(b7.KEY_ENTER))&&this.finish()}}class Mh{static #t=(()=>{/**
	 * Loads intro with a slight delay
	 */this.loadIntro=t=>new hI()// callWithDelay is important here, because we can't clear the scene in the middle
    // of an update loop. Therefore, if we want to execute anything that calls .clearScene(),
    // we must use callWithDelay, so that the scene will be cleared up in the end of the update loop
    .call(()=>t.callWithDelay(200,()=>Md.loadIntro(t)))})();static #e=(()=>{/**
	 * Loads the next level
	 */this.loadNextLevel=(t,e=1e3)=>new hI().waitTime(e).waitFor(Mh.wallFade(t,"fadein")).call(e=>{let i=S7.gameStateSelector(t);i.currentLevelIndex===i.gameData.levels.length-1?e.mergeWith(new hI().call(()=>Mo.endInfoBuilder(t).build()).waitFor(()=>new Ma).call(()=>t.callWithDelay(0,()=>Md.loadIntro(t)))):e.mergeWith(new hI().call(()=>t.callWithDelay(0,()=>Md.loadLevel(t,i.currentLevelIndex+1))))})})();static #i=(()=>{/**
	 * Loads a level by given index
	 */this.loadLevelByIndex=(t,e)=>new hI().waitFor(Mh.wallFade(t,"fadein")).call(()=>t.callWithDelay(0,()=>Md.loadLevel(t,e)))})();static #r=(()=>{/**
	 * Completes a level and either loads the next one or re-loads the intro level,
	 * in case the intro itself has ended
	 */this.completeLevel=t=>new hI().call(t=>t.sendMessage(t_.LEVEL_COMPLETED)).call(e=>{let i=S7.gameStateSelector(t).currentLevel;"intro"===i.levelData.name?e.mergeWith(Mh.loadIntro(t)):e.mergeWith(Mh.loadNextLevel(t))})})();static #n=(()=>{/**
	 * Opens the door
	 */this.openDoor=t=>new hI().call(()=>{let e=S7.gameStateSelector(t).currentLevel;e.openDoor();let i=t.findObjectByTag(tg.DOOR);i.addComponent(new S6)})})();static #s=(()=>{/**
	 * Tries to move the train and either executes crash animation or applies the movement
	 */this.moveTrain=(t,e)=>{let{x:i,y:r}=SJ(e.position.direction),n=e.position.column+i,s=e.position.row+r,o=S7.gameStateSelector(t),a=o.currentLevel,h=a.getMapObject(n,s);if(h.type===tv.WALL||h.type===tv.DOOR&&!a.doorOpen)return Mh.crashTrain(t,e);// in terms of collisions with other cars, we can only move to the position of the last car, because as the train moves, so will the last car
let l=e.cars.findIndex(t=>t.position.column===n&&t.position.row===s);return -1!==l&&l!==e.cars.length-1?Mh.crashTrain(t,e):new hI().call(()=>{// add new car
if(h.isItem){a.pickItem(n,s);let i=e.addItemToTail(h.type);Md.destroyGameObject(t,h),Mo.trainCarBuilder(t,i).build()}// update all cars in the state
e.applyMovement();let i=t.findObjectByTag(tg.TRAIN);i.position.set(16*n,16*s)})}})();static #o=(()=>{/**
	 * Executes train crash animation and reloads the level
	 */this.crashTrain=(t,e)=>new hI().call(()=>{e.crashTrain();let i=t.findObjectByTag(tg.TRAIN);i.addComponent(new S8)}).waitTime(2e3).call(()=>t.callWithDelay(0,()=>Md.reloadLevel(t)))})();static #a=(()=>{/**
	 * Inits wall-fade animation and returns the animator that
	 * can be used for the waiting closure
	 */this.wallFade=(t,e)=>new hI().waitFor(()=>{let i=new S4({type:e}),r=Mo.wallTileBuilder(t).build();return r.addComponentAndRun(i),i})})()}class Ml extends hi{onInit(){this.subscribe(t_.STATE_CHANGE_TRAIN_POSITION,t_.STATE_CHANGE_ITEM_PICKED)}onMessage(t){let e=S7.gameStateSelector(this.scene).currentLevel;if(t.action===t_.STATE_CHANGE_TRAIN_POSITION){let i=t.data,r=e.getMapObject(i.column,i.row);// for more coupled solution, we could also put this into Actions.moveTrain
// and create two simple if-checks
r&&r.type===tv.DOOR&&this.scene.addGlobalComponentAndRun(Mh.completeLevel(this.scene))}else t.action===t_.STATE_CHANGE_ITEM_PICKED&&e.allItemsPicked()&&this.scene.addGlobalComponentAndRun(Mh.openDoor(this.scene))}}class Mu extends hi{onInit(){this.subscribe(t_.STATE_CHANGE_ITEM_PICKED,t_.LEVEL_COMPLETED,t_.STATE_CHANGE_TRAIN_CRASHED,t_.STATE_CHANGE_TRAIN_POSITION)}onMessage(t){t.action===t_.STATE_CHANGE_ITEM_PICKED&&E1.play(tm.SOUND_PICK),t.action===t_.LEVEL_COMPLETED&&E1.play(tm.SOUND_LEVEL_COMPLETD),t.action===t_.STATE_CHANGE_TRAIN_CRASHED&&E1.play(tm.SOUND_CRASH),t.action===t_.STATE_CHANGE_TRAIN_POSITION&&E1.play(tm.SOUND_MOVE)}}class Mc extends hi{onInit(){this.keyCmp=this.scene.getGlobalAttribute("key_input")}onUpdate(){if(this.keyCmp.isKeyPressed(b7.KEY_H)&&!this.isActive&&(this.hintText=this.scene.findObjectByTag(tg.PASSWORD).asBitmapText(),this.hintText.visible=!1,this.keyCmp.handleKey(b7.KEY_H),// put the name of the current level
this.createInputText(S7.gameStateSelector(this.scene).currentLevel.levelData.name),S7.gameStateSelector(this.scene).paused=!0,this.isActive=!0),this.keyCmp.isKeyPressed(27)&&this.isActive&&(this.keyCmp.handleKey(27),this.cleanup()),this.isActive){// a small hack. ECSLite doesn't expose the list of keys and we need it here
let t=this.keyCmp.keys;if(0!==t.size){// handle first key
let e=t.keys().next().value;if(this.keyCmp.handleKey(e),8===e||e===b7.KEY_LEFT)this.pointerPos=Math.max(0,this.pointerPos-1);else if(e===b7.KEY_RIGHT)this.pointerPos=Math.min(4,this.pointerPos+1);else if(e===b7.KEY_ENTER){// search for the level
let t=S7.gameDataSelector(this.scene).levels.findIndex(t=>t.name.toUpperCase()===this.password.toUpperCase());-1!==t?(// load the level
this.scene.addGlobalComponent(Mh.loadLevelByIndex(this.scene,t)),this.finish()):this.cleanup();return}else -1!=="ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(String.fromCharCode(e))&&(// update the current password string and move the pointer
this.password=this.password.substr(0,this.pointerPos)+String.fromCharCode(e).toUpperCase()+this.password.substr(this.pointerPos+1),this.pointerPos=Math.min(4,this.pointerPos+1));this.updateInputText()}}}cleanup(){this.isActive=!1,this.inputText.destroy(),this.pointer.destroy(),this.hintText.visible=!0,S7.gameStateSelector(this.scene).paused=!1}updateInputText(){this.pointer.position.set(this.inputText.position.x+(6+this.pointerPos)*8,193),this.inputText.text="heslo "+this.password.toUpperCase()}createInputText(t){this.password=t,this.pointerPos=0;let e="heslo "+t.toUpperCase();// since this is internal to this component only, we don't need to put this into builders.ts
this.inputText=new hg("",e,SX,8,16513875),this.inputText.position.x=8*(20-Math.ceil(e.length/2)),this.inputText.position.y=193,this.inputText.zIndex=25,this.scene.stage.addChild(this.inputText),this.pointer=new hy,this.pointer.zIndex=24,this.pointer.beginFill(5526780),this.pointer.drawRect(0,0,8,8),this.pointer.endFill(),this.scene.stage.addChild(this.pointer),this.updateInputText()}constructor(...t){super(...t),// isActive is internal to this component, therefore we don't need to put it
// into the game state (it only indicates that we are currently typing the password).
this.isActive=!1,this.pointerPos=0}}class Md{static #t=(()=>{/**
	 * Loads a level by an index
	 */this.loadLevel=(t,e)=>{let i=S7.gameStateSelector(t),r=i.gameData.levels[e];i.changeLevel(r),Md.reloadLevel(t)}})();static #e=(()=>{/**
	 * Reloads the current level
	 */this.reloadLevel=t=>{// recreate the scene from scratch to avoid leftovers from the previous level
Md.clearScene(t);let e=S7.gameStateSelector(t);e.reloadLevel(),Mo.wallTileBuilder(t).build(),Mo.levelNameTextBuilder(t).build(),// wait for input and load level content
t.addGlobalComponentAndRun(new hI().waitFor(()=>new Ma).call(()=>t.callWithDelay(0,()=>Md.loadLevelContent(t))))}})();static #i=(()=>{/**
	 * Loads intro animation
	 */this.loadIntro=t=>{// recreate the scene from scratch to avoid leftovers from the previous level
Md.clearScene(t);let e=S7.gameStateSelector(t),i=e.gameData.intro;e.changeLevel(i),t.addGlobalComponentAndRun(new Ml),Mo.tilesBuilder(t,i).build(),Mo.trainBuilder(t,i.trainInitPos,!0).build(),// wait for key input and load the first level
t.addGlobalComponentAndRun(new hI().waitFor(()=>new Ma).mergeWith(Mh.loadNextLevel(t,0)))}})();static #r=(()=>{/**
	 * Loads level content
	 */this.loadLevelContent=t=>{Md.clearScene(t);let e=S7.gameStateSelector(t),i=e.currentLevel,r=i.levelData.trainInitPos;t.addGlobalComponentAndRun(new Ml),// run fade out animation
t.addGlobalComponentAndRun(Mh.wallFade(t,"fadeout")),t.addGlobalComponent(new Mu),t.addGlobalComponent(new Mc),Mo.tilesBuilder(t,i.levelData).build(),Mo.trainBuilder(t,r,!1).build(),Mo.levelTextsBuilder(t).build()}})();static #n=(()=>{this.destroyGameObject=(t,e)=>{let i=t.findObjectByTag(SZ(e.column,e.row));i.destroy()}})();static #s=(()=>{this.createTexture=(t,e)=>{let i=rH.from(tm.SPRITESHEET);return(i=i.clone()).frame=new iU(16*t,16*e,16,16),i}})();static #o=(()=>{this.clearScene=t=>{let e=S7.gameStateSelector(t);t.clearScene(),// reassign global attributes and keyboard controller
t.stage.sortableChildren=!0,t.assignGlobalAttribute(ty.GAME_DATA,e.gameData),t.assignGlobalAttribute(ty.GAME_STATE,e);let i=Mo.keyboardBuilder();t.addGlobalComponentAndRun(i),t.assignGlobalAttribute("key_input",i)}})()}class Mp{loadGame(t){t.app.loader.reset().add(`${mZ()}/assets/game_vlak/pcsenior.fnt`).add(tm.SPRITESHEET,`${mZ()}/assets/game_vlak/spritesheet.png`).add(tm.LEVELS,`${mZ()}/assets/game_vlak/levels.txt`).add(tm.SOUND_CRASH,`${mZ()}/assets/game_vlak/sounds/crash.wav`).add(tm.SOUND_LEVEL_COMPLETD,`${mZ()}/assets/game_vlak/sounds/level_completed.wav`).add(tm.SOUND_PICK,`${mZ()}/assets/game_vlak/sounds/pick.wav`).add(tm.SOUND_MOVE,`${mZ()}/assets/game_vlak/sounds/move.wav`).load(()=>this.onAssetsLoaded(t)),E1.add(tm.SOUND_CRASH,`${mZ()}/assets/game_vlak/sounds/crash.wav`),E1.add(tm.SOUND_LEVEL_COMPLETD,`${mZ()}/assets/game_vlak/sounds/level_completed.wav`),E1.add(tm.SOUND_PICK,`${mZ()}/assets/game_vlak/sounds/pick.wav`),E1.add(tm.SOUND_MOVE,`${mZ()}/assets/game_vlak/sounds/move.wav`)}onAssetsLoaded(t){let e=t.app.loader.resources[tm.LEVELS].data,i=new Sq,r=i.parseLevels(e),n=r.find(t=>"intro"===t.name),s={levels:r.filter(t=>"intro"!==t.name),intro:n};t.scene.assignGlobalAttribute(ty.GAME_DATA,s),t.scene.assignGlobalAttribute(ty.GAME_STATE,new S5(t.scene,s)),Md.loadIntro(t.scene)}}(L=tx||(tx={})).CONTROLLER_BLOCK="CONTROLLER_BLOCK",L.CONTROLLER_RUN="CONTROLLER_RUN",L.ROW_CLEARED="ROW_CLEARED",L.GAME_OVER="GAME_OVER",L.LEVEL_UP="LEVEL_UP",L.MOVE_DOWN_BEGIN="MOVE_DOWN_BEGIN",L.MOVE_DOWN_END="MOVE_DOWN_END",L.TETROMINO_PLACED="TETROMINO_PLACED",L.TETROMINO_ROTATED="TETROMINO_ROTATED",(N=tb||(tb={})).FONT_DOS="FONT_DOS",N.FONT_DOS_TEXTURE="FONT_DOS_TEXTURE",N.SOUND_GAMEOVER="SOUND_GAMEOVER",N.SOUND_LEVELUP="SOUND_LEVELUP",N.SOUND_MOVEDOWN="SOUND_MOVEDOWN",N.SOUND_PLACE="SOUND_PLACE",N.SOUND_ROTATE="SOUND_ROTATE",N.SOUND_ROWCLEAR="SOUND_ROWCLEAR",N.MUSIC="MUSIC";const Mf={// ms after we go to the next row, multiplied by game speed
moveDownAutoDelay:500,// ms after we go to the next row manually
moveDownManualDelay:30,// delay after we move aside for the first time
moveAsideFirstDelay:200,// delay after we move aside for the 2nd+ time
moveAsideOtherDelay:50,// number of tetrominos before we switch to the next level
tetrominosPerLevel:20,gameSpeedMultiplier:.6,maxLevel:10,maxScorePlaces:10};(D=tE||(tE={})).DECOR_BOTTOMRIGHT="",D.DECOR_TOPLEFT="",D.DECOR_TOPRIGHT="",D.DECOR_BOTTOMLEFT="",D.DECOR_COL="",D.DECOR_ROW="",D.DECOR_FILL="",D.DECOR_FLEFT="",D.DECOR_FRIGHT="",D.DECOR_SEMIFILL="",(F=tT||(tT={}))[F.BLUE=170]="BLUE",F[F.GREEN=43520]="GREEN",F[F.CYAN=43690]="CYAN",F[F.RED=11141120]="RED",F[F.LBLUE=5592575]="LBLUE",F[F.LGREEN=5635925]="LGREEN",F[F.LCYAN=5636095]="LCYAN",F[F.LRED=16733525]="LRED",F[F.WHITE=16777215]="WHITE",F[F.BLACK=0]="BLACK",(B=tw||(tw={}))[B.NORMAL=0]="NORMAL",B[B.HIGHLIGHTED=1]="HIGHLIGHTED";class Mm extends hi{/**
	 * Clears up the whole screen
	 */clear(){this.drawRect(" ",0,0,this.props.columns,this.props.rows)}/**
	 * Draws a single character
	 * @param char character to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 */drawChar(t,e,i){if("	"===t||"\b"===t||"\r"===t)throw Error("Tabs and returns are not supported!");let r=this.posToIndex(e,i);this.changeText(r,t)}/**
	 * Draws a row of the same character
	 * @param char character to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param length length of the row
	 */drawRow(t,e,i,r){let n=Math.min(r,this.props.columns-e),s=this.posToIndex(e,i),o="";for(let e=0;e<n;e++)o+=t.charAt(0);this.changeText(s,o)}/**
	 * Draws a column of the same character
	 * @param char character to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param length length (height) of the column
	 */drawColumn(t,e,i,r){let n=Math.min(r,this.props.rows-i);for(let r=0;r<n;r++){let n=this.posToIndex(e,i+r);this.changeText(n,t.charAt(0))}}/**
	 * Draws a pattern. You can use newline characters as well
	 * For instance:  ABC will draw ABCABCABC
	 * AB\nBA will render  ABAB...
	 *                     BABA...
	 * @param pattern pattern to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param width width of the rectangle
	 * @param height height of the rectangle
	 */drawPattern(t,e,i,r,n){let s=Math.min(r,this.props.columns-e),o=Math.min(n,this.props.rows-i),a=t.split("\n");for(let t=0;t<s;t++)for(let r=0;r<o;r++){let n=a[r%a.length],s=n.charAt(t%n.length);this.drawChar(s,e+t,i+r)}}/**
	 * Draws a rectangle of the same characters
	 * @param char character to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param width width of the rectangle
	 * @param height height of the rectangle
	 */drawRect(t,e,i,r,n){let s=Math.min(n,this.props.rows-i);for(let n=0;n<s;n++)this.drawRow(t,e,i+n,r)}/**
	 * Draws text and renders a box around it
	 * @param text text to draw
	 * @param col column of the text
	 * @param row row of the text
	 * @param align horizontal align (allowed values are left, right, center)
	 * @param margin margin of the box
	 */drawTextWithBox(t,e,i,r="left",n=1){let s=this.drawText(t,e,i,r);// vertical margin is lowered by 1, as the decoration symbols have some extra space
this.drawBox(s.x-n-1,s.y-n,s.w+2*n+2,s.h+2*n)}/**
	 * Draws a decorated box
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param width width of the box
	 * @param height height of the box
	 */drawBox(t,e,i,r){let n=Math.min(i,this.props.columns-t),s=Math.min(r,this.props.rows-e);this.drawChar(tE.DECOR_TOPLEFT,t,e),this.drawChar(tE.DECOR_BOTTOMLEFT,t,e+s-1),this.drawChar(tE.DECOR_BOTTOMRIGHT,t+n-1,e+s-1),this.drawChar(tE.DECOR_TOPRIGHT,t+n-1,e),this.drawColumn(tE.DECOR_COL,t,e+1,s-2),this.drawColumn(tE.DECOR_COL,t+n-1,e+1,s-2),this.drawRow(tE.DECOR_ROW,t+1,e,n-2),this.drawRow(tE.DECOR_ROW,t+1,e+s-1,n-2)}/**
	 * Switches to highlight mode
	 */enableHighlight(){this.mode=tw.HIGHLIGHTED}/**
	 * Switches to normal mode
	 */disableHighlight(){this.mode=tw.NORMAL}get isHighlighted(){return this.mode===tw.HIGHLIGHTED}/**
	 * Draws a text and returns its bounding box
	 * Be advised that the text always starts at the top-left edge,
	 * regardless of the horizontal alignment
	 * @param text text to draw
	 * @param col column in the grid
	 * @param row row in the grid
	 * @param align horizontal alignment (allowed values are left, right, center)
	 * @param width width of the container (by default it's the
	 * remaining space before the edge of the window)
	 * @param valign vertical alignment (allowed values are top, center, bottom)
	 * @param height height of the container (by default it's the
	 * remaining space before the edge of the window)
	 * @returns bounding box of the drawn text
	 */drawText(t,e,i,r="left",n=this.props.columns,s="top",o=this.props.rows){if(-1!==t.indexOf("	")||-1!==t.indexOf("\b")||-1!==t.indexOf("\r"))throw Error("Backspaces and tabs are not supported");// PHASE 1: calculate lines with words that will fit the space
let a=[];if(// clamp values
n=Math.min(n,this.props.columns-e),o=Math.min(o,this.props.rows-i),t.length<=n&&-1===t.indexOf("\n"))a.push({line:t,col:0,row:0});else{// split by lines
let e=t.split("\n"),i=0;for(let t of e){// split by words
let e=t.split(" "),r=0;for(let t=0;t<e.length;t++){let s=e[t];if(s.length<=n-r)a.length&&a[a.length-1].row===i?// - this will be important for horizontal and vertical alignment later on
a[a.length-1].line+=" "+s:a.push({line:s,col:r,row:i}),r+=s.length+1;else if(s.length<=n)// word would fit if it was on a new line -> increment the line pointer
i++,r=0,a.push({line:s,col:r,row:i}),r+=s.length+1;else{// word does not fit at all -> we need to split it (this may happen for too long words)
let o=s.substr(0,n-r);a.length&&a[a.length-1].row===i?a[a.length-1].line+=" "+o:a.push({line:o,col:r,row:i}),// go to another line and add the remaining word to this collection
i++,r=0;let h=s.substr(o.length);e.splice(t+1,0,h)}}i++}}// here, linesToDraw should contain words to render for each line separately
// now we need to apply horizontal and vertical alignment
// PHASE 2: draw the text and calculate bounding box of drawn text for the caller
let h={x:e+a[0].col,y:i+a[0].row,w:0,h:a.length},l=i;for(let t of("center"===s?l=i+Math.floor((o-a.length)/2):"bottom"===s&&(l=i+o-a.length),a)){// position is stored relatively
let i=this.posToIndex(t.col+e,t.row+l);"center"===r?i+=Math.floor((n-t.line.length)/2):"right"===r&&(i=i+n-t.line.length),// draw each line one by one
this.changeText(i,t.line),h.w=Math.max(h.w,t.line.length)}return h}posToIndex(t,e){return(t<0||e<0||t>=this.props.columns||e>=this.props.rows)&&(// clamp the pos
t=Math.min(Math.max(t,0),this.props.columns-1),e=Math.min(Math.max(e,0),this.props.rows-1)),e*this.props.columns+t}constructor(...t){super(...t),this.mode=tw.NORMAL}}class Mg extends Mm{onInit(){// initialize the grid with empty spaces
let t=this.props.fontDefinition.getElementsByTagName("char");this.highlighted=new Set,this.maxWidth=0,this.maxHeight=0,this.resetColors();// get char data from XML
for(let e=0;e<t.length;e++){let i=t.item(e),r=parseInt(i.getAttribute("id")),n=parseInt(i.getAttribute("x")),s=parseInt(i.getAttribute("y")),o=parseInt(i.getAttribute("width")),a=parseInt(i.getAttribute("height")),h=parseInt(i.getAttribute("xoffset")),l=parseInt(i.getAttribute("yoffset"));this.maxWidth=Math.max(this.maxWidth,o),this.maxHeight=Math.max(this.maxHeight,a),this.charDefs.set(r,{x:n,y:s,width:o,height:a,xOffset:h,yOffset:l})}// put all sprites in place
for(let t=0;t<this.props.rows;t++)for(let e=0;e<this.props.columns;e++){let i=t*this.props.columns+e;this.text[i]=new hb("",this.props.fontTexture.clone()),this.text[i].position.set(e*this.maxWidth,t*this.maxHeight),this.text[i].tint=this.textColor,// highlight only draws  behind the main text
this.highlights[i]=new hb("",this.props.fontTexture.clone()),this.highlights[i].position.set(e*this.maxWidth,t*this.maxHeight),this.highlights[i].tint=this.textColor;let r=tE.DECOR_FILL.charCodeAt(0),n=this.charDefs.get(r);// the frame of highlights won't change
this.highlights[i].texture.frame=new iU(n.x,n.y,n.width,this.maxHeight),// highlights must be put first
this.owner.addChild(this.highlights[i]),this.owner.addChild(this.text[i]),// draw an empty space -> nothing, in order to initialize the second layer
this.drawChar(" ",e,t)}}onFinish(){super.onFinish(),this.text.forEach(t=>t.destroy()),this.highlights.forEach(t=>t.destroy())}revertHighlight(){for(let t of(this.disableHighlight(),this.highlighted.values()))this.highlights[t].visible=!1,this.text[t].tint=this.textColor;this.highlighted.clear()}/**
	 * Changes the colors to new values
	 * @param textColor color of the text
	 * @param highlightColor color of the highlighted text
	 * @param apply if true, it will be applied to the text that has been rendered
	 */changeColors(t,e,i=!1){this.textColor=t,this.highlightColor=e,i&&this.text.forEach((i,r)=>{this.highlighted.has(r)?i.tint=e:i.tint=t,this.highlights[r].tint=t})}/**
	 * Resets the colors to the default values specified in PROPS entity
	 * @param apply if true, it will be applied to the text that has been rendered
	 */resetColors(t=!1){this.changeColors(this.props.textColor,this.props.highlightColor,t)}changeText(t,e){for(let i=t;i<t+e.length;i++){let r=e.charCodeAt(i-t),n=this.charDefs.get(r);n||(n=this.charDefs.get(63));let s=i%this.props.columns,o=Math.floor(i/this.props.columns);this.text[i].tint=this.textColor,this.text[i].texture.frame=new iU(n.x,n.y,n.width,n.height),// adjust the position a bit by the yOffset - each character has its own offset
this.text[i].position.set(8*s+n.xOffset,16*o+n.yOffset),this.isHighlighted?(// highlighted background always has the same sizing, since we render 
this.text[i].tint=this.props.highlightedTextColor,this.highlights[i].visible=!0,this.highlights[i].tint=this.highlightColor,this.highlighted.add(i)):(this.highlights[i].visible=!1,this.highlighted.delete(i))}}constructor(...t){super(...t),this.text=[],this.highlights=[],this.charDefs=new Map}}const My=[{name:"TRI",data:[[0,1,0],[1,1,1]],offsetRight:[1,0],offsetBottom:[0,1],offsetLeft:[0,0]},{name:"LTETR",data:[[1,1,1],[0,0,1]],offsetRight:[0,-1],offsetBottom:[0,-1],offsetLeft:[1,-1]},{name:"SKEWL",data:[[1,1,0],[0,1,1]]},{name:"SQUARE",data:[[1,1],[1,1]]},{name:"SKEWR",data:[[0,1,1],[1,1,0]],// weird, but SKEWR rotates differently than SKEWL
offsetRight:[1,-1],offsetLeft:[1,-1]},{name:"STRAIGHT",data:[[1,1,1,1]],offsetRight:[2,-2],offsetLeft:[2,-2]},{name:"RTETR",data:[[1,1,1],[1,0,0]],offsetRight:[0,-1],offsetBottom:[0,-1],offsetLeft:[1,-1]}];(U=tS||(tS={})).LEFT="LEFT",U.RIGHT="RIGHT",U.DOWN="DOWN",(G=tM||(tM={})).TOP="TOP",G.RIGHT="RIGHT",G.BOTTOM="BOTTOM",G.LEFT="LEFT";/**
 * Helper for time-based actions
 */class M_{constructor(t){this.lastInputTime=0,this.lastProgressTime=0,this.lastManualProgressTime=0,this.inputNum=0,this.gameSpeed=1,this.scene=t}canMoveAside(){return!!((0===this.inputNum||1===this.inputNum)&&this.isTime(this.lastInputTime,this.scene.currentAbsolute,Mf.moveAsideFirstDelay)||this.inputNum>=2&&this.isTime(this.lastInputTime,this.scene.currentAbsolute,Mf.moveAsideOtherDelay))&&(this.lastInputTime=this.scene.currentAbsolute,this.inputNum++,!0)}resetMoveAside(){this.lastInputTime=0,this.inputNum=0}canMoveDown(){return!!this.isTime(this.lastManualProgressTime,this.scene.currentAbsolute,Mf.moveDownManualDelay)&&(this.lastManualProgressTime=this.scene.currentAbsolute,!0)}canGameProgress(){return!!this.isTime(this.lastProgressTime,this.scene.currentAbsolute,Mf.moveDownAutoDelay/this.gameSpeed)&&(this.lastProgressTime=this.scene.currentAbsolute,!0)}isTime(t,e,i){return e-t>=i}}class Mv extends hi{onInit(){this.timeWatch=new M_(this.scene),this.paused=!1,this.subscribe(tx.CONTROLLER_BLOCK,tx.CONTROLLER_RUN),this.updateGameSpeed()}onMessage(t){t.action===tx.CONTROLLER_RUN?this.paused=!1:t.action===tx.CONTROLLER_BLOCK&&(this.paused=!0)}cancelMovement(){this.timeWatch.resetMoveAside()}endGame(){this.scene.callWithDelay(0,()=>new MG().loadHighScoreSaver(this.scene,this.props.currentScore))}/**
	 * Moves player along a new direction.
	 * @param direction target direction
	 * @param speedup flag for extra score calc when the player holds the DOWN key
	 */movePlayer(t,e=!1){if(this.props.hasTetromino){if(t===tS.DOWN&&this.timeWatch.canMoveDown()){// move down
if(e&&0===this.moveDownCounter&&this.initMovementDown(),this.props.canMoveTetromino(tS.DOWN))this.props.moveTetromino(tS.DOWN),this.moveDownCounter++;else{let t=this.props.currentLevel,e=this.props.applyTetromino(this.moveDownCounter);this.resetMovementDown(),this.sendMessage(tx.MOVE_DOWN_END),e.length?this.sendMessage(tx.ROW_CLEARED,e):this.sendMessage(tx.TETROMINO_PLACED),this.props.isGameOver&&this.sendMessage(tx.GAME_OVER),t!==this.props.currentLevel&&(this.sendMessage(tx.LEVEL_UP),this.updateGameSpeed())}}else t!==tS.DOWN&&this.timeWatch.canMoveAside()&&this.props.canMoveTetromino(t)&&this.props.moveTetromino(t)}}initMovementDown(){this.moveDownCounter=0,this.sendMessage(tx.MOVE_DOWN_BEGIN)}resetMovementDown(){0!==this.moveDownCounter&&(this.moveDownCounter=0,this.sendMessage(tx.MOVE_DOWN_END))}rotatePlayer(t){this.props.hasTetromino&&this.props.canRotate(t)&&(this.props.rotate(t),this.sendMessage(tx.TETROMINO_ROTATED))}onUpdate(t,e){this.paused||(this.props.hasTetromino&&this.timeWatch.canGameProgress()?this.movePlayer(tS.DOWN):this.props.hasTetromino||this.props.putRandomTetromino())}updateGameSpeed(){this.timeWatch.gameSpeed=this.props.currentLevel*Mf.gameSpeedMultiplier+1}constructor(...t){super(...t),this.moveDownCounter=0// we get extra score if we hold the down key
}}class Mx extends Mv{onInit(){super.onInit(),this.keyInput=this.scene.getGlobalAttribute("key_input")}onUpdate(t,e){if(!this.paused){// when the game ends, we need to press the spacebar to get to the highscore table
if(this.props.isGameOver){this.keyInput.isKeyPressed(b7.KEY_SPACE)&&(this.endGame(),this.finish());return}this.keyInput.isKeyPressed(b7.KEY_A)?(this.rotatePlayer(tS.LEFT),this.keyInput.handleKey(b7.KEY_A)):this.keyInput.isKeyPressed(b7.KEY_S)?(this.rotatePlayer(tS.RIGHT),this.keyInput.handleKey(b7.KEY_S)):(this.keyInput.isKeyPressed(b7.KEY_DOWN)?this.movePlayer(tS.DOWN,!0):this.resetMovementDown(),this.keyInput.isKeyPressed(b7.KEY_LEFT)?this.movePlayer(tS.LEFT):this.keyInput.isKeyPressed(b7.KEY_RIGHT)?this.movePlayer(tS.RIGHT):this.cancelMovement()),super.onUpdate(t,e)}}}const Mb=tT.WHITE,ME=tT.LBLUE,MT={x:8,y:0,w:18,h:26},Mw={x:28,y:3,w:22,h:24},MS={x:Mw.x,y:0,w:Mw.w,h:3},MM={x:52,y:0,w:20,h:5},MA={x:MM.x,y:MM.y+MM.h,w:12,h:5},MR={x:MA.x,y:MA.y+MA.h,w:MA.w,h:4};class MC extends hi{onInit(){this.cli=this.scene.getGlobalAttribute("cli"),this.cli.changeColors(Mb,tT.BLACK),this.statsOffsets=new Map,this.paused=!1,this.subscribe(tx.ROW_CLEARED,tx.GAME_OVER)}onMessage(t){t.action===tx.ROW_CLEARED?this.runRowClearAnimation(t.data):t.action===tx.GAME_OVER&&this.runGameOverAnimation()}onAttach(){this.initGameBoard()}onUpdate(){this.paused||(this.drawModel(),this.drawStats())}initGameBoard(){// statistics
this.cli.drawBox(MT.x,MT.y,MT.w,MT.h),this.cli.drawText("STATISTICS",MT.x+1,MT.y+1,"center",MT.w-2);let t=3;for(let e of My){for(let i=0;i<e.data.length;i++)for(let r=0;r<e.data[i].length;r++)1===e.data[i][r]&&(this.cli.drawText("",MT.x+2+2*r,MT.y+i+t+1),this.statsOffsets.set(e.name,t));t+=3}// lines
this.cli.drawBox(MS.x,MS.y,MS.w,MS.h),this.cli.drawText("LINES",MS.x+2,MS.y+1),// top and score
this.cli.drawBox(MM.x,MM.y,MM.w,MM.h),this.cli.drawText("SCORE",MM.x+2,MM.y+1),// next
this.cli.drawBox(MA.x,MA.y,MA.w,MA.h),this.cli.drawText("NEXT",MA.x+1,MA.y+1,"center",MA.w-2),// level
this.cli.drawBox(MR.x,MR.y,MR.w,MR.h),this.cli.drawText("LEVEL",MR.x+2,MR.y+1),this.cli.drawText("Press Arrows for moving and A/S for rotations",MR.x,MR.y+MR.h+2,"left",12),// main box
this.cli.drawBox(Mw.x,Mw.y,Mw.w,Mw.h),// filling of the main box
this.drawBoxContent(),this.runGameInitAnimation()}drawModel(){let{model:t}=this.props;this.drawBoxContent();for(let e=0;e<t.rows;e++)for(let i=0;i<t.columns;i++){let r=t.cellTypeAt(new hD(i,e+t.extraRows));// don't render extra rows
2===r?this.drawCell(new hD(i,e),ME):1===r&&this.drawCell(new hD(i,e),Mb)}}drawStats(){let t=this.props.model.getStats();for(let e of My)this.cli.drawText(this.pad(t.shapesGenerated.get(e.name)||0,3),MT.x+12,MT.y+this.statsOffsets.get(e.name)+1);this.cli.drawText(`LINES-${this.pad(t.removedRows,3)}`,MS.x+2,MS.y+1),this.cli.drawText(this.pad(this.props.model.currentScore,6),MM.x+2,MM.y+3);let e=t.nextShape;if(e){this.cli.drawPattern(" ",MA.x+1,MA.y+2,MA.w-2,2);for(let t=0;t<e.data.length;t++)for(let i=0;i<e.data[t].length;i++)if(1===e.data[t][i]){let r="STRAIGHT"===e.name?1:3;this.cli.drawText("",MA.x+r+2*i,MA.y+t+2)}}this.cli.drawText(this.pad(this.props.model.currentLevel,2),MR.x+2,MR.y+2)}drawBoxContent(){this.cli.drawPattern(". ",Mw.x+1,Mw.y+1,Mw.w-2,Mw.h-4)}drawCell(t,e=Mb){e!==Mb&&this.cli.changeColors(e,tT.BLACK),this.cli.drawChar(tE.DECOR_FRIGHT,Mw.x+2*t.x+1,Mw.y+t.y+1),this.cli.drawChar(tE.DECOR_FILL,Mw.x+2*t.x+2,Mw.y+t.y+1),e!==Mb&&this.cli.resetColors()}runGameInitAnimation(){this.cli.drawPattern("#",Mw.x+1,Mw.y+1,Mw.w-2,Mw.h-4),this.sendMessage(tx.CONTROLLER_BLOCK),this.paused=!0;let t=0;this.owner.addComponentAndRun(new hI().beginWhile(()=>t<this.props.model.rows).waitTime(40).call(()=>{this.cli.drawPattern(". ",Mw.x+1,Mw.y+1+t,Mw.w-2,1),t++}).endWhile().call(()=>{this.sendMessage(tx.CONTROLLER_RUN),this.paused=!1}))}runGameOverAnimation(){// draw the most recent state and execute the animation
this.drawModel(),this.sendMessage(tx.CONTROLLER_BLOCK),this.paused=!0;let t=0;// wait for 1 second and draw ######## over the game board
this.owner.addComponentAndRun(new hI().waitTime(1e3).beginWhile(()=>t<this.props.model.rows).waitTime(40).call(()=>{this.cli.drawRow("#",Mw.x+1,Mw.y+1+t,Mw.w-2),t++}).endWhile().call(()=>{this.sendMessage(tx.CONTROLLER_RUN)}))}runRowClearAnimation(t){// stop the controller
this.sendMessage(tx.CONTROLLER_BLOCK),this.paused=!0;let e=0;// clear rows with a 60ms delay
this.owner.addComponentAndRun(new hI().beginWhile(()=>e<this.props.model.columns/2).waitTime(60).call(()=>{let i=Math.floor(this.props.model.columns/2);for(let r of t)this.cli.drawChar(" ",Mw.x+(i+e)*2+1,Mw.y+r+1),this.cli.drawChar(" ",Mw.x+(i+e)*2+2,Mw.y+r+1),this.cli.drawChar(" ",Mw.x+(i-e)*2+1,Mw.y+r+1),this.cli.drawChar(" ",Mw.x+(i-e)*2+2,Mw.y+r+1);e++}).endWhile().call(()=>{this.sendMessage(tx.CONTROLLER_RUN),this.paused=!1}))}pad(t,e){let i=t+"";return i.length>=e?i:Array(e-i.length+1).join("0")+t}}class MP{generate(){this.currentPermutation&&this.permPointer!==this.currentPermutation.length-1||this.generatePermutation(),this.permPointer++,this.shapeCounter++,this.incrementStats(this.getCurrentShape().name)}getCurrentShape(){return this.currentPermutation[this.permPointer]}getNextShape(){if(this.currentPermutation)return this.permPointer+1<this.currentPermutation.length?this.currentPermutation[this.permPointer+1]:this.nextPermutation[0]}generatePermutation(){this.nextPermutation?this.currentPermutation=this.nextPermutation:this.currentPermutation=this.shuffleShapeArray(),// random shuffle
this.nextPermutation=this.shuffleShapeArray(),this.permPointer=-1}incrementStats(t){this.shapesGenerated.has(t)?this.shapesGenerated.set(t,this.shapesGenerated.get(t)+1):this.shapesGenerated.set(t,1)}shuffleShapeArray(){// sort() mutates the original array. Hence the [...] spread operator
return[...My].sort(()=>Math.random()-.5)}constructor(){this.shapeCounter=0,this.shapesGenerated=new Map}}/**
 * Score counter implemented according to this table:
 * https://www.codewars.com/kata/5da9af1142d7910001815d32
 */class MI{onTetrominoPlaced(t){this.currentScore+=t}onLinesCleared(t){switch(t){case 1:this.currentScore+=40*(this.level+1);break;case 2:this.currentScore+=100*(this.level+1);break;case 3:this.currentScore+=300*(this.level+1);break;case 4:this.currentScore+=1200*(this.level+1)}}constructor(){this.currentScore=0,this.level=0}}class MO{/**
	 * Initializes the model
	 * @param columns columns of the game board
	 * @param rows rows of the game board
	 * @param extraRows extra rows needed for the player to rotate once the tetromino arrives at the first visible row
	 * @param level first level
	 */constructor(t,e,i,r=0){this.gameBoard=[],this.rows=e,this.extraRows=i,this.columns=t,this.firstLevel=r,this.reset()}get currentLevel(){return this.scoreCounter.level}get boardSize(){return this.columns*(this.rows+this.extraRows)}get hasTetromino(){return null!==this.tetromino&&void 0!==this.tetromino}get currentScore(){return this.scoreCounter.currentScore}get isGameOver(){return this.gameOver}getStats(){return{removedRows:this.removedRows,shapesGenerated:this.generator.shapesGenerated,nextShape:this.generator.getNextShape()}}/**
	 * Returns true, if a cell at a given position is empty
	 * @param pos position to check
	 */isEmpty(t){return 0===this.gameBoard[this.posToIndex(t)]}cellTypeAt(t){return this.gameBoard[this.posToIndex(t)]}/**
	 * Resets the game board
	 */reset(){// init with empty cells
for(let t=0;t<this.boardSize;t++)this.gameBoard[t]=0;this.tetromino=null,this.gameOver=!1,this.generator=new MP,this.scoreCounter=new MI,this.scoreCounter.level=this.firstLevel,this.removedRows=0,this.levelShapeCounter=0}putRandomTetromino(){let t;this.generator.generate();let e=this.generator.getCurrentShape();// if the new shape is colliding, there is nowhere to go
if(t="STRAIGHT"===e.name?new hD(Math.floor(this.columns/2)-2,this.extraRows):new hD(Math.floor(this.columns/2)-1,this.extraRows),// all tetrominos are put with the same rotation
this.putTetromino(e,tM.TOP,t),this.tetromino.collides){this.gameOver=!0;return}this.levelShapeCounter++,this.levelShapeCounter>Mf.tetrominosPerLevel&&this.currentLevel<Mf.maxLevel&&(this.levelShapeCounter=0,this.increaseLevel())}/**
	 * Applies the current tetromino, changes its value
	 * from CELL_PLAYER to CELL_PLACED
	 * and generates a new random tetromino
	 * @returns array of indices of rows that has been cleared out
	 */applyTetromino(t){if(!this.tetromino||this.tetromino.collides)throw Error("Player is in a wrong state.");if(this.canMoveTetromino(tS.DOWN))throw Error("Player can still go down!");let e=this.calcTetrominoIndices();for(let t of e)this.gameBoard[t]=1;this.scoreCounter.onTetrominoPlaced(t),this.tetromino=null;let i=this.findFullRows();return i.length&&this.removeRows(i),this.putRandomTetromino(),i}/**
	 * Returns rows that can be removed. **Doesn't consider extra rows**
	 * Should be called after 'applyMovingShape()'
	 */findFullRows(){let t=[];for(let e=this.extraRows;e<this.rows+this.extraRows;e++){let i=0;// once every column contains non-empty cell, we have a row that can be removed
for(let t=0;t<this.columns;t++)1===this.cellTypeAt(new hD(t,e))&&i++;i===this.columns&&t.push(e-this.extraRows)}return t}/**
	 * Removes passed rows, not including the extra rows!
	 * The rows must be sorted in a descending order
	 */removeRows(t){for(let e of t){for(let t=e-1;t>=0;t--)for(let e=0;e<this.columns;e++){let i=this.posToIndex(new hD(e,t+this.extraRows)),r=this.posToIndex(new hD(e,t+1+this.extraRows));this.gameBoard[r]=this.gameBoard[i]}this.removedRows++}this.scoreCounter.onLinesCleared(t.length)}/**
	 * Returns true, if the tetromino can follow a given direction
	 */canMoveTetromino(t){if(this.tetromino.collides)return!1;let e=this.calcTetrominoIndices();for(let i of e)switch(t){case tS.DOWN:if(i+this.columns>=this.boardSize||1===this.gameBoard[i+this.columns])return!1;break;case tS.LEFT:if(i%this.columns==0||1===this.gameBoard[i-1])return!1;break;case tS.RIGHT:if(i%this.columns==this.columns-1||1===this.gameBoard[i+1])return!1}return!0}/**
	 * Moves tetromino along the given direction
	 */moveTetromino(t){if(!this.canMoveTetromino(t))throw Error("Tetromino can't go this way!");let e=this.calcTetrominoIndices();switch(t){case tS.DOWN:this.tetromino.position=this.tetromino.position.add(new hD(0,1));break;case tS.LEFT:this.tetromino.position=this.tetromino.position.add(new hD(-1,0));break;case tS.RIGHT:this.tetromino.position=this.tetromino.position.add(new hD(1,0))}// calc new indices and swap cell states
let i=this.calcTetrominoIndices();// we need to do it twice - first, remove all player indices
// and put them again with updated positions
for(let t of e)this.gameBoard[t]=0;for(let t of i)this.gameBoard[t]=2}/**
	 * Returns true if given rotation can be applied
	 * @param direction rotation direction
	 * @returns
	 */canRotate(t){if(this.tetromino.collides)return!1;let e=this.directionToNewRotation(t),i=this.calcRotationData(this.tetromino.shape.data,e),r=this.getRotationDiffOffset(e),n=this.tetromino.position.add(new hD(r[0],r[1]));for(let t=0;t<i.length;t++)for(let e=0;e<i[t].length;e++)if(1===i[t][e]){// occupied cell -> check if we can put it to the board
let i=n.x+e,r=n.y+t,s=this.posToIndex(new hD(i,r));if(1===this.gameBoard[s]||i<0||r<0||i>=this.columns||r>=this.rows)return!1}return!0}/**
	 * Applies a rotation
	 * @param direction direction to apply
	 */rotate(t){if(!this.canRotate(t))throw Error("Rotation can't be applied!");let e=this.directionToNewRotation(t),{shape:i,position:r}=this.tetromino;// remove the shape and put it again with updated rotation index
this.removeTetromino(),this.putTetromino(i,e,r)}/**
	 * Removes the tetromino and replaces it with empty cells
	 */removeTetromino(){if(!this.tetromino)throw Error("There is no tetromino to remove!");let t=this.calcTetrominoIndices();// remove tetromino indices and put them again
for(let e of t)this.gameBoard[e]=0;this.tetromino=null}increaseLevel(){this.scoreCounter.level++}/**
	 * Calculates offset of which the rotated tetromino will be shifted
	 */getRotationDiffOffset(t){let e;switch(t){case tM.TOP:e=null;break;case tM.RIGHT:e=this.tetromino.shape.offsetRight;break;case tM.BOTTOM:e=this.tetromino.shape.offsetBottom;break;case tM.LEFT:e=this.tetromino.shape.offsetLeft}return e||[0,0]}/**
	 * Inserts a new tetromino
	 * @param shape shape to insert
	 * @param rotation rotation of the shape
	 * @param position top-left position of the tetromino (first occupied block)
	 * Keep in mind that the final position will also consider the rotation offsets
	 */putTetromino(t,e,i){if(this.tetromino)throw Error("There already is a tetromino. You need to remove it first");this.tetromino={...this.tetromino,shape:t,rotation:e,position:i,offset:null};// offset needs to be stored separately from player position, since
// it changes based on the current rotation, but the rotation itself
// doesn't afect the position of the player, even if the tetramino is shifted
let r=this.getRotationDiffOffset(e);this.tetromino.offset=r;let n=this.calcRotationData(t.data,e);for(let t=0;t<n.length;t++)for(let e=0;e<n[t].length;e++)if(1===n[t][e]){let n=e+i.x+r[0],s=t+i.y+r[1],o=this.posToIndex(new hD(n,s));1===this.gameBoard[o]&&(this.tetromino.collides=!0),this.gameBoard[o]=2}}/**
	 * Calculates exact indices of the tetromino in the game board, according
	 * to the position of the tetromino and shape data
	 */calcTetrominoIndices(){let t=this.calcRotationData(this.tetromino.shape.data,this.tetromino.rotation),e=[];// just a reminder: player shape data contains tetromino in a format like this:
// [1,0,0]
// [1,1,1]
// hence, if the player's position if [5, 7], the position of the first occupied cell is
// also [5 ,7], but the next two cells on the same row are empty
for(let i=0;i<t.length;i++)for(let r=0;r<t[i].length;r++)if(1===t[i][r]){let t=new hD(r+this.tetromino.position.x+this.tetromino.offset[0],i+this.tetromino.position.y+this.tetromino.offset[1]),n=this.posToIndex(t);e.push(n)}return e}posToIndex(t){return this.columns*t.y+t.x}directionToNewRotation(t){switch(this.tetromino.rotation){case tM.TOP:return t===tS.LEFT?tM.LEFT:tM.RIGHT;case tM.RIGHT:return t===tS.LEFT?tM.TOP:tM.BOTTOM;case tM.BOTTOM:return t===tS.LEFT?tM.RIGHT:tM.LEFT;case tM.LEFT:return t===tS.LEFT?tM.BOTTOM:tM.TOP}}/**
	 * Builds data array for a given rotation
	 * Doesn't calculate rotation offsets!
	 * @param data data of the default rotation
	 * @param rotation next rotation
	 */calcRotationData(t,e){let i=0;switch(e){case tM.TOP:// no rotation
return i=0,t;case tM.RIGHT:i=3;break;case tM.BOTTOM:i=2;break;case tM.LEFT:i=1}// 2D array transposition function
let r=t=>t[0].map((e,i)=>t.map(t=>t[t.length-i-1]));// rotating from the left
for(let e=0;e<i;e++)t=r(t);return t}}const ML=[[1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,1,0,0,1,1,1],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0],[0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,0,1,1,1],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,1],[0,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1]];class MN extends hi{onInit(){this.cli=this.scene.getGlobalAttribute("cli"),this.keyInput=this.scene.getGlobalAttribute("key_input")}onAttach(){let t=Math.floor(this.cli.props.rows/2)-4,e=0,i="PRESS SPACEBAR TO CONTINUE",r="",n=ML.reduce((t,e)=>t+e.map(t=>0===t?"  ":"").join("")+"\n","");this.owner.addComponent(new hI().beginWhile(()=>e<t).call(()=>{this.cli.clear(),this.cli.drawText(n,11,e++,"left",this.cli.props.columns)}).waitTime(150).endWhile().beginWhile(()=>i!==r).call(()=>{r=i.substring(0,r.length+1),this.cli.drawText(r,0,15,"center",this.cli.props.columns)}).waitFrames(1).endWhile())}onUpdate(){this.keyInput.isKeyPressed(b7.KEY_SPACE)&&(// clear out the scene and render level selector
this.scene.callWithDelay(0,()=>new MG().loadLevelSelector(this.scene)),this.finish())}}class MD extends hi{onInit(){this.cli=this.scene.getGlobalAttribute("cli"),this.keyInput=this.scene.getGlobalAttribute("key_input")}onUpdate(){let t=Math.floor(this.cli.props.columns/2),e=Math.floor(this.cli.props.rows/2);this.cli.drawBox(t-12,e-4,24,8),this.cli.drawText("Select level",t-12,e-4,"center",24);for(let i=0;i<=9;i++)i===this.currentLevel&&this.cli.enableHighlight(),this.cli.drawText(` ${i} `,t-12+i%5*3+4,e-1+Math.floor(i/5)),i===this.currentLevel&&this.cli.disableHighlight();this.keyInput.isKeyPressed(b7.KEY_LEFT)?(this.keyInput.handleKey(b7.KEY_LEFT),(this.currentLevel>0||this.currentLevel>5)&&this.currentLevel--):this.keyInput.isKeyPressed(b7.KEY_RIGHT)?(this.keyInput.handleKey(b7.KEY_RIGHT),(this.currentLevel<4||this.currentLevel<9)&&this.currentLevel++):this.keyInput.isKeyPressed(b7.KEY_UP)?(this.keyInput.handleKey(b7.KEY_UP),this.currentLevel>4&&(this.currentLevel-=5)):this.keyInput.isKeyPressed(b7.KEY_DOWN)&&(this.keyInput.handleKey(b7.KEY_DOWN),this.currentLevel<5&&(this.currentLevel+=5)),this.keyInput.isKeyPressed(b7.KEY_SPACE)&&(this.scene.callWithDelay(0,()=>new MG().loadGame(this.scene,this.currentLevel)),this.finish())}constructor(...t){super(...t),this.currentLevel=0}}const MF="tetris-score";class MB extends hi{onInit(){// todo refactor this
this.cli=this.scene.getGlobalAttribute("cli"),this.keyInput=this.scene.getGlobalAttribute("key_input"),this.loadHighScore(),this.drawScoreBoard()}loadHighScore(){try{let t=localStorage.getItem(MF);t?this.highScore=JSON.parse(t):this.highScore=[]}catch(t){console.error(t),this.highScore=[]}// put "null" at the position of the current round, it will be filled later
for(let t=0;t<this.highScore.length;t++)if(this.highScore[t].score<=this.props){this.currentPlace=t,this.highScore=this.highScore.slice(0,t).concat(null).concat(this.highScore.slice(t));break}else this.currentPlace++}get isInputAllowed(){return this.currentPlace<Mf.maxScorePlaces&&0!==this.props}saveHighScore(){let t={score:this.props,name:this.inputName},e=this.highScore.slice(0,this.currentPlace).concat([t]).concat(this.highScore.slice(this.currentPlace+1));e=e.slice(0,Mf.maxScorePlaces);let i=JSON.stringify(e);localStorage.setItem(MF,i)}drawScoreBoard(){let t=Math.floor(this.cli.props.columns/2),e=Math.floor(this.cli.props.rows/2);this.cli.drawBox(t-18,e-11,36,2*Mf.maxScorePlaces+2),this.cli.drawText("Highscore table",t-18,e-11,"center",36);for(let i=0;i<Mf.maxScorePlaces;i++){let r="",n="";this.highScore.length>i&&i!==this.currentPlace?(r=this.highScore[i].name,n=`${this.highScore[i].score}`):i===this.currentPlace&&(n=`${this.props}`),this.cli.drawText(`${this.pad(i+1+"",2," ")}.   ${this.pad(n,6,n?"0":" ")}    ${this.pad(r,10," ",!1)}`,t-18+2,e-11+2+2*i,"left")}}checkInput(){// a small hack. ECSLite doesn't expose the list of keys and we need it here
let t=this.keyInput.keys;if(0!==t.size){// handle first key
let e=t.keys().next().value;this.keyInput.handleKey(e),e===b7.KEY_LEFT?this.pointerPos=Math.max(0,this.pointerPos-1):e===b7.KEY_RIGHT?this.inputName[this.pointerPos]&&(this.pointerPos=Math.min(9,this.pointerPos+1)):8===e?this.pointerPos<9||!this.inputName[9]?(this.inputName=this.inputName.substr(0,this.pointerPos-1).concat(this.inputName.substr(this.pointerPos)),this.pointerPos=Math.max(0,this.pointerPos-1)):this.inputName=this.inputName.substr(0,this.pointerPos).concat(this.inputName.substr(this.pointerPos+1)):-1!=="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".indexOf(String.fromCharCode(e))&&(// update the current input string and move the pointer
this.inputName=this.inputName.substr(0,this.pointerPos)+String.fromCharCode(e).toUpperCase()+this.inputName.substr(this.pointerPos+1),this.pointerPos=Math.min(9,this.pointerPos+1))}}renderInput(t){let e=Math.floor(this.cli.props.columns/2),i=Math.floor(this.cli.props.rows/2);// flickering effect of the pointer
if(this.cli.drawPattern(" ",e-18+2+16,i-11+2+2*this.currentPlace,10,1),this.cli.drawText(this.inputName,e-18+2+16,i-11+2+2*this.currentPlace,"left"),this.highlightFlag){let t=this.inputName[this.pointerPos]||" ";this.cli.enableHighlight(),this.cli.drawText(t,e-18+2+16+this.pointerPos,i-11+2+2*this.currentPlace),this.cli.disableHighlight()}t%10==0&&(this.highlightFlag=!this.highlightFlag)}onUpdate(){this.keyInput.isKeyPressed(b7.KEY_ENTER)?(0!==this.inputName.length&&this.saveHighScore(),this.scene.callWithDelay(0,()=>new MG().loadIntro(this.scene)),this.finish()):this.isInputAllowed&&(this.checkInput(),this.renderInput(this.frameCounter++))}pad(t,e,i,r=!0){return r?t.length>=e?t:Array(e-t.length+1).join(i)+t:t.length>=e?t:t+Array(e-t.length+1).join(i)}constructor(...t){super(...t),this.inputName="",this.currentPlace=0// winning place
,this.pointerPos=0// input field pointer
,this.highlightFlag=!0// flickering cursor
,this.frameCounter=0}}class MU extends hi{onInit(){this.subscribe(tx.GAME_OVER,tx.LEVEL_UP,tx.MOVE_DOWN_BEGIN,tx.MOVE_DOWN_END,tx.ROW_CLEARED,tx.TETROMINO_PLACED,tx.TETROMINO_ROTATED)}onAttach(){E1.play(tb.MUSIC,{loop:!0})}onMessage(t){t.action===tx.TETROMINO_ROTATED?E1.play(tb.SOUND_ROTATE,{volume:.5}):t.action===tx.GAME_OVER?(E1.stop(tb.MUSIC),E1.play(tb.SOUND_GAMEOVER,{volume:.5})):t.action===tx.ROW_CLEARED?(E1.stop(tb.SOUND_MOVEDOWN),E1.play(tb.SOUND_ROWCLEAR,{volume:.3})):t.action===tx.TETROMINO_PLACED?E1.play(tb.SOUND_PLACE,{volume:.5}):t.action===tx.LEVEL_UP?E1.play(tb.SOUND_LEVELUP,{volume:.5}):t.action===tx.MOVE_DOWN_BEGIN?E1.play(tb.SOUND_MOVEDOWN,{loop:!0,volume:.5}):t.action===tx.MOVE_DOWN_END&&E1.stop(tb.SOUND_MOVEDOWN)}}class MG{loadIntro(t){t.clearScene(),this.buildGlobalDefaults(t),t.addGlobalComponentAndRun(new MN)}loadLevelSelector(t){t.clearScene(),this.buildGlobalDefaults(t),t.addGlobalComponentAndRun(new MD)}loadHighScoreSaver(t,e){t.clearScene(),this.buildGlobalDefaults(t),t.addGlobalComponentAndRun(new MB(e))}loadGame(t,e=0){t.clearScene(),this.buildGlobalDefaults(t);let i=new MO(10,20,2,e);t.addGlobalComponentAndRun(new Mx(i)),t.addGlobalComponentAndRun(new MC({model:i})),t.addGlobalComponentAndRun(new MU)}buildGlobalDefaults(t){let e=rH.from(tb.FONT_DOS_TEXTURE),i=t.app.loader.resources[tb.FONT_DOS].data,r=new DOMParser().parseFromString(i,"text/xml"),n=new Mg({columns:80,rows:25,fontDefinition:r,fontTexture:e,textColor:tT.WHITE,highlightColor:tT.LBLUE,highlightedTextColor:tT.WHITE});t.addGlobalComponentAndRun(n),// todo refactor this
t.assignGlobalAttribute("cli",n);let s=new ha;t.assignGlobalAttribute("key_input",s),t.addGlobalComponentAndRun(s)}}// create a global variable with respective examples
window.APH={PixiHelloWorld:class extends mQ{load(){// load a sprite
this.creature=oB.from(`${mZ()}/assets/01-helloworld/crash.png`),// set anchor to the center
this.creature.anchor.set(.5),// set position to the center of the screen
this.creature.x=this.app.screen.width/2,this.creature.y=this.app.screen.height/2,// stage is a root element of the scene graph
this.app.stage.addChild(this.creature)}// game loop, invoked 60times per second
update(t){this.creature.rotation+=.01*t}},ThreeHelloWorld:class extends m${load(){let t=null,e=null;fetch(new Request(`${mZ()}/assets/01-helloworld/example-3D.vert`)).then(t=>t.text()).then(i=>{t=i,fetch(new Request(`${mZ()}/assets/01-helloworld/example-3D.frag`)).then(t=>t.text()).then(i=>{e=i,this.camera=new uV,this.camera.position.z=1;let r=new u5(2,2),n=new uj({uniforms:this.uniforms,vertexShader:t,fragmentShader:e}),s=new uB(r,n);this.scene.add(s),this.uniforms.u_resolution.value.x=this.renderer.domElement.width,this.uniforms.u_resolution.value.y=this.renderer.domElement.height,this.loadFinished=!0})})}update(){this.loadFinished&&(this.uniforms.u_time.value+=.05,this.renderer.render(this.scene,this.camera))}constructor(...t){super(...t),this.uniforms={u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new hX},u_mouse:{type:"v2",value:new hX}},this.loadFinished=!1}},Button:class extends mQ{load(){let t=rH.from(`${mZ()}/assets/02-pixi-intro/sonic.png`);this.sonic=new oB(t),this.sonic.position.set(this.app.screen.width/2,this.app.screen.height/2),this.sonic.anchor.set(.5),this.sonic.interactive=!0,this.sonic.buttonMode=!0,this.sonic.on("pointerdown",()=>{this.animRunning=!this.animRunning}),this.app.stage.addChild(this.sonic)}update(t){this.animRunning&&(this.sonic.rotation+=.01*t)}constructor(...t){super(...t),this.animRunning=!1}},Loop:class extends mQ{init(t){super.init(t,!0)}load(){this.gfx=new oP,this.gfx.position.set(400,300),this.gfx.pivot.set(100,100),this.gfx.beginFill(16711680),this.gfx.drawRect(0,0,200,200),this.gfx.endFill(),this.app.stage.addChild(this.gfx),this.app.ticker.autoStart=!1,this.app.ticker.stop(),this.loop(performance.now())}loop(t){let e=Math.min(t-this.lastTime,100);this.lastTime=t,this.gameTime+=e,this.performUpdate(16,this.gameTime),this.running&&(this.app.ticker.update(t),this.animFrameRequest=requestAnimationFrame(t=>this.loop(t)))}performUpdate(t,e){this.gfx.rotation+=.001*t}destroy(){this.app.destroy(),cancelAnimationFrame(this.animFrameRequest),this.running=!1}update(t){// no-op
}constructor(...t){super(...t),this.lastTime=0,this.gameTime=0,this.running=!0}},Particles:m1,Primitives:class extends mQ{load(){let t=new oP;t.beginFill(2236962),t.drawRect(100,150,600,250);let e=new oP;e.lineStyle(1,16777181),e.drawCircle(250,275,90),e.drawCircle(250,275,70),e.beginFill(16777181),e.drawCircle(250,275,50),e.endFill(),t.addChild(e);let i=e.clone();i.position.set(300,0),t.addChild(i),t.lineStyle(1,16777181),t.moveTo(340,275).lineTo(460,275),this.app.stage.addChild(t)}update(){// no-op
}},Sound:class extends mQ{load(){this.sonic=oB.from(`${mZ()}/assets/02-pixi-intro/sonic.png`),this.sonic.position.set(this.app.screen.width/2,this.app.screen.height/2),this.sonic.anchor.set(.5),this.sonic.interactive=!0,this.sonic.buttonMode=!0,E1.add("sound",`${mZ()}/assets/02-pixi-intro/sound.mp3`),this.sonic.on("pointerdown",()=>{E1.play("sound")}),this.app.stage.addChild(this.sonic)}update(){// no-op
}},Text:class extends mQ{load(){let t=new oH({fontFamily:"Arial",fontSize:36,fill:["#ffffff","#00ff99"],stroke:"#4a1850",strokeThickness:5});this.text=new oq("Hello World",t),this.text.position.set(this.app.screen.width/2,this.app.screen.height/2),this.text.anchor.set(.5),this.app.stage.addChild(this.text)}update(t){this.directionLeft?this.text.position.x-=2*t:this.text.position.x+=2*t,this.text.getBounds().left<0?this.directionLeft=!1:this.text.getBounds().right>this.app.screen.width&&(this.directionLeft=!0)}constructor(...t){super(...t),this.directionLeft=!1}},BitmapText:class extends m0{load(){this.engine.app.loader.reset().add(`${mZ()}/assets/02-pixi-intro/bitmap-font/jupiter.fnt`).load(()=>{let t=new hg("test","hello world","Jupiter Crash BRK",80,16711680);t.position.set(this.engine.app.screen.width/2,this.engine.app.screen.height/2),t.anchor.set(.5),t.addComponent(new hO("").doOnUpdate(()=>t.rotation+=.1)),this.engine.scene.stage.addChild(t)})}},Scene:class extends m${load(){this.camera=new uX(75,this.canvas.width/this.canvas.height,.1,1e3);// add a cube
let t=new uG,e=new un({color:16711935}),i=new uB(t,e);this.scene.add(i),this.camera.position.z=5}update(){this.renderer.render(this.scene,this.camera)}},Sprites:class extends m${load(){let t=new mo;this.camera=new uX(75,this.canvas.width/this.canvas.height,.1,1e3),this.camera.position.z=1e3,this.scene.fog=new pu(0,.001);let e=[];// generate random vertices
for(let t=0;t<1e4;t++){let t=2e3*Math.random()-1e3,i=2e3*Math.random()-1e3,r=2e3*Math.random()-1e3;e.push(t,i,r)}// Create a geometry
let i=new uv;i.setAttribute("position",new uu(e,3));// Load a texture from './assets/02-pixi-intro/ghost.png' and create a material
let r=t.load(`${mZ()}/assets/02-pixi-intro/ghost.png`),n=new pJ({size:20,map:r,blending:2,depthTest:!1,transparent:!0}),s=new p1(i,n);this.scene.add(s)}update(){// Rotate all objects in the scene
let t=.1*this.clock.getElapsedTime();this.scene.children.filter(t=>t instanceof p1).forEach(e=>{e.rotation.y=t}),this.renderer.render(this.scene,this.camera)}},Squares:class extends m0{load(){let t=new hy;t.beginFill(16711680),t.drawRect(0,0,200,200),t.endFill(),t.pivot.set(100,100),t.position.set(.25*this.canvas.width,.5*this.canvas.height);let e=new hy;e.beginFill(255),e.drawRect(0,0,200,200),e.endFill(),e.pivot.set(100,100),e.position.set(.75*this.canvas.width,.5*this.canvas.height),t.addComponent(new E5),t.setFlag(1),e.addComponent(new E5),this.engine.scene.stage.addChild(t),this.engine.scene.stage.addChild(e)}},Graphics:class extends m0{load(){this.engine.scene.assignGlobalAttribute(k.SCENE_STATE,{isRunning:!0});let t=new ha;this.engine.scene.addGlobalComponent(t),// TODO will need refactor in the ECSLite library
this.engine.scene.assignGlobalAttribute("key_input",t),this.engine.scene.addGlobalComponent(new E8)}},PIXIAnimation:class extends mQ{load(){// use an asynchronous loader
this.app.loader.add(E2).load(()=>{let t=this.app.loader.resources[E2].spritesheet,e=new a8(t.animations.warrior);e.animationSpeed=.167,e.loop=!0,e.play(),e.scale.set(.5),e.position.set(this.app.screen.width/2,this.app.screen.height/2),e.anchor.set(.5),this.app.stage.addChild(e)})}update(t){// no-op
}},ECSAnimation:class extends m0{load(){this.engine.app.loader.add(E3).load(()=>{let t=this.engine.app.loader.resources[E3].texture,e=0,i=0;new hR(this.engine.scene).asSprite(t).withParent(this.engine.scene.stage).localPos(this.engine.app.view.width/2,this.engine.app.view.height/2).anchor(.5).withComponent(new hO("animator").setFixedFrequency(10).doOnFixedUpdate((t,r,n)=>{t.owner.asSprite().texture.frame=new iU(e%4*528,540*Math.floor(e/4),528,540),e=i++%8})).build()})}update(){// no-op
}},DistributionNormal:class extends Tj{generateNumber(t,e){return this.random.normal(t,e,1)}},DistributionUniform:class extends Tj{generateNumber(t,e){return this.random.uniform(t,e)}},Pathfinding:class extends m0{constructor(t){super(t),this.slowPathCost=10,this.mapCellSize=32// 32px
,// sprites of arrows
this.arrows=new Set,// sprites of visited blocks
this.visitedBlocks=new Set,this.startPosition=new hD(1,8),// frames for sprite atlas
this.startRect=new iU(96,0,32,32),this.pathRect=new iU(0,0,32,32),this.obstructionRect=new iU(32,0,32,32),this.slowPathRect=new iU(32,32,32,32),this.visitedRect=new iU(0,32,32,32),this.arrowRect=new iU(64,0,32,32),this.lastCalcX=0,this.lastCalcY=0,// map Vec2 to indices because of hashing
this.indexMapper=t=>t.y*this.mapWidth+t.x,this.onMouseClick=t=>{let e=this.engine.app.view.getBoundingClientRect(),i=t.clientX,r=t.clientY,n=this.engine.scene.app.renderer.resolution,s=Math.round((i-e.left)/(e.right-e.left)*this.engine.scene.app.view.width/n),o=Math.round((r-e.top)/(e.bottom-e.top)*this.engine.scene.app.view.height/n),a=this.worldToMap(s,o);(a.x!==this.lastCalcX||a.y!==this.lastCalcY)&&this.recalc(a.x,a.y)},this.mapType=t&&t.mapType||j.TILE,this.algorithm=t&&t.algorithm||V.ASTAR,this.distanceMeasurement=t&&t.distanceMeasurement||X.MANHATTAN,this.heuristics=t&&t.heuristics||W.DEFAULT,this.mapWidth=TV[0].length,this.mapHeight=TV.length}load(){this.engine.app.loader.reset()// necessary for hot reload
.add("pathfinding",`${mZ()}/assets/04-space/pathfinding.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){switch(// initialize grid from the static array
this.grid=new TM(this.mapType===j.TILE?1:2,10,this.mapWidth,this.mapHeight),this.algorithm){case V.ASTAR:this.pathFinder=new TS;break;case V.BREADTH_FIRST:this.pathFinder=new TT;break;case V.DIJKSTRA:this.pathFinder=new Tw}for(let t=0;t<this.mapHeight;t++)for(let e=0;e<this.mapWidth;e++){let i=TV[t][e];1===i?this.grid.addObstruction(new hD(e,t)):2===i&&this.grid.setElevation(new hD(e,t),this.slowPathCost)}// recreate view model
this.recreateMap(),this.engine.app.view.addEventListener("mousedown",this.onMouseClick)}/**
	 * Recreates view-model
	 */recreateMap(){let t=new rH(rS.from("pathfinding"));this.engine.scene.clearScene();// create sprites
for(let e=0;e<this.mapWidth;e++)for(let i=0;i<this.mapHeight;i++){let r=t.clone(),n=new hb("",r),s=this.mapToWorld(e,i);n.position.set(s.x,s.y),r.frame=this.getSpriteFrame(new hD(e,i)),this.engine.scene.stage.addChild(n)}// render starting point
let e=t.clone(),i=new hb("",e),r=this.mapToWorld(this.startPosition.x,this.startPosition.y);i.position.set(r.x,r.y),e.frame=this.startRect,this.engine.scene.stage.addChild(i)}recalc(t,e){this.lastCalcX=t,this.lastCalcY=e;let i=new rH(rS.from("pathfinding"));// remove all sprites
for(let t of this.arrows)t.destroy();for(let t of(this.arrows.clear(),this.visitedBlocks))t.destroy();this.visitedBlocks.clear();// recalculatePath
let r=new Tx,n=this.searchPath(r,new hD(t,e));// create sprites for visited blocks (red square)
for(let t of r.visited){let e=i.clone(),r=new hb("",e),n=this.mapCoordByIndex(t),s=this.mapToWorld(n.x,n.y);r.position.set(s.x,s.y),e.frame=this.visitedRect,this.engine.scene.stage.addChild(r),this.visitedBlocks.add(r)}if(n)for(let t=0;t<r.pathFound.length-1;t++){let e=r.pathFound[t],n=r.pathFound[t+1],s=i.clone(),o=new hb("",s),a=this.mapToWorld(e.x,e.y);switch(o.position.set(a.x+16,a.y+16),o.anchor.set(.5),s.frame=this.arrowRect,this.engine.scene.stage.addChild(o),this.arrows.add(o),this.getDirection(e,n)){case 7:o.rotation=-Math.PI/2;break;case 8:o.rotation=-Math.PI/4;break;case 1:o.rotation=0;break;case 2:o.rotation=Math.PI/4;break;case 3:o.rotation=Math.PI/2;break;case 4:o.rotation=3*Math.PI/4;break;case 5:o.rotation=Math.PI;break;case 6:o.rotation=-3*Math.PI/4}}}searchPath(t,e){if(this.algorithm!==V.ASTAR)return this.pathFinder.search(this.grid,this.startPosition,e,t);{let i,r=this.pathFinder;switch(this.heuristics){case W.DEFAULT:i=(t,e)=>t+e;break;case W.OPTIMISTIC:i=(t,e)=>t+1.2*e;break;case W.PESSIMISTIC:i=(t,e)=>t+e/1.2;break;case W.VERY_OPTIMISTIC:i=(t,e)=>t+5*e;break;case W.VERY_PESSIMISTIC:i=(t,e)=>t+e/5}return r.search(this.grid,this.startPosition,e,t,this.distanceMeasurement===X.EUCLIDEAN?"euclidean":"manhattan",i)}}/**
	 * Sets sprite index according to the type of the block of the map
	 */getSpriteFrame(t){let e=this.grid.getElevation(t);return this.grid.hasObstruction(t)?this.obstructionRect:1===e?this.pathRect:this.slowPathRect}/**
		* Transforms map coordinates into world coordinates
		*/mapToWorld(t,e){return new hD(t*this.mapCellSize,e*this.mapCellSize)}/**
	 * Transforms world coordinates into map coordinates
	 */worldToMap(t,e){return new hD(Math.floor(t/this.mapCellSize),Math.floor(e/this.mapCellSize))}/**
	 * Gets map index by coordinate
	 */mapIndexByCoord(t,e){return e*this.mapWidth+t}/**
	 * Gets map coordinate by index
	 */mapCoordByIndex(t){return new hD(t%this.mapWidth,Math.floor(t/this.mapWidth))}getDirection(t,e){return t.x+1===e.x&&t.y===e.y?1:t.x+1===e.x&&t.y+1===e.y?2:t.x===e.x&&t.y+1===e.y?3:t.x-1===e.x&&t.y+1===e.y?4:t.x-1===e.x&&t.y===e.y?5:t.x-1===e.x&&t.y-1===e.y?6:t.x===e.x&&t.y-1===e.y?7:t.x+1===e.x&&t.y-1===e.y?8:void 0}},PerlinNoise:class extends m0{load(){this.mapWidth=Math.floor(this.engine.app.view.clientWidth/this.mapCellSize),this.mapHeight=Math.floor(this.engine.app.view.clientHeight/this.mapCellSize),this.perlin=new Tt(50*Math.random()),this.engine.app.loader.reset()// necessary for hot reload
.add("pathfinding",`${mZ()}/assets/04-space/pathfinding.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){// initialize grid from the static array
this.grid=new TM(2,10,this.mapWidth,this.mapHeight);for(let t=0;t<this.mapHeight;t++)for(let e=0;e<this.mapWidth;e++){let i=Math.floor((2-(this.perlin.interpolatedNoise(e,t,1,3,20)+1))/2*255);// inverted value
this.grid.setElevation(new hD(e,t),i),this.maxElevation=Math.max(this.maxElevation,i)}// recreate view model
this.recreateMap(),// upon click, try to find a path to that particular block
this.engine.app.view.addEventListener("mousedown",this.onMouseClick)}/**
	 * Recreates view-model
	 */recreateMap(){this.engine.scene.clearScene();// create sprites
for(let t=0;t<this.mapWidth;t++)for(let e=0;e<this.mapHeight;e++){let i=new hy(""),r=this.mapToWorld(t,e);i.position.set(r.x,r.y);let n=this.grid.getElevation(new hD(t,e));n=n/this.maxElevation*255,i.beginFill((n<<16)+(n<<8)+n),i.drawRect(0,0,this.mapCellSize,this.mapCellSize),i.endFill(),this.engine.scene.stage.addChild(i)}}recalc(t,e){this.lastCalcX=t,this.lastCalcY=e;let i=new rH(rS.from("pathfinding"));// remove all sprites
for(let t of this.arrows)t.destroy();this.arrows.clear();// recalculatePath
let r=new Tx;if(this.pathFinder.search(this.grid,new hD(0,15),new hD(t,e),r))for(let t=0;t<r.pathFound.length-1;t++){let e=r.pathFound[t],n=i.clone(),s=new hb("",n);s.scale.set(this.mapCellSize/32*2);let o=this.mapToWorld(e.x,e.y);s.position.set(o.x+16,o.y+16),s.anchor.set(.5),n.frame=this.visitedRect,this.engine.scene.stage.addChild(s),this.arrows.add(s)}}/**
		* Transforms map coordinates into world coordinates
		*/mapToWorld(t,e){return new hD(t*this.mapCellSize,e*this.mapCellSize)}/**
	 * Transforms world coordinates into map coordinates
	 */worldToMap(t,e){return new hD(Math.floor(t/this.mapCellSize),Math.floor(e/this.mapCellSize))}/**
	 * Gets map index by coordinate
	 */mapIndexByCoord(t,e){return e*this.mapWidth+t}/**
	 * Gets map coordinate by index
	 */mapCoordByIndex(t){return new hD(t%this.mapWidth,Math.floor(t/this.mapWidth))}destroy(){this.engine.app.view.removeEventListener("mousedown",this.onMouseClick)}constructor(...t){super(...t),this.slowPathCost=10,this.mapCellSize=16// px
,// sprites of arrows
this.arrows=new Set,// pathfinding algorithm
this.pathFinder=new TS,this.visitedRect=new iU(0,32,32,32),this.lastCalcX=0,this.lastCalcY=0,this.maxElevation=0,// map Vec2 to indices because of hashing
this.indexMapper=t=>t.y*this.mapWidth+t.x,this.onMouseClick=t=>{let e=this.engine.app.view.getBoundingClientRect(),i=t.clientX,r=t.clientY,n=this.engine.scene.app.renderer.resolution,s=Math.round((i-e.left)/(e.right-e.left)*this.engine.scene.app.view.width/n),o=Math.round((r-e.top)/(e.bottom-e.top)*this.engine.scene.app.view.height/n),a=this.worldToMap(s,o);(a.x!==this.lastCalcX||a.y!==this.lastCalcY)&&this.recalc(a.x,a.y)}}},QuadTree:class extends m0{constructor(t){super(t),this.objectNum=t&&t.objectNum||50,this.maxObjectsInLeaf=t&&t.maxObjectsInLeaf||4,this.maxTreeLevels=t&&t.maxTreeLevels||4}load(){let t=this.engine.scene;t.clearScene();let e=new iU(0,0,t.app.screen.width,t.app.screen.height),i=new Te(e,this.maxObjectsInLeaf,this.maxTreeLevels),r=[];// add items
for(let e=0;e<this.objectNum;e++){let e={x:Math.random()*t.app.screen.width,y:Math.random()*t.app.screen.height,vx:30*Math.random()-15,vy:30*Math.random()-15};r.push(e)}new hR(t).withComponent(new hO("Updater")// update positions of all objects based on their velocities
.doOnUpdate((e,n,s)=>{// update objects and insert them into the tree again
for(let e of(// remove all objects and subnodes
i.clear(),r))e.x+=e.vx*n*.01,e.y+=e.vy*n*.01,(e.x>t.app.screen.width||e.x<0)&&(e.vx*=-1),(e.y>t.app.screen.height||e.y<0)&&(e.vy*=-1),i.insert(e)})).withComponent(new hO("Renderer")// render objects and the tree
.doOnUpdate((t,e,n)=>{let s=t.owner.asGraphics();for(let t of(s.clear(),s.beginFill(15298415),r))s.drawCircle(t.x,t.y,4);s.endFill(),s.lineStyle(1,4694485);let o=(t,e)=>{null==e.topRight?t.drawRect(e.bounds.x,e.bounds.y,e.bounds.width,e.bounds.height):(o(t,e.topLeft),o(t,e.topRight),o(t,e.bottomLeft),o(t,e.bottomRight))};o(s,i)})).asGraphics().withParent(t.stage).build()}},Missile:class extends m0{constructor(t){super(t)}load(){let t=this.engine.config.frequency??10,e=new hy;e.beginFill(t1.string2hex(TX.rhino80)),e.drawPolygon([0,0,40,0,40,20,0,20,0,0]),e.endFill(),e.pivot.set(e.width/2,e.height/2),e.position.set(.03*this.engine.scene.app.screen.width,.9*this.engine.scene.app.screen.height),e.rotation=-Math.PI/3,e.addComponent(new TJ(t)),this.engine.scene.stage.addChild(e)}},Rotation:class extends m0{constructor(t){super(t)}load(){let{width:t,height:e}=this.engine.scene.app.screen,i=this.engine.config.frequency??10,r=new hy;r.beginFill(16777215),r.drawCircle(t/2,e/2,50),r.endFill(),r.lineStyle(2,5592405),r.arc(t/2,e/2,e/5,0,2*Math.PI,!1),r.moveTo(t/2+e/4,e/2),r.arc(t/2,e/2,e/4,0,2*Math.PI,!1),r.moveTo(t/2+e/3,e/2),r.arc(t/2,e/2,e/3,0,2*Math.PI,!1),r.moveTo(t/2+e/2,e/2),r.arc(t/2,e/2,e/2,0,2*Math.PI,!1),this.engine.scene.stage.addChild(r),this.createProjectile(TX.lemon,i,q.EULER_EXPLICIT),this.createProjectile(TX.royal,i,q.EULER_IMPROVED),this.createProjectile(TX.tomatoLight,i,q.EULER_IMPLICIT)}createProjectile(t,e,i){let r;let n=this.engine.scene.app.screen.height*(.5-1/3),s=new hD(0,n),o=new hD(this.engine.scene.app.screen.width/2,this.engine.scene.app.screen.height/2),a=new hy;switch(a.endFill(),a.pivot.set(1,1),i){case q.EULER_EXPLICIT:r=new T$({color:t,velocity:s,origin:o});break;case q.EULER_IMPLICIT:r=new T0({color:t,velocity:s,origin:o});break;case q.EULER_IMPROVED:r=new TQ({color:t,velocity:s,origin:o})}r.fixedFrequency=e,new hR(this.engine.scene).localPos(this.engine.scene.app.screen.width/3,this.engine.scene.app.screen.height/2).withComponent(r).withParent(this.engine.scene.stage).buildInto(a)}},AckermannSimple:class extends m0{load(){let t=new T1({wheelBase:100,trackWidth:80}),e=new ha;new hR(this.engine.scene).asGraphics().localPos(400,300).withComponent(t).withComponent(new T3({},t)).withComponent(e).withComponent(new T5(t,e)).withParent(this.engine.scene.stage).build()}},AckermannAdvanced:class extends m0{load(){this.engine.app.loader.reset().add("car",`${mZ()}/assets/05-dynamics/car.png`).load(()=>this.loadScene())}loadScene(){// load car texture
let t=rS.from("car"),e=new rH(t);new hR(this.engine.scene).asGraphics().withComponent(new wr).withParent(this.engine.scene.stage).build();// this will somehow fit the car image
let i=new T9({trackWidth:42,wheelBase:70,wheelSize:8,rotation:Math.PI});new hR(this.engine.scene).asGraphics().withTag("car").withComponent(i).withComponent(new wt({car:i})).withComponent(new wi(i)).withComponent(new we).localPos(this.engine.scene.width/2,this.engine.scene.height/2).withChild(new hR(this.engine.scene).asSprite(e).anchor(.5).withComponent(new hO("").doOnUpdate(t=>{// synchronization component that will rotate the sprite
t.owner.rotation=-i.rotation+Math.PI}))).withParent(this.engine.scene.stage).build()}},SteeringCombined:class extends m0{load(){for(let t=0;t<100;t++)this.createRandomObject()}createRandomObject(){let t=this.engine.scene,e=new hy;e.beginFill((Math.floor(255*Math.random())<<16)+(Math.floor(255*Math.random())<<8)+Math.floor(255*Math.random())),e.drawPolygon([-10,-10,-10,10,15,0]),e.endFill(),e.position.set(t.app.screen.width*Math.random(),t.app.screen.height*Math.random()),e.scale.set(1+3*Math.random());let i=0;if(Math.random()>.5&&0!==this.objects.length){let t=this.objects[Math.floor(Math.random()*(this.objects.length-1))];e.addComponent(new wl({target:t,speed:10})),i++}else if(Math.random()>.7&&0!==this.objects.length){let t=this.objects[Math.floor(Math.random()*(this.objects.length-1))];e.addComponent(new wh({target:t,speed:8})),i++}Math.random()>.5&&(e.addComponent(new wu({speed:10,initialVelocity:new hD(1,1),distance:100*Math.random(),radius:50*Math.random(),jittering:Math.random(),boid:e})),i++),0!==i&&(this.objects.push(e),t.stage.addChild(e))}constructor(...t){super(...t),this.objects=[]}},SteeringSeek:class extends m0{load(){let t=this.engine.scene,e=new hy("TARGET");e.beginFill(15298415),e.drawCircle(0,0,40),e.endFill(),e.position.x=t.app.screen.width/2,e.position.y=t.app.screen.height/2,t.stage.addChild(e);let i=new hy("SEEK");i.beginFill(t1.string2hex(TX.tomatoLight)),i.drawPolygon([-10,-10,-10,10,15,0]),i.endFill(),i.scale.set(3),t.stage.addChild(i),i.addComponent(new wa({target:e,speed:10,initialVelocity:new hD(100,25)}))}},SteeringEvade:class extends m0{load(){let t=this.engine.scene,e=new hy("EVADE"),i=new hy("PURSUIT");e.beginFill(t1.string2hex(TX.royal)),e.drawPolygon([-10,-10,-10,10,15,0]),e.endFill(),e.position.set(.7*t.app.screen.width,.8*t.app.screen.height),e.scale.set(2),e.addComponent(new wh({target:i,initialVelocity:new hD(1,5),speed:8})),i.beginFill(t1.string2hex(TX.emerald)),i.drawPolygon([-10,-10,-10,10,15,0]),i.endFill(),i.position.set(t.app.screen.width/4,t.app.screen.height/2),i.scale.set(3),t.stage.addChild(i),i.addComponent(new wl({target:e,speed:10})),t.stage.addChild(e)}},SteeringPursuit:class extends m0{load(){let t=this.engine.scene,e=new hy("WANDER");e.beginFill(t1.string2hex(TX.lemon)),e.drawPolygon([-10,-10,-10,10,15,0]),e.endFill(),e.position.set(.7*t.app.screen.width,.8*t.app.screen.height),e.scale.set(2),e.addComponent(new wu({speed:10,initialVelocity:new hD(1,1),distance:20,radius:10,jittering:.1,boid:e})),t.stage.addChild(e);let i=new hy("PURSUIT");i.beginFill(t1.string2hex(TX.emerald)),i.drawPolygon([-10,-10,-10,10,15,0]),i.endFill(),i.position.set(t.app.screen.width/4,t.app.screen.height/2),i.scale.set(3),t.stage.addChild(i),i.addComponent(new wl({target:e,speed:10}))}},SteeringWander:class extends m0{load(){this.createWander(100,50,.1,t1.string2hex(TX.lemon)),this.createWander(50,20,.5,t1.string2hex(TX.lemon)),this.createWander(0,50,.8,t1.string2hex(TX.lemon)),this.createWander(20,60,.9,t1.string2hex(TX.lemon))}createWander(t,e,i,r){let n=this.engine.scene,s=new hs("PARENT");n.app.stage.addChild(s);let o=new hy("CIRCLE");o.lineStyle(2,16711935),o.drawCircle(0,0,e),o.endFill(),s.addChild(o);let a=new hy("DOT");a.beginFill(16777215),a.drawCircle(0,0,10),a.endFill(),s.addChild(a);let h=new hy("WANDER");h.beginFill(r),h.drawPolygon([-10,-10,-10,10,15,0]),h.endFill(),h.scale.set(3),s.addChild(h),s.position.set(n.app.screen.width*Math.random(),n.app.screen.height*Math.random()),s.addComponent(new wu({speed:10,initialVelocity:new hD(1,1),distance:t,radius:e,jittering:i,boid:h,dot:a,circle:o}))}},MatterAirFriction:class extends m0{load(){let t=new wm;t.init(this.engine.scene),// add bodies
wc.World.add(t.mWorld,[// falling blocks
wc.Bodies.rectangle(200,100,60,60,{frictionAir:.001}),wc.Bodies.rectangle(400,100,60,60,{frictionAir:.05}),wc.Bodies.rectangle(600,100,60,60,{frictionAir:.1}),// walls
wc.Bodies.rectangle(400,0,800,50,{isStatic:!0}),wc.Bodies.rectangle(400,600,800,50,{isStatic:!0}),wc.Bodies.rectangle(800,300,50,600,{isStatic:!0}),wc.Bodies.rectangle(0,300,50,600,{isStatic:!0})])}},MatterFriction:class extends m0{load(){let t=new wm;t.init(this.engine.scene),// add bodies
wc.World.add(t.mWorld,[// walls
wc.Bodies.rectangle(400,0,800,50,{isStatic:!0}),wc.Bodies.rectangle(400,600,800,50,{isStatic:!0}),wc.Bodies.rectangle(800,300,50,600,{isStatic:!0}),wc.Bodies.rectangle(0,300,50,600,{isStatic:!0})]),wc.World.add(t.mWorld,[wc.Bodies.rectangle(300,180,700,20,{isStatic:!0,angle:.06*Math.PI}),wc.Bodies.rectangle(300,70,40,40,{friction:.001})]),wc.World.add(t.mWorld,[wc.Bodies.rectangle(300,350,700,20,{isStatic:!0,angle:.06*Math.PI}),wc.Bodies.rectangle(300,250,40,40,{friction:5e-4})]),wc.World.add(t.mWorld,[wc.Bodies.rectangle(300,520,700,20,{isStatic:!0,angle:.06*Math.PI}),wc.Bodies.rectangle(300,430,40,40,{friction:0})])}},MatterBridge:class extends m0{load(){let t=new wm;t.init(this.engine.scene);let e=new E7(4e3),i=wc.Body.nextGroup(!0),r=wc.Composites.stack(160,290,15,1,0,0,(t,e)=>wc.Bodies.rectangle(t-20,e,53,20,{collisionFilter:{group:i},chamfer:5,density:.005,frictionAir:.05,render:{fillStyle:"#575375"}}));wc.Composites.chain(r,.3,0,-.3,0,{stiffness:1,length:0,render:{visible:!1}});let n=wc.Composites.stack(250,50,6,3,0,0,(t,i)=>wc.Bodies.rectangle(t,i,50,50,e.uniform(20,40)));wc.World.add(t.mWorld,[r,n,wc.Bodies.rectangle(30,490,220,380,{isStatic:!0,chamfer:{radius:20}}),wc.Bodies.rectangle(770,490,220,380,{isStatic:!0,chamfer:{radius:20}}),wc.Constraint.create({pointA:{x:140,y:300},bodyB:r.bodies[0],pointB:{x:-25,y:0},length:2,stiffness:.9}),wc.Constraint.create({pointA:{x:660,y:300},bodyB:r.bodies[r.bodies.length-1],pointB:{x:25,y:0},length:2,stiffness:.9})])}},MatterCar:class extends m0{load(){let t=new wm;t.init(this.engine.scene),// add bodies
wc.World.add(t.mWorld,[// walls
wc.Bodies.rectangle(400,0,800,50,{isStatic:!0}),wc.Bodies.rectangle(400,600,800,50,{isStatic:!0}),wc.Bodies.rectangle(800,300,50,600,{isStatic:!0}),wc.Bodies.rectangle(0,300,50,600,{isStatic:!0})]);let e=.9;wc.World.add(t.mWorld,wc.Composites.car(150,100,150*e,30*e,30*e)),e=.8,wc.World.add(t.mWorld,wc.Composites.car(350,300,150*e,30*e,30*e)),wc.World.add(t.mWorld,[wc.Bodies.rectangle(200,150,400,20,{isStatic:!0,angle:.06*Math.PI}),wc.Bodies.rectangle(500,350,650,20,{isStatic:!0,angle:-(.06*Math.PI)}),wc.Bodies.rectangle(300,560,600,20,{isStatic:!0,angle:.04*Math.PI})])}},MatterChains:class extends m0{load(){let t=new wm;t.init(this.engine.scene);// add bodies
let e=wc.Body.nextGroup(!0),i=wc.Composites.stack(100,50,8,1,10,10,(t,i)=>wc.Bodies.rectangle(t,i,50,20,{collisionFilter:{group:e}}));wc.Composites.chain(i,.5,0,-.5,0,{stiffness:.8,length:2,render:{type:"line"}}),wc.Composite.add(i,wc.Constraint.create({bodyB:i.bodies[0],pointB:{x:-25,y:0},pointA:{x:i.bodies[0].position.x,y:i.bodies[0].position.y},stiffness:.5})),e=wc.Body.nextGroup(!0);let r=wc.Composites.stack(350,50,10,1,10,10,(t,i)=>wc.Bodies.circle(t,i,20,{collisionFilter:{group:e}}));wc.Composites.chain(r,.5,0,-.5,0,{stiffness:.8,length:2,render:{type:"line"}}),wc.Composite.add(r,wc.Constraint.create({bodyB:r.bodies[0],pointB:{x:-20,y:0},pointA:{x:r.bodies[0].position.x,y:r.bodies[0].position.y},stiffness:.5})),e=wc.Body.nextGroup(!0);let n=wc.Composites.stack(600,50,13,1,10,10,(t,i)=>wc.Bodies.rectangle(t-20,i,50,20,{collisionFilter:{group:e},chamfer:5}));wc.Composites.chain(n,.3,0,-.3,0,{stiffness:1,length:0}),wc.Composite.add(n,wc.Constraint.create({bodyB:n.bodies[0],pointB:{x:-20,y:0},pointA:{x:n.bodies[0].position.x,y:n.bodies[0].position.y},stiffness:.5})),wc.World.add(t.mWorld,[i,r,n,wc.Bodies.rectangle(400,600,1200,50.5,{isStatic:!0})])}},MatterCradle:class extends m0{load(){let t=new wm;t.init(this.engine.scene);// add bodies
let e=wc.Composites.newtonsCradle(280,100,5,30,200);wc.World.add(t.mWorld,e),wc.Body.translate(e.bodies[0],{x:-180,y:-100}),e=wc.Composites.newtonsCradle(280,380,7,20,140),wc.World.add(t.mWorld,e),wc.Body.translate(e.bodies[0],{x:-140,y:-100})}},MatterMixedShapes:class extends m0{load(){let t=new wm;t.init(this.engine.scene);let e=new E7(4e3),i=wc.Composites.stack(20,20,10,5,0,0,(t,i)=>{let r=Math.round(e.uniform(1,8)),n=null;switch(// triangles can be a little unstable, so avoid until fixed
(r=3===r?4:r)>2&&e.uniform()>.7&&(n={radius:10}),Math.round(e.uniform(0,1))){case 0:if(.8>e.uniform())return wc.Bodies.rectangle(t,i,e.uniform(25,50),e.uniform(25,50),{chamfer:n});return wc.Bodies.rectangle(t,i,e.uniform(80,120),e.uniform(25,30),{chamfer:n});case 1:return wc.Bodies.polygon(t,i,r,e.uniform(25,50),{chamfer:n})}});wc.World.add(t.mWorld,i),wc.World.add(t.mWorld,[// walls
wc.Bodies.rectangle(400,0,800,50,{isStatic:!0}),wc.Bodies.rectangle(400,600,800,50,{isStatic:!0}),wc.Bodies.rectangle(800,300,50,600,{isStatic:!0}),wc.Bodies.rectangle(0,300,50,600,{isStatic:!0})])}},MatterBinding:class extends m0{load(){let t=new wm;t.init(this.engine.scene,{mouseControl:!1,renderConstraints:!1,renderAngles:!1});let e=this.engine.scene.app.screen.width,i=this.engine.scene.app.screen.height,r=.3*e,n=.25*i,s=e-r,o=.1*i,a=Math.ceil(i/(o+n))+1;for(let e=0;e<a;e++){let i=(e%2==0?r:0)+s/2,h=(o+n)*e+o/2,l=t.addBody(wc.Bodies.rectangle(i,h,s,o,{isStatic:!0})),u=(o+n)*a;l.addComponent(new wx({shift:u,platformHeight:o}))}t.addBody(wc.Bodies.rectangle(-25,i/2,50,2*i,{isStatic:!0})),t.addBody(wc.Bodies.rectangle(e+25,i/2,50,2*i,{isStatic:!0}));let h=Math.min(.75*r,.75*n),l=t.addBody(wc.Bodies.rectangle(h/2,n+h/2,h,h)),u=new ha;l.addComponent(new wb),this.engine.scene.addGlobalComponent(u),this.engine.scene.assignGlobalAttribute("key_input",u)}},Cloth:class extends m0{load(){this.cloth=new wv(new hD(0,.2));let{width:t,height:e}=this.engine.app.screen;this.initCloth(new hD(t/2,e/2),2*t/3,2*e/3,9,4,.1);let i=new hy;this.engine.app.stage.addChild(i),i.addComponent(new hN({handlePointerDown:!0,handlePointerOver:!0,handlePointerRelease:!0})),i.addComponent(new hO("updater").doOnUpdate((t,e,r)=>{this.cloth.update(),i.clear(),this.draw(i)}).doOnMessage(Ei.POINTER_DOWN,(t,e)=>this.mousePressed(e.data.mousePos.posX,e.data.mousePos.posY)).doOnMessage(Ei.POINTER_OVER,(t,e)=>this.mouseMoved(e.data.mousePos.posX,e.data.mousePos.posY)).doOnMessage(Ei.POINTER_RELEASE,(t,e)=>this.mouseReleased()))}draw(t){this.cloth.draw(t);let e=this.findNearestParticle();e&&(t.beginFill(11317498),t.drawCircle(e.pos.x,e.pos.y,8),t.endFill())}initCloth(t,e,i,r,n,s){let o=e/r,a=i/r;for(let n=0;n<r;n++)for(let h=0;h<r;h++){let l=t.x+h*o-e/2+o/2,u=t.y+n*a-i/2+a/2;if(this.cloth.particles.push(new wg(new hD(l,u))),h>0){let t=this.cloth.particles[n*r+h],e=this.cloth.particles[n*r+(h-1)];this.cloth.constraints.push(new w_(t,e,s))}if(n>0){let t=this.cloth.particles[n*r+h],e=this.cloth.particles[(n-1)*r+h];this.cloth.constraints.push(new w_(t,e,s))}}for(let t=0;t<r;t++)if(t%n==0){let e=this.cloth.particles[t];this.cloth.constraints.push(new wy(e,e.pos))}}findNearestParticle(){if(!this.mouse)return null;let t=0,e=null;for(let i of this.cloth.particles){let r=i.pos.squareDistance(this.mouse);r<1600&&(!e||r<t)&&(e=i,t=r)}return e}mousePressed(t,e){this.mouse=new hD(t,e),this.draggedEntity=this.findNearestParticle()}mouseMoved(t,e){this.mouse=new hD(t,e),this.draggedEntity&&(this.draggedEntity.pos=new hD(t,e))}mouseReleased(){this.draggedEntity=null}constructor(...t){super(...t),this.draggedEntity=null}},CollisionsRectangles:class extends m0{load(){let{xSpeed:t,ySpeed:e,sizeA:i,sizeB:r}=this.props,n=new hR(this.engine.scene).asGraphics().relativePos(.5,.5).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(t=>{let e=t.owner.asGraphics();e.beginFill(13487565),e.drawRect(-i/2,-i/2,i,i),e.endFill()})).build();new hR(this.engine.scene).asGraphics().relativePos(.25,.25).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(t=>{let e=t.owner.asGraphics();e.beginFill(15724527),e.drawRect(0,0,r,r),e.endFill()}).doOnUpdate((i,r,s)=>{let o=i.owner.position,a=i.owner.getBounds();(a.x<0&&t<0||a.right>=i.scene.width&&t>=0)&&(t*=-1),(a.y<0&&e<0||a.bottom>=i.scene.height&&e>=0)&&(e*=-1);let h=n.getBounds(),l=t*r*.1,u=e*r*.1,c=a.x+a.width+l>h.x&&a.x+l<h.x+h.width&&a.y+a.height>h.y&&a.y<h.y+h.height,d=a.y+a.height+u>h.y&&a.y+u<h.y+h.height&&a.x+a.width>h.x&&a.x<h.x+h.width;c&&(l*=-1,t*=-1),d&&(u*=-1,e*=-1),o.x+=l,o.y+=u})).build()}constructor(...t){super(...t),this.props={xSpeed:5,ySpeed:9,sizeA:150,sizeB:30}}},CollisionsBalls:class extends m0{load(){let{xSpeed:t,ySpeed:e,radiusA:i,radiusB:r}=this.props,n=new hR(this.engine.scene).asGraphics().relativePos(.5,.5).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(t=>{let e=t.owner.asGraphics();e.beginFill(13487565),e.drawCircle(0,0,i),e.endFill()})).build();new hR(this.engine.scene).asGraphics().relativePos(.25,.25).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(t=>{let e=t.owner.asGraphics();e.beginFill(15724527),e.drawCircle(0,0,r),e.endFill()}).doOnUpdate((s,o,a)=>{let h=s.owner.position,l=s.owner.getBounds();(l.x<0&&t<0||l.right>=s.scene.width&&t>=0)&&(t*=-1),(l.y<0&&e<0||l.bottom>=s.scene.height&&e>=0)&&(e*=-1);// ball-ball collision
let u=n.getBounds(),c=l.x+l.width/2,d=u.x+u.width/2,p=l.y+l.height/2,f=u.y+u.height/2,m=t*o*.1,g=e*o*.1,y=Math.abs(c-d)<=i+r,_=Math.abs(p-f)<=i+r,v=new hD(c,p).distance(new hD(d,f))<=i+r,x=new hD(c+m,p+g).distance(new hD(d,f))<=i+r,b=Math.abs(c+m-d)<=i+r,E=Math.abs(p+g-f)<=i+r;!v&&x&&(y&&E&&(g*=-1,e*=-1),_&&b&&(m*=-1,t*=-1)),h.x+=m,h.y+=g})).build()}constructor(...t){super(...t),this.props={xSpeed:5,ySpeed:9,radiusA:50,radiusB:30}}},CollisionsBall:class extends m0{load(){let{xSpeed:t,ySpeed:e,radius:i}=this.props;new hR(this.engine.scene).asGraphics().relativePos(.5,.5).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(t=>{let e=t.owner.asGraphics();e.beginFill(13487565),e.drawCircle(0,0,i),e.endFill()}).doOnUpdate((i,r,n)=>{let s=i.owner.position,o=i.owner.getBounds();s.x+=t*r*.1,s.y+=e*r*.1,(o.x<0&&t<0||o.right>=i.scene.width&&t>=0)&&(t*=-1),(o.y<0&&e<0||o.bottom>=i.scene.height&&e>=0)&&(e*=-1)})).build()}constructor(...t){super(...t),this.props={xSpeed:5,ySpeed:4,radius:50}}},CollisionsRaycasting:class extends m0{makeStep(t,e,i,r){let n=r.owner.position,s=this.xSpeed*t*.1,o=this.ySpeed*t*.1;for(let a of i){let i=e.position.x,h=e.position.y,l=i+this.props.sizeBall+Math.sign(this.xSpeed)*this.props.sizeBall,u=h+this.props.sizeBall+Math.sign(this.ySpeed)*this.props.sizeBall,c=Math.max(0,Math.min(1,(a.y-u)/o)),d=Math.max(0,Math.min(1,(a.y+a.height-u)/o)),p=Math.max(0,Math.min(1,(a.x-l)/s)),f=Math.max(0,Math.min(1,(a.x+a.width-l)/s)),m=Math.min(c,d),g=Math.max(c,d),y=Math.min(p,f),_=Math.max(p,f);if(this.collides=Math.min(g,_)-Math.max(m,y)>0,this.collides){let i=Math.min(c>0?c:1e4,d>0?d:1e4,p>0?p:1e4,f>0?f:1e4);(i===c||i===d)&&(this.ySpeed*=-1),(i===p||i===f)&&(this.xSpeed*=-1),s*=i,o*=i,n.x+=s,n.y+=o;let h=t*i;return h!==t&&this.makeStep(h,e,[a],r),!0}}n.x+=s,n.y+=o}load(){let{sizeBall:t,sizeRect:e}=this.props,i=[];for(let t of[[.25,.3],[.5,.3],[.7,.5],[.2,.6],[.3,.8],[.5,.9],[.1,.4],[.8,.2],[.7,.8]]){let r=new hR(this.engine.scene).asGraphics().relativePos(t[0],t[1]).withParent(this.engine.scene.stage).withComponent(new hO("").doOnUpdate((t,i,r)=>{let n=t.owner.asGraphics();n.clear(),this.collides?n.beginFill(16711680):n.beginFill(13487565),n.drawRect(-e/2,-e/2,e,e),n.endFill()})).build();i.push(r)}let r=new hR(this.engine.scene).asGraphics().relativePos(.25,.25).withParent(this.engine.scene.stage).withComponent(new hO("").doOnInit(e=>{let i=e.owner.asGraphics();i.clear(),i.beginFill(15724527),i.drawCircle(t,t,t),i.endFill()}).doOnUpdate((t,e,n)=>{let s=i.map(t=>t.getBounds()),o=new iU(0,-10,t.scene.width,10),a=new iU(-10,-10,10,t.scene.height+10),h=new iU(t.scene.width,0,10,t.scene.height),l=new iU(-10,t.scene.height,t.scene.width+10,10);this.makeStep(e,r,[...s,o,a,h,l],t)})).build();this.gfx=new hR(this.engine.scene).asGraphics().withParent(this.engine.scene.stage).build()}constructor(...t){super(...t),this.props={sizeRect:30,sizeBall:10},this.collides=!1,this.xSpeed=12,this.ySpeed=4}},Platformer:class extends m0{constructor(t={}){super({...t,width:800,height:600,resolution:32,backgroundColor:657930,antialias:!1})}load(){ec.SCALE_MODE=x2.NEAREST,this.engine.app.loader.reset().add(J.SPRITESHEET,`${mZ()}/assets/06-physics/platformer/spritesheet.png`).add(J.LEVEL_BACKGROUND,`${mZ()}/assets/06-physics/platformer/level_background.jpg`).load(()=>this.loadScene())}loadScene(){let t=this.engine.scene,e=new wP().buildLevel("default",wC,21),i=new wR;i.loadLevel(e,t)}onDestroy(){ec.SCALE_MODE=x2.LINEAR}},Raycaster:class{init(t){"string"==typeof t?this.canvas=document.getElementById(t):this.canvas=t,this.canvas.getContext&&(this.width=this.canvas.width,this.height=this.canvas.height,this.canvas.style.background="rgb(0, 0, 0)",this.ctx=this.canvas.getContext("2d")),this.player.init(),this.running=!0,this.loop()}loop(){this.running&&(// attach to requestAnimationFrame
requestAnimationFrame(()=>this.loop()),// update player inputs
this.player.update(this.map),// draw everything
this.draw())}destroy(){this.running=!1,document.removeEventListener("keydown",this.player.keyDown),document.removeEventListener("keyup",this.player.keyUp),this.player.destroy()}draw(){this.ctx.clearRect(0,0,this.width,this.height),this.drawBackground();// distance to the wall for every column, used for sprites
let t=[];// the magic happens right here
// for every vertical line, use raycasting to render textures
for(let e=0;e<this.width;e++)this.drawColumn(e,t);// draw sprites
this.drawSprites(t)}drawColumn(t,e,i=1){let r=2*t/this.width-1,n=this.player.posX,s=this.player.posY,o=this.player.dirX+this.player.camX*r,a=this.player.dirY+this.player.camY*r,h=Math.floor(n),l=Math.floor(s),u=Math.sqrt(1+a*a/(o*o)),c=Math.sqrt(1+o*o/(a*a)),d=0,p=0,f=0,m=0;// camera coordinate scaled to [-1..1]
o<0?(f=-1,d=(n-h)*u):(f=1,d=(h+1-n)*u),a<0?(m=-1,p=(s-l)*c):(m=1,p=(l+1-s)*c);let g=!1;// ray-wall collision calculation
for(;d<p?(d+=u,h+=f,g=!0):(p+=c,l+=m,g=!1),this.map.isFree(h,l););let y=0,_=0;g?(// horizontal wall
y=(h-n+(1-f)/2)/o,_=s+(h-n+(1-f)/2)/o*a):(// vertical wall
y=(l-s+(1-m)/2)/a,_=n+(l-s+(1-m)/2)/a*o),// round X coord
_-=Math.floor(_),y<0&&(y=-y),// save the distance into zBuffer
e[t]=y;let v=Math.abs(Math.floor(this.height/y)),x=-v/2+this.height/2;_=Math.floor(_*this.map.getTextureByPosition(h,l).width),g&&o>0&&(_=this.map.getTextureByPosition(h,l).width-_-1),!g&&a<0&&(_=this.map.getTextureByPosition(h,l).width-_-1),this.drawWall(h,l,t,_,x,v,i)}drawBackground(){// draw floor gradient
let t=this.ctx.createLinearGradient(0,this.height/2,0,this.height);t.addColorStop(0,this.map.floor0),t.addColorStop(1,this.map.floor1),this.ctx.fillStyle=t,this.ctx.fillRect(0,this.height/2,this.width,this.height/2),// draw ceiling gradient
(t=this.ctx.createLinearGradient(0,0,0,this.height/2)).addColorStop(1,this.map.ceiling0),t.addColorStop(0,this.map.ceiling1),this.ctx.fillStyle=t,this.ctx.fillRect(0,0,this.width,this.height/2)}drawWall(t,e,i,r,n,s,o=1){let a=this.map.getTextureByPosition(t,e);this.ctx.drawImage(a,r,0,1,a.height,i,n,o,s);// calculate shadow light
let h=1-1.6*s/this.height;this.ctx.fillStyle="rgba(0,0,0,"+h+")",this.ctx.fillRect(i,n,o,s)}drawSprites(t,e=1){// get all sprites sorted by their distance to the player
let i=this.map.items.sorted(this.player.posX,this.player.posY);for(let r=0;r<i.length;r++){let n=i[r].posX-this.player.posX,s=i[r].posY-this.player.posY,o=1/(this.player.camX*this.player.dirY-this.player.dirX*this.player.camY),a=o*(this.player.dirY*n-this.player.dirX*s),h=o*(-this.player.camY*n+this.player.camX*s),l=Math.floor(this.width/2*(1+a/h)),u=Math.abs(Math.floor(this.height/h))*i[r].size,c=Math.floor(-u/2+this.height/2);c<0&&(c=0);let d=Math.floor(-u/2+l),p=0;d<0&&(p=-d,d=0);let f=Math.floor(u/2+l);f>=this.width&&(f=this.width-1);// draw for each occupied vertical column
for(let n=d;n<f;n++)if(h>0&&n>0&&n<this.width&&h<t[n]){let t=this.map.items.getTexture(i[r].texture),s=Math.floor((n-d)*t.width/u);this.ctx.drawImage(t,p+s,0,1,t.height,n,c+Math.floor(256/h)-u/2,e,u)}}}constructor(){// for preview mode
this.lastLoopCol=0,this.previewStep=8,this.previewDownScale=8,this.map=new wN,this.player=new wI(1,1)}},ShaderBasic:class extends m0{load(){let t=new r$().addAttribute("aVertexPosition",rY.from([-1,-1,1,-1,-1,1,1,1]),2)// vertex position, 2 coordinates for each
.addAttribute("aTexturePosition",rY.from([1,1,0,1,1,0,0,0]),2)// u,v coordinates
.addIndex([0,1,3,0,3,2])// create index over attribute coordinates -> we have 2 triangles
.interleave(),e=this.engine.app.loader;// interleave attributes into one buffer (better for performance)
e.reset().add("noise_vert",`${mZ()}/assets/07-graphics/shaders/basic.vert`).add("noise_frag",`${mZ()}/assets/07-graphics/shaders/basic.frag`).add("texture",`${mZ()}/assets/01-helloworld/crash.png`).load(()=>{let i={texture:new rH(rS.from("texture"))},r=e.resources.noise_vert.data,n=e.resources.noise_frag.data;new hR(this.engine.scene).asMesh(t,nM.from(r,n,i)).scale(.5,1).withParent(this.engine.scene.stage).build()})}},ShaderNoise:class extends m0{load(){let t=new r$().addAttribute("aVertexPosition",rY.from([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),2)// the size of the attribute
.addAttribute("aTexturePosition",rY.from([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),2),e={u_resolution:[this.engine.app.screen.width,this.engine.app.screen.height],u_time:0},i=this.engine.app.loader;// the size of the attribute
i.reset().add("noise_vert",`${mZ()}/assets/07-graphics/shaders/noise.vert`).add("noise_frag",`${mZ()}/assets/07-graphics/shaders/noise.frag`).load(()=>{let r=i.resources.noise_vert.data,n=i.resources.noise_frag.data;new hR(this.engine.scene).asMesh(t,nM.from(r,n,e)).withComponent(new hO("updater").doOnUpdate((t,e,i)=>t.owner.asMesh().shader.uniforms.u_time+=.1)).withParent(this.engine.scene.stage).build()})}},ShaderWave:class extends m0{load(){let t=new r$().addAttribute("aVertexPosition",rY.from([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),2)// the size of the attribute
.addAttribute("aTexturePosition",rY.from([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),2),e={u_resolution:[this.engine.app.screen.width,this.engine.app.screen.height],u_time:0},i=this.engine.app.loader;// the size of the attribute
i.reset().add("noise_vert",`${mZ()}/assets/07-graphics/shaders/wave.vert`).add("noise_frag",`${mZ()}/assets/07-graphics/shaders/wave.frag`).load(()=>{let r=i.resources.noise_vert.data,n=i.resources.noise_frag.data;new hR(this.engine.scene).asMesh(t,nM.from(r,n,e)).withComponent(new hO("updater").doOnUpdate((t,e,i)=>t.owner.asMesh().shader.uniforms.u_time+=.1)).withParent(this.engine.scene.stage).build()})}},TweenRotation:class extends m0{constructor(t){super(t),this.interpolation=t&&t.interpolation?wD(t.interpolation):TN.linear}load(){this.engine.app.loader.reset().load(()=>{let t=new wU(0,2*Math.PI,2e3,!0,0),e=new hR(this.engine.scene).asGraphics().relativePos(.5).anchor(.5).withParent(this.engine.scene.stage).withComponent(t).build(),i=this.engine.app.view.width;e.beginFill(16711680),e.drawRect(0,0,i/4,i/4),e.endFill(),t.interpolation=this.interpolation})}},TweenTranslation:class extends m0{constructor(t){super(t),this.interpolation=t&&t.interpolation?wD(t.interpolation):TN.linear}load(){this.engine.app.loader.reset().load(()=>{let t=new wB(0,0,this.engine.app.view.clientWidth-200,this.engine.app.view.clientHeight-200,3e3,!0,0),e=new hR(this.engine.scene).asGraphics().relativePos(.5).anchor(.5).withParent(this.engine.scene.stage).withComponent(t).build(),i=this.engine.app.view.width;e.beginFill(16711680),e.drawRect(0,0,i/4,i/4),e.endFill(),t.interpolation=this.interpolation})}},VisionCone:class extends m0{load(){this.mapWidth=wG[0].length,this.mapHeight=wG.length,this.engine.app.loader.reset()// necessary for hot reload
.add("pathfinding",`${mZ()}/assets/07-graphics/vision.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){// initialize grid from the static array
this.grid=new TM(2,10,this.mapWidth,this.mapHeight);for(let t=0;t<this.mapHeight;t++)for(let e=0;e<this.mapWidth;e++){let i=wG[t][e];1===i?this.grid.addObstruction(new hD(e,t)):2===i&&this.grid.setElevation(new hD(e,t),this.slowPathCost)}// recreate view model
this.recreateMap(),this.addBot(new hD(10,10),16711680),this.addBot(new hD(15,15),65280),this.addBot(new hD(12,13),255)}addBot(t,e){let i=new hb("",new rH(rS.from("pathfinding")));i.addComponent(new wj(this,0,10,.1)),i.anchor.set(.5),i.addComponent(new wV);let r=this.mapToWorld(t.x,t.y);i.position.set(r.x,r.y);let n=new hy("");n.addComponent(new wX(this,i,e)),this.engine.scene.stage.addChild(n),this.engine.scene.stage.addChild(i)}/**
	 * Recreates view-model
	 */recreateMap(){let t=new rH(rS.from("pathfinding"));this.engine.scene.clearScene();// create sprites
for(let e=0;e<this.mapWidth;e++)for(let i=0;i<this.mapHeight;i++){let r=t.clone(),n=new hb("",r),s=this.mapToWorld(e,i);n.position.set(s.x,s.y),r.frame=this.getSpriteFrame(new hD(e,i)),this.engine.scene.stage.addChild(n)}}/**
	 * Sets sprite index according to the type of the block of the map
	 */getSpriteFrame(t){let e=this.grid.getElevation(t);return this.grid.hasObstruction(t)?this.obstructionRect:1===e?this.pathRect:void 0}/**
	 * Transforms map coordinates into world coordinates
	 */mapToWorld(t,e){return new hD(t*this.mapCellSize,e*this.mapCellSize)}/**
	 * Transforms world coordinates into map coordinates
	 */worldToMap(t,e){return new hD(Math.floor(t/this.mapCellSize),Math.floor(e/this.mapCellSize))}constructor(...t){super(...t),this.slowPathCost=10,this.mapCellSize=32// 32px
,// frames for sprite atlas
this.pathRect=new iU(0,0,32,32),this.obstructionRect=new iU(32,0,32,32),this.indexMapper=t=>t.y*this.mapWidth+t.x}},Mandelbrot:class extends m0{load(){let t=new r$().addAttribute("aVertexPosition",rY.from([-1,-1,1,-1,-1,1,1,1]),2)// the size of the attribute
.addAttribute("aTexturePosition",rY.from([-4,-4,4,-4,-4,4,4,4]),2).addIndex([0,1,3,0,3,2])// create index over attribute coordinates -> we have 2 triangles
.interleave(),e=this.engine.app.loader;// interleave attributes into one buffer (better for performance)
e.reset().add("mandelbrot_vert",`${mZ()}/assets/07-graphics/shaders/mandelbrot.vert`).add("mandelbrot_frag",`${mZ()}/assets/07-graphics/shaders/mandelbrot.frag`).add("palette",`${mZ()}/assets/07-graphics/shaders/mandelbrot_palette.png`).load(()=>{let i=e.resources.mandelbrot_vert.data,r=e.resources.mandelbrot_frag.data,n={colorPalette:new rH(rS.from("palette")),maxIteration:256,projectionMatrix:iX.IDENTITY};new hR(this.engine.scene).withName("quad").asMesh(t,nM.from(i,r,n)).withComponent(new hO("updater").doOnUpdate((t,e,i)=>{t.owner.scale.set(1.01*t.owner.scale.x),t.owner.position.x-=.001*t.owner.scale.x,t.owner.position.y-=6e-4*t.owner.scale.y})).withParent(this.engine.scene.stage).build()})}},Lighting:class extends m${load(){let t=fetch(`${mZ()}/assets/07-graphics/shaders/lighting.vert`),e=fetch(`${mZ()}/assets/07-graphics/shaders/lighting.frag`);// async/await is not support in this version. Hence, we need to use a chain of promises
Promise.all([t,e]).then(([t,e])=>Promise.all([t.text(),e.text()])).then(([t,e])=>{this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setClearColor(new ur(0,0,0)),console.log(e),// Initialize the camera
this.camera=new uX(75,this.canvas.width/this.canvas.height,.1,5e3),this.camera.position.z=30,// Define the shader uniforms
this.uniforms={u_time:{type:"f",value:0},u_frame:{type:"f",value:0},u_resolution:{type:"v2",value:new hX(this.canvas.width,this.canvas.height).multiplyScalar(window.devicePixelRatio)},u_mouse:{type:"v2",value:new hX(.7*this.canvas.width,this.canvas.height).multiplyScalar(window.devicePixelRatio)}},// Create the shader material
this.material=new uj({uniforms:this.uniforms,vertexShader:t,fragmentShader:e,side:2,transparent:!0,extensions:{derivatives:!0}}),// Create the mesh and add it to the scene
this.addMeshToScene(),// Add the event listeners
this.renderer.domElement.addEventListener("mousemove",this.onMouseMove,!1),this.renderer.domElement.addEventListener("touchstart",this.onTouchMove,!1),this.renderer.domElement.addEventListener("touchmove",this.onTouchMove,!1)})}destroy(){this.renderer.domElement.removeEventListener("mousemove",this.onMouseMove),this.renderer.domElement.addEventListener("touchstart",this.onTouchMove),this.renderer.domElement.removeEventListener("touchmove",this.onTouchMove),super.destroy()}update(){this.uniforms&&(this.uniforms.u_time.value=this.clock.getElapsedTime(),this.uniforms.u_frame.value+=1,this.renderer.render(this.scene,this.camera))}/*
	 * Adds the mesh to the scene
	 */addMeshToScene(){this.mesh&&this.scene.remove(this.mesh);// Create the desired geometry
let t=new fW(6.5,2.3,256,32);// Create the mesh and add it to the scene
this.mesh=new uB(t,this.material),this.scene.add(this.mesh)}constructor(...t){super(...t),/*
	 * Updates the uniforms when the mouse moves
	 */this.onMouseMove=t=>{// Update the mouse uniform
this.uniforms.u_mouse.value.set(t.pageX,this.canvas.height-t.pageY).multiplyScalar(window.devicePixelRatio)},/*
	 * Updates the uniforms when the touch moves
	 */this.onTouchMove=t=>{// Update the mouse uniform
this.uniforms.u_mouse.value.set(t.touches[0].pageX,this.canvas.height-t.touches[0].pageY).multiplyScalar(window.devicePixelRatio)}}},Bots:class extends m0{load(){this.engine.app.loader.reset()// for hot reload
.add(ts.TEXTURE,`${mZ()}/assets/08-ai/spritesheet.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){new Sh().initializeGame(this.engine.scene.stage,new w7)}},Pursue:class extends m0{load(){this.engine.app.loader.reset()// necessary for hot reload
.add("pathfinding",`${mZ()}/assets/07-graphics/vision.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){new SM().loadScene(this.engine.scene,Sl)}},PixiHitTest:class extends mQ{load(){this.sonic=new SA(rH.from(`${mZ()}/assets/02-pixi-intro/sonic.png`)),this.sonic.position.set(this.app.screen.width/2,this.app.screen.height/2),this.sonic.anchor.set(.5),this.sonic.interactive=!0,this.sonic.on("mouseover",()=>{this.sonic.tint=16711680}),this.sonic.on("mouseout",()=>{this.sonic.tint=16777215}),this.app.stage.addChild(this.sonic)}update(){// no-op
}},Dialog:class extends m0{load(){// must be done before we load the textures
ec.ROUND_PIXELS=!0,ec.SCALE_MODE=x2.NEAREST,this.engine.app.loader.reset().add(ta.DIALOG_TEXTURE,`${mZ()}/assets/others/dialog/dialog.png`).add(ta.FONT,`${mZ()}/assets/others/dialog/font.json`).add(ta.FONT_TEXTURE,`${mZ()}/assets/others/dialog/font.png`).add(ta.MARKER_TEXTURE,`${mZ()}/assets/others/dialog/marker.png`).load(()=>this.onAssetsLoaded())}onAssetsLoaded(){let t=this.engine.scene,e=new ha;t.addGlobalComponent(e);let i=this.engine.app.loader.resources[ta.FONT].data,r=rH.from(ta.FONT_TEXTURE),n=new SC().parseFont(i,r);t.assignGlobalAttribute(th.FONT,n),t.addGlobalComponent(new SI({text:"Vanquish Thy foes, brave warrior. And prepare yourself for the greatest of challenges.",dialogHeight:40,keyInput:e}))}onDestroy(){ec.SCALE_MODE=x2.LINEAR,ec.ROUND_PIXELS=!1}},ProgressParallel:class extends SN{isSequential(){return!1}},ProgressSequential:SN,Matrices:class extends m0{drawTriangle(t,e){t.lineStyle(1,13487565),t.moveTo(e[0].x,e[0].y),t.lineTo(e[1].x,e[1].y),t.lineTo(e[2].x,e[2].y),t.lineTo(e[0].x,e[0].y),t.moveTo(0,0),t.lineStyle(0)}load(){let t=this.engine.scene,e=.5*Math.PI,i=0;new hR(t).withParent(t.stage).withComponent(new hO("rotation").doOnUpdate(t=>{let r=t.owner.asGraphics(),n=wJ();r.clear();let s=wY(.75,e,.1,1e3),o=wK(i),a=wq(i+.5);for(let t of(i+=.1,n.tris)){let e=w$(t,o);e=w$(e,a),// translate it first
e[0].z+=3,e[1].z+=3,e[2].z+=3,// calculate projection
e=w$(e,s),// scale and move each triangle the center of the screen
e[0].x+=1,e[0].y+=1,e[1].x+=1,e[1].y+=1,e[2].x+=1,e[2].y+=1,e[0].x*=400,e[0].y*=300,e[1].x*=400,e[1].y*=300,e[2].x*=400,e[2].y*=300,this.drawTriangle(r,e)}})).asGraphics().build()}},BlockBreaker:class extends m0{constructor(t={}){super({...t,width:1280,height:800,resolution:80})}load(){this.engine.app.loader.reset().add(tp.SPRITESHEET,`${mZ()}/assets/game_blockbreaker/spritesheet.png`).add(tp.LEVELS,`${mZ()}/assets/game_blockbreaker/levels.txt`).load(()=>this.loadGame())}loadGame(){let t=this.engine.app.loader.resources[tp.LEVELS].data,e=new SV,i=e.parse(t),r=new Sj;r.loadLevel(i[0],this.engine.scene)}},Vlak:class extends m0{constructor(t={}){super({...t,width:960,height:600,resolution:3}),this.resizeHandler=()=>{// the window can resize only if we can scale the original resolution by an integer. Otherwise it would blur the pixel art
let t=Math.min(Math.floor(window.innerWidth/320),Math.floor(window.innerHeight/200));t>0&&(this.engine.app.renderer.resolution=t,this.engine.app.view.width=320*t,this.engine.app.view.height=200*t)}}load(){// pixel-art: no interpolation, round pixels
ec.ROUND_PIXELS=!0,ec.SCALE_MODE=x2.NEAREST,new Mp().loadGame(this.engine)}initResizable(t){super.init(t),this.initResizeHandler()}onDestroy(){ec.SCALE_MODE=x2.LINEAR,ec.ROUND_PIXELS=!1}initResizeHandler(){this.resizeHandler(),window.addEventListener("resize",this.resizeHandler)}},Tetris:class extends m0{constructor(t={}){super({...t,width:1280,height:800,resolution:2}),this.resizeHandler=()=>{let t=Math.min(Math.floor(window.innerWidth/640),Math.floor(window.innerHeight/400));t>0&&(this.engine.app.renderer.resolution=t,this.engine.app.view.width=640*t,this.engine.app.view.height=400*t)}}load(){ec.ROUND_PIXELS=!0,ec.SCALE_MODE=x2.NEAREST,this.initResizeHandler(),this.displayLoadingText(),this.engine.app.loader.reset().add(tb.FONT_DOS,`${mZ()}/assets/game_tetris/dos.fnt`).add(tb.FONT_DOS_TEXTURE,`${mZ()}/assets/game_tetris/dos.png`).add(tb.SOUND_GAMEOVER,`${mZ()}/assets/game_tetris/snd_gameover.mp3`).add(tb.SOUND_LEVELUP,`${mZ()}/assets/game_tetris/snd_levelup.mp3`).add(tb.SOUND_MOVEDOWN,`${mZ()}/assets/game_tetris/snd_movedown.mp3`).add(tb.SOUND_PLACE,`${mZ()}/assets/game_tetris/snd_place.mp3`).add(tb.SOUND_ROTATE,`${mZ()}/assets/game_tetris/snd_rotate.mp3`).add(tb.SOUND_ROWCLEAR,`${mZ()}/assets/game_tetris/snd_rowclear.mp3`).add(tb.MUSIC,`${mZ()}/assets/game_tetris/music.mp3`).load(()=>this.loadGame()),E1.add(tb.SOUND_GAMEOVER,`${mZ()}/assets/game_tetris/snd_gameover.mp3`),E1.add(tb.SOUND_LEVELUP,`${mZ()}/assets/game_tetris/snd_levelup.mp3`),E1.add(tb.SOUND_MOVEDOWN,`${mZ()}/assets/game_tetris/snd_movedown.mp3`),E1.add(tb.SOUND_PLACE,`${mZ()}/assets/game_tetris/snd_place.mp3`),E1.add(tb.SOUND_ROTATE,`${mZ()}/assets/game_tetris/snd_rotate.mp3`),E1.add(tb.SOUND_ROWCLEAR,`${mZ()}/assets/game_tetris/snd_rowclear.mp3`),E1.add(tb.MUSIC,`${mZ()}/assets/game_tetris/music.mp3`)}/**
	 * Displays a loading text
	 * No need to remove it, because the whole scene is going to be cleared out
	 * after the assets has been loaded
	 */displayLoadingText(){let t=new hE("");t.style=new oH({fill:"0xFFFFFF",fontWeight:"bold",fontSize:"30pt",align:"center"}),t.anchor.set(.5),t.position.set(this.engine.scene.width/2,this.engine.scene.height/2),this.engine.scene.stage.addChild(t);// will display animated dots
let e=0;this.engine.scene.addGlobalComponent(new hO("").setFixedFrequency(5).doOnFixedUpdate(()=>{let i=Array(2*e).fill(".").join("");t.text=i,e=(e+1)%20}))}loadGame(){let t=new MG;t.loadIntro(this.engine.scene)}initResizable(t){super.init(t),this.initResizeHandler()}onDestroy(){ec.SCALE_MODE=x2.LINEAR,ec.ROUND_PIXELS=!1}initResizeHandler(){this.resizeHandler(),window.addEventListener("resize",this.resizeHandler)}}};